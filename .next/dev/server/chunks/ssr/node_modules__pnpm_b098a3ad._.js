module.exports = [
"[project]/node_modules/.pnpm/http-status@2.1.0/node_modules/http-status/dist/chunk-CUNVWAK5.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "a",
    ()=>t,
    "b",
    ()=>E
]);
var e = {
    "1xx": "Informational",
    "1xx_NAME": "INFORMATIONAL",
    "1xx_MESSAGE": "Indicates an interim response for communicating connection status or request progress prior to completing the requested action and sending a final response.",
    INFORMATIONAL: "1xx",
    "2xx": "Successful",
    "2xx_NAME": "SUCCESSFUL",
    "2xx_MESSAGE": "Indicates that the client's request was successfully received, understood, and accepted.",
    SUCCESSFUL: "2xx",
    "3xx": "Redirection",
    "3xx_NAME": "REDIRECTION",
    "3xx_MESSAGE": "Indicates that further action needs to be taken by the user agent in order to fulfill the request.",
    REDIRECTION: "3xx",
    "4xx": "Client Error",
    "4xx_NAME": "CLIENT_ERROR",
    "4xx_MESSAGE": "Indicates that the client seems to have erred.",
    CLIENT_ERROR: "4xx",
    "5xx": "Server Error",
    "5xx_NAME": "SERVER_ERROR",
    "5xx_MESSAGE": "Indicates that the server is aware that it has erred or is incapable of performing the requested method.",
    SERVER_ERROR: "5xx"
}, t = {
    classes: e,
    100: "Continue",
    "100_NAME": "CONTINUE",
    "100_MESSAGE": "The server has received the request headers and the client should proceed to send the request body.",
    "100_CLASS": e.INFORMATIONAL,
    CONTINUE: 100,
    101: "Switching Protocols",
    "101_NAME": "SWITCHING_PROTOCOLS",
    "101_MESSAGE": "The requester has asked the server to switch protocols and the server has agreed to do so.",
    "101_CLASS": e.INFORMATIONAL,
    SWITCHING_PROTOCOLS: 101,
    102: "Processing",
    "102_NAME": "PROCESSING",
    "102_MESSAGE": "A WebDAV request may contain many sub-requests involving file operations, requiring a long time to complete the request. This code indicates that the server has received and is processing the request, but no response is available yet.[7] This prevents the client from timing out and assuming the request was lost.",
    "102_CLASS": e.INFORMATIONAL,
    PROCESSING: 102,
    103: "Early Hints",
    "103_NAME": "EARLY_HINTS",
    "103_MESSAGE": "Used to return some response headers before final HTTP message.",
    "103_CLASS": e.INFORMATIONAL,
    EARLY_HINTS: 103,
    200: "OK",
    "200_NAME": "OK",
    "200_MESSAGE": "Standard response for successful HTTP requests.",
    "200_CLASS": e.SUCCESSFUL,
    OK: 200,
    201: "Created",
    "201_NAME": "CREATED",
    "201_MESSAGE": "The request has been fulfilled, resulting in the creation of a new resource.",
    "201_CLASS": e.SUCCESSFUL,
    CREATED: 201,
    202: "Accepted",
    "202_NAME": "ACCEPTED",
    "202_MESSAGE": "The request has been accepted for processing, but the processing has not been completed.",
    "202_CLASS": e.SUCCESSFUL,
    ACCEPTED: 202,
    203: "Non-Authoritative Information",
    "203_NAME": "NON_AUTHORITATIVE_INFORMATION",
    "203_MESSAGE": "The server is a transforming proxy (e.g. a Web accelerator) that received a 200 OK from its origin, but is returning a modified version of the origin's response.",
    "203_CLASS": e.SUCCESSFUL,
    NON_AUTHORITATIVE_INFORMATION: 203,
    204: "No Content",
    "204_NAME": "NO_CONTENT",
    "204_MESSAGE": "The server successfully processed the request and is not returning any content.",
    "204_CLASS": e.SUCCESSFUL,
    NO_CONTENT: 204,
    205: "Reset Content",
    "205_NAME": "RESET_CONTENT",
    "205_MESSAGE": "The server successfully processed the request, but is not returning any content. Unlike a 204 response, this response requires that the requester reset the document view.",
    "205_CLASS": e.SUCCESSFUL,
    RESET_CONTENT: 205,
    206: "Partial Content",
    "206_NAME": "PARTIAL_CONTENT",
    "206_MESSAGE": "The server is delivering only part of the resource (byte serving) due to a range header sent by the client.",
    "206_CLASS": e.SUCCESSFUL,
    PARTIAL_CONTENT: 206,
    207: "Multi Status",
    "207_NAME": "MULTI_STATUS",
    "207_MESSAGE": "The message body that follows is by default an XML message and can contain a number of separate response codes, depending on how many sub-requests were made.",
    "207_CLASS": e.SUCCESSFUL,
    MULTI_STATUS: 207,
    208: "Already Reported",
    "208_NAME": "ALREADY_REPORTED",
    "208_MESSAGE": "The members of a DAV binding have already been enumerated in a preceding part of the (multistatus) response, and are not being included again.",
    "208_CLASS": e.SUCCESSFUL,
    ALREADY_REPORTED: 208,
    226: "IM Used",
    "226_NAME": "IM_USED",
    "226_MESSAGE": "The server has fulfilled a request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.",
    "226_CLASS": e.SUCCESSFUL,
    IM_USED: 226,
    300: "Multiple Choices",
    "300_NAME": "MULTIPLE_CHOICES",
    "300_MESSAGE": "Indicates multiple options for the resource from which the client may choose.",
    "300_CLASS": e.REDIRECTION,
    MULTIPLE_CHOICES: 300,
    301: "Moved Permanently",
    "301_NAME": "MOVED_PERMANENTLY",
    "301_MESSAGE": "This and all future requests should be directed to the given URI.",
    "301_CLASS": e.REDIRECTION,
    MOVED_PERMANENTLY: 301,
    302: "Found",
    "302_NAME": "FOUND",
    "302_MESSAGE": 'This is an example of industry practice contradicting the standard. The HTTP/1.0 specification (RFC 1945) required the client to perform a temporary redirect (the original describing phrase was "Moved Temporarily"), but popular browsers implemented 302 with the functionality of a 303 See Other. Therefore, HTTP/1.1 added status codes 303 and 307 to distinguish between the two behaviours.',
    "302_CLASS": e.REDIRECTION,
    FOUND: 302,
    303: "See Other",
    "303_NAME": "SEE_OTHER",
    "303_MESSAGE": "The response to the request can be found under another URI using the GET method.",
    "303_CLASS": e.REDIRECTION,
    SEE_OTHER: 303,
    304: "Not Modified",
    "304_NAME": "NOT_MODIFIED",
    "304_MESSAGE": "Indicates that the resource has not been modified since the version specified by the request headers If-Modified-Since or If-None-Match.",
    "304_CLASS": e.REDIRECTION,
    NOT_MODIFIED: 304,
    305: "Use Proxy",
    "305_NAME": "USE_PROXY",
    "305_MESSAGE": "The requested resource is available only through a proxy, the address for which is provided in the response.",
    "305_CLASS": e.REDIRECTION,
    USE_PROXY: 305,
    306: "Switch Proxy",
    "306_NAME": "SWITCH_PROXY",
    "306_MESSAGE": 'No longer used. Originally meant "Subsequent requests should use the specified proxy.',
    "306_CLASS": e.REDIRECTION,
    SWITCH_PROXY: 306,
    307: "Temporary Redirect",
    "307_NAME": "TEMPORARY_REDIRECT",
    "307_MESSAGE": "In this case, the request should be repeated with another URI; however, future requests should still use the original URI.",
    "307_CLASS": e.REDIRECTION,
    TEMPORARY_REDIRECT: 307,
    308: "Permanent Redirect",
    "308_NAME": "PERMANENT_REDIRECT",
    "308_MESSAGE": "The request and all future requests should be repeated using another URI.",
    "308_CLASS": e.REDIRECTION,
    PERMANENT_REDIRECT: 308,
    400: "Bad Request",
    "400_NAME": "BAD_REQUEST",
    "400_MESSAGE": "The server cannot or will not process the request due to an apparent client error.",
    "400_CLASS": e.CLIENT_ERROR,
    BAD_REQUEST: 400,
    401: "Unauthorized",
    "401_NAME": "UNAUTHORIZED",
    "401_MESSAGE": "Similar to 403 Forbidden, but specifically for use when authentication is required and has failed or has not yet been provided.",
    "401_CLASS": e.CLIENT_ERROR,
    UNAUTHORIZED: 401,
    402: "Payment Required",
    "402_NAME": "PAYMENT_REQUIRED",
    "402_MESSAGE": "Reserved for future use. The original intention was that this code might be used as part of some form of digital cash or micropayment scheme, as proposed for example by GNU Taler, but that has not yet happened, and this code is not usually used.",
    "402_CLASS": e.CLIENT_ERROR,
    PAYMENT_REQUIRED: 402,
    403: "Forbidden",
    "403_NAME": "FORBIDDEN",
    "403_MESSAGE": "The request was valid, but the server is refusing action.",
    "403_CLASS": e.CLIENT_ERROR,
    FORBIDDEN: 403,
    404: "Not Found",
    "404_NAME": "NOT_FOUND",
    "404_MESSAGE": "The requested resource could not be found but may be available in the future. Subsequent requests by the client are permissible.",
    "404_CLASS": e.CLIENT_ERROR,
    NOT_FOUND: 404,
    405: "Method Not Allowed",
    "405_NAME": "METHOD_NOT_ALLOWED",
    "405_MESSAGE": "A request method is not supported for the requested resource.",
    "405_CLASS": e.CLIENT_ERROR,
    METHOD_NOT_ALLOWED: 405,
    406: "Not Acceptable",
    "406_NAME": "NOT_ACCEPTABLE",
    "406_MESSAGE": "The requested resource is capable of generating only content not acceptable according to the Accept headers sent in the request.",
    "406_CLASS": e.CLIENT_ERROR,
    NOT_ACCEPTABLE: 406,
    407: "Proxy Authentication Required",
    "407_NAME": "PROXY_AUTHENTICATION_REQUIRED",
    "407_MESSAGE": "The client must first authenticate itself with the proxy.",
    "407_CLASS": e.CLIENT_ERROR,
    PROXY_AUTHENTICATION_REQUIRED: 407,
    408: "Request Time-out",
    "408_NAME": "REQUEST_TIMEOUT",
    "408_MESSAGE": "The server timed out waiting for the request.",
    "408_CLASS": e.CLIENT_ERROR,
    REQUEST_TIMEOUT: 408,
    409: "Conflict",
    "409_NAME": "CONFLICT",
    "409_MESSAGE": "Indicates that the request could not be processed because of conflict in the request, such as an edit conflict between multiple simultaneous updates.",
    "409_CLASS": e.CLIENT_ERROR,
    CONFLICT: 409,
    410: "Gone",
    "410_NAME": "GONE",
    "410_MESSAGE": "Indicates that the resource requested is no longer available and will not be available again.",
    "410_CLASS": e.CLIENT_ERROR,
    GONE: 410,
    411: "Length Required",
    "411_NAME": "LENGTH_REQUIRED",
    "411_MESSAGE": "The request did not specify the length of its content, which is required by the requested resource.",
    "411_CLASS": e.CLIENT_ERROR,
    LENGTH_REQUIRED: 411,
    412: "Precondition Failed",
    "412_NAME": "PRECONDITION_FAILED",
    "412_MESSAGE": "The server does not meet one of the preconditions that the requester put on the request.",
    "412_CLASS": e.CLIENT_ERROR,
    PRECONDITION_FAILED: 412,
    413: "Request Entity Too Large",
    "413_NAME": "REQUEST_ENTITY_TOO_LARGE",
    "413_MESSAGE": 'The request is larger than the server is willing or able to process. Previously called "Request Entity Too Large".',
    "413_CLASS": e.CLIENT_ERROR,
    REQUEST_ENTITY_TOO_LARGE: 413,
    414: "Request-URI Too Large",
    "414_NAME": "REQUEST_URI_TOO_LONG",
    "414_MESSAGE": "The URI provided was too long for the server to process.",
    "414_CLASS": e.CLIENT_ERROR,
    REQUEST_URI_TOO_LONG: 414,
    415: "Unsupported Media Type",
    "415_NAME": "UNSUPPORTED_MEDIA_TYPE",
    "415_MESSAGE": "The request entity has a media type which the server or resource does not support.",
    "415_CLASS": e.CLIENT_ERROR,
    UNSUPPORTED_MEDIA_TYPE: 415,
    416: "Requested Range not Satisfiable",
    "416_NAME": "REQUESTED_RANGE_NOT_SATISFIABLE",
    "416_MESSAGE": "The client has asked for a portion of the file (byte serving), but the server cannot supply that portion.",
    "416_CLASS": e.CLIENT_ERROR,
    REQUESTED_RANGE_NOT_SATISFIABLE: 416,
    417: "Expectation Failed",
    "417_NAME": "EXPECTATION_FAILED",
    "417_MESSAGE": "The server cannot meet the requirements of the Expect request-header field.",
    "417_CLASS": e.CLIENT_ERROR,
    EXPECTATION_FAILED: 417,
    418: "I'm a teapot",
    "418_NAME": "IM_A_TEAPOT",
    "418_MESSAGE": `Any attempt to brew coffee with a teapot should result in the error code "418 I'm a teapot". The resulting entity body MAY be short and stout.`,
    "418_CLASS": e.CLIENT_ERROR,
    IM_A_TEAPOT: 418,
    421: "Misdirected Request",
    "421_NAME": "MISDIRECTED_REQUEST",
    "421_MESSAGE": "The request was directed at a server that is not able to produce a response.",
    "421_CLASS": e.CLIENT_ERROR,
    MISDIRECTED_REQUEST: 421,
    422: "Unprocessable Entity",
    "422_NAME": "UNPROCESSABLE_ENTITY",
    "422_MESSAGE": "The request was well-formed but was unable to be followed due to semantic errors.",
    "422_CLASS": e.CLIENT_ERROR,
    UNPROCESSABLE_ENTITY: 422,
    423: "Locked",
    "423_NAME": "LOCKED",
    "423_MESSAGE": "The resource that is being accessed is locked.",
    "423_CLASS": e.CLIENT_ERROR,
    LOCKED: 423,
    424: "Failed Dependency",
    "424_NAME": "FAILED_DEPENDENCY",
    "424_MESSAGE": "The request failed because it depended on another request and that request failed.",
    "424_CLASS": e.CLIENT_ERROR,
    FAILED_DEPENDENCY: 424,
    425: "Too Early",
    "425_NAME": "TOO_EARLY",
    "425_MESSAGE": "The server is unwilling to risk processing a request that might be replayed.",
    "425_CLASS": e.CLIENT_ERROR,
    TOO_EARLY: 425,
    426: "Upgrade Required",
    "426_NAME": "UPGRADE_REQUIRED",
    "426_MESSAGE": "The client should switch to a different protocol such as TLS/1.0, given in the Upgrade header field.",
    "426_CLASS": e.CLIENT_ERROR,
    UPGRADE_REQUIRED: 426,
    428: "Precondition Required",
    "428_NAME": "PRECONDITION_REQUIRED",
    "428_MESSAGE": "The origin server requires the request to be conditional.",
    "428_CLASS": e.CLIENT_ERROR,
    PRECONDITION_REQUIRED: 428,
    429: "Too Many Requests",
    "429_NAME": "TOO_MANY_REQUESTS",
    "429_MESSAGE": "The user has sent too many requests in a given amount of time.",
    "429_CLASS": e.CLIENT_ERROR,
    TOO_MANY_REQUESTS: 429,
    431: "Request Header Fields Too Large",
    "431_NAME": "REQUEST_HEADER_FIELDS_TOO_LARGE",
    "431_MESSAGE": "The server is unwilling to process the request because either an individual header field, or all the header fields collectively, are too large.",
    "431_CLASS": e.CLIENT_ERROR,
    REQUEST_HEADER_FIELDS_TOO_LARGE: 431,
    451: "Unavailable For Legal Reasons",
    "451_NAME": "UNAVAILABLE_FOR_LEGAL_REASONS",
    "451_MESSAGE": "A server operator has received a legal demand to deny access to a resource or to a set of resources that includes the requested resource.",
    "451_CLASS": e.CLIENT_ERROR,
    UNAVAILABLE_FOR_LEGAL_REASONS: 451,
    500: "Internal Server Error",
    "500_NAME": "INTERNAL_SERVER_ERROR",
    "500_MESSAGE": "A generic error message, given when an unexpected condition was encountered and no more specific message is suitable.",
    "500_CLASS": e.SERVER_ERROR,
    INTERNAL_SERVER_ERROR: 500,
    501: "Not Implemented",
    "501_NAME": "NOT_IMPLEMENTED",
    "501_MESSAGE": "The server either does not recognize the request method, or it lacks the ability to fulfil the request. Usually this implies future availability.",
    "501_CLASS": e.SERVER_ERROR,
    NOT_IMPLEMENTED: 501,
    502: "Bad Gateway",
    "502_NAME": "BAD_GATEWAY",
    "502_MESSAGE": "The server was acting as a gateway or proxy and received an invalid response from the upstream server.",
    "502_CLASS": e.SERVER_ERROR,
    BAD_GATEWAY: 502,
    503: "Service Unavailable",
    "503_NAME": "SERVICE_UNAVAILABLE",
    "503_MESSAGE": "The server is currently unavailable (because it is overloaded or down for maintenance). Generally, this is a temporary state.",
    "503_CLASS": e.SERVER_ERROR,
    SERVICE_UNAVAILABLE: 503,
    504: "Gateway Time-out",
    "504_NAME": "GATEWAY_TIMEOUT",
    "504_MESSAGE": "The server was acting as a gateway or proxy and did not receive a timely response from the upstream server.",
    "504_CLASS": e.SERVER_ERROR,
    GATEWAY_TIMEOUT: 504,
    505: "HTTP Version not Supported",
    "505_NAME": "HTTP_VERSION_NOT_SUPPORTED",
    "505_MESSAGE": "The server does not support the HTTP protocol version used in the request.",
    "505_CLASS": e.SERVER_ERROR,
    HTTP_VERSION_NOT_SUPPORTED: 505,
    506: "Variant Also Negotiates",
    "506_NAME": "VARIANT_ALSO_NEGOTIATES",
    "506_MESSAGE": "Transparent content negotiation for the request results in a circular reference.",
    "506_CLASS": e.SERVER_ERROR,
    VARIANT_ALSO_NEGOTIATES: 506,
    507: "Insufficient Storage",
    "507_NAME": "INSUFFICIENT_STORAGE",
    "507_MESSAGE": "The server is unable to store the representation needed to complete the request.",
    "507_CLASS": e.SERVER_ERROR,
    INSUFFICIENT_STORAGE: 507,
    508: "Loop Detected",
    "508_NAME": "LOOP_DETECTED",
    "508_MESSAGE": "The server detected an infinite loop while processing the request.",
    "508_CLASS": e.SERVER_ERROR,
    LOOP_DETECTED: 508,
    510: "Not Extended",
    "510_NAME": "NOT_EXTENDED",
    "510_MESSAGE": "Further extensions to the request are required for the server to fulfil it.",
    "510_CLASS": e.SERVER_ERROR,
    NOT_EXTENDED: 510,
    511: "Network Authentication Required",
    "511_NAME": "NETWORK_AUTHENTICATION_REQUIRED",
    "511_MESSAGE": "The client needs to authenticate to gain network access. Intended for use by intercepting proxies used to control access to the network.",
    "511_CLASS": e.SERVER_ERROR,
    NETWORK_AUTHENTICATION_REQUIRED: 511,
    extra: {
        unofficial: {
            103: "Checkpoint",
            "103_NAME": "CHECKPOINT",
            "103_MESSAGE": "Used in the resumable requests proposal to resume aborted PUT or POST requests.",
            "103_CLASS": e.INFORMATIONAL,
            CHECKPOINT: 103,
            419: "Page Expired",
            "419_NAME": "PAGE_EXPIRED",
            "419_MESSAGE": "Used by the Laravel Framework when a CSRF Token is missing or expired.",
            "419_CLASS": e.CLIENT_ERROR,
            PAGE_EXPIRED: 419,
            218: "This is fine",
            "218_NAME": "THIS_IS_FINE",
            "218_MESSAGE": "Used as a catch-all error condition for allowing response bodies to flow through Apache when ProxyErrorOverride is enabled. When ProxyErrorOverride is enabled in Apache, response bodies that contain a status code of 4xx or 5xx are automatically discarded by Apache in favor of a generic response or a custom response specified by the ErrorDocument directive.",
            "218_CLASS": e.SUCCESSFUL,
            THIS_IS_FINE: 218,
            420: "Enhance Your Calm",
            "420_NAME": "ENHANCE_YOUR_CALM",
            "420_MESSAGE": "Returned by version 1 of the Twitter Search and Trends API when the client is being rate limited; versions 1.1 and later use the 429 Too Many Requests response code instead.",
            "420_CLASS": e.CLIENT_ERROR,
            ENHANCE_YOUR_CALM: 420,
            450: "Blocked by Windows Parental Controls",
            "450_NAME": "BLOCKED_BY_WINDOWS_PARENTAL_CONTROLS",
            "450_MESSAGE": "The Microsoft extension code indicated when Windows Parental Controls are turned on and are blocking access to the requested webpage.",
            "450_CLASS": e.CLIENT_ERROR,
            BLOCKED_BY_WINDOWS_PARENTAL_CONTROLS: 450,
            498: "Invalid Token",
            "498_NAME": "INVALID_TOKEN",
            "498_MESSAGE": "Returned by ArcGIS for Server. Code 498 indicates an expired or otherwise invalid token.",
            "498_CLASS": e.CLIENT_ERROR,
            INVALID_TOKEN: 498,
            499: "Token Required",
            "499_NAME": "TOKEN_REQUIRED",
            "499_MESSAGE": "Returned by ArcGIS for Server. Code 499 indicates that a token is required but was not submitted.",
            "499_CLASS": e.CLIENT_ERROR,
            TOKEN_REQUIRED: 499,
            509: "Bandwidth Limit Exceeded",
            "509_NAME": "BANDWIDTH_LIMIT_EXCEEDED",
            "509_MESSAGE": "The server has exceeded the bandwidth specified by the server administrator.",
            "509_CLASS": e.SERVER_ERROR,
            BANDWIDTH_LIMIT_EXCEEDED: 509,
            530: "Site is frozen",
            "530_NAME": "SITE_IS_FROZEN",
            "530_MESSAGE": "Used by the Pantheon web platform to indicate a site that has been frozen due to inactivity.",
            "530_CLASS": e.SERVER_ERROR,
            SITE_IS_FROZEN: 530,
            598: "Network read timeout error",
            "598_NAME": "NETWORK_READ_TIMEOUT_ERROR",
            "598_MESSAGE": "Used by some HTTP proxies to signal a network read timeout behind the proxy to a client in front of the proxy.",
            "598_CLASS": e.SERVER_ERROR,
            NETWORK_READ_TIMEOUT_ERROR: 598
        },
        iis: {
            440: "Login Time-out",
            "440_NAME": "LOGIN_TIME_OUT",
            "440_MESSAGE": "The client's session has expired and must log in again.",
            "440_CLASS": e.CLIENT_ERROR,
            LOGIN_TIME_OUT: 440,
            449: "Retry With",
            "449_NAME": "RETRY_WITH",
            "449_MESSAGE": "The server cannot honour the request because the user has not provided the required information.",
            "449_CLASS": e.CLIENT_ERROR,
            RETRY_WITH: 449,
            451: "Redirect",
            "451_NAME": "REDIRECT",
            "451_MESSAGE": "Used in Exchange ActiveSync when either a more efficient server is available or the server cannot access the users' mailbox.",
            "451_CLASS": e.CLIENT_ERROR,
            REDIRECT: 451
        },
        nginx: {
            444: "No Response",
            "444_NAME": "NO_RESPONSE",
            "444_MESSAGE": "Used internally to instruct the server to return no information to the client and close the connection immediately.",
            "444_CLASS": e.CLIENT_ERROR,
            NO_RESPONSE: 444,
            494: "Request header too large",
            "494_NAME": "REQUEST_HEADER_TOO_LARGE",
            "494_MESSAGE": "Client sent too large request or too long header line.",
            "494_CLASS": e.CLIENT_ERROR,
            REQUEST_HEADER_TOO_LARGE: 494,
            495: "SSL Certificate Error",
            "495_NAME": "SSL_CERTIFICATE_ERROR",
            "495_MESSAGE": "An expansion of the 400 Bad Request response code, used when the client has provided an invalid client certificate.",
            "495_CLASS": e.CLIENT_ERROR,
            SSL_CERTIFICATE_ERROR: 495,
            496: "SSL Certificate Required",
            "496_NAME": "SSL_CERTIFICATE_REQUIRED",
            "496_MESSAGE": "An expansion of the 400 Bad Request response code, used when a client certificate is required but not provided.",
            "496_CLASS": e.CLIENT_ERROR,
            SSL_CERTIFICATE_REQUIRED: 496,
            497: "HTTP Request Sent to HTTPS Port",
            "497_NAME": "HTTP_REQUEST_SENT_TO_HTTPS_PORT",
            "497_MESSAGE": "An expansion of the 400 Bad Request response code, used when the client has made a HTTP request to a port listening for HTTPS requests.",
            "497_CLASS": e.CLIENT_ERROR,
            HTTP_REQUEST_SENT_TO_HTTPS_PORT: 497,
            499: "Client Closed Request",
            "499_NAME": "CLIENT_CLOSED_REQUEST",
            "499_MESSAGE": "Used when the client has closed the request before the server could send a response.",
            "499_CLASS": e.CLIENT_ERROR,
            CLIENT_CLOSED_REQUEST: 499
        },
        cloudflare: {
            520: "Unknown Error",
            "520_NAME": "UNKNOWN_ERROR",
            "520_MESSAGE": 'The 520 error is used as a "catch-all response for when the origin server returns something unexpected", listing connection resets, large headers, and empty or invalid responses as common triggers.',
            "520_CLASS": e.SERVER_ERROR,
            UNKNOWN_ERROR: 520,
            521: "Web Server Is Down",
            "521_NAME": "WEB_SERVER_IS_DOWN",
            "521_MESSAGE": "The origin server has refused the connection from Cloudflare.",
            "521_CLASS": e.SERVER_ERROR,
            WEB_SERVER_IS_DOWN: 521,
            522: "Connection Timed Out",
            "522_NAME": "CONNECTION_TIMED_OUT",
            "522_MESSAGE": "Cloudflare could not negotiate a TCP handshake with the origin server.",
            "522_CLASS": e.SERVER_ERROR,
            CONNECTION_TIMED_OUT: 522,
            523: "Origin Is Unreachable",
            "523_NAME": "ORIGIN_IS_UNREACHABLE",
            "523_MESSAGE": "Cloudflare could not reach the origin server.",
            "523_CLASS": e.SERVER_ERROR,
            ORIGIN_IS_UNREACHABLE: 523,
            524: "A Timeout Occurred",
            "524_NAME": "A_TIMEOUT_OCCURRED",
            "524_MESSAGE": "Cloudflare was able to complete a TCP connection to the origin server, but did not receive a timely HTTP response.",
            "524_CLASS": e.SERVER_ERROR,
            A_TIMEOUT_OCCURRED: 524,
            525: "SSL Handshake Failed",
            "525_NAME": "SSL_HANDSHAKE_FAILED",
            "525_MESSAGE": "Cloudflare could not negotiate a SSL/TLS handshake with the origin server.",
            "525_CLASS": e.SERVER_ERROR,
            SSL_HANDSHAKE_FAILED: 525,
            526: "Invalid SSL Certificate",
            "526_NAME": "INVALID_SSL_CERTIFICATE",
            "526_MESSAGE": "Cloudflare could not validate the SSL/TLS certificate that the origin server presented.",
            "526_CLASS": e.SERVER_ERROR,
            INVALID_SSL_CERTIFICATE: 526,
            527: "Railgun Error",
            "527_NAME": "RAILGUN_ERROR",
            "527_MESSAGE": "Error 527 indicates that the request timed out or failed after the WAN connection had been established.",
            "527_CLASS": e.SERVER_ERROR,
            RAILGUN_ERROR: 527
        }
    }
}, E = t;
;
}),
"[project]/node_modules/.pnpm/http-status@2.1.0/node_modules/http-status/dist/index.js [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$http$2d$status$40$2$2e$1$2e$0$2f$node_modules$2f$http$2d$status$2f$dist$2f$chunk$2d$CUNVWAK5$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/http-status@2.1.0/node_modules/http-status/dist/chunk-CUNVWAK5.js [app-rsc] (ecmascript)");
;
;
}),
"[project]/node_modules/.pnpm/http-status@2.1.0/node_modules/http-status/dist/chunk-CUNVWAK5.js [app-rsc] (ecmascript) <export a as status>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "status",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$http$2d$status$40$2$2e$1$2e$0$2f$node_modules$2f$http$2d$status$2f$dist$2f$chunk$2d$CUNVWAK5$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["a"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$http$2d$status$40$2$2e$1$2e$0$2f$node_modules$2f$http$2d$status$2f$dist$2f$chunk$2d$CUNVWAK5$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/http-status@2.1.0/node_modules/http-status/dist/chunk-CUNVWAK5.js [app-rsc] (ecmascript)");
}),
"[project]/node_modules/.pnpm/http-status@2.1.0/node_modules/http-status/dist/chunk-CUNVWAK5.js [app-rsc] (ecmascript) <export b as default>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$http$2d$status$40$2$2e$1$2e$0$2f$node_modules$2f$http$2d$status$2f$dist$2f$chunk$2d$CUNVWAK5$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["b"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$http$2d$status$40$2$2e$1$2e$0$2f$node_modules$2f$http$2d$status$2f$dist$2f$chunk$2d$CUNVWAK5$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/http-status@2.1.0/node_modules/http-status/dist/chunk-CUNVWAK5.js [app-rsc] (ecmascript)");
}),
"[project]/node_modules/.pnpm/dataloader@2.2.3/node_modules/dataloader/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) 2019-present, GraphQL Foundation
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */ // A Function, which when given an Array of keys, returns a Promise of an Array
// of values or Errors.
// Optionally turn off batching or caching or provide a cache key function or a
// custom cache instance.
// If a custom cache is provided, it must be of this type (a subset of ES6 Map).
/**
 * A `DataLoader` creates a public API for loading data from a particular
 * data back-end with unique keys such as the `id` column of a SQL table or
 * document name in a MongoDB database, given a batch loading function.
 *
 * Each `DataLoader` instance contains a unique memoized cache. Use caution when
 * used in long-lived applications or those which serve many users with
 * different access permissions and consider creating a new instance per
 * web request.
 */ var DataLoader = /*#__PURE__*/ function() {
    function DataLoader(batchLoadFn, options) {
        if (typeof batchLoadFn !== 'function') {
            throw new TypeError('DataLoader must be constructed with a function which accepts ' + ("Array<key> and returns Promise<Array<value>>, but got: " + batchLoadFn + "."));
        }
        this._batchLoadFn = batchLoadFn;
        this._maxBatchSize = getValidMaxBatchSize(options);
        this._batchScheduleFn = getValidBatchScheduleFn(options);
        this._cacheKeyFn = getValidCacheKeyFn(options);
        this._cacheMap = getValidCacheMap(options);
        this._batch = null;
        this.name = getValidName(options);
    } // Private
    var _proto = DataLoader.prototype;
    /**
   * Loads a key, returning a `Promise` for the value represented by that key.
   */ _proto.load = function load(key) {
        if (key === null || key === undefined) {
            throw new TypeError('The loader.load() function must be called with a value, ' + ("but got: " + String(key) + "."));
        }
        var batch = getCurrentBatch(this);
        var cacheMap = this._cacheMap;
        var cacheKey; // If caching and there is a cache-hit, return cached Promise.
        if (cacheMap) {
            cacheKey = this._cacheKeyFn(key);
            var cachedPromise = cacheMap.get(cacheKey);
            if (cachedPromise) {
                var cacheHits = batch.cacheHits || (batch.cacheHits = []);
                return new Promise(function(resolve) {
                    cacheHits.push(function() {
                        resolve(cachedPromise);
                    });
                });
            }
        } // Otherwise, produce a new Promise for this key, and enqueue it to be
        // dispatched along with the current batch.
        batch.keys.push(key);
        var promise = new Promise(function(resolve, reject) {
            batch.callbacks.push({
                resolve: resolve,
                reject: reject
            });
        }); // If caching, cache this promise.
        if (cacheMap) {
            cacheMap.set(cacheKey, promise);
        }
        return promise;
    };
    _proto.loadMany = function loadMany(keys) {
        if (!isArrayLike(keys)) {
            throw new TypeError('The loader.loadMany() function must be called with Array<key> ' + ("but got: " + keys + "."));
        } // Support ArrayLike by using only minimal property access
        var loadPromises = [];
        for(var i = 0; i < keys.length; i++){
            loadPromises.push(this.load(keys[i])["catch"](function(error) {
                return error;
            }));
        }
        return Promise.all(loadPromises);
    };
    _proto.clear = function clear(key) {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
            var cacheKey = this._cacheKeyFn(key);
            cacheMap["delete"](cacheKey);
        }
        return this;
    };
    _proto.clearAll = function clearAll() {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
            cacheMap.clear();
        }
        return this;
    };
    _proto.prime = function prime(key, value) {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
            var cacheKey = this._cacheKeyFn(key); // Only add the key if it does not already exist.
            if (cacheMap.get(cacheKey) === undefined) {
                // Cache a rejected promise if the value is an Error, in order to match
                // the behavior of load(key).
                var promise;
                if (value instanceof Error) {
                    promise = Promise.reject(value); // Since this is a case where an Error is intentionally being primed
                    // for a given key, we want to disable unhandled promise rejection.
                    promise["catch"](function() {});
                } else {
                    promise = Promise.resolve(value);
                }
                cacheMap.set(cacheKey, promise);
            }
        }
        return this;
    };
    return DataLoader;
}(); // Private: Enqueue a Job to be executed after all "PromiseJobs" Jobs.
//
// ES6 JavaScript uses the concepts Job and JobQueue to schedule work to occur
// after the current execution context has completed:
// http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues
//
// Node.js uses the `process.nextTick` mechanism to implement the concept of a
// Job, maintaining a global FIFO JobQueue for all Jobs, which is flushed after
// the current call stack ends.
//
// When calling `then` on a Promise, it enqueues a Job on a specific
// "PromiseJobs" JobQueue which is flushed in Node as a single Job on the
// global JobQueue.
//
// DataLoader batches all loads which occur in a single frame of execution, but
// should include in the batch all loads which occur during the flushing of the
// "PromiseJobs" JobQueue after that same execution frame.
//
// In order to avoid the DataLoader dispatch Job occuring before "PromiseJobs",
// A Promise Job is created with the sole purpose of enqueuing a global Job,
// ensuring that it always occurs after "PromiseJobs" ends.
//
// Node.js's job queue is unique. Browsers do not have an equivalent mechanism
// for enqueuing a job to be performed after promise microtasks and before the
// next macrotask. For browser environments, a macrotask is used (via
// setImmediate or setTimeout) at a potential performance penalty.
var enqueuePostPromiseJob = typeof process === 'object' && typeof process.nextTick === 'function' ? function(fn) {
    if (!resolvedPromise) {
        resolvedPromise = Promise.resolve();
    }
    resolvedPromise.then(function() {
        process.nextTick(fn);
    });
} : typeof setImmediate === 'function' ? function(fn) {
    setImmediate(fn);
} : function(fn) {
    setTimeout(fn);
}; // Private: cached resolved Promise instance
var resolvedPromise; // Private: Describes a batch of requests
// Private: Either returns the current batch, or creates and schedules a
// dispatch of a new batch for the given loader.
function getCurrentBatch(loader) {
    // If there is an existing batch which has not yet dispatched and is within
    // the limit of the batch size, then return it.
    var existingBatch = loader._batch;
    if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {
        return existingBatch;
    } // Otherwise, create a new batch for this loader.
    var newBatch = {
        hasDispatched: false,
        keys: [],
        callbacks: []
    }; // Store it on the loader so it may be reused.
    loader._batch = newBatch; // Then schedule a task to dispatch this batch of requests.
    loader._batchScheduleFn(function() {
        dispatchBatch(loader, newBatch);
    });
    return newBatch;
}
function dispatchBatch(loader, batch) {
    // Mark this batch as having been dispatched.
    batch.hasDispatched = true; // If there's nothing to load, resolve any cache hits and return early.
    if (batch.keys.length === 0) {
        resolveCacheHits(batch);
        return;
    } // Call the provided batchLoadFn for this loader with the batch's keys and
    // with the loader as the `this` context.
    var batchPromise;
    try {
        batchPromise = loader._batchLoadFn(batch.keys);
    } catch (e) {
        return failedDispatch(loader, batch, new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function ' + ("errored synchronously: " + String(e) + ".")));
    } // Assert the expected response from batchLoadFn
    if (!batchPromise || typeof batchPromise.then !== 'function') {
        return failedDispatch(loader, batch, new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + ("not return a Promise: " + String(batchPromise) + ".")));
    } // Await the resolution of the call to batchLoadFn.
    batchPromise.then(function(values) {
        // Assert the expected resolution from batchLoadFn.
        if (!isArrayLike(values)) {
            throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + ("not return a Promise of an Array: " + String(values) + "."));
        }
        if (values.length !== batch.keys.length) {
            throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + 'not return a Promise of an Array of the same length as the Array ' + 'of keys.' + ("\n\nKeys:\n" + String(batch.keys)) + ("\n\nValues:\n" + String(values)));
        } // Resolve all cache hits in the same micro-task as freshly loaded values.
        resolveCacheHits(batch); // Step through values, resolving or rejecting each Promise in the batch.
        for(var i = 0; i < batch.callbacks.length; i++){
            var _value = values[i];
            if (_value instanceof Error) {
                batch.callbacks[i].reject(_value);
            } else {
                batch.callbacks[i].resolve(_value);
            }
        }
    })["catch"](function(error) {
        failedDispatch(loader, batch, error);
    });
} // Private: do not cache individual loads if the entire batch dispatch fails,
// but still reject each request so they do not hang.
function failedDispatch(loader, batch, error) {
    // Cache hits are resolved, even though the batch failed.
    resolveCacheHits(batch);
    for(var i = 0; i < batch.keys.length; i++){
        loader.clear(batch.keys[i]);
        batch.callbacks[i].reject(error);
    }
} // Private: Resolves the Promises for any cache hits in this batch.
function resolveCacheHits(batch) {
    if (batch.cacheHits) {
        for(var i = 0; i < batch.cacheHits.length; i++){
            batch.cacheHits[i]();
        }
    }
} // Private: given the DataLoader's options, produce a valid max batch size.
function getValidMaxBatchSize(options) {
    var shouldBatch = !options || options.batch !== false;
    if (!shouldBatch) {
        return 1;
    }
    var maxBatchSize = options && options.maxBatchSize;
    if (maxBatchSize === undefined) {
        return Infinity;
    }
    if (typeof maxBatchSize !== 'number' || maxBatchSize < 1) {
        throw new TypeError("maxBatchSize must be a positive number: " + maxBatchSize);
    }
    return maxBatchSize;
} // Private
function getValidBatchScheduleFn(options) {
    var batchScheduleFn = options && options.batchScheduleFn;
    if (batchScheduleFn === undefined) {
        return enqueuePostPromiseJob;
    }
    if (typeof batchScheduleFn !== 'function') {
        throw new TypeError("batchScheduleFn must be a function: " + batchScheduleFn);
    }
    return batchScheduleFn;
} // Private: given the DataLoader's options, produce a cache key function.
function getValidCacheKeyFn(options) {
    var cacheKeyFn = options && options.cacheKeyFn;
    if (cacheKeyFn === undefined) {
        return function(key) {
            return key;
        };
    }
    if (typeof cacheKeyFn !== 'function') {
        throw new TypeError("cacheKeyFn must be a function: " + cacheKeyFn);
    }
    return cacheKeyFn;
} // Private: given the DataLoader's options, produce a CacheMap to be used.
function getValidCacheMap(options) {
    var shouldCache = !options || options.cache !== false;
    if (!shouldCache) {
        return null;
    }
    var cacheMap = options && options.cacheMap;
    if (cacheMap === undefined) {
        return new Map();
    }
    if (cacheMap !== null) {
        var cacheFunctions = [
            'get',
            'set',
            'delete',
            'clear'
        ];
        var missingFunctions = cacheFunctions.filter(function(fnName) {
            return cacheMap && typeof cacheMap[fnName] !== 'function';
        });
        if (missingFunctions.length !== 0) {
            throw new TypeError('Custom cacheMap missing methods: ' + missingFunctions.join(', '));
        }
    }
    return cacheMap;
}
function getValidName(options) {
    if (options && options.name) {
        return options.name;
    }
    return null;
} // Private
function isArrayLike(x) {
    return typeof x === 'object' && x !== null && typeof x.length === 'number' && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));
}
module.exports = DataLoader;
}),
"[project]/node_modules/.pnpm/bson-objectid@2.0.4/node_modules/bson-objectid/objectid.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var MACHINE_ID = Math.floor(Math.random() * 0xFFFFFF);
var index = ObjectID.index = parseInt(Math.random() * 0xFFFFFF, 10);
var pid = (typeof process === 'undefined' || typeof process.pid !== 'number' ? Math.floor(Math.random() * 100000) : process.pid) % 0xFFFF;
// <https://github.com/williamkapke/bson-objectid/pull/51>
// Attempt to fallback Buffer if _Buffer is undefined (e.g. for Node.js).
// Worst case fallback to null and handle with null checking before using.
var BufferCtr = (()=>{
    try {
        return _Buffer;
    } catch (_) {
        try {
            return Buffer;
        } catch (_) {
            return null;
        }
    }
})();
/**
 * Determine if an object is Buffer
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 */ var isBuffer = function(obj) {
    return !!(obj != null && obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj));
};
// Precomputed hex table enables speedy hex string conversion
var hexTable = [];
for(var i = 0; i < 256; i++){
    hexTable[i] = (i <= 15 ? '0' : '') + i.toString(16);
}
// Regular expression that checks for hex value
var checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$');
// Lookup tables
var decodeLookup = [];
i = 0;
while(i < 10)decodeLookup[0x30 + i] = i++;
while(i < 16)decodeLookup[0x41 - 10 + i] = decodeLookup[0x61 - 10 + i] = i++;
/**
 * Create a new immutable ObjectID instance
 *
 * @class Represents the BSON ObjectID type
 * @param {String|Number} id Can be a 24 byte hex string, 12 byte binary string or a Number.
 * @return {Object} instance of ObjectID.
 */ function ObjectID(id) {
    if (!(this instanceof ObjectID)) return new ObjectID(id);
    if (id && (id instanceof ObjectID || id._bsontype === "ObjectID")) return id;
    this._bsontype = 'ObjectID';
    // The most common usecase (blank id, new objectId instance)
    if (id == null || typeof id === 'number') {
        // Generate a new id
        this.id = this.generate(id);
        // Return the object
        return;
    }
    // Check if the passed in id is valid
    var valid = ObjectID.isValid(id);
    // Throw an error if it's not a valid setup
    if (!valid && id != null) {
        throw new Error('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');
    } else if (valid && typeof id === 'string' && id.length === 24) {
        return ObjectID.createFromHexString(id);
    } else if (id != null && id.length === 12) {
        // assume 12 byte string
        this.id = id;
    } else if (id != null && typeof id.toHexString === 'function') {
        // Duck-typing to support ObjectId from different npm packages
        return id;
    } else {
        throw new Error('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');
    }
}
module.exports = ObjectID;
ObjectID.default = ObjectID;
/**
 * Creates an ObjectID from a second based number, with the rest of the ObjectID zeroed out. Used for comparisons or sorting the ObjectID.
 *
 * @param {Number} time an integer number representing a number of seconds.
 * @return {ObjectID} return the created ObjectID
 * @api public
 */ ObjectID.createFromTime = function(time) {
    time = parseInt(time, 10) % 0xFFFFFFFF;
    return new ObjectID(hex(8, time) + "0000000000000000");
};
/**
 * Creates an ObjectID from a hex string representation of an ObjectID.
 *
 * @param {String} hexString create a ObjectID from a passed in 24 byte hexstring.
 * @return {ObjectID} return the created ObjectID
 * @api public
 */ ObjectID.createFromHexString = function(hexString) {
    // Throw an error if it's not a valid setup
    if (typeof hexString === 'undefined' || hexString != null && hexString.length !== 24) {
        throw new Error('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');
    }
    // Calculate lengths
    var data = '';
    var i = 0;
    while(i < 24){
        data += String.fromCharCode(decodeLookup[hexString.charCodeAt(i++)] << 4 | decodeLookup[hexString.charCodeAt(i++)]);
    }
    return new ObjectID(data);
};
/**
 * Checks if a value is a valid bson ObjectId
 *
 * @param {String} objectid Can be a 24 byte hex string or an instance of ObjectID.
 * @return {Boolean} return true if the value is a valid bson ObjectID, return false otherwise.
 * @api public
 *
 * THE NATIVE DOCUMENTATION ISN'T CLEAR ON THIS GUY!
 * http://mongodb.github.io/node-mongodb-native/api-bson-generated/objectid.html#objectid-isvalid
 */ ObjectID.isValid = function(id) {
    if (id == null) return false;
    if (typeof id === 'number') {
        return true;
    }
    if (typeof id === 'string') {
        return id.length === 12 || id.length === 24 && checkForHexRegExp.test(id);
    }
    if (id instanceof ObjectID) {
        return true;
    }
    // <https://github.com/williamkapke/bson-objectid/issues/53>
    if (isBuffer(id)) {
        return ObjectID.isValid(id.toString('hex'));
    }
    // Duck-Typing detection of ObjectId like objects
    // <https://github.com/williamkapke/bson-objectid/pull/51>
    if (typeof id.toHexString === 'function') {
        if (BufferCtr && (id.id instanceof BufferCtr || typeof id.id === 'string')) {
            return id.id.length === 12 || id.id.length === 24 && checkForHexRegExp.test(id.id);
        }
    }
    return false;
};
ObjectID.prototype = {
    constructor: ObjectID,
    /**
   * Return the ObjectID id as a 24 byte hex string representation
   *
   * @return {String} return the 24 byte hex string representation.
   * @api public
   */ toHexString: function() {
        if (!this.id || !this.id.length) {
            throw new Error('invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [' + JSON.stringify(this.id) + ']');
        }
        if (this.id.length === 24) {
            return this.id;
        }
        if (isBuffer(this.id)) {
            return this.id.toString('hex');
        }
        var hexString = '';
        for(var i = 0; i < this.id.length; i++){
            hexString += hexTable[this.id.charCodeAt(i)];
        }
        return hexString;
    },
    /**
   * Compares the equality of this ObjectID with `otherID`.
   *
   * @param {Object} otherId ObjectID instance to compare against.
   * @return {Boolean} the result of comparing two ObjectID's
   * @api public
   */ equals: function(otherId) {
        if (otherId instanceof ObjectID) {
            return this.toString() === otherId.toString();
        } else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 12 && isBuffer(this.id)) {
            return otherId === this.id.toString('binary');
        } else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 24) {
            return otherId.toLowerCase() === this.toHexString();
        } else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 12) {
            return otherId === this.id;
        } else if (otherId != null && (otherId instanceof ObjectID || otherId.toHexString)) {
            return otherId.toHexString() === this.toHexString();
        } else {
            return false;
        }
    },
    /**
   * Returns the generation date (accurate up to the second) that this ID was generated.
   *
   * @return {Date} the generation date
   * @api public
   */ getTimestamp: function() {
        var timestamp = new Date();
        var time;
        if (isBuffer(this.id)) {
            time = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
        } else {
            time = this.id.charCodeAt(3) | this.id.charCodeAt(2) << 8 | this.id.charCodeAt(1) << 16 | this.id.charCodeAt(0) << 24;
        }
        timestamp.setTime(Math.floor(time) * 1000);
        return timestamp;
    },
    /**
  * Generate a 12 byte id buffer used in ObjectID's
  *
  * @method
  * @param {number} [time] optional parameter allowing to pass in a second based timestamp.
  * @return {string} return the 12 byte id buffer string.
  */ generate: function(time) {
        if ('number' !== typeof time) {
            time = ~~(Date.now() / 1000);
        }
        //keep it in the ring!
        time = parseInt(time, 10) % 0xFFFFFFFF;
        var inc = next();
        return String.fromCharCode(time >> 24 & 0xFF, time >> 16 & 0xFF, time >> 8 & 0xFF, time & 0xFF, MACHINE_ID >> 16 & 0xFF, MACHINE_ID >> 8 & 0xFF, MACHINE_ID & 0xFF, pid >> 8 & 0xFF, pid & 0xFF, inc >> 16 & 0xFF, inc >> 8 & 0xFF, inc & 0xFF);
    }
};
function next() {
    return index = (index + 1) % 0xFFFFFF;
}
function hex(length, n) {
    n = n.toString(16);
    return n.length === length ? n : "00000000".substring(n.length, length) + n;
}
function buffer(str) {
    var i = 0, out = [];
    if (str.length === 24) for(; i < 24; out.push(parseInt(str[i] + str[i + 1], 16)), i += 2);
    else if (str.length === 12) for(; i < 12; out.push(str.charCodeAt(i)), i++);
    return out;
}
var inspect = Symbol && Symbol.for && Symbol.for('nodejs.util.inspect.custom') || 'inspect';
/**
 * Converts to a string representation of this Id.
 *
 * @return {String} return the 24 byte hex string representation.
 * @api private
 */ ObjectID.prototype[inspect] = function() {
    return "ObjectID(" + this + ")";
};
ObjectID.prototype.toJSON = ObjectID.prototype.toHexString;
ObjectID.prototype.toString = ObjectID.prototype.toHexString;
}),
"[project]/node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// do not edit .js files directly - edit src/index.jst
module.exports = function equal(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
            length = a.length;
            if (length != b.length) return false;
            for(i = length; i-- !== 0;)if (!equal(a[i], b[i])) return false;
            return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for(i = length; i-- !== 0;){
            var key = keys[i];
            if (!equal(a[key], b[key])) return false;
        }
        return true;
    }
    // true if both NaN, false otherwise
    return a !== a && b !== b;
};
}),
"[project]/node_modules/.pnpm/json-schema-traverse@1.0.0/node_modules/json-schema-traverse/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var traverse = module.exports = function(schema, opts, cb) {
    // Legacy support for v0.3.1 and earlier.
    if (typeof opts == 'function') {
        cb = opts;
        opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == 'function' ? cb : cb.pre || function() {};
    var post = cb.post || function() {};
    _traverse(opts, pre, post, schema, '', schema);
};
traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true,
    if: true,
    then: true,
    else: true
};
traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
};
traverse.propsKeywords = {
    $defs: true,
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
};
traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
};
function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for(var key in schema){
            var sch = schema[key];
            if (Array.isArray(sch)) {
                if (key in traverse.arrayKeywords) {
                    for(var i = 0; i < sch.length; i++)_traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
                }
            } else if (key in traverse.propsKeywords) {
                if (sch && typeof sch == 'object') {
                    for(var prop in sch)_traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
                }
            } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
                _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
            }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
}
function escapeJsonPtr(str) {
    return str.replace(/~/g, '~0').replace(/\//g, '~1');
}
}),
"[project]/node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/lib/utils.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {(value: string) => boolean} */ const isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
/** @type {(value: string) => boolean} */ const isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
/**
 * @param {Array<string>} input
 * @returns {string}
 */ function stringArrayToHexStripped(input) {
    let acc = '';
    let code = 0;
    let i = 0;
    for(i = 0; i < input.length; i++){
        code = input[i].charCodeAt(0);
        if (code === 48) {
            continue;
        }
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
            return '';
        }
        acc += input[i];
        break;
    }
    for(i += 1; i < input.length; i++){
        code = input[i].charCodeAt(0);
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
            return '';
        }
        acc += input[i];
    }
    return acc;
}
/**
 * @typedef {Object} GetIPV6Result
 * @property {boolean} error - Indicates if there was an error parsing the IPv6 address.
 * @property {string} address - The parsed IPv6 address.
 * @property {string} [zone] - The zone identifier, if present.
 */ /**
 * @param {string} value
 * @returns {boolean}
 */ const nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
/**
 * @param {Array<string>} buffer
 * @returns {boolean}
 */ function consumeIsZone(buffer) {
    buffer.length = 0;
    return true;
}
/**
 * @param {Array<string>} buffer
 * @param {Array<string>} address
 * @param {GetIPV6Result} output
 * @returns {boolean}
 */ function consumeHextets(buffer, address, output) {
    if (buffer.length) {
        const hex = stringArrayToHexStripped(buffer);
        if (hex !== '') {
            address.push(hex);
        } else {
            output.error = true;
            return false;
        }
        buffer.length = 0;
    }
    return true;
}
/**
 * @param {string} input
 * @returns {GetIPV6Result}
 */ function getIPV6(input) {
    let tokenCount = 0;
    const output = {
        error: false,
        address: '',
        zone: ''
    };
    /** @type {Array<string>} */ const address = [];
    /** @type {Array<string>} */ const buffer = [];
    let endipv6Encountered = false;
    let endIpv6 = false;
    let consume = consumeHextets;
    for(let i = 0; i < input.length; i++){
        const cursor = input[i];
        if (cursor === '[' || cursor === ']') {
            continue;
        }
        if (cursor === ':') {
            if (endipv6Encountered === true) {
                endIpv6 = true;
            }
            if (!consume(buffer, address, output)) {
                break;
            }
            if (++tokenCount > 7) {
                // not valid
                output.error = true;
                break;
            }
            if (i > 0 && input[i - 1] === ':') {
                endipv6Encountered = true;
            }
            address.push(':');
            continue;
        } else if (cursor === '%') {
            if (!consume(buffer, address, output)) {
                break;
            }
            // switch to zone detection
            consume = consumeIsZone;
        } else {
            buffer.push(cursor);
            continue;
        }
    }
    if (buffer.length) {
        if (consume === consumeIsZone) {
            output.zone = buffer.join('');
        } else if (endIpv6) {
            address.push(buffer.join(''));
        } else {
            address.push(stringArrayToHexStripped(buffer));
        }
    }
    output.address = address.join('');
    return output;
}
/**
 * @typedef {Object} NormalizeIPv6Result
 * @property {string} host - The normalized host.
 * @property {string} [escapedHost] - The escaped host.
 * @property {boolean} isIPV6 - Indicates if the host is an IPv6 address.
 */ /**
 * @param {string} host
 * @returns {NormalizeIPv6Result}
 */ function normalizeIPv6(host) {
    if (findToken(host, ':') < 2) {
        return {
            host,
            isIPV6: false
        };
    }
    const ipv6 = getIPV6(host);
    if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
            newHost += '%' + ipv6.zone;
            escapedHost += '%25' + ipv6.zone;
        }
        return {
            host: newHost,
            isIPV6: true,
            escapedHost
        };
    } else {
        return {
            host,
            isIPV6: false
        };
    }
}
/**
 * @param {string} str
 * @param {string} token
 * @returns {number}
 */ function findToken(str, token) {
    let ind = 0;
    for(let i = 0; i < str.length; i++){
        if (str[i] === token) ind++;
    }
    return ind;
}
/**
 * @param {string} path
 * @returns {string}
 *
 * @see https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4
 */ function removeDotSegments(path) {
    let input = path;
    const output = [];
    let nextSlash = -1;
    let len = 0;
    // eslint-disable-next-line no-cond-assign
    while(len = input.length){
        if (len === 1) {
            if (input === '.') {
                break;
            } else if (input === '/') {
                output.push('/');
                break;
            } else {
                output.push(input);
                break;
            }
        } else if (len === 2) {
            if (input[0] === '.') {
                if (input[1] === '.') {
                    break;
                } else if (input[1] === '/') {
                    input = input.slice(2);
                    continue;
                }
            } else if (input[0] === '/') {
                if (input[1] === '.' || input[1] === '/') {
                    output.push('/');
                    break;
                }
            }
        } else if (len === 3) {
            if (input === '/..') {
                if (output.length !== 0) {
                    output.pop();
                }
                output.push('/');
                break;
            }
        }
        if (input[0] === '.') {
            if (input[1] === '.') {
                if (input[2] === '/') {
                    input = input.slice(3);
                    continue;
                }
            } else if (input[1] === '/') {
                input = input.slice(2);
                continue;
            }
        } else if (input[0] === '/') {
            if (input[1] === '.') {
                if (input[2] === '/') {
                    input = input.slice(2);
                    continue;
                } else if (input[2] === '.') {
                    if (input[3] === '/') {
                        input = input.slice(3);
                        if (output.length !== 0) {
                            output.pop();
                        }
                        continue;
                    }
                }
            }
        }
        // Rule 2E: Move normal path segment to output
        if ((nextSlash = input.indexOf('/', 1)) === -1) {
            output.push(input);
            break;
        } else {
            output.push(input.slice(0, nextSlash));
            input = input.slice(nextSlash);
        }
    }
    return output.join('');
}
/**
 * @param {import('../types/index').URIComponent} component
 * @param {boolean} esc
 * @returns {import('../types/index').URIComponent}
 */ function normalizeComponentEncoding(component, esc) {
    const func = esc !== true ? escape : unescape;
    if (component.scheme !== undefined) {
        component.scheme = func(component.scheme);
    }
    if (component.userinfo !== undefined) {
        component.userinfo = func(component.userinfo);
    }
    if (component.host !== undefined) {
        component.host = func(component.host);
    }
    if (component.path !== undefined) {
        component.path = func(component.path);
    }
    if (component.query !== undefined) {
        component.query = func(component.query);
    }
    if (component.fragment !== undefined) {
        component.fragment = func(component.fragment);
    }
    return component;
}
/**
 * @param {import('../types/index').URIComponent} component
 * @returns {string|undefined}
 */ function recomposeAuthority(component) {
    const uriTokens = [];
    if (component.userinfo !== undefined) {
        uriTokens.push(component.userinfo);
        uriTokens.push('@');
    }
    if (component.host !== undefined) {
        let host = unescape(component.host);
        if (!isIPv4(host)) {
            const ipV6res = normalizeIPv6(host);
            if (ipV6res.isIPV6 === true) {
                host = `[${ipV6res.escapedHost}]`;
            } else {
                host = component.host;
            }
        }
        uriTokens.push(host);
    }
    if (typeof component.port === 'number' || typeof component.port === 'string') {
        uriTokens.push(':');
        uriTokens.push(String(component.port));
    }
    return uriTokens.length ? uriTokens.join('') : undefined;
}
;
module.exports = {
    nonSimpleDomain,
    recomposeAuthority,
    normalizeComponentEncoding,
    removeDotSegments,
    isIPv4,
    isUUID,
    normalizeIPv6,
    stringArrayToHexStripped
};
}),
"[project]/node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/lib/schemes.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { isUUID } = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/lib/utils.js [app-rsc] (ecmascript)");
const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
const supportedSchemeNames = [
    'http',
    'https',
    'ws',
    'wss',
    'urn',
    'urn:uuid'
];
/** @typedef {supportedSchemeNames[number]} SchemeName */ /**
 * @param {string} name
 * @returns {name is SchemeName}
 */ function isValidSchemeName(name) {
    return supportedSchemeNames.indexOf(name) !== -1;
}
/**
 * @callback SchemeFn
 * @param {import('../types/index').URIComponent} component
 * @param {import('../types/index').Options} options
 * @returns {import('../types/index').URIComponent}
 */ /**
 * @typedef {Object} SchemeHandler
 * @property {SchemeName} scheme - The scheme name.
 * @property {boolean} [domainHost] - Indicates if the scheme supports domain hosts.
 * @property {SchemeFn} parse - Function to parse the URI component for this scheme.
 * @property {SchemeFn} serialize - Function to serialize the URI component for this scheme.
 * @property {boolean} [skipNormalize] - Indicates if normalization should be skipped for this scheme.
 * @property {boolean} [absolutePath] - Indicates if the scheme uses absolute paths.
 * @property {boolean} [unicodeSupport] - Indicates if the scheme supports Unicode.
 */ /**
 * @param {import('../types/index').URIComponent} wsComponent
 * @returns {boolean}
 */ function wsIsSecure(wsComponent) {
    if (wsComponent.secure === true) {
        return true;
    } else if (wsComponent.secure === false) {
        return false;
    } else if (wsComponent.scheme) {
        return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === 'w' || wsComponent.scheme[0] === 'W') && (wsComponent.scheme[1] === 's' || wsComponent.scheme[1] === 'S') && (wsComponent.scheme[2] === 's' || wsComponent.scheme[2] === 'S');
    } else {
        return false;
    }
}
/** @type {SchemeFn} */ function httpParse(component) {
    if (!component.host) {
        component.error = component.error || 'HTTP URIs must have a host.';
    }
    return component;
}
/** @type {SchemeFn} */ function httpSerialize(component) {
    const secure = String(component.scheme).toLowerCase() === 'https';
    // normalize the default port
    if (component.port === (secure ? 443 : 80) || component.port === '') {
        component.port = undefined;
    }
    // normalize the empty path
    if (!component.path) {
        component.path = '/';
    }
    // NOTE: We do not parse query strings for HTTP URIs
    // as WWW Form Url Encoded query strings are part of the HTML4+ spec,
    // and not the HTTP spec.
    return component;
}
/** @type {SchemeFn} */ function wsParse(wsComponent) {
    // indicate if the secure flag is set
    wsComponent.secure = wsIsSecure(wsComponent);
    // construct resouce name
    wsComponent.resourceName = (wsComponent.path || '/') + (wsComponent.query ? '?' + wsComponent.query : '');
    wsComponent.path = undefined;
    wsComponent.query = undefined;
    return wsComponent;
}
/** @type {SchemeFn} */ function wsSerialize(wsComponent) {
    // normalize the default port
    if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === '') {
        wsComponent.port = undefined;
    }
    // ensure scheme matches secure flag
    if (typeof wsComponent.secure === 'boolean') {
        wsComponent.scheme = wsComponent.secure ? 'wss' : 'ws';
        wsComponent.secure = undefined;
    }
    // reconstruct path from resource name
    if (wsComponent.resourceName) {
        const [path, query] = wsComponent.resourceName.split('?');
        wsComponent.path = path && path !== '/' ? path : undefined;
        wsComponent.query = query;
        wsComponent.resourceName = undefined;
    }
    // forbid fragment component
    wsComponent.fragment = undefined;
    return wsComponent;
}
/** @type {SchemeFn} */ function urnParse(urnComponent, options) {
    if (!urnComponent.path) {
        urnComponent.error = 'URN can not be parsed';
        return urnComponent;
    }
    const matches = urnComponent.path.match(URN_REG);
    if (matches) {
        const scheme = options.scheme || urnComponent.scheme || 'urn';
        urnComponent.nid = matches[1].toLowerCase();
        urnComponent.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
        const schemeHandler = getSchemeHandler(urnScheme);
        urnComponent.path = undefined;
        if (schemeHandler) {
            urnComponent = schemeHandler.parse(urnComponent, options);
        }
    } else {
        urnComponent.error = urnComponent.error || 'URN can not be parsed.';
    }
    return urnComponent;
}
/** @type {SchemeFn} */ function urnSerialize(urnComponent, options) {
    if (urnComponent.nid === undefined) {
        throw new Error('URN without nid cannot be serialized');
    }
    const scheme = options.scheme || urnComponent.scheme || 'urn';
    const nid = urnComponent.nid.toLowerCase();
    const urnScheme = `${scheme}:${options.nid || nid}`;
    const schemeHandler = getSchemeHandler(urnScheme);
    if (schemeHandler) {
        urnComponent = schemeHandler.serialize(urnComponent, options);
    }
    const uriComponent = urnComponent;
    const nss = urnComponent.nss;
    uriComponent.path = `${nid || options.nid}:${nss}`;
    options.skipEscape = true;
    return uriComponent;
}
/** @type {SchemeFn} */ function urnuuidParse(urnComponent, options) {
    const uuidComponent = urnComponent;
    uuidComponent.uuid = uuidComponent.nss;
    uuidComponent.nss = undefined;
    if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
        uuidComponent.error = uuidComponent.error || 'UUID is not valid.';
    }
    return uuidComponent;
}
/** @type {SchemeFn} */ function urnuuidSerialize(uuidComponent) {
    const urnComponent = uuidComponent;
    // normalize UUID
    urnComponent.nss = (uuidComponent.uuid || '').toLowerCase();
    return urnComponent;
}
const http = {
    scheme: 'http',
    domainHost: true,
    parse: httpParse,
    serialize: httpSerialize
};
const https = {
    scheme: 'https',
    domainHost: http.domainHost,
    parse: httpParse,
    serialize: httpSerialize
};
const ws = {
    scheme: 'ws',
    domainHost: true,
    parse: wsParse,
    serialize: wsSerialize
};
const wss = {
    scheme: 'wss',
    domainHost: ws.domainHost,
    parse: ws.parse,
    serialize: ws.serialize
};
const urn = {
    scheme: 'urn',
    parse: urnParse,
    serialize: urnSerialize,
    skipNormalize: true
};
const urnuuid = {
    scheme: 'urn:uuid',
    parse: urnuuidParse,
    serialize: urnuuidSerialize,
    skipNormalize: true
};
const SCHEMES = {
    http,
    https,
    ws,
    wss,
    urn,
    'urn:uuid': urnuuid
};
Object.setPrototypeOf(SCHEMES, null);
/**
 * @param {string|undefined} scheme
 * @returns {SchemeHandler|undefined}
 */ function getSchemeHandler(scheme) {
    return scheme && (SCHEMES[scheme] || SCHEMES[scheme.toLowerCase()]) || undefined;
}
module.exports = {
    wsIsSecure,
    SCHEMES,
    isValidSchemeName,
    getSchemeHandler
};
}),
"[project]/node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/lib/utils.js [app-rsc] (ecmascript)");
const { SCHEMES, getSchemeHandler } = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/lib/schemes.js [app-rsc] (ecmascript)");
/**
 * @template {import('./types/index').URIComponent|string} T
 * @param {T} uri
 * @param {import('./types/index').Options} [options]
 * @returns {T}
 */ function normalize(uri, options) {
    if (typeof uri === 'string') {
        uri = serialize(parse(uri, options), options);
    } else if (typeof uri === 'object') {
        uri = parse(serialize(uri, options), options);
    }
    return uri;
}
/**
 * @param {string} baseURI
 * @param {string} relativeURI
 * @param {import('./types/index').Options} [options]
 * @returns {string}
 */ function resolve(baseURI, relativeURI, options) {
    const schemelessOptions = options ? Object.assign({
        scheme: 'null'
    }, options) : {
        scheme: 'null'
    };
    const resolved = resolveComponent(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
    schemelessOptions.skipEscape = true;
    return serialize(resolved, schemelessOptions);
}
/**
 * @param {import ('./types/index').URIComponent} base
 * @param {import ('./types/index').URIComponent} relative
 * @param {import('./types/index').Options} [options]
 * @param {boolean} [skipNormalization=false]
 * @returns {import ('./types/index').URIComponent}
 */ function resolveComponent(base, relative, options, skipNormalization) {
    /** @type {import('./types/index').URIComponent} */ const target = {};
    if (!skipNormalization) {
        base = parse(serialize(base, options), options); // normalize base component
        relative = parse(serialize(relative, options), options); // normalize relative component
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        // target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || '');
        target.query = relative.query;
    } else {
        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
            // target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || '');
            target.query = relative.query;
        } else {
            if (!relative.path) {
                target.path = base.path;
                if (relative.query !== undefined) {
                    target.query = relative.query;
                } else {
                    target.query = base.query;
                }
            } else {
                if (relative.path[0] === '/') {
                    target.path = removeDotSegments(relative.path);
                } else {
                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                        target.path = '/' + relative.path;
                    } else if (!base.path) {
                        target.path = relative.path;
                    } else {
                        target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path;
                    }
                    target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
            }
            // target.authority = base.authority;
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
        }
        target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
}
/**
 * @param {import ('./types/index').URIComponent|string} uriA
 * @param {import ('./types/index').URIComponent|string} uriB
 * @param {import ('./types/index').Options} options
 * @returns {boolean}
 */ function equal(uriA, uriB, options) {
    if (typeof uriA === 'string') {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), {
            ...options,
            skipEscape: true
        });
    } else if (typeof uriA === 'object') {
        uriA = serialize(normalizeComponentEncoding(uriA, true), {
            ...options,
            skipEscape: true
        });
    }
    if (typeof uriB === 'string') {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), {
            ...options,
            skipEscape: true
        });
    } else if (typeof uriB === 'object') {
        uriB = serialize(normalizeComponentEncoding(uriB, true), {
            ...options,
            skipEscape: true
        });
    }
    return uriA.toLowerCase() === uriB.toLowerCase();
}
/**
 * @param {Readonly<import('./types/index').URIComponent>} cmpts
 * @param {import('./types/index').Options} [opts]
 * @returns {string}
 */ function serialize(cmpts, opts) {
    const component = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ''
    };
    const options = Object.assign({}, opts);
    const uriTokens = [];
    // find scheme handler
    const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
    // perform scheme specific serialization
    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
    if (component.path !== undefined) {
        if (!options.skipEscape) {
            component.path = escape(component.path);
            if (component.scheme !== undefined) {
                component.path = component.path.split('%3A').join(':');
            }
        } else {
            component.path = unescape(component.path);
        }
    }
    if (options.reference !== 'suffix' && component.scheme) {
        uriTokens.push(component.scheme, ':');
    }
    const authority = recomposeAuthority(component);
    if (authority !== undefined) {
        if (options.reference !== 'suffix') {
            uriTokens.push('//');
        }
        uriTokens.push(authority);
        if (component.path && component.path[0] !== '/') {
            uriTokens.push('/');
        }
    }
    if (component.path !== undefined) {
        let s = component.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
        }
        if (authority === undefined && s[0] === '/' && s[1] === '/') {
            // don't allow the path to start with "//"
            s = '/%2F' + s.slice(2);
        }
        uriTokens.push(s);
    }
    if (component.query !== undefined) {
        uriTokens.push('?', component.query);
    }
    if (component.fragment !== undefined) {
        uriTokens.push('#', component.fragment);
    }
    return uriTokens.join('');
}
const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
/**
 * @param {string} uri
 * @param {import('./types/index').Options} [opts]
 * @returns
 */ function parse(uri, opts) {
    const options = Object.assign({}, opts);
    /** @type {import('./types/index').URIComponent} */ const parsed = {
        scheme: undefined,
        userinfo: undefined,
        host: '',
        port: undefined,
        path: '',
        query: undefined,
        fragment: undefined
    };
    let isIP = false;
    if (options.reference === 'suffix') {
        if (options.scheme) {
            uri = options.scheme + ':' + uri;
        } else {
            uri = '//' + uri;
        }
    }
    const matches = uri.match(URI_PARSE);
    if (matches) {
        // store each component
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || '';
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        // fix port number
        if (isNaN(parsed.port)) {
            parsed.port = matches[5];
        }
        if (parsed.host) {
            const ipv4result = isIPv4(parsed.host);
            if (ipv4result === false) {
                const ipv6result = normalizeIPv6(parsed.host);
                parsed.host = ipv6result.host.toLowerCase();
                isIP = ipv6result.isIPV6;
            } else {
                isIP = true;
            }
        }
        if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && parsed.query === undefined && !parsed.path) {
            parsed.reference = 'same-document';
        } else if (parsed.scheme === undefined) {
            parsed.reference = 'relative';
        } else if (parsed.fragment === undefined) {
            parsed.reference = 'absolute';
        } else {
            parsed.reference = 'uri';
        }
        // check for reference errors
        if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {
            parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.';
        }
        // find scheme handler
        const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
        // check if scheme can't handle IRIs
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            // if host component is a domain name
            if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
                // convert Unicode IDN -> ASCII IDN
                try {
                    parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
                } catch (e) {
                    parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
                }
            }
        // convert IRI -> URI
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
            if (uri.indexOf('%') !== -1) {
                if (parsed.scheme !== undefined) {
                    parsed.scheme = unescape(parsed.scheme);
                }
                if (parsed.host !== undefined) {
                    parsed.host = unescape(parsed.host);
                }
            }
            if (parsed.path) {
                parsed.path = escape(unescape(parsed.path));
            }
            if (parsed.fragment) {
                parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
            }
        }
        // perform scheme specific parsing
        if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(parsed, options);
        }
    } else {
        parsed.error = parsed.error || 'URI can not be parsed.';
    }
    return parsed;
}
const fastUri = {
    SCHEMES,
    normalize,
    resolve,
    resolveComponent,
    equal,
    serialize,
    parse
};
module.exports = fastUri;
module.exports.default = fastUri;
module.exports.fastUri = fastUri;
}),
"[project]/node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isMergeableObject = function isMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
    return !!value && typeof value === 'object';
}
function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
}
// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;
function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}
function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
    });
}
function getMergeFunction(key, options) {
    if (!options.customMerge) {
        return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === 'function' ? customMerge : deepmerge;
}
function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
    }) : [];
}
function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
}
function propertyIsOnObject(object, property) {
    try {
        return property in object;
    } catch (_) {
        return false;
    }
}
// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
     && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
     && Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
    ;
}
function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
            destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
    }
    getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
            return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
            destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
            destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
    });
    return destination;
}
function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    // implementations can use it. The caller may not replace it.
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
    } else {
        return mergeObject(target, source, options);
    }
}
deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) {
        throw new Error('first argument should be an array');
    }
    return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
    }, {});
};
var deepmerge_1 = deepmerge;
module.exports = deepmerge_1;
}),
"[project]/node_modules/.pnpm/@payloadcms+translations@3.64.0/node_modules/@payloadcms/translations/dist/utilities/getTranslation.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getTranslation",
    ()=>getTranslation
]);
const getTranslation = (label, /**
   * @todo type as I18nClient in 4.0
   */ i18n)=>{
    // If it's a Record, look for translation. If string or React Element, pass through
    if (typeof label === 'object' && !Object.prototype.hasOwnProperty.call(label, '$$typeof')) {
        // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve
        if (label[i18n.language]) {
            // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve
            return label[i18n.language];
        }
        let fallbacks = [];
        if (typeof i18n.fallbackLanguage === 'string') {
            fallbacks = [
                i18n.fallbackLanguage
            ];
        } else if (Array.isArray(i18n.fallbackLanguage)) {
            fallbacks = i18n.fallbackLanguage;
        }
        const fallbackLang = fallbacks.find((language)=>label[language]);
        // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve
        return fallbackLang && label[fallbackLang] ? label[fallbackLang] : label[Object.keys(label)[0]];
    }
    if (typeof label === 'function') {
        return label({
            i18n: i18n,
            t: i18n.t
        });
    }
    // If it's a React Element or string, then we should just pass it through
    return label;
}; //# sourceMappingURL=getTranslation.js.map
}),
"[project]/node_modules/.pnpm/@payloadcms+translations@3.64.0/node_modules/@payloadcms/translations/dist/utilities/deepMergeSimple.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Very simple, but fast deepMerge implementation. Only deepMerges objects, not arrays and clones everything.
 * Do not use this if your object contains any complex objects like React Components, or if you would like to combine Arrays.
 * If you only have simple objects and need a fast deepMerge, this is the function for you.
 *
 * obj2 takes precedence over obj1 - thus if obj2 has a key that obj1 also has, obj2's value will be used.
 *
 * @param obj1 base object
 * @param obj2 object to merge "into" obj1
 */ __turbopack_context__.s([
    "deepMergeSimple",
    ()=>deepMergeSimple
]);
function deepMergeSimple(obj1, obj2) {
    const output = {
        ...obj1
    };
    for(const key in obj2){
        if (Object.prototype.hasOwnProperty.call(obj2, key)) {
            // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve
            if (typeof obj2[key] === 'object' && !Array.isArray(obj2[key]) && obj1[key]) {
                // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve
                output[key] = deepMergeSimple(obj1[key], obj2[key]);
            } else {
                // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve
                output[key] = obj2[key];
            }
        }
    }
    return output;
} //# sourceMappingURL=deepMergeSimple.js.map
}),
"[project]/node_modules/.pnpm/@payloadcms+translations@3.64.0/node_modules/@payloadcms/translations/dist/importDateFNSLocale.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "importDateFNSLocale",
    ()=>importDateFNSLocale
]);
const importDateFNSLocale = async (locale)=>{
    let result;
    switch(locale){
        case 'ar':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/ar.js [app-rsc] (ecmascript, async loader)")).ar;
            break;
        case 'az':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/az.js [app-rsc] (ecmascript, async loader)")).az;
            break;
        case 'bg':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/bg.js [app-rsc] (ecmascript, async loader)")).bg;
            break;
        case 'bn-BD':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/bn.js [app-rsc] (ecmascript, async loader)")).bn;
            break;
        case 'bn-IN':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/bn.js [app-rsc] (ecmascript, async loader)")).bn;
            break;
        case 'ca':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/ca.js [app-rsc] (ecmascript, async loader)")).ca;
            break;
        case 'cs':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/cs.js [app-rsc] (ecmascript, async loader)")).cs;
            break;
        case 'da':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/da.js [app-rsc] (ecmascript, async loader)")).da;
            break;
        case 'de':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/de.js [app-rsc] (ecmascript, async loader)")).de;
            break;
        case 'en-US':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/en-US.js [app-rsc] (ecmascript, async loader)")).enUS;
            break;
        case 'es':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/es.js [app-rsc] (ecmascript, async loader)")).es;
            break;
        case 'et':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/et.js [app-rsc] (ecmascript, async loader)")).et;
            break;
        case 'fa-IR':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/fa-IR.js [app-rsc] (ecmascript, async loader)")).faIR;
            break;
        case 'fr':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/fr.js [app-rsc] (ecmascript, async loader)")).fr;
            break;
        case 'he':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/he.js [app-rsc] (ecmascript, async loader)")).he;
            break;
        case 'hr':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/hr.js [app-rsc] (ecmascript, async loader)")).hr;
            break;
        case 'hu':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/hu.js [app-rsc] (ecmascript, async loader)")).hu;
            break;
        case 'id':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/id.js [app-rsc] (ecmascript, async loader)")).id;
            break;
        case 'is':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/is.js [app-rsc] (ecmascript, async loader)")).is;
            break;
        case 'it':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/it.js [app-rsc] (ecmascript, async loader)")).it;
            break;
        case 'ja':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/ja.js [app-rsc] (ecmascript, async loader)")).ja;
            break;
        case 'ko':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/ko.js [app-rsc] (ecmascript, async loader)")).ko;
            break;
        case 'lt':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/lt.js [app-rsc] (ecmascript, async loader)")).lt;
            break;
        case 'lv':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/lv.js [app-rsc] (ecmascript, async loader)")).lv;
            break;
        case 'nb':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/nb.js [app-rsc] (ecmascript, async loader)")).nb;
            break;
        case 'nl':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/nl.js [app-rsc] (ecmascript, async loader)")).nl;
            break;
        case 'pl':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/pl.js [app-rsc] (ecmascript, async loader)")).pl;
            break;
        case 'pt':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/pt.js [app-rsc] (ecmascript, async loader)")).pt;
            break;
        case 'ro':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/ro.js [app-rsc] (ecmascript, async loader)")).ro;
            break;
        case 'rs':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/sr.js [app-rsc] (ecmascript, async loader)")).sr;
            break;
        case 'rs-Latin':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/sr-Latn.js [app-rsc] (ecmascript, async loader)")).srLatn;
            break;
        case 'ru':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/ru.js [app-rsc] (ecmascript, async loader)")).ru;
            break;
        case 'sk':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/sk.js [app-rsc] (ecmascript, async loader)")).sk;
            break;
        case 'sl-SI':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/sl.js [app-rsc] (ecmascript, async loader)")).sl;
            break;
        case 'sv':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/sv.js [app-rsc] (ecmascript, async loader)")).sv;
            break;
        case 'ta':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/ta.js [app-rsc] (ecmascript, async loader)")).ta;
            break;
        case 'th':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/th.js [app-rsc] (ecmascript, async loader)")).th;
            break;
        case 'tr':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/tr.js [app-rsc] (ecmascript, async loader)")).tr;
            break;
        case 'uk':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/uk.js [app-rsc] (ecmascript, async loader)")).uk;
            break;
        case 'vi':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/vi.js [app-rsc] (ecmascript, async loader)")).vi;
            break;
        case 'zh-CN':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/zh-CN.js [app-rsc] (ecmascript, async loader)")).zhCN;
            break;
        case 'zh-TW':
            result = (await __turbopack_context__.A("[project]/node_modules/.pnpm/date-fns@4.1.0/node_modules/date-fns/locale/zh-TW.js [app-rsc] (ecmascript, async loader)")).zhTW;
            break;
    }
    // @ts-expect-error - I'm not sure if this is still necessary.
    if (result?.default) {
        // @ts-expect-error - I'm not sure if this is still necessary.
        return result.default;
    }
    return result;
}; //# sourceMappingURL=importDateFNSLocale.js.map
}),
"[project]/node_modules/.pnpm/@payloadcms+translations@3.64.0/node_modules/@payloadcms/translations/dist/clientKeys.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "clientTranslationKeys",
    ()=>clientTranslationKeys
]);
function createClientTranslationKeys(keys) {
    return keys;
}
const clientTranslationKeys = createClientTranslationKeys([
    'authentication:account',
    'authentication:accountOfCurrentUser',
    'authentication:accountVerified',
    'authentication:alreadyActivated',
    'authentication:alreadyLoggedIn',
    'authentication:apiKey',
    'authentication:authenticated',
    'authentication:backToLogin',
    'authentication:beginCreateFirstUser',
    'authentication:changePassword',
    'authentication:checkYourEmailForPasswordReset',
    'authentication:confirmGeneration',
    'authentication:confirmPassword',
    'authentication:createFirstUser',
    'authentication:emailNotValid',
    'authentication:usernameNotValid',
    'authentication:emailOrUsername',
    'authentication:emailSent',
    'authentication:emailVerified',
    'authentication:enableAPIKey',
    'authentication:failedToUnlock',
    'authentication:forceUnlock',
    'authentication:forgotPassword',
    'authentication:forgotPasswordEmailInstructions',
    'authentication:forgotPasswordUsernameInstructions',
    'authentication:forgotPasswordQuestion',
    'authentication:generate',
    'authentication:generateNewAPIKey',
    'authentication:generatingNewAPIKeyWillInvalidate',
    'authentication:logBackIn',
    'authentication:loggedOutInactivity',
    'authentication:loggedOutSuccessfully',
    'authentication:loggingOut',
    'authentication:login',
    'authentication:logOut',
    'authentication:loggedIn',
    'authentication:loggedInChangePassword',
    'authentication:logout',
    'authentication:logoutUser',
    'authentication:logoutSuccessful',
    'authentication:newAPIKeyGenerated',
    'authentication:newPassword',
    'authentication:passed',
    'authentication:passwordResetSuccessfully',
    'authentication:resetPassword',
    'authentication:stayLoggedIn',
    'authentication:successfullyRegisteredFirstUser',
    'authentication:successfullyUnlocked',
    'authentication:username',
    'authentication:unableToVerify',
    'authentication:tokenRefreshSuccessful',
    'authentication:verified',
    'authentication:verifiedSuccessfully',
    'authentication:verify',
    'authentication:verifyUser',
    'authentication:youAreInactive',
    'error:autosaving',
    'error:correctInvalidFields',
    'error:deletingTitle',
    'error:documentNotFound',
    'error:emailOrPasswordIncorrect',
    'error:usernameOrPasswordIncorrect',
    'error:loadingDocument',
    'error:insufficientClipboardPermissions',
    'error:invalidClipboardData',
    'error:invalidRequestArgs',
    'error:invalidFileType',
    'error:logoutFailed',
    'error:noMatchedField',
    'error:notAllowedToAccessPage',
    'error:previewing',
    'error:unableToCopy',
    'error:unableToDeleteCount',
    'error:unableToReindexCollection',
    'error:unableToUpdateCount',
    'error:unauthorized',
    'error:unauthorizedAdmin',
    'error:unknown',
    'error:unspecific',
    'error:unverifiedEmail',
    'error:userEmailAlreadyRegistered',
    'error:usernameAlreadyRegistered',
    'error:tokenNotProvided',
    'error:unPublishingDocument',
    'error:problemUploadingFile',
    'error:restoringTitle',
    'fields:addLabel',
    'fields:addLink',
    'fields:addNew',
    'fields:addNewLabel',
    'fields:addRelationship',
    'fields:addUpload',
    'fields:block',
    'fields:blocks',
    'fields:blockType',
    'fields:chooseBetweenCustomTextOrDocument',
    'fields:customURL',
    'fields:chooseDocumentToLink',
    'fields:openInNewTab',
    'fields:enterURL',
    'fields:internalLink',
    'fields:chooseFromExisting',
    'fields:linkType',
    'fields:textToDisplay',
    'fields:searchForLanguage',
    'fields:collapseAll',
    'fields:editLink',
    'fields:editRelationship',
    'fields:itemsAndMore',
    'fields:labelRelationship',
    'fields:latitude',
    'fields:linkedTo',
    'fields:longitude',
    'fields:passwordsDoNotMatch',
    'fields:removeRelationship',
    'fields:removeUpload',
    'fields:saveChanges',
    'fields:searchForBlock',
    'fields:selectFieldsToEdit',
    'fields:showAll',
    'fields:swapRelationship',
    'fields:swapUpload',
    'fields:toggleBlock',
    'fields:uploadNewLabel',
    'folder:byFolder',
    'folder:browseByFolder',
    'folder:deleteFolder',
    'folder:folders',
    'folder:folderTypeDescription',
    'folder:folderName',
    'folder:itemsMovedToFolder',
    'folder:itemsMovedToRoot',
    'folder:itemHasBeenMoved',
    'folder:itemHasBeenMovedToRoot',
    'folder:moveFolder',
    'folder:movingFromFolder',
    'folder:moveItemsToFolderConfirmation',
    'folder:moveItemsToRootConfirmation',
    'folder:moveItemToFolderConfirmation',
    'folder:moveItemToRootConfirmation',
    'folder:noFolder',
    'folder:newFolder',
    'folder:renameFolder',
    'folder:searchByNameInFolder',
    'folder:selectFolderForItem',
    'general:all',
    'general:aboutToDeleteCount',
    'general:aboutToDelete',
    'general:aboutToPermanentlyDelete',
    'general:aboutToPermanentlyDeleteTrash',
    'general:aboutToRestore',
    'general:aboutToRestoreAsDraft',
    'general:aboutToRestoreAsDraftCount',
    'general:aboutToRestoreCount',
    'general:aboutToTrash',
    'general:aboutToTrashCount',
    'general:addBelow',
    'general:addFilter',
    'general:adminTheme',
    'general:allCollections',
    'general:and',
    'general:anotherUser',
    'general:anotherUserTakenOver',
    'general:applyChanges',
    'general:ascending',
    'general:automatic',
    'general:backToDashboard',
    'general:cancel',
    'general:changesNotSaved',
    'general:close',
    'general:collapse',
    'general:collections',
    'general:confirmMove',
    'general:yes',
    'general:no',
    'general:columns',
    'general:columnToSort',
    'general:confirm',
    'general:confirmCopy',
    'general:confirmDeletion',
    'general:confirmDuplication',
    'general:confirmReindex',
    'general:confirmReindexAll',
    'general:confirmReindexDescription',
    'general:confirmReindexDescriptionAll',
    'general:confirmRestoration',
    'general:copied',
    'general:clear',
    'general:clearAll',
    'general:copy',
    'general:copyField',
    'general:copyRow',
    'general:copyWarning',
    'general:copying',
    'general:create',
    'general:created',
    'general:createdAt',
    'general:createNew',
    'general:createNewLabel',
    'general:creating',
    'general:creatingNewLabel',
    'general:currentlyEditing',
    'general:custom',
    'general:dark',
    'general:dashboard',
    'general:delete',
    'general:deleted',
    'general:deletedAt',
    'general:deletePermanently',
    'general:deleteLabel',
    'general:deletedSuccessfully',
    'general:deletedCountSuccessfully',
    'general:deleting',
    'general:descending',
    'general:depth',
    'general:deselectAllRows',
    'general:document',
    'general:documentIsTrashed',
    'general:documentLocked',
    'general:documents',
    'general:duplicate',
    'general:duplicateWithoutSaving',
    'general:edit',
    'general:editAll',
    'general:editing',
    'general:editingLabel',
    'general:editingTakenOver',
    'general:editLabel',
    'general:editedSince',
    'general:email',
    'general:emailAddress',
    'general:emptyTrash',
    'general:emptyTrashLabel',
    'general:enterAValue',
    'general:error',
    'general:errors',
    'general:fallbackToDefaultLocale',
    'general:false',
    'general:filters',
    'general:filterWhere',
    'general:globals',
    'general:goBack',
    'general:groupByLabel',
    'general:isEditing',
    'general:item',
    'general:items',
    'general:language',
    'general:lastModified',
    'general:leaveAnyway',
    'general:leaveWithoutSaving',
    'general:light',
    'general:livePreview',
    'general:exitLivePreview',
    'general:loading',
    'general:locale',
    'general:locales',
    'general:menu',
    'general:moreOptions',
    'general:move',
    'general:moveConfirm',
    'general:moveCount',
    'general:moveDown',
    'general:moveUp',
    'general:moving',
    'general:movingCount',
    'general:name',
    'general:next',
    'general:newLabel',
    'general:noDateSelected',
    'general:noFiltersSet',
    'general:noLabel',
    'general:none',
    'general:noOptions',
    'general:noResults',
    'general:notFound',
    'general:nothingFound',
    'general:noTrashResults',
    'general:noUpcomingEventsScheduled',
    'general:noValue',
    'general:of',
    'general:open',
    'general:only',
    'general:or',
    'general:order',
    'general:overwriteExistingData',
    'general:pageNotFound',
    'general:password',
    'general:pasteField',
    'general:pasteRow',
    'general:payloadSettings',
    'general:permanentlyDelete',
    'general:permanentlyDeletedCountSuccessfully',
    'general:perPage',
    'general:previous',
    'general:reindex',
    'general:reindexingAll',
    'general:remove',
    'general:rename',
    'general:reset',
    'general:resetPreferences',
    'general:resetPreferencesDescription',
    'general:resettingPreferences',
    'general:restore',
    'general:restoreAsPublished',
    'general:restoredCountSuccessfully',
    'general:restoring',
    'general:row',
    'general:rows',
    'general:save',
    'general:schedulePublishFor',
    'general:saving',
    'general:searchBy',
    'general:select',
    'general:selectAll',
    'general:selectAllRows',
    'general:selectedCount',
    'general:selectLabel',
    'general:selectValue',
    'general:showAllLabel',
    'general:sorryNotFound',
    'general:sort',
    'general:sortByLabelDirection',
    'general:stayOnThisPage',
    'general:submissionSuccessful',
    'general:submit',
    'general:submitting',
    'general:success',
    'general:successfullyCreated',
    'general:successfullyDuplicated',
    'general:successfullyReindexed',
    'general:takeOver',
    'general:thisLanguage',
    'general:time',
    'general:timezone',
    'general:titleDeleted',
    'general:titleTrashed',
    'general:titleRestored',
    'general:trash',
    'general:trashedCountSuccessfully',
    'general:import',
    'general:export',
    'general:allLocales',
    'general:true',
    'general:upcomingEvents',
    'general:users',
    'general:user',
    'general:username',
    'general:unauthorized',
    'general:unsavedChanges',
    'general:unsavedChangesDuplicate',
    'general:untitled',
    'general:updatedAt',
    'general:updatedLabelSuccessfully',
    'general:updatedCountSuccessfully',
    'general:updateForEveryone',
    'general:updatedSuccessfully',
    'general:updating',
    'general:value',
    'general:viewing',
    'general:viewReadOnly',
    'general:uploading',
    'general:uploadingBulk',
    'general:welcome',
    'localization:localeToPublish',
    'localization:copyToLocale',
    'localization:copyFromTo',
    'localization:selectedLocales',
    'localization:selectLocaleToCopy',
    'localization:selectLocaleToDuplicate',
    'localization:cannotCopySameLocale',
    'localization:copyFrom',
    'localization:copyTo',
    'operators:equals',
    'operators:exists',
    'operators:isNotIn',
    'operators:isIn',
    'operators:contains',
    'operators:isLike',
    'operators:isNotLike',
    'operators:isNotEqualTo',
    'operators:near',
    'operators:isGreaterThan',
    'operators:isLessThan',
    'operators:isGreaterThanOrEqualTo',
    'operators:isLessThanOrEqualTo',
    'operators:within',
    'operators:intersects',
    'upload:addFile',
    'upload:addFiles',
    'upload:bulkUpload',
    'upload:crop',
    'upload:cropToolDescription',
    'upload:dragAndDrop',
    'upload:editImage',
    'upload:fileToUpload',
    'upload:filesToUpload',
    'upload:focalPoint',
    'upload:focalPointDescription',
    'upload:height',
    'upload:pasteURL',
    'upload:previewSizes',
    'upload:selectCollectionToBrowse',
    'upload:selectFile',
    'upload:setCropArea',
    'upload:setFocalPoint',
    'upload:sizesFor',
    'upload:sizes',
    'upload:width',
    'upload:fileName',
    'upload:fileSize',
    'upload:noFile',
    'upload:download',
    'validation:emailAddress',
    'validation:enterNumber',
    'validation:fieldHasNo',
    'validation:greaterThanMax',
    'validation:invalidInput',
    'validation:invalidSelection',
    'validation:invalidSelections',
    'validation:latitudeOutOfBounds',
    'validation:lessThanMin',
    'validation:limitReached',
    'validation:longitudeOutOfBounds',
    'validation:invalidBlock',
    'validation:invalidBlocks',
    'validation:longerThanMin',
    'validation:notValidDate',
    'validation:required',
    'validation:requiresAtLeast',
    'validation:requiresNoMoreThan',
    'validation:requiresTwoNumbers',
    'validation:shorterThanMax',
    'validation:trueOrFalse',
    'validation:timezoneRequired',
    'validation:username',
    'validation:validUploadID',
    'version:aboutToPublishSelection',
    'version:aboutToRestore',
    'version:aboutToRestoreGlobal',
    'version:aboutToRevertToPublished',
    'version:aboutToUnpublish',
    'version:aboutToUnpublishSelection',
    'version:autosave',
    'version:autosavedSuccessfully',
    'version:autosavedVersion',
    'version:versionAgo',
    'version:moreVersions',
    'version:changed',
    'version:changedFieldsCount',
    'version:confirmRevertToSaved',
    'version:compareVersions',
    'version:comparingAgainst',
    'version:currentlyViewing',
    'version:confirmPublish',
    'version:confirmUnpublish',
    'version:confirmVersionRestoration',
    'version:currentDraft',
    'version:currentPublishedVersion',
    'version:currentlyPublished',
    'version:draft',
    'version:draftHasPublishedVersion',
    'version:draftSavedSuccessfully',
    'version:lastSavedAgo',
    'version:modifiedOnly',
    'version:noFurtherVersionsFound',
    'version:noLabelGroup',
    'version:noRowsFound',
    'version:noRowsSelected',
    'version:preview',
    'version:previouslyDraft',
    'version:previouslyPublished',
    'version:previousVersion',
    'version:problemRestoringVersion',
    'version:publish',
    'version:publishAllLocales',
    'version:publishChanges',
    'version:published',
    'version:publishIn',
    'version:publishing',
    'version:restoreAsDraft',
    'version:restoredSuccessfully',
    'version:restoreThisVersion',
    'version:restoring',
    'version:reverting',
    'version:revertToPublished',
    'version:saveDraft',
    'version:scheduledSuccessfully',
    'version:schedulePublish',
    'version:selectLocales',
    'version:selectVersionToCompare',
    'version:showLocales',
    'version:specificVersion',
    'version:status',
    'version:type',
    'version:unpublish',
    'version:unpublishing',
    'version:versionID',
    'version:version',
    'version:versions',
    'version:viewingVersion',
    'version:viewingVersionGlobal',
    'version:viewingVersions',
    'version:viewingVersionsGlobal'
]); //# sourceMappingURL=clientKeys.js.map
}),
"[project]/node_modules/.pnpm/@payloadcms+translations@3.64.0/node_modules/@payloadcms/translations/dist/utilities/getTranslationsByContext.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getTranslationsByContext",
    ()=>getTranslationsByContext
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$translations$40$3$2e$64$2e$0$2f$node_modules$2f40$payloadcms$2f$translations$2f$dist$2f$clientKeys$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@payloadcms+translations@3.64.0/node_modules/@payloadcms/translations/dist/clientKeys.js [app-rsc] (ecmascript)");
;
function filterKeys(obj, parentGroupKey = '', keys) {
    const result = {};
    for (const [namespaceKey, value] of Object.entries(obj)){
        // Skip $schema key
        if (namespaceKey === '$schema') {
            result[namespaceKey] = value;
            continue;
        }
        if (typeof value === 'object') {
            const filteredObject = filterKeys(value, namespaceKey, keys);
            if (Object.keys(filteredObject).length > 0) {
                result[namespaceKey] = filteredObject;
            }
        } else {
            for (const key of keys){
                const [groupKey, selector] = key.split(':');
                if (parentGroupKey === groupKey) {
                    if (namespaceKey === selector) {
                        result[selector] = value;
                    } else {
                        const pluralKeys = [
                            'zero',
                            'one',
                            'two',
                            'few',
                            'many',
                            'other'
                        ];
                        pluralKeys.forEach((pluralKey)=>{
                            if (namespaceKey === `${selector}_${pluralKey}`) {
                                result[`${selector}_${pluralKey}`] = value;
                            }
                        });
                    }
                }
            }
        }
    }
    return result;
}
function sortObject(obj) {
    const sortedObject = {};
    Object.keys(obj).sort().forEach((key)=>{
        if (typeof obj[key] === 'object') {
            sortedObject[key] = sortObject(obj[key]);
        } else {
            sortedObject[key] = obj[key];
        }
    });
    return sortedObject;
}
const getTranslationsByContext = (selectedLanguage, context)=>{
    if (context === 'client') {
        return sortObject(filterKeys(selectedLanguage.translations, '', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$translations$40$3$2e$64$2e$0$2f$node_modules$2f40$payloadcms$2f$translations$2f$dist$2f$clientKeys$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clientTranslationKeys"]));
    } else {
        return selectedLanguage.translations;
    }
}; //# sourceMappingURL=getTranslationsByContext.js.map
}),
"[project]/node_modules/.pnpm/@payloadcms+translations@3.64.0/node_modules/@payloadcms/translations/dist/utilities/init.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getTranslationString",
    ()=>getTranslationString,
    "initI18n",
    ()=>initI18n,
    "t",
    ()=>t
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$translations$40$3$2e$64$2e$0$2f$node_modules$2f40$payloadcms$2f$translations$2f$dist$2f$importDateFNSLocale$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@payloadcms+translations@3.64.0/node_modules/@payloadcms/translations/dist/importDateFNSLocale.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$translations$40$3$2e$64$2e$0$2f$node_modules$2f40$payloadcms$2f$translations$2f$dist$2f$utilities$2f$deepMergeSimple$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@payloadcms+translations@3.64.0/node_modules/@payloadcms/translations/dist/utilities/deepMergeSimple.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$translations$40$3$2e$64$2e$0$2f$node_modules$2f40$payloadcms$2f$translations$2f$dist$2f$utilities$2f$getTranslationsByContext$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@payloadcms+translations@3.64.0/node_modules/@payloadcms/translations/dist/utilities/getTranslationsByContext.js [app-rsc] (ecmascript)");
;
;
;
const getTranslationString = ({ count, key, translations })=>{
    const keys = key.split(':');
    let keySuffix = '';
    const translation = keys.reduce((acc, key, index)=>{
        if (typeof acc === 'string') {
            return acc;
        }
        if (typeof count === 'number') {
            if (count === 0 && `${key}_zero` in acc) {
                keySuffix = '_zero';
            } else if (count === 1 && `${key}_one` in acc) {
                keySuffix = '_one';
            } else if (count === 2 && `${key}_two` in acc) {
                keySuffix = '_two';
            } else if (count > 5 && `${key}_many` in acc) {
                keySuffix = '_many';
            } else if (count > 2 && count <= 5 && `${key}_few` in acc) {
                keySuffix = '_few';
            } else if (`${key}_other` in acc) {
                keySuffix = '_other';
            }
        }
        let keyToUse = key;
        if (index === keys.length - 1 && keySuffix) {
            keyToUse = `${key}${keySuffix}`;
        }
        if (acc && keyToUse in acc) {
            return acc[keyToUse];
        }
        return undefined;
    }, translations);
    if (!translation) {
        console.log('key not found:', key);
    }
    return translation || key;
};
/**
 * @function replaceVars
 *
 * Replaces variables in a translation string with values from an object
 *
 * @returns string
 */ const replaceVars = ({ translationString, vars })=>{
    const parts = translationString.split(/(\{\{.*?\}\})/);
    return parts.map((part)=>{
        if (part.startsWith('{{') && part.endsWith('}}')) {
            const placeholder = part.substring(2, part.length - 2).trim();
            const value = vars[placeholder];
            return value !== undefined && value !== null ? value : part;
        } else {
            return part;
        }
    }).join('');
};
function t({ key, translations, vars }) {
    let translationString = getTranslationString({
        count: typeof vars?.count === 'number' ? vars.count : undefined,
        key,
        translations
    });
    if (vars) {
        translationString = replaceVars({
            translationString,
            vars
        });
    }
    if (!translationString) {
        translationString = key;
    }
    return translationString;
}
const initTFunction = (args)=>{
    const { config, language, translations } = args;
    const mergedTranslations = language && config?.translations?.[language] ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$translations$40$3$2e$64$2e$0$2f$node_modules$2f40$payloadcms$2f$translations$2f$dist$2f$utilities$2f$deepMergeSimple$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepMergeSimple"])(translations, config.translations[language]) : translations;
    return {
        t: (key, vars)=>{
            return t({
                key,
                translations: mergedTranslations,
                vars
            });
        },
        translations: mergedTranslations
    };
};
function memoize(fn, keys) {
    const cacheMap = new Map();
    const memoized = async (args)=>{
        const cacheKey = keys.reduce((acc, key)=>acc + String(args[key]), '');
        if (!cacheMap.has(cacheKey)) {
            const result = await fn(args);
            cacheMap.set(cacheKey, result);
        }
        return cacheMap.get(cacheKey);
    };
    return memoized;
}
const initI18n = memoize(async ({ config, context, language = config.fallbackLanguage })=>{
    if (!language || !config.supportedLanguages?.[language]) {
        throw new Error(`Language ${language} not supported`);
    }
    const translations = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$translations$40$3$2e$64$2e$0$2f$node_modules$2f40$payloadcms$2f$translations$2f$dist$2f$utilities$2f$getTranslationsByContext$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getTranslationsByContext"])(config.supportedLanguages?.[language], context);
    const { t, translations: mergedTranslations } = initTFunction({
        config: config,
        language: language || config.fallbackLanguage,
        translations: translations
    });
    const dateFNSKey = config.supportedLanguages[language]?.dateFNSKey || 'en-US';
    const dateFNS = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$translations$40$3$2e$64$2e$0$2f$node_modules$2f40$payloadcms$2f$translations$2f$dist$2f$importDateFNSLocale$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["importDateFNSLocale"])(dateFNSKey);
    const i18n = {
        dateFNS,
        dateFNSKey,
        fallbackLanguage: config.fallbackLanguage,
        language: language || config.fallbackLanguage,
        t,
        translations: mergedTranslations
    };
    return i18n;
}, [
    'language',
    'context'
]); //# sourceMappingURL=init.js.map
}),
"[project]/node_modules/.pnpm/@payloadcms+translations@3.64.0/node_modules/@payloadcms/translations/dist/languages/en.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "en",
    ()=>en,
    "enTranslations",
    ()=>enTranslations
]);
const enTranslations = {
    authentication: {
        account: 'Account',
        accountOfCurrentUser: 'Account of current user',
        accountVerified: 'Account verified successfully.',
        alreadyActivated: 'Already Activated',
        alreadyLoggedIn: 'Already logged in',
        apiKey: 'API Key',
        authenticated: 'Authenticated',
        backToLogin: 'Back to login',
        beginCreateFirstUser: 'To begin, create your first user.',
        changePassword: 'Change Password',
        checkYourEmailForPasswordReset: "If the email address is associated with an account, you will receive instructions to reset your password shortly. Please check your spam or junk mail folder if you don't see the email in your inbox.",
        confirmGeneration: 'Confirm Generation',
        confirmPassword: 'Confirm Password',
        createFirstUser: 'Create first user',
        emailNotValid: 'The email provided is not valid',
        emailOrUsername: 'Email or Username',
        emailSent: 'Email Sent',
        emailVerified: 'Email verified successfully.',
        enableAPIKey: 'Enable API Key',
        failedToUnlock: 'Failed to unlock',
        forceUnlock: 'Force Unlock',
        forgotPassword: 'Forgot Password',
        forgotPasswordEmailInstructions: 'Please enter your email below. You will receive an email message with instructions on how to reset your password.',
        forgotPasswordUsernameInstructions: 'Please enter your username below. Instructions on how to reset your password will be sent to email address associated with your username.',
        usernameNotValid: 'The username provided is not valid',
        forgotPasswordQuestion: 'Forgot password?',
        generate: 'Generate',
        generateNewAPIKey: 'Generate new API key',
        generatingNewAPIKeyWillInvalidate: 'Generating a new API key will <1>invalidate</1> the previous key. Are you sure you wish to continue?',
        lockUntil: 'Lock Until',
        logBackIn: 'Log back in',
        loggedIn: 'To log in with another user, you should <0>log out</0> first.',
        loggedInChangePassword: 'To change your password, go to your <0>account</0> and edit your password there.',
        loggedOutInactivity: 'You have been logged out due to inactivity.',
        loggedOutSuccessfully: 'You have been logged out successfully.',
        loggingOut: 'Logging out...',
        login: 'Login',
        loginAttempts: 'Login Attempts',
        loginUser: 'Login user',
        loginWithAnotherUser: 'To log in with another user, you should <0>log out</0> first.',
        logOut: 'Log out',
        logout: 'Logout',
        logoutSuccessful: 'Logout successful.',
        logoutUser: 'Logout user',
        newAccountCreated: 'A new account has just been created for you to access <a href="{{serverURL}}">{{serverURL}}</a> Please click on the following link or paste the URL below into your browser to verify your email: <a href="{{verificationURL}}">{{verificationURL}}</a><br> After verifying your email, you will be able to log in successfully.',
        newAPIKeyGenerated: 'New API Key Generated.',
        newPassword: 'New Password',
        passed: 'Authentication Passed',
        passwordResetSuccessfully: 'Password reset successfully.',
        resetPassword: 'Reset Password',
        resetPasswordExpiration: 'Reset Password Expiration',
        resetPasswordToken: 'Reset Password Token',
        resetYourPassword: 'Reset Your Password',
        stayLoggedIn: 'Stay logged in',
        successfullyRegisteredFirstUser: 'Successfully registered first user.',
        successfullyUnlocked: 'Successfully unlocked',
        tokenRefreshSuccessful: 'Token refresh successful.',
        unableToVerify: 'Unable to Verify',
        username: 'Username',
        verified: 'Verified',
        verifiedSuccessfully: 'Verified Successfully',
        verify: 'Verify',
        verifyUser: 'Verify User',
        verifyYourEmail: 'Verify your email',
        youAreInactive: "You haven't been active in a little while and will shortly be automatically logged out for your own security. Would you like to stay logged in?",
        youAreReceivingResetPassword: 'You are receiving this because you (or someone else) have requested the reset of the password for your account. Please click on the following link, or paste this into your browser to complete the process:',
        youDidNotRequestPassword: 'If you did not request this, please ignore this email and your password will remain unchanged.'
    },
    error: {
        accountAlreadyActivated: 'This account has already been activated.',
        autosaving: 'There was a problem while autosaving this document.',
        correctInvalidFields: 'Please correct invalid fields.',
        deletingFile: 'There was an error deleting file.',
        deletingTitle: 'There was an error while deleting {{title}}. Please check your connection and try again.',
        documentNotFound: 'The document with ID {{id}} could not be found. It may have been deleted or never existed, or you may not have access to it.',
        emailOrPasswordIncorrect: 'The email or password provided is incorrect.',
        followingFieldsInvalid_one: 'The following field is invalid:',
        followingFieldsInvalid_other: 'The following fields are invalid:',
        incorrectCollection: 'Incorrect Collection',
        insufficientClipboardPermissions: 'Clipboard access denied. Please check your clipboard permissions.',
        invalidClipboardData: 'Invalid clipboard data.',
        invalidFileType: 'Invalid file type',
        invalidFileTypeValue: 'Invalid file type: {{value}}',
        invalidRequestArgs: 'Invalid arguments passed in request: {{args}}',
        loadingDocument: 'There was a problem loading the document with ID of {{id}}.',
        localesNotSaved_one: 'The following locale could not be saved:',
        localesNotSaved_other: 'The following locales could not be saved:',
        logoutFailed: 'Logout failed.',
        missingEmail: 'Missing email.',
        missingIDOfDocument: 'Missing ID of document to update.',
        missingIDOfVersion: 'Missing ID of version.',
        missingRequiredData: 'Missing required data.',
        noFilesUploaded: 'No files were uploaded.',
        noMatchedField: 'No matched field found for "{{label}}"',
        notAllowedToAccessPage: 'You are not allowed to access this page.',
        notAllowedToPerformAction: 'You are not allowed to perform this action.',
        notFound: 'The requested resource was not found.',
        noUser: 'No User',
        previewing: 'There was a problem previewing this document.',
        problemUploadingFile: 'There was a problem while uploading the file.',
        restoringTitle: 'There was an error while restoring {{title}}. Please check your connection and try again.',
        tokenInvalidOrExpired: 'Token is either invalid or has expired.',
        tokenNotProvided: 'Token not provided.',
        unableToCopy: 'Unable to copy.',
        unableToDeleteCount: 'Unable to delete {{count}} out of {{total}} {{label}}.',
        unableToReindexCollection: 'Error reindexing collection {{collection}}. Operation aborted.',
        unableToUpdateCount: 'Unable to update {{count}} out of {{total}} {{label}}.',
        unauthorized: 'Unauthorized, you must be logged in to make this request.',
        unauthorizedAdmin: 'Unauthorized, this user does not have access to the admin panel.',
        unknown: 'An unknown error has occurred.',
        unPublishingDocument: 'There was a problem while un-publishing this document.',
        unspecific: 'An error has occurred.',
        unverifiedEmail: 'Please verify your email before logging in.',
        userEmailAlreadyRegistered: 'A user with the given email is already registered.',
        userLocked: 'This user is locked due to having too many failed login attempts.',
        usernameAlreadyRegistered: 'A user with the given username is already registered.',
        usernameOrPasswordIncorrect: 'The username or password provided is incorrect.',
        valueMustBeUnique: 'Value must be unique',
        verificationTokenInvalid: 'Verification token is invalid.'
    },
    fields: {
        addLabel: 'Add {{label}}',
        addLink: 'Add Link',
        addNew: 'Add new',
        addNewLabel: 'Add new {{label}}',
        addRelationship: 'Add Relationship',
        addUpload: 'Add Upload',
        block: 'Block',
        blocks: 'blocks',
        blockType: 'Block Type',
        chooseBetweenCustomTextOrDocument: 'Choose between entering a custom text URL or linking to another document.',
        chooseDocumentToLink: 'Choose a document to link to',
        chooseFromExisting: 'Choose from existing',
        chooseLabel: 'Choose {{label}}',
        collapseAll: 'Collapse All',
        customURL: 'Custom URL',
        editLabelData: 'Edit {{label}} data',
        editLink: 'Edit Link',
        editRelationship: 'Edit Relationship',
        enterURL: 'Enter a URL',
        internalLink: 'Internal Link',
        itemsAndMore: '{{items}} and {{count}} more',
        labelRelationship: '{{label}} Relationship',
        latitude: 'Latitude',
        linkedTo: 'Linked to <0>{{label}}</0>',
        linkType: 'Link Type',
        longitude: 'Longitude',
        newLabel: 'New {{label}}',
        openInNewTab: 'Open in new tab',
        passwordsDoNotMatch: 'Passwords do not match.',
        relatedDocument: 'Related Document',
        relationTo: 'Relation To',
        removeRelationship: 'Remove Relationship',
        removeUpload: 'Remove Upload',
        saveChanges: 'Save changes',
        searchForBlock: 'Search for a block',
        searchForLanguage: 'Search for a language',
        selectExistingLabel: 'Select existing {{label}}',
        selectFieldsToEdit: 'Select fields to edit',
        showAll: 'Show All',
        swapRelationship: 'Swap Relationship',
        swapUpload: 'Swap Upload',
        textToDisplay: 'Text to display',
        toggleBlock: 'Toggle block',
        uploadNewLabel: 'Upload new {{label}}'
    },
    folder: {
        browseByFolder: 'Browse by Folder',
        byFolder: 'By Folder',
        deleteFolder: 'Delete Folder',
        folderName: 'Folder Name',
        folders: 'Folders',
        folderTypeDescription: 'Select which type of collection documents should be allowed in this folder.',
        itemHasBeenMoved: '{{title}} has been moved to {{folderName}}',
        itemHasBeenMovedToRoot: '{{title}} has been moved to the root folder',
        itemsMovedToFolder: '{{title}} moved to {{folderName}}',
        itemsMovedToRoot: '{{title}} moved to the root folder',
        moveFolder: 'Move Folder',
        moveItemsToFolderConfirmation: 'You are about to move <1>{{count}} {{label}}</1> to <2>{{toFolder}}</2>. Are you sure?',
        moveItemsToRootConfirmation: 'You are about to move <1>{{count}} {{label}}</1> to the root folder. Are you sure?',
        moveItemToFolderConfirmation: 'You are about to move <1>{{title}}</1> to <2>{{toFolder}}</2>. Are you sure?',
        moveItemToRootConfirmation: 'You are about to move <1>{{title}}</1> to the root folder. Are you sure?',
        movingFromFolder: 'Moving {{title}} from {{fromFolder}}',
        newFolder: 'New Folder',
        noFolder: 'No Folder',
        renameFolder: 'Rename Folder',
        searchByNameInFolder: 'Search by Name in {{folderName}}',
        selectFolderForItem: 'Select folder for {{title}}'
    },
    general: {
        name: 'Name',
        aboutToDelete: 'You are about to delete the {{label}} <1>{{title}}</1>. Are you sure?',
        aboutToDeleteCount_many: 'You are about to delete {{count}} {{label}}',
        aboutToDeleteCount_one: 'You are about to delete {{count}} {{label}}',
        aboutToDeleteCount_other: 'You are about to delete {{count}} {{label}}',
        aboutToPermanentlyDelete: 'You are about to permanently delete the {{label}} <1>{{title}}</1>. Are you sure?',
        aboutToPermanentlyDeleteTrash: 'You are about to permanently delete <0>{{count}}</0> <1>{{label}}</1> from the trash. Are you sure?',
        aboutToRestore: 'You are about to restore the {{label}} <1>{{title}}</1>. Are you sure?',
        aboutToRestoreAsDraft: 'You are about to restore the {{label}} <1>{{title}}</1> as a draft. Are you sure?',
        aboutToRestoreAsDraftCount: 'You are about to restore {{count}} {{label}} as draft',
        aboutToRestoreCount: 'You are about to restore {{count}} {{label}}',
        aboutToTrash: 'You are about to move the {{label}} <1>{{title}}</1> to the trash. Are you sure?',
        aboutToTrashCount: 'You are about to move {{count}} {{label}} to the trash',
        addBelow: 'Add Below',
        addFilter: 'Add Filter',
        adminTheme: 'Admin Theme',
        all: 'All',
        allCollections: 'All Collections',
        allLocales: 'All locales',
        and: 'And',
        anotherUser: 'Another user',
        anotherUserTakenOver: 'Another user has taken over editing this document.',
        applyChanges: 'Apply Changes',
        ascending: 'Ascending',
        automatic: 'Automatic',
        backToDashboard: 'Back to Dashboard',
        cancel: 'Cancel',
        changesNotSaved: 'Your changes have not been saved. If you leave now, you will lose your changes.',
        clear: 'Clear',
        clearAll: 'Clear All',
        close: 'Close',
        collapse: 'Collapse',
        collections: 'Collections',
        columns: 'Columns',
        columnToSort: 'Column to Sort',
        confirm: 'Confirm',
        confirmCopy: 'Confirm copy',
        confirmDeletion: 'Confirm deletion',
        confirmDuplication: 'Confirm duplication',
        confirmMove: 'Confirm move',
        confirmReindex: 'Reindex all {{collections}}?',
        confirmReindexAll: 'Reindex all collections?',
        confirmReindexDescription: 'This will remove existing indexes and reindex documents in the {{collections}} collections.',
        confirmReindexDescriptionAll: 'This will remove existing indexes and reindex documents in all collections.',
        confirmRestoration: 'Confirm restoration',
        copied: 'Copied',
        copy: 'Copy',
        copyField: 'Copy Field',
        copying: 'Copying',
        copyRow: 'Copy Row',
        copyWarning: 'You are about to overwrite {{to}} with {{from}} for {{label}} {{title}}. Are you sure?',
        create: 'Create',
        created: 'Created',
        createdAt: 'Created At',
        createNew: 'Create New',
        createNewLabel: 'Create new {{label}}',
        creating: 'Creating',
        creatingNewLabel: 'Creating new {{label}}',
        currentlyEditing: 'is currently editing this document. If you take over, they will be blocked from continuing to edit, and may also lose unsaved changes.',
        custom: 'Custom',
        dark: 'Dark',
        dashboard: 'Dashboard',
        delete: 'Delete',
        deleted: 'Deleted',
        deletedAt: 'Deleted At',
        deletedCountSuccessfully: 'Deleted {{count}} {{label}} successfully.',
        deletedSuccessfully: 'Deleted successfully.',
        deleteLabel: 'Delete {{label}}',
        deletePermanently: 'Skip trash and delete permanently',
        deleting: 'Deleting...',
        depth: 'Depth',
        descending: 'Descending',
        deselectAllRows: 'Deselect all rows',
        document: 'Document',
        documentIsTrashed: 'This {{label}} is trashed and is read-only.',
        documentLocked: 'Document locked',
        documents: 'Documents',
        duplicate: 'Duplicate',
        duplicateWithoutSaving: 'Duplicate without saving changes',
        edit: 'Edit',
        editAll: 'Edit all',
        editedSince: 'Edited since',
        editing: 'Editing',
        editingLabel_many: 'Editing {{count}} {{label}}',
        editingLabel_one: 'Editing {{count}} {{label}}',
        editingLabel_other: 'Editing {{count}} {{label}}',
        editingTakenOver: 'Editing taken over',
        editLabel: 'Edit {{label}}',
        email: 'Email',
        emailAddress: 'Email Address',
        emptyTrash: 'Empty trash',
        emptyTrashLabel: 'Empty {{label}} trash',
        enterAValue: 'Enter a value',
        error: 'Error',
        errors: 'Errors',
        exitLivePreview: 'Exit Live Preview',
        export: 'Export',
        fallbackToDefaultLocale: 'Fallback to default locale',
        false: 'False',
        filter: 'Filter',
        filters: 'Filters',
        filterWhere: 'Filter {{label}} where',
        globals: 'Globals',
        goBack: 'Go back',
        groupByLabel: 'Group by {{label}}',
        import: 'Import',
        isEditing: 'is editing',
        item: 'Item',
        items: 'items',
        language: 'Language',
        lastModified: 'Last Modified',
        leaveAnyway: 'Leave anyway',
        leaveWithoutSaving: 'Leave without saving',
        light: 'Light',
        livePreview: 'Live Preview',
        loading: 'Loading',
        locale: 'Locale',
        locales: 'Locales',
        menu: 'Menu',
        moreOptions: 'More options',
        move: 'Move',
        moveConfirm: 'You are about to move {{count}} {{label}} to <1>{{destination}}</1>. Are you sure?',
        moveCount: 'Move {{count}} {{label}}',
        moveDown: 'Move Down',
        moveUp: 'Move Up',
        moving: 'Moving',
        movingCount: 'Moving {{count}} {{label}}',
        newLabel: 'New {{label}}',
        newPassword: 'New Password',
        next: 'Next',
        no: 'No',
        noDateSelected: 'No date selected',
        noFiltersSet: 'No filters set',
        noLabel: '<No {{label}}>',
        none: 'None',
        noOptions: 'No options',
        noResults: "No {{label}} found. Either no {{label}} exist yet or none match the filters you've specified above.",
        notFound: 'Not Found',
        nothingFound: 'Nothing found',
        noTrashResults: 'No {{label}} in trash.',
        noUpcomingEventsScheduled: 'No upcoming events scheduled.',
        noValue: 'No value',
        of: 'of',
        only: 'Only',
        open: 'Open',
        or: 'Or',
        order: 'Order',
        overwriteExistingData: 'Overwrite existing field data',
        pageNotFound: 'Page not found',
        password: 'Password',
        pasteField: 'Paste Field',
        pasteRow: 'Paste Row',
        payloadSettings: 'Payload Settings',
        permanentlyDelete: 'Permanently Delete',
        permanentlyDeletedCountSuccessfully: 'Permanently deleted {{count}} {{label}} successfully.',
        perPage: 'Per Page: {{limit}}',
        previous: 'Previous',
        reindex: 'Reindex',
        reindexingAll: 'Reindexing all {{collections}}.',
        remove: 'Remove',
        rename: 'Rename',
        reset: 'Reset',
        resetPreferences: 'Reset Preferences',
        resetPreferencesDescription: 'This will reset all of your preferences to their default settings.',
        resettingPreferences: 'Resetting Preferences.',
        restore: 'Restore',
        restoreAsPublished: 'Restore as published version',
        restoredCountSuccessfully: 'Restored {{count}} {{label}} successfully.',
        restoring: 'Restoring...',
        row: 'Row',
        rows: 'Rows',
        save: 'Save',
        saving: 'Saving...',
        schedulePublishFor: 'Schedule publish for {{title}}',
        searchBy: 'Search by {{label}}',
        select: 'Select',
        selectAll: 'Select all {{count}} {{label}}',
        selectAllRows: 'Select all rows',
        selectedCount: '{{count}} {{label}} selected',
        selectLabel: 'Select {{label}}',
        selectValue: 'Select a value',
        showAllLabel: 'Show all {{label}}',
        sorryNotFound: 'Sorrythere is nothing to correspond with your request.',
        sort: 'Sort',
        sortByLabelDirection: 'Sort by {{label}} {{direction}}',
        stayOnThisPage: 'Stay on this page',
        submissionSuccessful: 'Submission Successful.',
        submit: 'Submit',
        submitting: 'Submitting...',
        success: 'Success',
        successfullyCreated: '{{label}} successfully created.',
        successfullyDuplicated: '{{label}} successfully duplicated.',
        successfullyReindexed: 'Successfully reindexed {{count}} of {{total}} documents from {{collections}} and skipped {{skips}} drafts.',
        takeOver: 'Take over',
        thisLanguage: 'English',
        time: 'Time',
        timezone: 'Timezone',
        titleDeleted: '{{label}} "{{title}}" successfully deleted.',
        titleRestored: '{{label}} "{{title}}" successfully restored.',
        titleTrashed: '{{label}} "{{title}}" moved to trash.',
        trash: 'Trash',
        trashedCountSuccessfully: '{{count}} {{label}} moved to trash.',
        true: 'True',
        unauthorized: 'Unauthorized',
        unsavedChanges: 'You have unsaved changes. Save or discard before continuing.',
        unsavedChangesDuplicate: 'You have unsaved changes. Would you like to continue to duplicate?',
        untitled: 'Untitled',
        upcomingEvents: 'Upcoming Events',
        updatedAt: 'Updated At',
        updatedCountSuccessfully: 'Updated {{count}} {{label}} successfully.',
        updatedLabelSuccessfully: 'Updated {{label}} successfully.',
        updatedSuccessfully: 'Updated successfully.',
        updateForEveryone: 'Update for everyone',
        updating: 'Updating',
        uploading: 'Uploading',
        uploadingBulk: 'Uploading {{current}} of {{total}}',
        user: 'User',
        username: 'Username',
        users: 'Users',
        value: 'Value',
        viewing: 'Viewing',
        viewReadOnly: 'View read-only',
        welcome: 'Welcome',
        yes: 'Yes'
    },
    localization: {
        cannotCopySameLocale: 'Cannot copy to the same locale',
        copyFrom: 'Copy from',
        copyFromTo: 'Copying from {{from}} to {{to}}',
        copyTo: 'Copy to',
        copyToLocale: 'Copy to locale',
        localeToPublish: 'Locale to publish',
        selectedLocales: 'Selected Locales',
        selectLocaleToCopy: 'Select locale to copy',
        selectLocaleToDuplicate: 'Select locales to duplicate'
    },
    operators: {
        contains: 'contains',
        equals: 'equals',
        exists: 'exists',
        intersects: 'intersects',
        isGreaterThan: 'is greater than',
        isGreaterThanOrEqualTo: 'is greater than or equal to',
        isIn: 'is in',
        isLessThan: 'is less than',
        isLessThanOrEqualTo: 'is less than or equal to',
        isLike: 'is like',
        isNotEqualTo: 'is not equal to',
        isNotIn: 'is not in',
        isNotLike: 'is not like',
        near: 'near',
        within: 'within'
    },
    upload: {
        addFile: 'Add file',
        addFiles: 'Add files',
        bulkUpload: 'Bulk Upload',
        crop: 'Crop',
        cropToolDescription: 'Drag the corners of the selected area, draw a new area or adjust the values below.',
        download: 'Download',
        dragAndDrop: 'Drag and drop a file',
        dragAndDropHere: 'or drag and drop a file here',
        editImage: 'Edit Image',
        fileName: 'File Name',
        fileSize: 'File Size',
        filesToUpload: 'Files to Upload',
        fileToUpload: 'File to Upload',
        focalPoint: 'Focal Point',
        focalPointDescription: 'Drag the focal point directly on the preview or adjust the values below.',
        height: 'Height',
        lessInfo: 'Less info',
        moreInfo: 'More info',
        noFile: 'No file',
        pasteURL: 'Paste URL',
        previewSizes: 'Preview Sizes',
        selectCollectionToBrowse: 'Select a Collection to Browse',
        selectFile: 'Select a file',
        setCropArea: 'Set crop area',
        setFocalPoint: 'Set focal point',
        sizes: 'Sizes',
        sizesFor: 'Sizes for {{label}}',
        width: 'Width'
    },
    validation: {
        emailAddress: 'Please enter a valid email address.',
        enterNumber: 'Please enter a valid number.',
        fieldHasNo: 'This field has no {{label}}',
        greaterThanMax: '{{value}} is greater than the max allowed {{label}} of {{max}}.',
        invalidBlock: 'The block "{{block}}" is not allowed.',
        invalidBlocks: 'This field contains blocks that are no longer allowed: {{blocks}}.',
        invalidInput: 'This field has an invalid input.',
        invalidSelection: 'This field has an invalid selection.',
        invalidSelections: 'This field has the following invalid selections:',
        latitudeOutOfBounds: 'Latitude must be between -90 and 90.',
        lessThanMin: '{{value}} is less than the min allowed {{label}} of {{min}}.',
        limitReached: 'Limit reached, only {{max}} items can be added.',
        longerThanMin: 'This value must be longer than the minimum length of {{minLength}} characters.',
        longitudeOutOfBounds: 'Longitude must be between -180 and 180.',
        notValidDate: '"{{value}}" is not a valid date.',
        required: 'This field is required.',
        requiresAtLeast: 'This field requires at least {{count}} {{label}}.',
        requiresNoMoreThan: 'This field requires no more than {{count}} {{label}}.',
        requiresTwoNumbers: 'This field requires two numbers.',
        shorterThanMax: 'This value must be shorter than the max length of {{maxLength}} characters.',
        timezoneRequired: 'A timezone is required.',
        trueOrFalse: 'This field can only be equal to true or false.',
        username: 'Please enter a valid username. Can contain letters, numbers, hyphens, periods and underscores.',
        validUploadID: 'This field is not a valid upload ID.'
    },
    version: {
        type: 'Type',
        aboutToPublishSelection: 'You are about to publish all {{label}} in the selection. Are you sure?',
        aboutToRestore: 'You are about to restore this {{label}} document to the state that it was in on {{versionDate}}.',
        aboutToRestoreGlobal: 'You are about to restore the global {{label}} to the state that it was in on {{versionDate}}.',
        aboutToRevertToPublished: "You are about to revert this document's changes to its published state. Are you sure?",
        aboutToUnpublish: 'You are about to unpublish this document. Are you sure?',
        aboutToUnpublishSelection: 'You are about to unpublish all {{label}} in the selection. Are you sure?',
        autosave: 'Autosave',
        autosavedSuccessfully: 'Autosaved successfully.',
        autosavedVersion: 'Autosaved version',
        changed: 'Changed',
        changedFieldsCount_one: '{{count}} changed field',
        changedFieldsCount_other: '{{count}} changed fields',
        compareVersion: 'Compare version against:',
        compareVersions: 'Compare Versions',
        comparingAgainst: 'Comparing against',
        confirmPublish: 'Confirm publish',
        confirmRevertToSaved: 'Confirm revert to saved',
        confirmUnpublish: 'Confirm unpublish',
        confirmVersionRestoration: 'Confirm Version Restoration',
        currentDocumentStatus: 'Current {{docStatus}} document',
        currentDraft: 'Current Draft',
        currentlyPublished: 'Currently Published',
        currentlyViewing: 'Currently viewing',
        currentPublishedVersion: 'Current Published Version',
        draft: 'Draft',
        draftHasPublishedVersion: 'Draft (has published version)',
        draftSavedSuccessfully: 'Draft saved successfully.',
        lastSavedAgo: 'Last saved {{distance}} ago',
        modifiedOnly: 'Modified only',
        moreVersions: 'More versions...',
        noFurtherVersionsFound: 'No further versions found',
        noLabelGroup: 'Unnamed Group',
        noRowsFound: 'No {{label}} found',
        noRowsSelected: 'No {{label}} selected',
        preview: 'Preview',
        previouslyDraft: 'Previously a Draft',
        previouslyPublished: 'Previously Published',
        previousVersion: 'Previous Version',
        problemRestoringVersion: 'There was a problem restoring this version',
        publish: 'Publish',
        publishAllLocales: 'Publish all locales',
        publishChanges: 'Publish changes',
        published: 'Published',
        publishIn: 'Publish in {{locale}}',
        publishing: 'Publishing',
        restoreAsDraft: 'Restore as draft',
        restoredSuccessfully: 'Restored Successfully.',
        restoreThisVersion: 'Restore this version',
        restoring: 'Restoring...',
        reverting: 'Reverting...',
        revertToPublished: 'Revert to published',
        saveDraft: 'Save Draft',
        scheduledSuccessfully: 'Scheduled successfully.',
        schedulePublish: 'Schedule Publish',
        selectLocales: 'Select locales to display',
        selectVersionToCompare: 'Select a version to compare',
        showingVersionsFor: 'Showing versions for:',
        showLocales: 'Show locales:',
        specificVersion: 'Specific Version',
        status: 'Status',
        unpublish: 'Unpublish',
        unpublishing: 'Unpublishing...',
        version: 'Version',
        versionAgo: '{{distance}} ago',
        versionCount_many: '{{count}} versions found',
        versionCount_none: 'No versions found',
        versionCount_one: '{{count}} version found',
        versionCount_other: '{{count}} versions found',
        versionID: 'Version ID',
        versions: 'Versions',
        viewingVersion: 'Viewing version for the {{entityLabel}} {{documentTitle}}',
        viewingVersionGlobal: 'Viewing version for the global {{entityLabel}}',
        viewingVersions: 'Viewing versions for the {{entityLabel}} {{documentTitle}}',
        viewingVersionsGlobal: 'Viewing versions for the global {{entityLabel}}'
    }
};
const en = {
    dateFNSKey: 'en-US',
    translations: enTranslations
}; //# sourceMappingURL=en.js.map
}),
"[project]/node_modules/.pnpm/@payloadcms+translations@3.64.0/node_modules/@payloadcms/translations/dist/utilities/languages.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "acceptedLanguages",
    ()=>acceptedLanguages,
    "extractHeaderLanguage",
    ()=>extractHeaderLanguage,
    "rtlLanguages",
    ()=>rtlLanguages
]);
const rtlLanguages = [
    'ar',
    'fa',
    'he'
];
const acceptedLanguages = [
    'ar',
    'az',
    'bg',
    'bn-BD',
    'bn-IN',
    'ca',
    'cs',
    'bn-BD',
    'bn-IN',
    'da',
    'de',
    'en',
    'es',
    'et',
    'fa',
    'fr',
    'he',
    'hr',
    'hu',
    'hy',
    'id',
    'is',
    'it',
    'ja',
    'ko',
    'lt',
    'lv',
    'my',
    'nb',
    'nl',
    'pl',
    'pt',
    'ro',
    'rs',
    'rs-latin',
    'ru',
    'sk',
    'sl',
    'sv',
    'ta',
    'th',
    'tr',
    'uk',
    'vi',
    'zh',
    'zh-TW'
];
function parseAcceptLanguage(acceptLanguageHeader) {
    return acceptLanguageHeader.split(',').map((lang)=>{
        const [language, quality] = lang.trim().split(';q=');
        return {
            language,
            quality: quality ? parseFloat(quality) : 1
        };
    }).sort((a, b)=>b.quality - a.quality) // Sort by quality, highest to lowest
    ;
}
function extractHeaderLanguage(acceptLanguageHeader) {
    const parsedHeader = parseAcceptLanguage(acceptLanguageHeader);
    let matchedLanguage;
    for (const { language } of parsedHeader){
        if (!matchedLanguage && acceptedLanguages.includes(language)) {
            matchedLanguage = language;
        }
    }
    return matchedLanguage;
} //# sourceMappingURL=languages.js.map
}),
"[project]/node_modules/.pnpm/pluralize@8.0.0/node_modules/pluralize/pluralize.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

/* global define */ (function(root, pluralize) {
    /* istanbul ignore else */ if ("TURBOPACK compile-time truthy", 1) {
        // Node.
        module.exports = pluralize();
    } else //TURBOPACK unreachable
    ;
})(/*TURBOPACK member replacement*/ __turbopack_context__.e, function() {
    // Rule storage - pluralize and singularize need to be run sequentially,
    // while other rules can be optimized using an object for instant lookups.
    var pluralRules = [];
    var singularRules = [];
    var uncountables = {};
    var irregularPlurals = {};
    var irregularSingles = {};
    /**
   * Sanitize a pluralization rule to a usable regular expression.
   *
   * @param  {(RegExp|string)} rule
   * @return {RegExp}
   */ function sanitizeRule(rule) {
        if (typeof rule === 'string') {
            return new RegExp('^' + rule + '$', 'i');
        }
        return rule;
    }
    /**
   * Pass in a word token to produce a function that can replicate the case on
   * another word.
   *
   * @param  {string}   word
   * @param  {string}   token
   * @return {Function}
   */ function restoreCase(word, token) {
        // Tokens are an exact match.
        if (word === token) return token;
        // Lower cased words. E.g. "hello".
        if (word === word.toLowerCase()) return token.toLowerCase();
        // Upper cased words. E.g. "WHISKY".
        if (word === word.toUpperCase()) return token.toUpperCase();
        // Title cased words. E.g. "Title".
        if (word[0] === word[0].toUpperCase()) {
            return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase();
        }
        // Lower cased words. E.g. "test".
        return token.toLowerCase();
    }
    /**
   * Interpolate a regexp string.
   *
   * @param  {string} str
   * @param  {Array}  args
   * @return {string}
   */ function interpolate(str, args) {
        return str.replace(/\$(\d{1,2})/g, function(match, index) {
            return args[index] || '';
        });
    }
    /**
   * Replace a word using a rule.
   *
   * @param  {string} word
   * @param  {Array}  rule
   * @return {string}
   */ function replace(word, rule) {
        return word.replace(rule[0], function(match, index) {
            var result = interpolate(rule[1], arguments);
            if (match === '') {
                return restoreCase(word[index - 1], result);
            }
            return restoreCase(match, result);
        });
    }
    /**
   * Sanitize a word by passing in the word and sanitization rules.
   *
   * @param  {string}   token
   * @param  {string}   word
   * @param  {Array}    rules
   * @return {string}
   */ function sanitizeWord(token, word, rules) {
        // Empty string or doesn't need fixing.
        if (!token.length || uncountables.hasOwnProperty(token)) {
            return word;
        }
        var len = rules.length;
        // Iterate over the sanitization rules and use the first one to match.
        while(len--){
            var rule = rules[len];
            if (rule[0].test(word)) return replace(word, rule);
        }
        return word;
    }
    /**
   * Replace a word with the updated word.
   *
   * @param  {Object}   replaceMap
   * @param  {Object}   keepMap
   * @param  {Array}    rules
   * @return {Function}
   */ function replaceWord(replaceMap, keepMap, rules) {
        return function(word) {
            // Get the correct token and case restoration functions.
            var token = word.toLowerCase();
            // Check against the keep object map.
            if (keepMap.hasOwnProperty(token)) {
                return restoreCase(word, token);
            }
            // Check against the replacement map for a direct word replacement.
            if (replaceMap.hasOwnProperty(token)) {
                return restoreCase(word, replaceMap[token]);
            }
            // Run all the rules against the word.
            return sanitizeWord(token, word, rules);
        };
    }
    /**
   * Check if a word is part of the map.
   */ function checkWord(replaceMap, keepMap, rules, bool) {
        return function(word) {
            var token = word.toLowerCase();
            if (keepMap.hasOwnProperty(token)) return true;
            if (replaceMap.hasOwnProperty(token)) return false;
            return sanitizeWord(token, token, rules) === token;
        };
    }
    /**
   * Pluralize or singularize a word based on the passed in count.
   *
   * @param  {string}  word      The word to pluralize
   * @param  {number}  count     How many of the word exist
   * @param  {boolean} inclusive Whether to prefix with the number (e.g. 3 ducks)
   * @return {string}
   */ function pluralize(word, count, inclusive) {
        var pluralized = count === 1 ? pluralize.singular(word) : pluralize.plural(word);
        return (inclusive ? count + ' ' : '') + pluralized;
    }
    /**
   * Pluralize a word.
   *
   * @type {Function}
   */ pluralize.plural = replaceWord(irregularSingles, irregularPlurals, pluralRules);
    /**
   * Check if a word is plural.
   *
   * @type {Function}
   */ pluralize.isPlural = checkWord(irregularSingles, irregularPlurals, pluralRules);
    /**
   * Singularize a word.
   *
   * @type {Function}
   */ pluralize.singular = replaceWord(irregularPlurals, irregularSingles, singularRules);
    /**
   * Check if a word is singular.
   *
   * @type {Function}
   */ pluralize.isSingular = checkWord(irregularPlurals, irregularSingles, singularRules);
    /**
   * Add a pluralization rule to the collection.
   *
   * @param {(string|RegExp)} rule
   * @param {string}          replacement
   */ pluralize.addPluralRule = function(rule, replacement) {
        pluralRules.push([
            sanitizeRule(rule),
            replacement
        ]);
    };
    /**
   * Add a singularization rule to the collection.
   *
   * @param {(string|RegExp)} rule
   * @param {string}          replacement
   */ pluralize.addSingularRule = function(rule, replacement) {
        singularRules.push([
            sanitizeRule(rule),
            replacement
        ]);
    };
    /**
   * Add an uncountable word rule.
   *
   * @param {(string|RegExp)} word
   */ pluralize.addUncountableRule = function(word) {
        if (typeof word === 'string') {
            uncountables[word.toLowerCase()] = true;
            return;
        }
        // Set singular and plural references for the word.
        pluralize.addPluralRule(word, '$0');
        pluralize.addSingularRule(word, '$0');
    };
    /**
   * Add an irregular word definition.
   *
   * @param {string} single
   * @param {string} plural
   */ pluralize.addIrregularRule = function(single, plural) {
        plural = plural.toLowerCase();
        single = single.toLowerCase();
        irregularSingles[single] = plural;
        irregularPlurals[plural] = single;
    };
    /**
   * Irregular rules.
   */ [
        // Pronouns.
        [
            'I',
            'we'
        ],
        [
            'me',
            'us'
        ],
        [
            'he',
            'they'
        ],
        [
            'she',
            'they'
        ],
        [
            'them',
            'them'
        ],
        [
            'myself',
            'ourselves'
        ],
        [
            'yourself',
            'yourselves'
        ],
        [
            'itself',
            'themselves'
        ],
        [
            'herself',
            'themselves'
        ],
        [
            'himself',
            'themselves'
        ],
        [
            'themself',
            'themselves'
        ],
        [
            'is',
            'are'
        ],
        [
            'was',
            'were'
        ],
        [
            'has',
            'have'
        ],
        [
            'this',
            'these'
        ],
        [
            'that',
            'those'
        ],
        // Words ending in with a consonant and `o`.
        [
            'echo',
            'echoes'
        ],
        [
            'dingo',
            'dingoes'
        ],
        [
            'volcano',
            'volcanoes'
        ],
        [
            'tornado',
            'tornadoes'
        ],
        [
            'torpedo',
            'torpedoes'
        ],
        // Ends with `us`.
        [
            'genus',
            'genera'
        ],
        [
            'viscus',
            'viscera'
        ],
        // Ends with `ma`.
        [
            'stigma',
            'stigmata'
        ],
        [
            'stoma',
            'stomata'
        ],
        [
            'dogma',
            'dogmata'
        ],
        [
            'lemma',
            'lemmata'
        ],
        [
            'schema',
            'schemata'
        ],
        [
            'anathema',
            'anathemata'
        ],
        // Other irregular rules.
        [
            'ox',
            'oxen'
        ],
        [
            'axe',
            'axes'
        ],
        [
            'die',
            'dice'
        ],
        [
            'yes',
            'yeses'
        ],
        [
            'foot',
            'feet'
        ],
        [
            'eave',
            'eaves'
        ],
        [
            'goose',
            'geese'
        ],
        [
            'tooth',
            'teeth'
        ],
        [
            'quiz',
            'quizzes'
        ],
        [
            'human',
            'humans'
        ],
        [
            'proof',
            'proofs'
        ],
        [
            'carve',
            'carves'
        ],
        [
            'valve',
            'valves'
        ],
        [
            'looey',
            'looies'
        ],
        [
            'thief',
            'thieves'
        ],
        [
            'groove',
            'grooves'
        ],
        [
            'pickaxe',
            'pickaxes'
        ],
        [
            'passerby',
            'passersby'
        ]
    ].forEach(function(rule) {
        return pluralize.addIrregularRule(rule[0], rule[1]);
    });
    /**
   * Pluralization rules.
   */ [
        [
            /s?$/i,
            's'
        ],
        [
            /[^\u0000-\u007F]$/i,
            '$0'
        ],
        [
            /([^aeiou]ese)$/i,
            '$1'
        ],
        [
            /(ax|test)is$/i,
            '$1es'
        ],
        [
            /(alias|[^aou]us|t[lm]as|gas|ris)$/i,
            '$1es'
        ],
        [
            /(e[mn]u)s?$/i,
            '$1s'
        ],
        [
            /([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i,
            '$1'
        ],
        [
            /(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i,
            '$1i'
        ],
        [
            /(alumn|alg|vertebr)(?:a|ae)$/i,
            '$1ae'
        ],
        [
            /(seraph|cherub)(?:im)?$/i,
            '$1im'
        ],
        [
            /(her|at|gr)o$/i,
            '$1oes'
        ],
        [
            /(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i,
            '$1a'
        ],
        [
            /(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i,
            '$1a'
        ],
        [
            /sis$/i,
            'ses'
        ],
        [
            /(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i,
            '$1$2ves'
        ],
        [
            /([^aeiouy]|qu)y$/i,
            '$1ies'
        ],
        [
            /([^ch][ieo][ln])ey$/i,
            '$1ies'
        ],
        [
            /(x|ch|ss|sh|zz)$/i,
            '$1es'
        ],
        [
            /(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i,
            '$1ices'
        ],
        [
            /\b((?:tit)?m|l)(?:ice|ouse)$/i,
            '$1ice'
        ],
        [
            /(pe)(?:rson|ople)$/i,
            '$1ople'
        ],
        [
            /(child)(?:ren)?$/i,
            '$1ren'
        ],
        [
            /eaux$/i,
            '$0'
        ],
        [
            /m[ae]n$/i,
            'men'
        ],
        [
            'thou',
            'you'
        ]
    ].forEach(function(rule) {
        return pluralize.addPluralRule(rule[0], rule[1]);
    });
    /**
   * Singularization rules.
   */ [
        [
            /s$/i,
            ''
        ],
        [
            /(ss)$/i,
            '$1'
        ],
        [
            /(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i,
            '$1fe'
        ],
        [
            /(ar|(?:wo|[ae])l|[eo][ao])ves$/i,
            '$1f'
        ],
        [
            /ies$/i,
            'y'
        ],
        [
            /\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i,
            '$1ie'
        ],
        [
            /\b(mon|smil)ies$/i,
            '$1ey'
        ],
        [
            /\b((?:tit)?m|l)ice$/i,
            '$1ouse'
        ],
        [
            /(seraph|cherub)im$/i,
            '$1'
        ],
        [
            /(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i,
            '$1'
        ],
        [
            /(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i,
            '$1sis'
        ],
        [
            /(movie|twelve|abuse|e[mn]u)s$/i,
            '$1'
        ],
        [
            /(test)(?:is|es)$/i,
            '$1is'
        ],
        [
            /(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i,
            '$1us'
        ],
        [
            /(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i,
            '$1um'
        ],
        [
            /(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i,
            '$1on'
        ],
        [
            /(alumn|alg|vertebr)ae$/i,
            '$1a'
        ],
        [
            /(cod|mur|sil|vert|ind)ices$/i,
            '$1ex'
        ],
        [
            /(matr|append)ices$/i,
            '$1ix'
        ],
        [
            /(pe)(rson|ople)$/i,
            '$1rson'
        ],
        [
            /(child)ren$/i,
            '$1'
        ],
        [
            /(eau)x?$/i,
            '$1'
        ],
        [
            /men$/i,
            'man'
        ]
    ].forEach(function(rule) {
        return pluralize.addSingularRule(rule[0], rule[1]);
    });
    /**
   * Uncountable rules.
   */ [
        // Singular words with no plurals.
        'adulthood',
        'advice',
        'agenda',
        'aid',
        'aircraft',
        'alcohol',
        'ammo',
        'analytics',
        'anime',
        'athletics',
        'audio',
        'bison',
        'blood',
        'bream',
        'buffalo',
        'butter',
        'carp',
        'cash',
        'chassis',
        'chess',
        'clothing',
        'cod',
        'commerce',
        'cooperation',
        'corps',
        'debris',
        'diabetes',
        'digestion',
        'elk',
        'energy',
        'equipment',
        'excretion',
        'expertise',
        'firmware',
        'flounder',
        'fun',
        'gallows',
        'garbage',
        'graffiti',
        'hardware',
        'headquarters',
        'health',
        'herpes',
        'highjinks',
        'homework',
        'housework',
        'information',
        'jeans',
        'justice',
        'kudos',
        'labour',
        'literature',
        'machinery',
        'mackerel',
        'mail',
        'media',
        'mews',
        'moose',
        'music',
        'mud',
        'manga',
        'news',
        'only',
        'personnel',
        'pike',
        'plankton',
        'pliers',
        'police',
        'pollution',
        'premises',
        'rain',
        'research',
        'rice',
        'salmon',
        'scissors',
        'series',
        'sewage',
        'shambles',
        'shrimp',
        'software',
        'species',
        'staff',
        'swine',
        'tennis',
        'traffic',
        'transportation',
        'trout',
        'tuna',
        'wealth',
        'welfare',
        'whiting',
        'wildebeest',
        'wildlife',
        'you',
        /pok[e]mon$/i,
        // Regexes.
        /[^aeiou]ese$/i,
        /deer$/i,
        /fish$/i,
        /measles$/i,
        /o[iu]s$/i,
        /pox$/i,
        /sheep$/i
    ].forEach(pluralize.addUncountableRule);
    return pluralize;
});
}),
"[project]/node_modules/.pnpm/@lexical+selection@0.35.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "$addNodeStyle",
    ()=>$addNodeStyle,
    "$copyBlockFormatIndent",
    ()=>$copyBlockFormatIndent,
    "$ensureForwardRangeSelection",
    ()=>$ensureForwardRangeSelection,
    "$forEachSelectedTextNode",
    ()=>$forEachSelectedTextNode,
    "$getComputedStyleForElement",
    ()=>$getComputedStyleForElement,
    "$getComputedStyleForParent",
    ()=>$getComputedStyleForParent,
    "$getSelectionStyleValueForProperty",
    ()=>$getSelectionStyleValueForProperty,
    "$isAtNodeEnd",
    ()=>$isAtNodeEnd,
    "$isParentElementRTL",
    ()=>$isParentElementRTL,
    "$isParentRTL",
    ()=>$isParentRTL,
    "$moveCaretSelection",
    ()=>$moveCaretSelection,
    "$moveCharacter",
    ()=>$moveCharacter,
    "$patchStyleText",
    ()=>$patchStyleText,
    "$setBlocksType",
    ()=>$setBlocksType,
    "$shouldOverrideDefaultCharacterSelection",
    ()=>$shouldOverrideDefaultCharacterSelection,
    "$sliceSelectedTextNodeContent",
    ()=>$sliceSelectedTextNodeContent,
    "$trimTextContentFromAnchor",
    ()=>$trimTextContentFromAnchor,
    "$wrapNodes",
    ()=>$wrapNodes,
    "createDOMRange",
    ()=>createDOMRange,
    "createRectsFromDOMRange",
    ()=>createRectsFromDOMRange,
    "getCSSFromStyleObject",
    ()=>getCSSFromStyleObject,
    "getStyleObjectFromCSS",
    ()=>getStyleObjectFromCSS,
    "trimTextContentFromAnchor",
    ()=>trimTextContentFromAnchor
]);
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/lexical@0.35.0/node_modules/lexical/Lexical.dev.mjs [app-rsc] (ecmascript)");
;
;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ // Do not require this module directly! Use normal `invariant` calls.
function formatDevErrorMessage(message) {
    throw new Error(message);
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ const CSS_TO_STYLES = new Map();
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ function getDOMTextNode(element) {
    let node = element;
    while(node != null){
        if (node.nodeType === Node.TEXT_NODE) {
            return node;
        }
        node = node.firstChild;
    }
    return null;
}
function getDOMIndexWithinParent(node) {
    const parent = node.parentNode;
    if (parent == null) {
        throw new Error('Should never happen');
    }
    return [
        parent,
        Array.from(parent.childNodes).indexOf(node)
    ];
}
/**
 * Creates a selection range for the DOM.
 * @param editor - The lexical editor.
 * @param anchorNode - The anchor node of a selection.
 * @param _anchorOffset - The amount of space offset from the anchor to the focus.
 * @param focusNode - The current focus.
 * @param _focusOffset - The amount of space offset from the focus to the anchor.
 * @returns The range of selection for the DOM that was created.
 */ function createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {
    const anchorKey = anchorNode.getKey();
    const focusKey = focusNode.getKey();
    const range = document.createRange();
    let anchorDOM = editor.getElementByKey(anchorKey);
    let focusDOM = editor.getElementByKey(focusKey);
    let anchorOffset = _anchorOffset;
    let focusOffset = _focusOffset;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTextNode"])(anchorNode)) {
        anchorDOM = getDOMTextNode(anchorDOM);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTextNode"])(focusNode)) {
        focusDOM = getDOMTextNode(focusDOM);
    }
    if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {
        return null;
    }
    if (anchorDOM.nodeName === 'BR') {
        [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);
    }
    if (focusDOM.nodeName === 'BR') {
        [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);
    }
    const firstChild = anchorDOM.firstChild;
    if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {
        focusOffset = 1;
    }
    try {
        range.setStart(anchorDOM, anchorOffset);
        range.setEnd(focusDOM, focusOffset);
    } catch (e) {
        return null;
    }
    if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {
        // Range is backwards, we need to reverse it
        range.setStart(focusDOM, focusOffset);
        range.setEnd(anchorDOM, anchorOffset);
    }
    return range;
}
/**
 * Creates DOMRects, generally used to help the editor find a specific location on the screen.
 * @param editor - The lexical editor
 * @param range - A fragment of a document that can contain nodes and parts of text nodes.
 * @returns The selectionRects as an array.
 */ function createRectsFromDOMRange(editor, range) {
    const rootElement = editor.getRootElement();
    if (rootElement === null) {
        return [];
    }
    const rootRect = rootElement.getBoundingClientRect();
    const computedStyle = getComputedStyle(rootElement);
    const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
    const selectionRects = Array.from(range.getClientRects());
    let selectionRectsLength = selectionRects.length;
    //sort rects from top left to bottom right.
    selectionRects.sort((a, b)=>{
        const top = a.top - b.top;
        // Some rects match position closely, but not perfectly,
        // so we give a 3px tolerance.
        if (Math.abs(top) <= 3) {
            return a.left - b.left;
        }
        return top;
    });
    let prevRect;
    for(let i = 0; i < selectionRectsLength; i++){
        const selectionRect = selectionRects[i];
        // Exclude rects that overlap preceding Rects in the sorted list.
        const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;
        // Exclude selections that span the entire element
        const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;
        if (isOverlappingRect || selectionSpansElement) {
            selectionRects.splice(i--, 1);
            selectionRectsLength--;
            continue;
        }
        prevRect = selectionRect;
    }
    return selectionRects;
}
/**
 * Creates an object containing all the styles and their values provided in the CSS string.
 * @param css - The CSS string of styles and their values.
 * @returns The styleObject containing all the styles and their values.
 */ function getStyleObjectFromRawCSS(css) {
    const styleObject = {};
    if (!css) {
        return styleObject;
    }
    const styles = css.split(';');
    for (const style of styles){
        if (style !== '') {
            const [key, value] = style.split(/:([^]+)/); // split on first colon
            if (key && value) {
                styleObject[key.trim()] = value.trim();
            }
        }
    }
    return styleObject;
}
/**
 * Given a CSS string, returns an object from the style cache.
 * @param css - The CSS property as a string.
 * @returns The value of the given CSS property.
 */ function getStyleObjectFromCSS(css) {
    let value = CSS_TO_STYLES.get(css);
    if (value === undefined) {
        value = getStyleObjectFromRawCSS(css);
        CSS_TO_STYLES.set(css, value);
    }
    {
        // Freeze the value in DEV to prevent accidental mutations
        Object.freeze(value);
    }
    return value;
}
/**
 * Gets the CSS styles from the style object.
 * @param styles - The style object containing the styles to get.
 * @returns A string containing the CSS styles and their values.
 */ function getCSSFromStyleObject(styles) {
    let css = '';
    for(const style in styles){
        if (style) {
            css += `${style}: ${styles[style]};`;
        }
    }
    return css;
}
/**
 * Gets the computed DOM styles of the element.
 * @param node - The node to check the styles for.
 * @returns the computed styles of the element or null if there is no DOM element or no default view for the document.
 */ function $getComputedStyleForElement(element) {
    const editor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getEditor"])();
    const domElement = editor.getElementByKey(element.getKey());
    if (domElement === null) {
        return null;
    }
    const view = domElement.ownerDocument.defaultView;
    if (view === null) {
        return null;
    }
    return view.getComputedStyle(domElement);
}
/**
 * Gets the computed DOM styles of the parent of the node.
 * @param node - The node to check its parent's styles for.
 * @returns the computed styles of the node or null if there is no DOM element or no default view for the document.
 */ function $getComputedStyleForParent(node) {
    const parent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRootNode"])(node) ? node : node.getParentOrThrow();
    return $getComputedStyleForElement(parent);
}
/**
 * Determines whether a node's parent is RTL.
 * @param node - The node to check whether it is RTL.
 * @returns whether the node is RTL.
 */ function $isParentRTL(node) {
    const styles = $getComputedStyleForParent(node);
    return styles !== null && styles.direction === 'rtl';
}
/**
 * Generally used to append text content to HTML and JSON. Grabs the text content and "slices"
 * it to be generated into the new TextNode.
 * @param selection - The selection containing the node whose TextNode is to be edited.
 * @param textNode - The TextNode to be edited.
 * @returns The updated TextNode.
 */ function $sliceSelectedTextNodeContent(selection, textNode) {
    const anchorAndFocus = selection.getStartEndPoints();
    if (textNode.isSelected(selection) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTokenOrSegmented"])(textNode) && anchorAndFocus !== null) {
        const [anchor, focus] = anchorAndFocus;
        const isBackward = selection.isBackward();
        const anchorNode = anchor.getNode();
        const focusNode = focus.getNode();
        const isAnchor = textNode.is(anchorNode);
        const isFocus = textNode.is(focusNode);
        if (isAnchor || isFocus) {
            const [anchorOffset, focusOffset] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getCharacterOffsets"])(selection);
            const isSame = anchorNode.is(focusNode);
            const isFirst = textNode.is(isBackward ? focusNode : anchorNode);
            const isLast = textNode.is(isBackward ? anchorNode : focusNode);
            let startOffset = 0;
            let endOffset = undefined;
            if (isSame) {
                startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;
                endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;
            } else if (isFirst) {
                const offset = isBackward ? focusOffset : anchorOffset;
                startOffset = offset;
                endOffset = undefined;
            } else if (isLast) {
                const offset = isBackward ? anchorOffset : focusOffset;
                startOffset = 0;
                endOffset = offset;
            }
            // NOTE: This mutates __text directly because the primary use case is to
            // modify a $cloneWithProperties node that should never be added
            // to the EditorState so we must not call getWritable via setTextContent
            textNode.__text = textNode.__text.slice(startOffset, endOffset);
        }
    }
    return textNode;
}
/**
 * Determines if the current selection is at the end of the node.
 * @param point - The point of the selection to test.
 * @returns true if the provided point offset is in the last possible position, false otherwise.
 */ function $isAtNodeEnd(point) {
    if (point.type === 'text') {
        return point.offset === point.getNode().getTextContentSize();
    }
    const node = point.getNode();
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(node)) {
        formatDevErrorMessage(`isAtNodeEnd: node must be a TextNode or ElementNode`);
    }
    return point.offset === node.getChildrenSize();
}
/**
 * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text
 * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes
 * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.
 * @param editor - The lexical editor.
 * @param anchor - The anchor of the current selection, where the selection should be pointing.
 * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;
 */ function $trimTextContentFromAnchor(editor, anchor, delCount) {
    // Work from the current selection anchor point
    let currentNode = anchor.getNode();
    let remaining = delCount;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(currentNode)) {
        const descendantNode = currentNode.getDescendantByIndex(anchor.offset);
        if (descendantNode !== null) {
            currentNode = descendantNode;
        }
    }
    while(remaining > 0 && currentNode !== null){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(currentNode)) {
            const lastDescendant = currentNode.getLastDescendant();
            if (lastDescendant !== null) {
                currentNode = lastDescendant;
            }
        }
        let nextNode = currentNode.getPreviousSibling();
        let additionalElementWhitespace = 0;
        if (nextNode === null) {
            let parent = currentNode.getParentOrThrow();
            let parentSibling = parent.getPreviousSibling();
            while(parentSibling === null){
                parent = parent.getParent();
                if (parent === null) {
                    nextNode = null;
                    break;
                }
                parentSibling = parent.getPreviousSibling();
            }
            if (parent !== null) {
                additionalElementWhitespace = parent.isInline() ? 0 : 2;
                nextNode = parentSibling;
            }
        }
        let text = currentNode.getTextContent();
        // If the text is empty, we need to consider adding in two line breaks to match
        // the content if we were to get it from its parent.
        if (text === '' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(currentNode) && !currentNode.isInline()) {
            // TODO: should this be handled in core?
            text = '\n\n';
        }
        const currentNodeSize = text.length;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTextNode"])(currentNode) || remaining >= currentNodeSize) {
            const parent = currentNode.getParent();
            currentNode.remove();
            if (parent != null && parent.getChildrenSize() === 0 && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRootNode"])(parent)) {
                parent.remove();
            }
            remaining -= currentNodeSize + additionalElementWhitespace;
            currentNode = nextNode;
        } else {
            const key = currentNode.getKey();
            // See if we can just revert it to what was in the last editor state
            const prevTextContent = editor.getEditorState().read(()=>{
                const prevNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getNodeByKey"])(key);
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTextNode"])(prevNode) && prevNode.isSimpleText()) {
                    return prevNode.getTextContent();
                }
                return null;
            });
            const offset = currentNodeSize - remaining;
            const slicedText = text.slice(0, offset);
            if (prevTextContent !== null && prevTextContent !== text) {
                const prevSelection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getPreviousSelection"])();
                let target = currentNode;
                if (!currentNode.isSimpleText()) {
                    const textNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createTextNode"])(prevTextContent);
                    currentNode.replace(textNode);
                    target = textNode;
                } else {
                    currentNode.setTextContent(prevTextContent);
                }
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(prevSelection) && prevSelection.isCollapsed()) {
                    const prevOffset = prevSelection.anchor.offset;
                    target.select(prevOffset, prevOffset);
                }
            } else if (currentNode.isSimpleText()) {
                // Split text
                const isSelected = anchor.key === key;
                let anchorOffset = anchor.offset;
                // Move offset to end if it's less than the remaining number, otherwise
                // we'll have a negative splitStart.
                if (anchorOffset < remaining) {
                    anchorOffset = currentNodeSize;
                }
                const splitStart = isSelected ? anchorOffset - remaining : 0;
                const splitEnd = isSelected ? anchorOffset : offset;
                if (isSelected && splitStart === 0) {
                    const [excessNode] = currentNode.splitText(splitStart, splitEnd);
                    excessNode.remove();
                } else {
                    const [, excessNode] = currentNode.splitText(splitStart, splitEnd);
                    excessNode.remove();
                }
            } else {
                const textNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createTextNode"])(slicedText);
                currentNode.replace(textNode);
            }
            remaining = 0;
        }
    }
}
/**
 * Gets the TextNode's style object and adds the styles to the CSS.
 * @param node - The TextNode to add styles to.
 */ function $addNodeStyle(node) {
    const CSSText = node.getStyle();
    const styles = getStyleObjectFromRawCSS(CSSText);
    CSS_TO_STYLES.set(CSSText, styles);
}
/**
 * Applies the provided styles to the given TextNode, ElementNode, or
 * collapsed RangeSelection.
 *
 * @param target - The TextNode, ElementNode, or collapsed RangeSelection to apply the styles to
 * @param patch - The patch to apply, which can include multiple styles. \\{CSSProperty: value\\} . Can also accept a function that returns the new property value.
 */ function $patchStyle(target, patch) {
    if (!((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(target) ? target.isCollapsed() : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTextNode"])(target) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(target))) {
        formatDevErrorMessage(`$patchStyle must only be called with a TextNode, ElementNode, or collapsed RangeSelection`);
    }
    const prevStyles = getStyleObjectFromCSS((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(target) ? target.style : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTextNode"])(target) ? target.getStyle() : target.getTextStyle());
    const newStyles = Object.entries(patch).reduce((styles, [key, value])=>{
        if (typeof value === 'function') {
            styles[key] = value(prevStyles[key], target);
        } else if (value === null) {
            delete styles[key];
        } else {
            styles[key] = value;
        }
        return styles;
    }, {
        ...prevStyles
    });
    const newCSSText = getCSSFromStyleObject(newStyles);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(target) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTextNode"])(target)) {
        target.setStyle(newCSSText);
    } else {
        target.setTextStyle(newCSSText);
    }
    CSS_TO_STYLES.set(newCSSText, newStyles);
}
/**
 * Applies the provided styles to the TextNodes in the provided Selection.
 * Will update partially selected TextNodes by splitting the TextNode and applying
 * the styles to the appropriate one.
 * @param selection - The selected node(s) to update.
 * @param patch - The patch to apply, which can include multiple styles. \\{CSSProperty: value\\} . Can also accept a function that returns the new property value.
 */ function $patchStyleText(selection, patch) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection) && selection.isCollapsed()) {
        $patchStyle(selection, patch);
        const emptyNode = selection.anchor.getNode();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(emptyNode) && emptyNode.isEmpty()) {
            $patchStyle(emptyNode, patch);
        }
    }
    $forEachSelectedTextNode((textNode)=>{
        $patchStyle(textNode, patch);
    });
}
function $forEachSelectedTextNode(fn) {
    const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
    if (!selection) {
        return;
    }
    const slicedTextNodes = new Map();
    const getSliceIndices = (node)=>slicedTextNodes.get(node.getKey()) || [
            0,
            node.getTextContentSize()
        ];
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
        for (const slice of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$caretRangeFromSelection"])(selection).getTextSlices()){
            if (slice) {
                slicedTextNodes.set(slice.caret.origin.getKey(), slice.getSliceIndices());
            }
        }
    }
    const selectedNodes = selection.getNodes();
    for (const selectedNode of selectedNodes){
        if (!((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTextNode"])(selectedNode) && selectedNode.canHaveFormat())) {
            continue;
        }
        const [startOffset, endOffset] = getSliceIndices(selectedNode);
        // No actual text is selected, so do nothing.
        if (endOffset === startOffset) {
            continue;
        }
        // The entire node is selected or a token/segment, so just format it
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTokenOrSegmented"])(selectedNode) || startOffset === 0 && endOffset === selectedNode.getTextContentSize()) {
            fn(selectedNode);
        } else {
            // The node is partially selected, so split it into two or three nodes
            // and style the selected one.
            const splitNodes = selectedNode.splitText(startOffset, endOffset);
            const replacement = splitNodes[startOffset === 0 ? 0 : 1];
            fn(replacement);
        }
    }
    // Prior to NodeCaret #7046 this would have been a side-effect
    // so we do this for test compatibility.
    // TODO: we may want to consider simplifying by removing this
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection) && selection.anchor.type === 'text' && selection.focus.type === 'text' && selection.anchor.key === selection.focus.key) {
        $ensureForwardRangeSelection(selection);
    }
}
/**
 * Ensure that the given RangeSelection is not backwards. If it
 * is backwards, then the anchor and focus points will be swapped
 * in-place. Ensuring that the selection is a writable RangeSelection
 * is the responsibility of the caller (e.g. in a read-only context
 * you will want to clone $getSelection() before using this).
 *
 * @param selection a writable RangeSelection
 */ function $ensureForwardRangeSelection(selection) {
    if (selection.isBackward()) {
        const { anchor, focus } = selection;
        // stash for the in-place swap
        const { key, offset, type } = anchor;
        anchor.set(focus.key, focus.offset, focus.type);
        focus.set(key, offset, type);
    }
}
function $copyBlockFormatIndent(srcNode, destNode) {
    const format = srcNode.getFormatType();
    const indent = srcNode.getIndent();
    if (format !== destNode.getFormatType()) {
        destNode.setFormat(format);
    }
    if (indent !== destNode.getIndent()) {
        destNode.setIndent(indent);
    }
}
/**
 * Converts all nodes in the selection that are of one block type to another.
 * @param selection - The selected blocks to be converted.
 * @param $createElement - The function that creates the node. eg. $createParagraphNode.
 * @param $afterCreateElement - The function that updates the new node based on the previous one ($copyBlockFormatIndent by default)
 */ function $setBlocksType(selection, $createElement, $afterCreateElement = $copyBlockFormatIndent) {
    if (selection === null) {
        return;
    }
    // Selections tend to not include their containing blocks so we effectively
    // expand it here
    const anchorAndFocus = selection.getStartEndPoints();
    const blockMap = new Map();
    let newSelection = null;
    if (anchorAndFocus) {
        const [anchor, focus] = anchorAndFocus;
        newSelection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createRangeSelection"])();
        newSelection.anchor.set(anchor.key, anchor.offset, anchor.type);
        newSelection.focus.set(focus.key, focus.offset, focus.type);
        const anchorBlock = $getAncestor(anchor.getNode(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["INTERNAL_$isBlock"]);
        const focusBlock = $getAncestor(focus.getNode(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["INTERNAL_$isBlock"]);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(anchorBlock)) {
            blockMap.set(anchorBlock.getKey(), anchorBlock);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(focusBlock)) {
            blockMap.set(focusBlock.getKey(), focusBlock);
        }
    }
    for (const node of selection.getNodes()){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(node) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["INTERNAL_$isBlock"])(node)) {
            blockMap.set(node.getKey(), node);
        } else if (anchorAndFocus === null) {
            const ancestorBlock = $getAncestor(node, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["INTERNAL_$isBlock"]);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(ancestorBlock)) {
                blockMap.set(ancestorBlock.getKey(), ancestorBlock);
            }
        }
    }
    for (const [key, prevNode] of blockMap){
        const element = $createElement();
        $afterCreateElement(prevNode, element);
        prevNode.replace(element, true);
        if (newSelection) {
            if (key === newSelection.anchor.key) {
                newSelection.anchor.set(element.getKey(), newSelection.anchor.offset, newSelection.anchor.type);
            }
            if (key === newSelection.focus.key) {
                newSelection.focus.set(element.getKey(), newSelection.focus.offset, newSelection.focus.type);
            }
        }
    }
    if (newSelection && selection.is((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])())) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$setSelection"])(newSelection);
    }
}
function isPointAttached(point) {
    return point.getNode().isAttached();
}
function $removeParentEmptyElements(startingNode) {
    let node = startingNode;
    while(node !== null && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRootOrShadowRoot"])(node)){
        const latest = node.getLatest();
        const parentNode = node.getParent();
        if (latest.getChildrenSize() === 0) {
            node.remove(true);
        }
        node = parentNode;
    }
}
/**
 * @deprecated In favor of $setBlockTypes
 * Wraps all nodes in the selection into another node of the type returned by createElement.
 * @param selection - The selection of nodes to be wrapped.
 * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.
 * @param wrappingElement - An element to append the wrapped selection and its children to.
 */ function $wrapNodes(selection, createElement, wrappingElement = null) {
    const anchorAndFocus = selection.getStartEndPoints();
    const anchor = anchorAndFocus ? anchorAndFocus[0] : null;
    const nodes = selection.getNodes();
    const nodesLength = nodes.length;
    if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0)) {
        const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();
        const children = target.getChildren();
        let element = createElement();
        element.setFormat(target.getFormatType());
        element.setIndent(target.getIndent());
        children.forEach((child)=>element.append(child));
        if (wrappingElement) {
            element = wrappingElement.append(element);
        }
        target.replace(element);
        return;
    }
    let topLevelNode = null;
    let descendants = [];
    for(let i = 0; i < nodesLength; i++){
        const node = nodes[i];
        // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the
        // user selected multiple Root-like nodes that have to be treated separately as if they are
        // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each
        // of each of the cell nodes.
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRootOrShadowRoot"])(node)) {
            $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
            descendants = [];
            topLevelNode = node;
        } else if (topLevelNode === null || topLevelNode !== null && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$hasAncestor"])(node, topLevelNode)) {
            descendants.push(node);
        } else {
            $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
            descendants = [
                node
            ];
        }
    }
    $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
}
/**
 * Wraps each node into a new ElementNode.
 * @param selection - The selection of nodes to wrap.
 * @param nodes - An array of nodes, generally the descendants of the selection.
 * @param nodesLength - The length of nodes.
 * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.
 * @param wrappingElement - An element to wrap all the nodes into.
 * @returns
 */ function $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {
    if (nodes.length === 0) {
        return;
    }
    const firstNode = nodes[0];
    const elementMapping = new Map();
    const elements = [];
    // The below logic is to find the right target for us to
    // either insertAfter/insertBefore/append the corresponding
    // elements to. This is made more complicated due to nested
    // structures.
    let target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(firstNode) ? firstNode : firstNode.getParentOrThrow();
    if (target.isInline()) {
        target = target.getParentOrThrow();
    }
    let targetIsPrevSibling = false;
    while(target !== null){
        const prevSibling = target.getPreviousSibling();
        if (prevSibling !== null) {
            target = prevSibling;
            targetIsPrevSibling = true;
            break;
        }
        target = target.getParentOrThrow();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRootOrShadowRoot"])(target)) {
            break;
        }
    }
    const emptyElements = new Set();
    // Find any top level empty elements
    for(let i = 0; i < nodesLength; i++){
        const node = nodes[i];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(node) && node.getChildrenSize() === 0) {
            emptyElements.add(node.getKey());
        }
    }
    const movedNodes = new Set();
    // Move out all leaf nodes into our elements array.
    // If we find a top level empty element, also move make
    // an element for that.
    for(let i = 0; i < nodesLength; i++){
        const node = nodes[i];
        let parent = node.getParent();
        if (parent !== null && parent.isInline()) {
            parent = parent.getParent();
        }
        if (parent !== null && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isLeafNode"])(node) && !movedNodes.has(node.getKey())) {
            const parentKey = parent.getKey();
            if (elementMapping.get(parentKey) === undefined) {
                const targetElement = createElement();
                targetElement.setFormat(parent.getFormatType());
                targetElement.setIndent(parent.getIndent());
                elements.push(targetElement);
                elementMapping.set(parentKey, targetElement);
                // Move node and its siblings to the new
                // element.
                parent.getChildren().forEach((child)=>{
                    targetElement.append(child);
                    movedNodes.add(child.getKey());
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(child)) {
                        // Skip nested leaf nodes if the parent has already been moved
                        child.getChildrenKeys().forEach((key)=>movedNodes.add(key));
                    }
                });
                $removeParentEmptyElements(parent);
            }
        } else if (emptyElements.has(node.getKey())) {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(node)) {
                formatDevErrorMessage(`Expected node in emptyElements to be an ElementNode`);
            }
            const targetElement = createElement();
            targetElement.setFormat(node.getFormatType());
            targetElement.setIndent(node.getIndent());
            elements.push(targetElement);
            node.remove(true);
        }
    }
    if (wrappingElement !== null) {
        for(let i = 0; i < elements.length; i++){
            const element = elements[i];
            wrappingElement.append(element);
        }
    }
    let lastElement = null;
    // If our target is Root-like, let's see if we can re-adjust
    // so that the target is the first child instead.
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRootOrShadowRoot"])(target)) {
        if (targetIsPrevSibling) {
            if (wrappingElement !== null) {
                target.insertAfter(wrappingElement);
            } else {
                for(let i = elements.length - 1; i >= 0; i--){
                    const element = elements[i];
                    target.insertAfter(element);
                }
            }
        } else {
            const firstChild = target.getFirstChild();
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(firstChild)) {
                target = firstChild;
            }
            if (firstChild === null) {
                if (wrappingElement) {
                    target.append(wrappingElement);
                } else {
                    for(let i = 0; i < elements.length; i++){
                        const element = elements[i];
                        target.append(element);
                        lastElement = element;
                    }
                }
            } else {
                if (wrappingElement !== null) {
                    firstChild.insertBefore(wrappingElement);
                } else {
                    for(let i = 0; i < elements.length; i++){
                        const element = elements[i];
                        firstChild.insertBefore(element);
                        lastElement = element;
                    }
                }
            }
        }
    } else {
        if (wrappingElement) {
            target.insertAfter(wrappingElement);
        } else {
            for(let i = elements.length - 1; i >= 0; i--){
                const element = elements[i];
                target.insertAfter(element);
                lastElement = element;
            }
        }
    }
    const prevSelection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getPreviousSelection"])();
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$setSelection"])(prevSelection.clone());
    } else if (lastElement !== null) {
        lastElement.selectEnd();
    } else {
        selection.dirty = true;
    }
}
/**
 * Tests if the selection's parent element has vertical writing mode.
 * @param selection - The selection whose parent to test.
 * @returns true if the selection's parent has vertical writing mode (writing-mode: vertical-rl), false otherwise.
 */ function $isEditorVerticalOrientation(selection) {
    const computedStyle = $getComputedStyle(selection);
    return computedStyle !== null && computedStyle.writingMode === 'vertical-rl';
}
/**
 * Gets the computed DOM styles of the parent of the selection's anchor node.
 * @param selection - The selection to check the styles for.
 * @returns the computed styles of the node or null if there is no DOM element or no default view for the document.
 */ function $getComputedStyle(selection) {
    const anchorNode = selection.anchor.getNode();
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(anchorNode)) {
        return $getComputedStyleForElement(anchorNode);
    }
    return $getComputedStyleForParent(anchorNode);
}
/**
 * Determines if the default character selection should be overridden. Used with DecoratorNodes
 * @param selection - The selection whose default character selection may need to be overridden.
 * @param isBackward - Is the selection backwards (the focus comes before the anchor)?
 * @returns true if it should be overridden, false if not.
 */ function $shouldOverrideDefaultCharacterSelection(selection, isBackward) {
    const isVertical = $isEditorVerticalOrientation(selection);
    // In vertical writing mode, we adjust the direction for correct caret movement
    let adjustedIsBackward = isVertical ? !isBackward : isBackward;
    // In right-to-left writing mode, we invert the direction for correct caret movement
    if ($isParentElementRTL(selection)) {
        adjustedIsBackward = !adjustedIsBackward;
    }
    const focusCaret = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$caretFromPoint"])(selection.focus, adjustedIsBackward ? 'previous' : 'next');
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isExtendableTextPointCaret"])(focusCaret)) {
        return false;
    }
    for (const nextCaret of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$extendCaretToRange"])(focusCaret)){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isChildCaret"])(nextCaret)) {
            return !nextCaret.origin.isInline();
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(nextCaret.origin)) {
            continue;
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isDecoratorNode"])(nextCaret.origin)) {
            return true;
        }
        break;
    }
    return false;
}
/**
 * Moves the selection according to the arguments.
 * @param selection - The selected text or nodes.
 * @param isHoldingShift - Is the shift key being held down during the operation.
 * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?
 * @param granularity - The distance to adjust the current selection.
 */ function $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {
    selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);
}
/**
 * Tests a parent element for right to left direction.
 * @param selection - The selection whose parent is to be tested.
 * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.
 */ function $isParentElementRTL(selection) {
    const computedStyle = $getComputedStyle(selection);
    return computedStyle !== null && computedStyle.direction === 'rtl';
}
/**
 * Moves selection by character according to arguments.
 * @param selection - The selection of the characters to move.
 * @param isHoldingShift - Is the shift key being held down during the operation.
 * @param isBackward - Is the selection backward (the focus comes before the anchor)?
 */ function $moveCharacter(selection, isHoldingShift, isBackward) {
    const isRTL = $isParentElementRTL(selection);
    const isVertical = $isEditorVerticalOrientation(selection);
    // In vertical-rl writing mode, arrow key directions need to be flipped
    // to match the visual flow of text (top to bottom, right to left)
    let adjustedIsBackward;
    if (isVertical) {
        // In vertical-rl mode, we need to completely invert the direction
        // Left arrow (backward) should move down (forward)
        // Right arrow (forward) should move up (backward)
        adjustedIsBackward = !isBackward;
    } else if (isRTL) {
        // In horizontal RTL mode, use the standard RTL behavior
        adjustedIsBackward = !isBackward;
    } else {
        // Standard LTR horizontal text
        adjustedIsBackward = isBackward;
    }
    // Apply the direction adjustment to move the caret
    $moveCaretSelection(selection, isHoldingShift, adjustedIsBackward, 'character');
}
/**
 * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.
 * @param node - The node whose style value to get.
 * @param styleProperty - The CSS style property.
 * @param defaultValue - The default value for the property.
 * @returns The value of the property for node.
 */ function $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {
    const css = node.getStyle();
    const styleObject = getStyleObjectFromCSS(css);
    if (styleObject !== null) {
        return styleObject[styleProperty] || defaultValue;
    }
    return defaultValue;
}
/**
 * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.
 * If all TextNodes do not have the same value, it returns an empty string.
 * @param selection - The selection of TextNodes whose value to find.
 * @param styleProperty - The CSS style property.
 * @param defaultValue - The default value for the property, defaults to an empty string.
 * @returns The value of the property for the selected TextNodes.
 */ function $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {
    let styleValue = null;
    const nodes = selection.getNodes();
    const anchor = selection.anchor;
    const focus = selection.focus;
    const isBackward = selection.isBackward();
    const endOffset = isBackward ? focus.offset : anchor.offset;
    const endNode = isBackward ? focus.getNode() : anchor.getNode();
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection) && selection.isCollapsed() && selection.style !== '') {
        const css = selection.style;
        const styleObject = getStyleObjectFromCSS(css);
        if (styleObject !== null && styleProperty in styleObject) {
            return styleObject[styleProperty];
        }
    }
    for(let i = 0; i < nodes.length; i++){
        const node = nodes[i];
        // if no actual characters in the end node are selected, we don't
        // include it in the selection for purposes of determining style
        // value
        if (i !== 0 && endOffset === 0 && node.is(endNode)) {
            continue;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTextNode"])(node)) {
            const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);
            if (styleValue === null) {
                styleValue = nodeStyleValue;
            } else if (styleValue !== nodeStyleValue) {
                // multiple text nodes are in the selection and they don't all
                // have the same style.
                styleValue = '';
                break;
            }
        }
    }
    return styleValue === null ? defaultValue : styleValue;
}
function $getAncestor(node, predicate) {
    let parent = node;
    while(parent !== null && parent.getParent() !== null && !predicate(parent)){
        parent = parent.getParentOrThrow();
    }
    return predicate(parent) ? parent : null;
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ /** @deprecated renamed to {@link $trimTextContentFromAnchor} by @lexical/eslint-plugin rules-of-lexical */ const trimTextContentFromAnchor = $trimTextContentFromAnchor;
;
}),
"[project]/node_modules/.pnpm/@lexical+html@0.35.0/node_modules/@lexical/html/LexicalHtml.dev.mjs [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "$generateHtmlFromNodes",
    ()=>$generateHtmlFromNodes,
    "$generateNodesFromDOM",
    ()=>$generateNodesFromDOM
]);
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$selection$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$selection$2f$LexicalSelection$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@lexical+selection@0.35.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/lexical@0.35.0/node_modules/lexical/Lexical.dev.mjs [app-rsc] (ecmascript)");
;
;
;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ /**
 * How you parse your html string to get a document is left up to you. In the browser you can use the native
 * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom
 * or an equivalent library and pass in the document here.
 */ function $generateNodesFromDOM(editor, dom) {
    const elements = dom.body ? dom.body.childNodes : [];
    let lexicalNodes = [];
    const allArtificialNodes = [];
    for(let i = 0; i < elements.length; i++){
        const element = elements[i];
        if (!IGNORE_TAGS.has(element.nodeName)) {
            const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);
            if (lexicalNode !== null) {
                lexicalNodes = lexicalNodes.concat(lexicalNode);
            }
        }
    }
    $unwrapArtificialNodes(allArtificialNodes);
    return lexicalNodes;
}
function $generateHtmlFromNodes(editor, selection) {
    if (typeof document === 'undefined' || ("TURBOPACK compile-time value", "undefined") === 'undefined' && typeof /*TURBOPACK member replacement*/ __turbopack_context__.g.window === 'undefined') {
        throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');
    }
    const container = document.createElement('div');
    const root = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getRoot"])();
    const topLevelChildren = root.getChildren();
    for(let i = 0; i < topLevelChildren.length; i++){
        const topLevelNode = topLevelChildren[i];
        $appendNodesToHTML(editor, topLevelNode, container, selection);
    }
    return container.innerHTML;
}
function $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {
    let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;
    const shouldExclude = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(currentNode) && currentNode.excludeFromCopy('html');
    let target = currentNode;
    if (selection !== null) {
        let clone = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$cloneWithProperties"])(currentNode);
        clone = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTextNode"])(clone) && selection !== null ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$selection$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$selection$2f$LexicalSelection$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["$sliceSelectedTextNodeContent"])(selection, clone) : clone;
        target = clone;
    }
    const children = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(target) ? target.getChildren() : [];
    const registeredNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRegisteredNode"])(editor, target.getType());
    let exportOutput;
    // Use HTMLConfig overrides, if available.
    if (registeredNode && registeredNode.exportDOM !== undefined) {
        exportOutput = registeredNode.exportDOM(editor, target);
    } else {
        exportOutput = target.exportDOM(editor);
    }
    const { element, after } = exportOutput;
    if (!element) {
        return false;
    }
    const fragment = document.createDocumentFragment();
    for(let i = 0; i < children.length; i++){
        const childNode = children[i];
        const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);
        if (!shouldInclude && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {
            shouldInclude = true;
        }
    }
    if (shouldInclude && !shouldExclude) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(element) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isDocumentFragment"])(element)) {
            element.append(fragment);
        }
        parentElement.append(element);
        if (after) {
            const newElement = after.call(target, element);
            if (newElement) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isDocumentFragment"])(element)) {
                    element.replaceChildren(newElement);
                } else {
                    element.replaceWith(newElement);
                }
            }
        }
    } else {
        parentElement.append(fragment);
    }
    return shouldInclude;
}
function getConversionFunction(domNode, editor) {
    const { nodeName } = domNode;
    const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());
    let currentConversion = null;
    if (cachedConversions !== undefined) {
        for (const cachedConversion of cachedConversions){
            const domConversion = cachedConversion(domNode);
            if (domConversion !== null && (currentConversion === null || // Given equal priority, prefer the last registered importer
            // which is typically an application custom node or HTMLConfig['import']
            (currentConversion.priority || 0) <= (domConversion.priority || 0))) {
                currentConversion = domConversion;
            }
        }
    }
    return currentConversion !== null ? currentConversion.conversion : null;
}
const IGNORE_TAGS = new Set([
    'STYLE',
    'SCRIPT'
]);
function $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = new Map(), parentLexicalNode) {
    let lexicalNodes = [];
    if (IGNORE_TAGS.has(node.nodeName)) {
        return lexicalNodes;
    }
    let currentLexicalNode = null;
    const transformFunction = getConversionFunction(node, editor);
    const transformOutput = transformFunction ? transformFunction(node) : null;
    let postTransform = null;
    if (transformOutput !== null) {
        postTransform = transformOutput.after;
        const transformNodes = transformOutput.node;
        currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;
        if (currentLexicalNode !== null) {
            for (const [, forChildFunction] of forChildMap){
                currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);
                if (!currentLexicalNode) {
                    break;
                }
            }
            if (currentLexicalNode) {
                lexicalNodes.push(...Array.isArray(transformNodes) ? transformNodes : [
                    currentLexicalNode
                ]);
            }
        }
        if (transformOutput.forChild != null) {
            forChildMap.set(node.nodeName, transformOutput.forChild);
        }
    }
    // If the DOM node doesn't have a transformer, we don't know what
    // to do with it but we still need to process any childNodes.
    const children = node.childNodes;
    let childLexicalNodes = [];
    const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRootOrShadowRoot"])(currentLexicalNode) ? false : currentLexicalNode != null && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isBlockElementNode"])(currentLexicalNode) || hasBlockAncestorLexicalNode;
    for(let i = 0; i < children.length; i++){
        childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));
    }
    if (postTransform != null) {
        childLexicalNodes = postTransform(childLexicalNodes);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isBlockDomNode"])(node)) {
        if (!hasBlockAncestorLexicalNodeForChildren) {
            childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createParagraphNode"]);
        } else {
            childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, ()=>{
                const artificialNode = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ArtificialNode__DO_NOT_USE"]();
                allArtificialNodes.push(artificialNode);
                return artificialNode;
            });
        }
    }
    if (currentLexicalNode == null) {
        if (childLexicalNodes.length > 0) {
            // If it hasn't been converted to a LexicalNode, we hoist its children
            // up to the same level as it.
            lexicalNodes = lexicalNodes.concat(childLexicalNodes);
        } else {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isBlockDomNode"])(node) && isDomNodeBetweenTwoInlineNodes(node)) {
                // Empty block dom node that hasnt been converted, we replace it with a linebreak if its between inline nodes
                lexicalNodes = lexicalNodes.concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createLineBreakNode"])());
            }
        }
    } else {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(currentLexicalNode)) {
            // If the current node is a ElementNode after conversion,
            // we can append all the children to it.
            currentLexicalNode.append(...childLexicalNodes);
        }
    }
    return lexicalNodes;
}
function wrapContinuousInlines(domNode, nodes, createWrapperFn) {
    const textAlign = domNode.style.textAlign;
    const out = [];
    let continuousInlines = [];
    // wrap contiguous inline child nodes in para
    for(let i = 0; i < nodes.length; i++){
        const node = nodes[i];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isBlockElementNode"])(node)) {
            if (textAlign && !node.getFormat()) {
                node.setFormat(textAlign);
            }
            out.push(node);
        } else {
            continuousInlines.push(node);
            if (i === nodes.length - 1 || i < nodes.length - 1 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isBlockElementNode"])(nodes[i + 1])) {
                const wrapper = createWrapperFn();
                wrapper.setFormat(textAlign);
                wrapper.append(...continuousInlines);
                out.push(wrapper);
                continuousInlines = [];
            }
        }
    }
    return out;
}
function $unwrapArtificialNodes(allArtificialNodes) {
    for (const node of allArtificialNodes){
        if (node.getNextSibling() instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ArtificialNode__DO_NOT_USE"]) {
            node.insertAfter((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createLineBreakNode"])());
        }
    }
    // Replace artificial node with it's children
    for (const node of allArtificialNodes){
        const children = node.getChildren();
        for (const child of children){
            node.insertBefore(child);
        }
        node.remove();
    }
}
function isDomNodeBetweenTwoInlineNodes(node) {
    if (node.nextSibling == null || node.previousSibling == null) {
        return false;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isInlineDomNode"])(node.nextSibling) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isInlineDomNode"])(node.previousSibling);
}
;
}),
"[project]/node_modules/.pnpm/@lexical+utils@0.35.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "$descendantsMatching",
    ()=>$descendantsMatching,
    "$dfs",
    ()=>$dfs,
    "$dfsIterator",
    ()=>$dfsIterator,
    "$filter",
    ()=>$filter,
    "$findMatchingParent",
    ()=>$findMatchingParent,
    "$firstToLastIterator",
    ()=>$firstToLastIterator,
    "$getAdjacentCaret",
    ()=>$getAdjacentCaret,
    "$getAdjacentSiblingOrParentSiblingCaret",
    ()=>$getAdjacentSiblingOrParentSiblingCaret,
    "$getDepth",
    ()=>$getDepth,
    "$getNearestBlockElementAncestorOrThrow",
    ()=>$getNearestBlockElementAncestorOrThrow,
    "$getNearestNodeOfType",
    ()=>$getNearestNodeOfType,
    "$getNextRightPreorderNode",
    ()=>$getNextRightPreorderNode,
    "$getNextSiblingOrParentSibling",
    ()=>$getNextSiblingOrParentSibling,
    "$insertFirst",
    ()=>$insertFirst,
    "$insertNodeToNearestRoot",
    ()=>$insertNodeToNearestRoot,
    "$insertNodeToNearestRootAtCaret",
    ()=>$insertNodeToNearestRootAtCaret,
    "$isEditorIsNestedEditor",
    ()=>$isEditorIsNestedEditor,
    "$lastToFirstIterator",
    ()=>$lastToFirstIterator,
    "$restoreEditorState",
    ()=>$restoreEditorState,
    "$reverseDfs",
    ()=>$reverseDfs,
    "$reverseDfsIterator",
    ()=>$reverseDfsIterator,
    "$unwrapAndFilterDescendants",
    ()=>$unwrapAndFilterDescendants,
    "$unwrapNode",
    ()=>$unwrapNode,
    "$wrapNodeInElement",
    ()=>$wrapNodeInElement,
    "CAN_USE_BEFORE_INPUT",
    ()=>CAN_USE_BEFORE_INPUT,
    "CAN_USE_DOM",
    ()=>CAN_USE_DOM,
    "IS_ANDROID",
    ()=>IS_ANDROID,
    "IS_ANDROID_CHROME",
    ()=>IS_ANDROID_CHROME,
    "IS_APPLE",
    ()=>IS_APPLE,
    "IS_APPLE_WEBKIT",
    ()=>IS_APPLE_WEBKIT,
    "IS_CHROME",
    ()=>IS_CHROME,
    "IS_FIREFOX",
    ()=>IS_FIREFOX,
    "IS_IOS",
    ()=>IS_IOS,
    "IS_SAFARI",
    ()=>IS_SAFARI,
    "addClassNamesToElement",
    ()=>addClassNamesToElement,
    "calculateZoomLevel",
    ()=>calculateZoomLevel,
    "isMimeType",
    ()=>isMimeType,
    "makeStateWrapper",
    ()=>makeStateWrapper,
    "markSelection",
    ()=>markSelection,
    "mediaFileReader",
    ()=>mediaFileReader,
    "mergeRegister",
    ()=>mergeRegister,
    "objectKlassEquals",
    ()=>objectKlassEquals,
    "positionNodeOnRange",
    ()=>mlcPositionNodeOnRange,
    "registerNestedElementResolver",
    ()=>registerNestedElementResolver,
    "removeClassNamesFromElement",
    ()=>removeClassNamesFromElement,
    "selectionAlwaysOnDisplay",
    ()=>selectionAlwaysOnDisplay
]);
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/lexical@0.35.0/node_modules/lexical/Lexical.dev.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$selection$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$selection$2f$LexicalSelection$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@lexical+selection@0.35.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs [app-rsc] (ecmascript) <locals>");
;
;
;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ // Do not require this module directly! Use normal `invariant` calls.
function formatDevErrorMessage(message) {
    throw new Error(message);
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ const CAN_USE_DOM$1 = ("TURBOPACK compile-time value", "undefined") !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ const documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? "TURBOPACK unreachable" : null;
const IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
const IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
const CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? "TURBOPACK unreachable" : false;
const IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
const IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
const IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);
// Keep these in case we need to use them in the future.
// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);
const IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;
const IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;
const IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ function normalizeClassNames(...classNames) {
    const rval = [];
    for (const className of classNames){
        if (className && typeof className === 'string') {
            for (const [s] of className.matchAll(/\S+/g)){
                rval.push(s);
            }
        }
    }
    return rval;
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ /**
 * Returns a function that will execute all functions passed when called. It is generally used
 * to register multiple lexical listeners and then tear them down with a single function call, such
 * as React's useEffect hook.
 * @example
 * ```ts
 * useEffect(() => {
 *   return mergeRegister(
 *     editor.registerCommand(...registerCommand1 logic),
 *     editor.registerCommand(...registerCommand2 logic),
 *     editor.registerCommand(...registerCommand3 logic)
 *   )
 * }, [editor])
 * ```
 * In this case, useEffect is returning the function returned by mergeRegister as a cleanup
 * function to be executed after either the useEffect runs again (due to one of its dependencies
 * updating) or the component it resides in unmounts.
 * Note the functions don't necessarily need to be in an array as all arguments
 * are considered to be the func argument and spread from there.
 * The order of cleanup is the reverse of the argument order. Generally it is
 * expected that the first "acquire" will be "released" last (LIFO order),
 * because a later step may have some dependency on an earlier one.
 * @param func - An array of cleanup functions meant to be executed by the returned function.
 * @returns the function which executes all the passed cleanup functions.
 */ function mergeRegister(...func) {
    return ()=>{
        for(let i = func.length - 1; i >= 0; i--){
            func[i]();
        }
        // Clean up the references and make future calls a no-op
        func.length = 0;
    };
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ function px(value) {
    return `${value}px`;
}
const mutationObserverConfig = {
    attributes: true,
    characterData: true,
    childList: true,
    subtree: true
};
function prependDOMNode(parent, node) {
    parent.insertBefore(node, parent.firstChild);
}
/**
 * Place one or multiple newly created Nodes at the passed Range's position.
 * Multiple nodes will only be created when the Range spans multiple lines (aka
 * client rects).
 *
 * This function can come particularly useful to highlight particular parts of
 * the text without interfering with the EditorState, that will often replicate
 * the state across collab and clipboard.
 *
 * This function accounts for DOM updates which can modify the passed Range.
 * Hence, the function return to remove the listener.
 */ function mlcPositionNodeOnRange(editor, range, onReposition) {
    let rootDOMNode = null;
    let parentDOMNode = null;
    let observer = null;
    let lastNodes = [];
    const wrapperNode = document.createElement('div');
    wrapperNode.style.position = 'relative';
    function position() {
        if (!(rootDOMNode !== null)) {
            formatDevErrorMessage(`Unexpected null rootDOMNode`);
        }
        if (!(parentDOMNode !== null)) {
            formatDevErrorMessage(`Unexpected null parentDOMNode`);
        }
        const { left: parentLeft, top: parentTop } = parentDOMNode.getBoundingClientRect();
        const rects = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$selection$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$selection$2f$LexicalSelection$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createRectsFromDOMRange"])(editor, range);
        if (!wrapperNode.isConnected) {
            prependDOMNode(parentDOMNode, wrapperNode);
        }
        let hasRepositioned = false;
        for(let i = 0; i < rects.length; i++){
            const rect = rects[i];
            // Try to reuse the previously created Node when possible, no need to
            // remove/create on the most common case reposition case
            const rectNode = lastNodes[i] || document.createElement('div');
            const rectNodeStyle = rectNode.style;
            if (rectNodeStyle.position !== 'absolute') {
                rectNodeStyle.position = 'absolute';
                hasRepositioned = true;
            }
            const left = px(rect.left - parentLeft);
            if (rectNodeStyle.left !== left) {
                rectNodeStyle.left = left;
                hasRepositioned = true;
            }
            const top = px(rect.top - parentTop);
            if (rectNodeStyle.top !== top) {
                rectNode.style.top = top;
                hasRepositioned = true;
            }
            const width = px(rect.width);
            if (rectNodeStyle.width !== width) {
                rectNode.style.width = width;
                hasRepositioned = true;
            }
            const height = px(rect.height);
            if (rectNodeStyle.height !== height) {
                rectNode.style.height = height;
                hasRepositioned = true;
            }
            if (rectNode.parentNode !== wrapperNode) {
                wrapperNode.append(rectNode);
                hasRepositioned = true;
            }
            lastNodes[i] = rectNode;
        }
        while(lastNodes.length > rects.length){
            lastNodes.pop();
        }
        if (hasRepositioned) {
            onReposition(lastNodes);
        }
    }
    function stop() {
        parentDOMNode = null;
        rootDOMNode = null;
        if (observer !== null) {
            observer.disconnect();
        }
        observer = null;
        wrapperNode.remove();
        for (const node of lastNodes){
            node.remove();
        }
        lastNodes = [];
    }
    function restart() {
        const currentRootDOMNode = editor.getRootElement();
        if (currentRootDOMNode === null) {
            return stop();
        }
        const currentParentDOMNode = currentRootDOMNode.parentElement;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(currentParentDOMNode)) {
            return stop();
        }
        stop();
        rootDOMNode = currentRootDOMNode;
        parentDOMNode = currentParentDOMNode;
        observer = new MutationObserver((mutations)=>{
            const nextRootDOMNode = editor.getRootElement();
            const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;
            if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {
                return restart();
            }
            for (const mutation of mutations){
                if (!wrapperNode.contains(mutation.target)) {
                    // TODO throttle
                    return position();
                }
            }
        });
        observer.observe(currentParentDOMNode, mutationObserverConfig);
        position();
    }
    const removeRootListener = editor.registerRootListener(restart);
    return ()=>{
        removeRootListener();
        stop();
    };
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ function $getOrderedSelectionPoints(selection) {
    const points = selection.getStartEndPoints();
    return selection.isBackward() ? [
        points[1],
        points[0]
    ] : points;
}
function rangeTargetFromPoint(point, node, dom) {
    if (point.type === 'text' || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(node)) {
        const textDOM = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDOMTextNode"])(dom) || dom;
        return [
            textDOM,
            point.offset
        ];
    } else {
        const slot = node.getDOMSlot(dom);
        return [
            slot.element,
            slot.getFirstChildOffset() + point.offset
        ];
    }
}
function rangeFromPoints(editor, start, startNode, startDOM, end, endNode, endDOM) {
    const editorDocument = editor._window ? editor._window.document : document;
    const range = editorDocument.createRange();
    range.setStart(...rangeTargetFromPoint(start, startNode, startDOM));
    range.setEnd(...rangeTargetFromPoint(end, endNode, endDOM));
    return range;
}
/**
 * Place one or multiple newly created Nodes at the current selection. Multiple
 * nodes will only be created when the selection spans multiple lines (aka
 * client rects).
 *
 * This function can come useful when you want to show the selection but the
 * editor has been focused away.
 */ function markSelection(editor, onReposition) {
    let previousAnchorNode = null;
    let previousAnchorNodeDOM = null;
    let previousAnchorOffset = null;
    let previousFocusNode = null;
    let previousFocusNodeDOM = null;
    let previousFocusOffset = null;
    let removeRangeListener = ()=>{};
    function compute(editorState) {
        editorState.read(()=>{
            const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
                // TODO
                previousAnchorNode = null;
                previousAnchorOffset = null;
                previousFocusNode = null;
                previousFocusOffset = null;
                removeRangeListener();
                removeRangeListener = ()=>{};
                return;
            }
            const [start, end] = $getOrderedSelectionPoints(selection);
            const currentStartNode = start.getNode();
            const currentStartNodeKey = currentStartNode.getKey();
            const currentStartOffset = start.offset;
            const currentEndNode = end.getNode();
            const currentEndNodeKey = currentEndNode.getKey();
            const currentEndOffset = end.offset;
            const currentStartNodeDOM = editor.getElementByKey(currentStartNodeKey);
            const currentEndNodeDOM = editor.getElementByKey(currentEndNodeKey);
            const differentStartDOM = previousAnchorNode === null || currentStartNodeDOM !== previousAnchorNodeDOM || currentStartOffset !== previousAnchorOffset || currentStartNodeKey !== previousAnchorNode.getKey();
            const differentEndDOM = previousFocusNode === null || currentEndNodeDOM !== previousFocusNodeDOM || currentEndOffset !== previousFocusOffset || currentEndNodeKey !== previousFocusNode.getKey();
            if ((differentStartDOM || differentEndDOM) && currentStartNodeDOM !== null && currentEndNodeDOM !== null) {
                const range = rangeFromPoints(editor, start, currentStartNode, currentStartNodeDOM, end, currentEndNode, currentEndNodeDOM);
                removeRangeListener();
                removeRangeListener = mlcPositionNodeOnRange(editor, range, (domNodes)=>{
                    if (onReposition === undefined) {
                        for (const domNode of domNodes){
                            const domNodeStyle = domNode.style;
                            if (domNodeStyle.background !== 'Highlight') {
                                domNodeStyle.background = 'Highlight';
                            }
                            if (domNodeStyle.color !== 'HighlightText') {
                                domNodeStyle.color = 'HighlightText';
                            }
                            if (domNodeStyle.marginTop !== px(-1.5)) {
                                domNodeStyle.marginTop = px(-1.5);
                            }
                            if (domNodeStyle.paddingTop !== px(4)) {
                                domNodeStyle.paddingTop = px(4);
                            }
                            if (domNodeStyle.paddingBottom !== px(0)) {
                                domNodeStyle.paddingBottom = px(0);
                            }
                        }
                    } else {
                        onReposition(domNodes);
                    }
                });
            }
            previousAnchorNode = currentStartNode;
            previousAnchorNodeDOM = currentStartNodeDOM;
            previousAnchorOffset = currentStartOffset;
            previousFocusNode = currentEndNode;
            previousFocusNodeDOM = currentEndNodeDOM;
            previousFocusOffset = currentEndOffset;
        });
    }
    compute(editor.getEditorState());
    return mergeRegister(editor.registerUpdateListener(({ editorState })=>compute(editorState)), ()=>{
        removeRangeListener();
    });
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ function selectionAlwaysOnDisplay(editor) {
    let removeSelectionMark = null;
    const onSelectionChange = ()=>{
        const domSelection = getSelection();
        const domAnchorNode = domSelection && domSelection.anchorNode;
        const editorRootElement = editor.getRootElement();
        const isSelectionInsideEditor = domAnchorNode !== null && editorRootElement !== null && editorRootElement.contains(domAnchorNode);
        if (isSelectionInsideEditor) {
            if (removeSelectionMark !== null) {
                removeSelectionMark();
                removeSelectionMark = null;
            }
        } else {
            if (removeSelectionMark === null) {
                removeSelectionMark = markSelection(editor);
            }
        }
    };
    document.addEventListener('selectionchange', onSelectionChange);
    return ()=>{
        if (removeSelectionMark !== null) {
            removeSelectionMark();
        }
        document.removeEventListener('selectionchange', onSelectionChange);
    };
}
// Hotfix to export these with inlined types #5918
const CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;
const CAN_USE_DOM = CAN_USE_DOM$1;
const IS_ANDROID = IS_ANDROID$1;
const IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;
const IS_APPLE = IS_APPLE$1;
const IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;
const IS_CHROME = IS_CHROME$1;
const IS_FIREFOX = IS_FIREFOX$1;
const IS_IOS = IS_IOS$1;
const IS_SAFARI = IS_SAFARI$1;
/**
 * Takes an HTML element and adds the classNames passed within an array,
 * ignoring any non-string types. A space can be used to add multiple classes
 * eg. addClassNamesToElement(element, ['element-inner active', true, null])
 * will add both 'element-inner' and 'active' as classes to that element.
 * @param element - The element in which the classes are added
 * @param classNames - An array defining the class names to add to the element
 */ function addClassNamesToElement(element, ...classNames) {
    const classesToAdd = normalizeClassNames(...classNames);
    if (classesToAdd.length > 0) {
        element.classList.add(...classesToAdd);
    }
}
/**
 * Takes an HTML element and removes the classNames passed within an array,
 * ignoring any non-string types. A space can be used to remove multiple classes
 * eg. removeClassNamesFromElement(element, ['active small', true, null])
 * will remove both the 'active' and 'small' classes from that element.
 * @param element - The element in which the classes are removed
 * @param classNames - An array defining the class names to remove from the element
 */ function removeClassNamesFromElement(element, ...classNames) {
    const classesToRemove = normalizeClassNames(...classNames);
    if (classesToRemove.length > 0) {
        element.classList.remove(...classesToRemove);
    }
}
/**
 * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.
 * The types passed must be strings and are CASE-SENSITIVE.
 * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.
 * @param file - The file you want to type check.
 * @param acceptableMimeTypes - An array of strings of types which the file is checked against.
 * @returns true if the file is an acceptable mime type, false otherwise.
 */ function isMimeType(file, acceptableMimeTypes) {
    for (const acceptableType of acceptableMimeTypes){
        if (file.type.startsWith(acceptableType)) {
            return true;
        }
    }
    return false;
}
/**
 * Lexical File Reader with:
 *  1. MIME type support
 *  2. batched results (HistoryPlugin compatibility)
 *  3. Order aware (respects the order when multiple Files are passed)
 *
 * const filesResult = await mediaFileReader(files, ['image/']);
 * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\{
 *   src: file.result,
 * \\}));
 */ function mediaFileReader(files, acceptableMimeTypes) {
    const filesIterator = files[Symbol.iterator]();
    return new Promise((resolve, reject)=>{
        const processed = [];
        const handleNextFile = ()=>{
            const { done, value: file } = filesIterator.next();
            if (done) {
                return resolve(processed);
            }
            const fileReader = new FileReader();
            fileReader.addEventListener('error', reject);
            fileReader.addEventListener('load', ()=>{
                const result = fileReader.result;
                if (typeof result === 'string') {
                    processed.push({
                        file,
                        result
                    });
                }
                handleNextFile();
            });
            if (isMimeType(file, acceptableMimeTypes)) {
                fileReader.readAsDataURL(file);
            } else {
                handleNextFile();
            }
        };
        handleNextFile();
    });
}
/**
 * "Depth-First Search" starts at the root/top node of a tree and goes as far as it can down a branch end
 * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a
 * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.
 * It will then return all the nodes found in the search in an array of objects.
 * @param startNode - The node to start the search, if omitted, it will start at the root node.
 * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.
 * @returns An array of objects of all the nodes found by the search, including their depth into the tree.
 * \\{depth: number, node: LexicalNode\\} It will always return at least 1 node (the start node).
 */ function $dfs(startNode, endNode) {
    return Array.from($dfsIterator(startNode, endNode));
}
/**
 * Get the adjacent caret in the same direction
 *
 * @param caret A caret or null
 * @returns `caret.getAdjacentCaret()` or `null`
 */ function $getAdjacentCaret(caret) {
    return caret ? caret.getAdjacentCaret() : null;
}
/**
 * $dfs iterator (right to left). Tree traversal is done on the fly as new values are requested with O(1) memory.
 * @param startNode - The node to start the search, if omitted, it will start at the root node.
 * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.
 * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).
 */ function $reverseDfs(startNode, endNode) {
    return Array.from($reverseDfsIterator(startNode, endNode));
}
/**
 * $dfs iterator (left to right). Tree traversal is done on the fly as new values are requested with O(1) memory.
 * @param startNode - The node to start the search, if omitted, it will start at the root node.
 * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.
 * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).
 */ function $dfsIterator(startNode, endNode) {
    return $dfsCaretIterator('next', startNode, endNode);
}
function $getEndCaret(startNode, direction) {
    const rval = $getAdjacentSiblingOrParentSiblingCaret((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSiblingCaret"])(startNode, direction));
    return rval && rval[0];
}
function $dfsCaretIterator(direction, startNode, endNode) {
    const root = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getRoot"])();
    const start = startNode || root;
    const startCaret = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(start) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getChildCaret"])(start, direction) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSiblingCaret"])(start, direction);
    const startDepth = $getDepth(start);
    const endCaret = endNode ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getAdjacentChildCaret"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getChildCaretOrSelf"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSiblingCaret"])(endNode, direction))) : $getEndCaret(start, direction);
    let depth = startDepth;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["makeStepwiseIterator"])({
        hasNext: (state)=>state !== null,
        initial: startCaret,
        map: (state)=>({
                depth,
                node: state.origin
            }),
        step: (state)=>{
            if (state.isSameNodeCaret(endCaret)) {
                return null;
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isChildCaret"])(state)) {
                depth++;
            }
            const rval = $getAdjacentSiblingOrParentSiblingCaret(state);
            if (!rval || rval[0].isSameNodeCaret(endCaret)) {
                return null;
            }
            depth += rval[1];
            return rval[0];
        }
    });
}
/**
 * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example
 * R -> P -> T1, T2
 *   -> P2
 * returns T2 for node T1, P2 for node T2, and null for node P2.
 * @param node LexicalNode.
 * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.
 */ function $getNextSiblingOrParentSibling(node) {
    const rval = $getAdjacentSiblingOrParentSiblingCaret((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSiblingCaret"])(node, 'next'));
    return rval && [
        rval[0].origin,
        rval[1]
    ];
}
function $getDepth(node) {
    let depth = -1;
    for(let innerNode = node; innerNode !== null; innerNode = innerNode.getParent()){
        depth++;
    }
    return depth;
}
/**
 * Performs a right-to-left preorder tree traversal.
 * From the starting node it goes to the rightmost child, than backtracks to parent and finds new rightmost path.
 * It will return the next node in traversal sequence after the startingNode.
 * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.
 * @param startingNode - The node to start the search.
 * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist
 */ function $getNextRightPreorderNode(startingNode) {
    const startCaret = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getChildCaretOrSelf"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSiblingCaret"])(startingNode, 'previous'));
    const next = $getAdjacentSiblingOrParentSiblingCaret(startCaret, 'root');
    return next && next[0].origin;
}
/**
 * $dfs iterator (right to left). Tree traversal is done on the fly as new values are requested with O(1) memory.
 * @param startNode - The node to start the search, if omitted, it will start at the root node.
 * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.
 * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).
 */ function $reverseDfsIterator(startNode, endNode) {
    return $dfsCaretIterator('previous', startNode, endNode);
}
/**
 * Takes a node and traverses up its ancestors (toward the root node)
 * in order to find a specific type of node.
 * @param node - the node to begin searching.
 * @param klass - an instance of the type of node to look for.
 * @returns the node of type klass that was passed, or null if none exist.
 */ function $getNearestNodeOfType(node, klass) {
    let parent = node;
    while(parent != null){
        if (parent instanceof klass) {
            return parent;
        }
        parent = parent.getParent();
    }
    return null;
}
/**
 * Returns the element node of the nearest ancestor, otherwise throws an error.
 * @param startNode - The starting node of the search
 * @returns The ancestor node found
 */ function $getNearestBlockElementAncestorOrThrow(startNode) {
    const blockNode = $findMatchingParent(startNode, (node)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(node) && !node.isInline());
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(blockNode)) {
        {
            formatDevErrorMessage(`Expected node ${startNode.__key} to have closest block element node.`);
        }
    }
    return blockNode;
}
/**
 * Starts with a node and moves up the tree (toward the root node) to find a matching node based on
 * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be
 * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false
 * @param startingNode - The node where the search starts.
 * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.
 * @returns A parent node that matches the findFn parameters, or null if one wasn't found.
 */ const $findMatchingParent = (startingNode, findFn)=>{
    let curr = startingNode;
    while(curr !== (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getRoot"])() && curr != null){
        if (findFn(curr)) {
            return curr;
        }
        curr = curr.getParent();
    }
    return null;
};
/**
 * Attempts to resolve nested element nodes of the same type into a single node of that type.
 * It is generally used for marks/commenting
 * @param editor - The lexical editor
 * @param targetNode - The target for the nested element to be extracted from.
 * @param cloneNode - See {@link $createMarkNode}
 * @param handleOverlap - Handles any overlap between the node to extract and the targetNode
 * @returns The lexical editor
 */ function registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {
    const $isTargetNode = (node)=>{
        return node instanceof targetNode;
    };
    const $findMatch = (node)=>{
        // First validate we don't have any children that are of the target,
        // as we need to handle them first.
        const children = node.getChildren();
        for(let i = 0; i < children.length; i++){
            const child = children[i];
            if ($isTargetNode(child)) {
                return null;
            }
        }
        let parentNode = node;
        let childNode = node;
        while(parentNode !== null){
            childNode = parentNode;
            parentNode = parentNode.getParent();
            if ($isTargetNode(parentNode)) {
                return {
                    child: childNode,
                    parent: parentNode
                };
            }
        }
        return null;
    };
    const $elementNodeTransform = (node)=>{
        const match = $findMatch(node);
        if (match !== null) {
            const { child, parent } = match;
            // Simple path, we can move child out and siblings into a new parent.
            if (child.is(node)) {
                handleOverlap(parent, node);
                const nextSiblings = child.getNextSiblings();
                const nextSiblingsLength = nextSiblings.length;
                parent.insertAfter(child);
                if (nextSiblingsLength !== 0) {
                    const newParent = cloneNode(parent);
                    child.insertAfter(newParent);
                    for(let i = 0; i < nextSiblingsLength; i++){
                        newParent.append(nextSiblings[i]);
                    }
                }
                if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {
                    parent.remove();
                }
            }
        }
    };
    return editor.registerNodeTransform(targetNode, $elementNodeTransform);
}
/**
 * Clones the editor and marks it as dirty to be reconciled. If there was a selection,
 * it would be set back to its previous state, or null otherwise.
 * @param editor - The lexical editor
 * @param editorState - The editor's state
 */ function $restoreEditorState(editor, editorState) {
    const FULL_RECONCILE = 2;
    const nodeMap = new Map();
    const activeEditorState = editor._pendingEditorState;
    for (const [key, node] of editorState._nodeMap){
        nodeMap.set(key, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$cloneWithProperties"])(node));
    }
    if (activeEditorState) {
        activeEditorState._nodeMap = nodeMap;
    }
    editor._dirtyType = FULL_RECONCILE;
    const selection = editorState._selection;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$setSelection"])(selection === null ? null : selection.clone());
}
/**
 * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),
 * the node will be appended there, otherwise, it will be inserted before the insertion area.
 * If there is no selection where the node is to be inserted, it will be appended after any current nodes
 * within the tree, as a child of the root node. A paragraph will then be added after the inserted node and selected.
 * @param node - The node to be inserted
 * @returns The node after its insertion
 */ function $insertNodeToNearestRoot(node) {
    const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])() || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getPreviousSelection"])();
    let initialCaret;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
        initialCaret = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$caretFromPoint"])(selection.focus, 'next');
    } else {
        if (selection != null) {
            const nodes = selection.getNodes();
            const lastNode = nodes[nodes.length - 1];
            if (lastNode) {
                initialCaret = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSiblingCaret"])(lastNode, 'next');
            }
        }
        initialCaret = initialCaret || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getChildCaret"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getRoot"])(), 'previous').getFlipped().insert((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createParagraphNode"])());
    }
    const insertCaret = $insertNodeToNearestRootAtCaret(node, initialCaret);
    const adjacent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getAdjacentChildCaret"])(insertCaret);
    const selectionCaret = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isChildCaret"])(adjacent) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$normalizeCaret"])(adjacent) : insertCaret;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$setSelectionFromCaretRange"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getCollapsedCaretRange"])(selectionCaret));
    return node.getLatest();
}
/**
 * If the insertion caret is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),
 * the node will be inserted there, otherwise the parent nodes will be split according to the
 * given options.
 * @param node - The node to be inserted
 * @param caret - The location to insert or split from
 * @returns The node after its insertion
 */ function $insertNodeToNearestRootAtCaret(node, caret, options) {
    let insertCaret = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getCaretInDirection"])(caret, 'next');
    for(let nextCaret = insertCaret; nextCaret; nextCaret = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$splitAtPointCaretNext"])(nextCaret, options)){
        insertCaret = nextCaret;
    }
    if (!!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTextPointCaret"])(insertCaret)) {
        formatDevErrorMessage(`$insertNodeToNearestRootAtCaret: An unattached TextNode can not be split`);
    }
    insertCaret.insert(node.isInline() ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createParagraphNode"])().append(node) : node);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getCaretInDirection"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSiblingCaret"])(node.getLatest(), 'next'), caret.direction);
}
/**
 * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode
 * @param node - Node to be wrapped.
 * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.
 * @returns A new lexical element with the previous node appended within (as a child, including its children).
 */ function $wrapNodeInElement(node, createElementNode) {
    const elementNode = createElementNode();
    node.replace(elementNode);
    elementNode.append(node);
    return elementNode;
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
/**
 * @param object = The instance of the type
 * @param objectClass = The class of the type
 * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframes)
 */ function objectKlassEquals(object, objectClass) {
    return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;
}
/**
 * Filter the nodes
 * @param nodes Array of nodes that needs to be filtered
 * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null
 * @returns Array of filtered nodes
 */ function $filter(nodes, filterFn) {
    const result = [];
    for(let i = 0; i < nodes.length; i++){
        const node = filterFn(nodes[i]);
        if (node !== null) {
            result.push(node);
        }
    }
    return result;
}
/**
 * Appends the node before the first child of the parent node
 * @param parent A parent node
 * @param node Node that needs to be appended
 */ function $insertFirst(parent, node) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getChildCaret"])(parent, 'next').insert(node);
}
let NEEDS_MANUAL_ZOOM = ("TURBOPACK compile-time truthy", 1) ? false : "TURBOPACK unreachable";
function needsManualZoom() {
    if (NEEDS_MANUAL_ZOOM === undefined) {
        // If the browser implements standardized CSS zoom, then the client rect
        // will be wider after zoom is applied
        // https://chromestatus.com/feature/5198254868529152
        // https://github.com/facebook/lexical/issues/6863
        const div = document.createElement('div');
        div.style.cssText = 'position: absolute; opacity: 0; width: 100px; left: -1000px;';
        document.body.appendChild(div);
        const noZoom = div.getBoundingClientRect();
        div.style.setProperty('zoom', '2');
        NEEDS_MANUAL_ZOOM = div.getBoundingClientRect().width === noZoom.width;
        document.body.removeChild(div);
    }
    return NEEDS_MANUAL_ZOOM;
}
/**
 * Calculates the zoom level of an element as a result of using
 * css zoom property. For browsers that implement standardized CSS
 * zoom (Firefox, Chrome >= 128), this will always return 1.
 * @param element
 */ function calculateZoomLevel(element) {
    let zoom = 1;
    if (needsManualZoom()) {
        while(element){
            zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));
            element = element.parentElement;
        }
    }
    return zoom;
}
/**
 * Checks if the editor is a nested editor created by LexicalNestedComposer
 */ function $isEditorIsNestedEditor(editor) {
    return editor._parentEditor !== null;
}
/**
 * A depth first last-to-first traversal of root that stops at each node that matches
 * $predicate and ensures that its parent is root. This is typically used to discard
 * invalid or unsupported wrapping nodes. For example, a TableNode must only have
 * TableRowNode as children, but an importer might add invalid nodes based on
 * caption, tbody, thead, etc. and this will unwrap and discard those.
 *
 * @param root The root to start the traversal
 * @param $predicate Should return true for nodes that are permitted to be children of root
 * @returns true if this unwrapped or removed any nodes
 */ function $unwrapAndFilterDescendants(root, $predicate) {
    return $unwrapAndFilterDescendantsImpl(root, $predicate, null);
}
function $unwrapAndFilterDescendantsImpl(root, $predicate, $onSuccess) {
    let didMutate = false;
    for (const node of $lastToFirstIterator(root)){
        if ($predicate(node)) {
            if ($onSuccess !== null) {
                $onSuccess(node);
            }
            continue;
        }
        didMutate = true;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(node)) {
            $unwrapAndFilterDescendantsImpl(node, $predicate, $onSuccess || ((child)=>node.insertAfter(child)));
        }
        node.remove();
    }
    return didMutate;
}
/**
 * A depth first traversal of the children array that stops at and collects
 * each node that `$predicate` matches. This is typically used to discard
 * invalid or unsupported wrapping nodes on a children array in the `after`
 * of an {@link lexical!DOMConversionOutput}. For example, a TableNode must only have
 * TableRowNode as children, but an importer might add invalid nodes based on
 * caption, tbody, thead, etc. and this will unwrap and discard those.
 *
 * This function is read-only and performs no mutation operations, which makes
 * it suitable for import and export purposes but likely not for any in-place
 * mutation. You should use {@link $unwrapAndFilterDescendants} for in-place
 * mutations such as node transforms.
 *
 * @param children The children to traverse
 * @param $predicate Should return true for nodes that are permitted to be children of root
 * @returns The children or their descendants that match $predicate
 */ function $descendantsMatching(children, $predicate) {
    const result = [];
    const stack = Array.from(children).reverse();
    for(let child = stack.pop(); child !== undefined; child = stack.pop()){
        if ($predicate(child)) {
            result.push(child);
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(child)) {
            for (const grandchild of $lastToFirstIterator(child)){
                stack.push(grandchild);
            }
        }
    }
    return result;
}
/**
 * Return an iterator that yields each child of node from first to last, taking
 * care to preserve the next sibling before yielding the value in case the caller
 * removes the yielded node.
 *
 * @param node The node whose children to iterate
 * @returns An iterator of the node's children
 */ function $firstToLastIterator(node) {
    return $childIterator((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getChildCaret"])(node, 'next'));
}
/**
 * Return an iterator that yields each child of node from last to first, taking
 * care to preserve the previous sibling before yielding the value in case the caller
 * removes the yielded node.
 *
 * @param node The node whose children to iterate
 * @returns An iterator of the node's children
 */ function $lastToFirstIterator(node) {
    return $childIterator((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getChildCaret"])(node, 'previous'));
}
function $childIterator(startCaret) {
    const seen = new Set();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["makeStepwiseIterator"])({
        hasNext: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isSiblingCaret"],
        initial: startCaret.getAdjacentCaret(),
        map: (caret)=>{
            const origin = caret.origin.getLatest();
            if (seen !== null) {
                const key = origin.getKey();
                if (!!seen.has(key)) {
                    formatDevErrorMessage(`$childIterator: Cycle detected, node with key ${String(key)} has already been traversed`);
                }
                seen.add(key);
            }
            return origin;
        },
        step: (caret)=>caret.getAdjacentCaret()
    });
}
/**
 * Replace this node with its children
 *
 * @param node The ElementNode to unwrap and remove
 */ function $unwrapNode(node) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$rewindSiblingCaret"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSiblingCaret"])(node, 'next')).splice(1, node.getChildren());
}
/**
 * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example
 * R -> P -> T1, T2
 *   -> P2
 * returns T2 for node T1, P2 for node T2, and null for node P2.
 * @param node LexicalNode.
 * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.
 */ function $getAdjacentSiblingOrParentSiblingCaret(startCaret, rootMode = 'root') {
    let depthDiff = 0;
    let caret = startCaret;
    let nextCaret = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getAdjacentChildCaret"])(caret);
    while(nextCaret === null){
        depthDiff--;
        nextCaret = caret.getParentCaret(rootMode);
        if (!nextCaret) {
            return null;
        }
        caret = nextCaret;
        nextCaret = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getAdjacentChildCaret"])(caret);
    }
    return nextCaret && [
        nextCaret,
        depthDiff
    ];
}
/**
 * A wrapper that creates bound functions and methods for the
 * StateConfig to save some boilerplate when defining methods
 * or exporting only the accessors from your modules rather
 * than exposing the StateConfig directly.
 */ /**
 * EXPERIMENTAL
 *
 * A convenience interface for working with {@link $getState} and
 * {@link $setState}.
 *
 * @param stateConfig The stateConfig to wrap with convenience functionality
 * @returns a StateWrapper
 */ function makeStateWrapper(stateConfig) {
    const $get = (node)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getState"])(node, stateConfig);
    const $set = (node, valueOrUpdater)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$setState"])(node, stateConfig, valueOrUpdater);
    return {
        $get,
        $set,
        accessors: [
            $get,
            $set
        ],
        makeGetterMethod: ()=>function $getter() {
                return $get(this);
            },
        makeSetterMethod: ()=>function $setter(valueOrUpdater) {
                return $set(this, valueOrUpdater);
            },
        stateConfig
    };
}
;
}),
"[project]/node_modules/.pnpm/@lexical+clipboard@0.35.0/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "$generateJSONFromSelectedNodes",
    ()=>$generateJSONFromSelectedNodes,
    "$generateNodesFromSerializedNodes",
    ()=>$generateNodesFromSerializedNodes,
    "$getClipboardDataFromSelection",
    ()=>$getClipboardDataFromSelection,
    "$getHtmlContent",
    ()=>$getHtmlContent,
    "$getLexicalContent",
    ()=>$getLexicalContent,
    "$insertDataTransferForPlainText",
    ()=>$insertDataTransferForPlainText,
    "$insertDataTransferForRichText",
    ()=>$insertDataTransferForRichText,
    "$insertGeneratedNodes",
    ()=>$insertGeneratedNodes,
    "copyToClipboard",
    ()=>copyToClipboard,
    "setLexicalClipboardDataTransfer",
    ()=>setLexicalClipboardDataTransfer
]);
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$html$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$html$2f$LexicalHtml$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@lexical+html@0.35.0/node_modules/@lexical/html/LexicalHtml.dev.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$selection$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$selection$2f$LexicalSelection$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@lexical+selection@0.35.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@lexical+utils@0.35.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/lexical@0.35.0/node_modules/lexical/Lexical.dev.mjs [app-rsc] (ecmascript)");
;
;
;
;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ // Do not require this module directly! Use normal `invariant` calls.
function formatDevErrorMessage(message) {
    throw new Error(message);
}
/**
 * Returns the *currently selected* Lexical content as an HTML string, relying on the
 * logic defined in the exportDOM methods on the LexicalNode classes. Note that
 * this will not return the HTML content of the entire editor (unless all the content is included
 * in the current selection).
 *
 * @param editor - LexicalEditor instance to get HTML content from
 * @param selection - The selection to use (default is $getSelection())
 * @returns a string of HTML content
 */ function $getHtmlContent(editor, selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])()) {
    if (selection == null) {
        {
            formatDevErrorMessage(`Expected valid LexicalSelection`);
        }
    }
    // If we haven't selected anything
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {
        return '';
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$html$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$html$2f$LexicalHtml$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$generateHtmlFromNodes"])(editor, selection);
}
/**
 * Returns the *currently selected* Lexical content as a JSON string, relying on the
 * logic defined in the exportJSON methods on the LexicalNode classes. Note that
 * this will not return the JSON content of the entire editor (unless all the content is included
 * in the current selection).
 *
 * @param editor  - LexicalEditor instance to get the JSON content from
 * @param selection - The selection to use (default is $getSelection())
 * @returns
 */ function $getLexicalContent(editor, selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])()) {
    if (selection == null) {
        {
            formatDevErrorMessage(`Expected valid LexicalSelection`);
        }
    }
    // If we haven't selected anything
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {
        return null;
    }
    return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));
}
/**
 * Attempts to insert content of the mime-types text/plain or text/uri-list from
 * the provided DataTransfer object into the editor at the provided selection.
 * text/uri-list is only used if text/plain is not also provided.
 *
 * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)
 * @param selection the selection to use as the insertion point for the content in the DataTransfer object
 */ function $insertDataTransferForPlainText(dataTransfer, selection) {
    const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');
    if (text != null) {
        selection.insertRawText(text);
    }
}
/**
 * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,
 * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer
 * object into the editor at the provided selection.
 *
 * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)
 * @param selection the selection to use as the insertion point for the content in the DataTransfer object
 * @param editor the LexicalEditor the content is being inserted into.
 */ function $insertDataTransferForRichText(dataTransfer, selection, editor) {
    const lexicalString = dataTransfer.getData('application/x-lexical-editor');
    if (lexicalString) {
        try {
            const payload = JSON.parse(lexicalString);
            if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {
                const nodes = $generateNodesFromSerializedNodes(payload.nodes);
                return $insertGeneratedNodes(editor, nodes, selection);
            }
        } catch (_unused) {
        // Fail silently.
        }
    }
    const htmlString = dataTransfer.getData('text/html');
    const plainString = dataTransfer.getData('text/plain');
    // Skip HTML handling if it matches the plain text representation.
    // This avoids unnecessary processing for plain text strings created by
    // iOS Safari autocorrect, which incorrectly includes a `text/html` type.
    if (htmlString && plainString !== htmlString) {
        try {
            const parser = new DOMParser();
            const dom = parser.parseFromString(trustHTML(htmlString), 'text/html');
            const nodes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$html$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$html$2f$LexicalHtml$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$generateNodesFromDOM"])(editor, dom);
            return $insertGeneratedNodes(editor, nodes, selection);
        } catch (_unused2) {
        // Fail silently.
        }
    }
    // Multi-line plain text in rich text mode pasted as separate paragraphs
    // instead of single paragraph with linebreaks.
    // Webkit-specific: Supports read 'text/uri-list' in clipboard.
    const text = plainString || dataTransfer.getData('text/uri-list');
    if (text != null) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            const parts = text.split(/(\r?\n|\t)/);
            if (parts[parts.length - 1] === '') {
                parts.pop();
            }
            for(let i = 0; i < parts.length; i++){
                const currentSelection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(currentSelection)) {
                    const part = parts[i];
                    if (part === '\n' || part === '\r\n') {
                        currentSelection.insertParagraph();
                    } else if (part === '\t') {
                        currentSelection.insertNodes([
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createTabNode"])()
                        ]);
                    } else {
                        currentSelection.insertText(part);
                    }
                }
            }
        } else {
            selection.insertRawText(text);
        }
    }
}
function trustHTML(html) {
    if (window.trustedTypes && window.trustedTypes.createPolicy) {
        const policy = window.trustedTypes.createPolicy('lexical', {
            createHTML: (input)=>input
        });
        return policy.createHTML(html);
    }
    return html;
}
/**
 * Inserts Lexical nodes into the editor using different strategies depending on
 * some simple selection-based heuristics. If you're looking for a generic way to
 * to insert nodes into the editor at a specific selection point, you probably want
 * {@link lexical.$insertNodes}
 *
 * @param editor LexicalEditor instance to insert the nodes into.
 * @param nodes The nodes to insert.
 * @param selection The selection to insert the nodes into.
 */ function $insertGeneratedNodes(editor, nodes, selection) {
    if (!editor.dispatchCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["SELECTION_INSERT_CLIPBOARD_NODES_COMMAND"], {
        nodes,
        selection
    })) {
        selection.insertNodes(nodes);
        $updateSelectionOnInsert(selection);
    }
    return;
}
function $updateSelectionOnInsert(selection) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection) && selection.isCollapsed()) {
        const anchor = selection.anchor;
        let nodeToInspect = null;
        const anchorCaret = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$caretFromPoint"])(anchor, 'previous');
        if (anchorCaret) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTextPointCaret"])(anchorCaret)) {
                nodeToInspect = anchorCaret.origin;
            } else {
                const range = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getCaretRange"])(anchorCaret, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getChildCaret"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getRoot"])(), 'next').getFlipped());
                for (const caret of range){
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTextNode"])(caret.origin)) {
                        nodeToInspect = caret.origin;
                        break;
                    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(caret.origin) && !caret.origin.isInline()) {
                        break;
                    }
                }
            }
        }
        if (nodeToInspect && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTextNode"])(nodeToInspect)) {
            const newFormat = nodeToInspect.getFormat();
            const newStyle = nodeToInspect.getStyle();
            if (selection.format !== newFormat || selection.style !== newStyle) {
                selection.format = newFormat;
                selection.style = newStyle;
                selection.dirty = true;
            }
        }
    }
}
function exportNodeToJSON(node) {
    const serializedNode = node.exportJSON();
    const nodeClass = node.constructor;
    if (serializedNode.type !== nodeClass.getType()) {
        {
            formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);
        }
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(node)) {
        const serializedChildren = serializedNode.children;
        if (!Array.isArray(serializedChildren)) {
            {
                formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
            }
        }
    }
    return serializedNode;
}
function $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {
    let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;
    const shouldExclude = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(currentNode) && currentNode.excludeFromCopy('html');
    let target = currentNode;
    if (selection !== null) {
        let clone = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$cloneWithProperties"])(currentNode);
        clone = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTextNode"])(clone) && selection !== null ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$selection$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$selection$2f$LexicalSelection$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["$sliceSelectedTextNodeContent"])(selection, clone) : clone;
        target = clone;
    }
    const children = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(target) ? target.getChildren() : [];
    const serializedNode = exportNodeToJSON(target);
    // TODO: TextNode calls getTextContent() (NOT node.__text) within its exportJSON method
    // which uses getLatest() to get the text from the original node with the same key.
    // This is a deeper issue with the word "clone" here, it's still a reference to the
    // same node as far as the LexicalEditor is concerned since it shares a key.
    // We need a way to create a clone of a Node in memory with its own key, but
    // until then this hack will work for the selected text extract use case.
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTextNode"])(target)) {
        const text = target.__text;
        // If an uncollapsed selection ends or starts at the end of a line of specialized,
        // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one
        // with text of length 0. We don't want this, it makes a confusing mess. Reset!
        if (text.length > 0) {
            serializedNode.text = text;
        } else {
            shouldInclude = false;
        }
    }
    for(let i = 0; i < children.length; i++){
        const childNode = children[i];
        const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);
        if (!shouldInclude && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {
            shouldInclude = true;
        }
    }
    if (shouldInclude && !shouldExclude) {
        targetArray.push(serializedNode);
    } else if (Array.isArray(serializedNode.children)) {
        for(let i = 0; i < serializedNode.children.length; i++){
            const serializedChildNode = serializedNode.children[i];
            targetArray.push(serializedChildNode);
        }
    }
    return shouldInclude;
}
// TODO why $ function with Editor instance?
/**
 * Gets the Lexical JSON of the nodes inside the provided Selection.
 *
 * @param editor LexicalEditor to get the JSON content from.
 * @param selection Selection to get the JSON content from.
 * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.
 */ function $generateJSONFromSelectedNodes(editor, selection) {
    const nodes = [];
    const root = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getRoot"])();
    const topLevelChildren = root.getChildren();
    for(let i = 0; i < topLevelChildren.length; i++){
        const topLevelNode = topLevelChildren[i];
        $appendNodesToJSON(editor, selection, topLevelNode, nodes);
    }
    return {
        namespace: editor._config.namespace,
        nodes
    };
}
/**
 * This method takes an array of objects conforming to the BaseSerializedNode interface and returns
 * an Array containing instances of the corresponding LexicalNode classes registered on the editor.
 * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}
 *
 * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.
 * @returns an Array of Lexical Node objects.
 */ function $generateNodesFromSerializedNodes(serializedNodes) {
    const nodes = [];
    for(let i = 0; i < serializedNodes.length; i++){
        const serializedNode = serializedNodes[i];
        const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$parseSerializedNode"])(serializedNode);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTextNode"])(node)) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$selection$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$selection$2f$LexicalSelection$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["$addNodeStyle"])(node);
        }
        nodes.push(node);
    }
    return nodes;
}
const EVENT_LATENCY = 50;
let clipboardEventTimeout = null;
// TODO custom selection
// TODO potentially have a node customizable version for plain text
/**
 * Copies the content of the current selection to the clipboard in
 * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)
 * formats.
 *
 * @param editor the LexicalEditor instance to copy content from
 * @param event the native browser ClipboardEvent to add the content to.
 * @returns
 */ async function copyToClipboard(editor, event, data) {
    if (clipboardEventTimeout !== null) {
        // Prevent weird race conditions that can happen when this function is run multiple times
        // synchronously. In the future, we can do better, we can cancel/override the previously running job.
        return false;
    }
    if (event !== null) {
        return new Promise((resolve, reject)=>{
            editor.update(()=>{
                resolve($copyToClipboardEvent(editor, event, data));
            });
        });
    }
    const rootElement = editor.getRootElement();
    const editorWindow = editor._window || window;
    const windowDocument = window.document;
    const domSelection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDOMSelection"])(editorWindow);
    if (rootElement === null || domSelection === null) {
        return false;
    }
    const element = windowDocument.createElement('span');
    element.style.cssText = 'position: fixed; top: -1000px;';
    element.append(windowDocument.createTextNode('#'));
    rootElement.append(element);
    const range = new Range();
    range.setStart(element, 0);
    range.setEnd(element, 1);
    domSelection.removeAllRanges();
    domSelection.addRange(range);
    return new Promise((resolve, reject)=>{
        const removeListener = editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COPY_COMMAND"], (secondEvent)=>{
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["objectKlassEquals"])(secondEvent, ClipboardEvent)) {
                removeListener();
                if (clipboardEventTimeout !== null) {
                    window.clearTimeout(clipboardEventTimeout);
                    clipboardEventTimeout = null;
                }
                resolve($copyToClipboardEvent(editor, secondEvent, data));
            }
            // Block the entire copy flow while we wait for the next ClipboardEvent
            return true;
        }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_CRITICAL"]);
        // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,
        // the listener will be quickly freed so that the user can reuse it again
        clipboardEventTimeout = window.setTimeout(()=>{
            removeListener();
            clipboardEventTimeout = null;
            resolve(false);
        }, EVENT_LATENCY);
        windowDocument.execCommand('copy');
        element.remove();
    });
}
// TODO shouldn't pass editor (pass namespace directly)
function $copyToClipboardEvent(editor, event, data) {
    if (data === undefined) {
        const domSelection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDOMSelection"])(editor._window);
        if (!domSelection) {
            return false;
        }
        const anchorDOM = domSelection.anchorNode;
        const focusDOM = domSelection.focusNode;
        if (anchorDOM !== null && focusDOM !== null && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isSelectionWithinEditor"])(editor, anchorDOM, focusDOM)) {
            return false;
        }
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if (selection === null) {
            return false;
        }
        data = $getClipboardDataFromSelection(selection);
    }
    event.preventDefault();
    const clipboardData = event.clipboardData;
    if (clipboardData === null) {
        return false;
    }
    setLexicalClipboardDataTransfer(clipboardData, data);
    return true;
}
const clipboardDataFunctions = [
    [
        'text/html',
        $getHtmlContent
    ],
    [
        'application/x-lexical-editor',
        $getLexicalContent
    ]
];
/**
 * Serialize the content of the current selection to strings in
 * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)
 * formats (as available).
 *
 * @param selection the selection to serialize (defaults to $getSelection())
 * @returns LexicalClipboardData
 */ function $getClipboardDataFromSelection(selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])()) {
    const clipboardData = {
        'text/plain': selection ? selection.getTextContent() : ''
    };
    if (selection) {
        const editor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getEditor"])();
        for (const [mimeType, $editorFn] of clipboardDataFunctions){
            const v = $editorFn(editor, selection);
            if (v !== null) {
                clipboardData[mimeType] = v;
            }
        }
    }
    return clipboardData;
}
/**
 * Call setData on the given clipboardData for each MIME type present
 * in the given data (from {@link $getClipboardDataFromSelection})
 *
 * @param clipboardData the event.clipboardData to populate from data
 * @param data The lexical data
 */ function setLexicalClipboardDataTransfer(clipboardData, data) {
    for(const k in data){
        const v = data[k];
        if (v !== undefined) {
            clipboardData.setData(k, v);
        }
    }
}
;
}),
"[project]/node_modules/.pnpm/@lexical+rich-text@0.35.0/node_modules/@lexical/rich-text/LexicalRichText.dev.mjs [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "$createHeadingNode",
    ()=>$createHeadingNode,
    "$createQuoteNode",
    ()=>$createQuoteNode,
    "$isHeadingNode",
    ()=>$isHeadingNode,
    "$isQuoteNode",
    ()=>$isQuoteNode,
    "DRAG_DROP_PASTE",
    ()=>DRAG_DROP_PASTE,
    "HeadingNode",
    ()=>HeadingNode,
    "QuoteNode",
    ()=>QuoteNode,
    "eventFiles",
    ()=>eventFiles,
    "registerRichText",
    ()=>registerRichText
]);
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$clipboard$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$clipboard$2f$LexicalClipboard$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@lexical+clipboard@0.35.0/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$selection$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$selection$2f$LexicalSelection$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@lexical+selection@0.35.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@lexical+utils@0.35.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/lexical@0.35.0/node_modules/lexical/Lexical.dev.mjs [app-rsc] (ecmascript)");
;
;
;
;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ function caretFromPoint(x, y) {
    if (typeof document.caretRangeFromPoint !== 'undefined') {
        const range = document.caretRangeFromPoint(x, y);
        if (range === null) {
            return null;
        }
        return {
            node: range.startContainer,
            offset: range.startOffset
        };
    // @ts-ignore
    } else if (document.caretPositionFromPoint !== 'undefined') {
        // @ts-ignore FF - no types
        const range = document.caretPositionFromPoint(x, y);
        if (range === null) {
            return null;
        }
        return {
            node: range.offsetNode,
            offset: range.offset
        };
    } else {
        // Gracefully handle IE
        return null;
    }
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ const CAN_USE_DOM = ("TURBOPACK compile-time value", "undefined") !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ const documentMode = CAN_USE_DOM && 'documentMode' in document ? "TURBOPACK unreachable" : null;
const CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? "TURBOPACK unreachable" : false;
const IS_SAFARI = CAN_USE_DOM && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
const IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
// Keep these in case we need to use them in the future.
// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);
const IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);
const IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ const DRAG_DROP_PASTE = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createCommand"])('DRAG_DROP_PASTE_FILE');
/** @noInheritDoc */ class QuoteNode extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ElementNode"] {
    static getType() {
        return 'quote';
    }
    static clone(node) {
        return new QuoteNode(node.__key);
    }
    // View
    createDOM(config) {
        const element = document.createElement('blockquote');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addClassNamesToElement"])(element, config.theme.quote);
        return element;
    }
    updateDOM(prevNode, dom) {
        return false;
    }
    static importDOM() {
        return {
            blockquote: (node)=>({
                    conversion: $convertBlockquoteElement,
                    priority: 0
                })
        };
    }
    exportDOM(editor) {
        const { element } = super.exportDOM(editor);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(element)) {
            if (this.isEmpty()) {
                element.append(document.createElement('br'));
            }
            const formatType = this.getFormatType();
            if (formatType) {
                element.style.textAlign = formatType;
            }
            const direction = this.getDirection();
            if (direction) {
                element.dir = direction;
            }
        }
        return {
            element
        };
    }
    static importJSON(serializedNode) {
        return $createQuoteNode().updateFromJSON(serializedNode);
    }
    // Mutation
    insertNewAfter(_, restoreSelection) {
        const newBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createParagraphNode"])();
        const direction = this.getDirection();
        newBlock.setDirection(direction);
        this.insertAfter(newBlock, restoreSelection);
        return newBlock;
    }
    collapseAtStart() {
        const paragraph = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createParagraphNode"])();
        const children = this.getChildren();
        children.forEach((child)=>paragraph.append(child));
        this.replace(paragraph);
        return true;
    }
    canMergeWhenEmpty() {
        return true;
    }
}
function $createQuoteNode() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$applyNodeReplacement"])(new QuoteNode());
}
function $isQuoteNode(node) {
    return node instanceof QuoteNode;
}
/** @noInheritDoc */ class HeadingNode extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ElementNode"] {
    /** @internal */ static getType() {
        return 'heading';
    }
    static clone(node) {
        return new HeadingNode(node.__tag, node.__key);
    }
    constructor(tag, key){
        super(key);
        this.__tag = tag;
    }
    getTag() {
        return this.__tag;
    }
    setTag(tag) {
        const self = this.getWritable();
        this.__tag = tag;
        return self;
    }
    // View
    createDOM(config) {
        const tag = this.__tag;
        const element = document.createElement(tag);
        const theme = config.theme;
        const classNames = theme.heading;
        if (classNames !== undefined) {
            const className = classNames[tag];
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addClassNamesToElement"])(element, className);
        }
        return element;
    }
    updateDOM(prevNode, dom, config) {
        return prevNode.__tag !== this.__tag;
    }
    static importDOM() {
        return {
            h1: (node)=>({
                    conversion: $convertHeadingElement,
                    priority: 0
                }),
            h2: (node)=>({
                    conversion: $convertHeadingElement,
                    priority: 0
                }),
            h3: (node)=>({
                    conversion: $convertHeadingElement,
                    priority: 0
                }),
            h4: (node)=>({
                    conversion: $convertHeadingElement,
                    priority: 0
                }),
            h5: (node)=>({
                    conversion: $convertHeadingElement,
                    priority: 0
                }),
            h6: (node)=>({
                    conversion: $convertHeadingElement,
                    priority: 0
                }),
            p: (node)=>{
                // domNode is a <p> since we matched it by nodeName
                const paragraph = node;
                const firstChild = paragraph.firstChild;
                if (firstChild !== null && isGoogleDocsTitle(firstChild)) {
                    return {
                        conversion: ()=>({
                                node: null
                            }),
                        priority: 3
                    };
                }
                return null;
            },
            span: (node)=>{
                if (isGoogleDocsTitle(node)) {
                    return {
                        conversion: (domNode)=>{
                            return {
                                node: $createHeadingNode('h1')
                            };
                        },
                        priority: 3
                    };
                }
                return null;
            }
        };
    }
    exportDOM(editor) {
        const { element } = super.exportDOM(editor);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(element)) {
            if (this.isEmpty()) {
                element.append(document.createElement('br'));
            }
            const formatType = this.getFormatType();
            if (formatType) {
                element.style.textAlign = formatType;
            }
            const direction = this.getDirection();
            if (direction) {
                element.dir = direction;
            }
        }
        return {
            element
        };
    }
    static importJSON(serializedNode) {
        return $createHeadingNode(serializedNode.tag).updateFromJSON(serializedNode);
    }
    updateFromJSON(serializedNode) {
        return super.updateFromJSON(serializedNode).setTag(serializedNode.tag);
    }
    exportJSON() {
        return {
            ...super.exportJSON(),
            tag: this.getTag()
        };
    }
    // Mutation
    insertNewAfter(selection, restoreSelection = true) {
        const anchorOffet = selection ? selection.anchor.offset : 0;
        const lastDesc = this.getLastDescendant();
        const isAtEnd = !lastDesc || selection && selection.anchor.key === lastDesc.getKey() && anchorOffet === lastDesc.getTextContentSize();
        const newElement = isAtEnd || !selection ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createParagraphNode"])() : $createHeadingNode(this.getTag());
        const direction = this.getDirection();
        newElement.setDirection(direction);
        this.insertAfter(newElement, restoreSelection);
        if (anchorOffet === 0 && !this.isEmpty() && selection) {
            const paragraph = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createParagraphNode"])();
            paragraph.select();
            this.replace(paragraph, true);
        }
        return newElement;
    }
    collapseAtStart() {
        const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createParagraphNode"])();
        const children = this.getChildren();
        children.forEach((child)=>newElement.append(child));
        this.replace(newElement);
        return true;
    }
    extractWithChild() {
        return true;
    }
}
function isGoogleDocsTitle(domNode) {
    if (domNode.nodeName.toLowerCase() === 'span') {
        return domNode.style.fontSize === '26pt';
    }
    return false;
}
function $convertHeadingElement(element) {
    const nodeName = element.nodeName.toLowerCase();
    let node = null;
    if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {
        node = $createHeadingNode(nodeName);
        if (element.style !== null) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["setNodeIndentFromDOM"])(element, node);
            node.setFormat(element.style.textAlign);
        }
    }
    return {
        node
    };
}
function $convertBlockquoteElement(element) {
    const node = $createQuoteNode();
    if (element.style !== null) {
        node.setFormat(element.style.textAlign);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["setNodeIndentFromDOM"])(element, node);
    }
    return {
        node
    };
}
function $createHeadingNode(headingTag = 'h1') {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$applyNodeReplacement"])(new HeadingNode(headingTag));
}
function $isHeadingNode(node) {
    return node instanceof HeadingNode;
}
function onPasteForRichText(event, editor) {
    event.preventDefault();
    editor.update(()=>{
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        const clipboardData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["objectKlassEquals"])(event, InputEvent) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["objectKlassEquals"])(event, KeyboardEvent) ? null : event.clipboardData;
        if (clipboardData != null && selection !== null) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$clipboard$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$clipboard$2f$LexicalClipboard$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$insertDataTransferForRichText"])(clipboardData, selection, editor);
        }
    }, {
        tag: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["PASTE_TAG"]
    });
}
async function onCutForRichText(event, editor) {
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$clipboard$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$clipboard$2f$LexicalClipboard$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["copyToClipboard"])(editor, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["objectKlassEquals"])(event, ClipboardEvent) ? event : null);
    editor.update(()=>{
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            selection.removeText();
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isNodeSelection"])(selection)) {
            selection.getNodes().forEach((node)=>node.remove());
        }
    });
}
// Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,
// in certain occasions, we want to know whether it was a file transfer, as opposed to text. We
// control this with the first boolean flag.
function eventFiles(event) {
    let dataTransfer = null;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["objectKlassEquals"])(event, DragEvent)) {
        dataTransfer = event.dataTransfer;
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["objectKlassEquals"])(event, ClipboardEvent)) {
        dataTransfer = event.clipboardData;
    }
    if (dataTransfer === null) {
        return [
            false,
            [],
            false
        ];
    }
    const types = dataTransfer.types;
    const hasFiles = types.includes('Files');
    const hasContent = types.includes('text/html') || types.includes('text/plain');
    return [
        hasFiles,
        Array.from(dataTransfer.files),
        hasContent
    ];
}
function $handleIndentAndOutdent(indentOrOutdent) {
    const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
        return false;
    }
    const alreadyHandled = new Set();
    const nodes = selection.getNodes();
    for(let i = 0; i < nodes.length; i++){
        const node = nodes[i];
        const key = node.getKey();
        if (alreadyHandled.has(key)) {
            continue;
        }
        const parentBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["$findMatchingParent"])(node, (parentNode)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(parentNode) && !parentNode.isInline());
        if (parentBlock === null) {
            continue;
        }
        const parentKey = parentBlock.getKey();
        if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {
            alreadyHandled.add(parentKey);
            indentOrOutdent(parentBlock);
        }
    }
    return alreadyHandled.size > 0;
}
function $isTargetWithinDecorator(target) {
    const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getNearestNodeFromDOMNode"])(target);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isDecoratorNode"])(node);
}
function $isSelectionAtEndOfRoot(selection) {
    const focus = selection.focus;
    return focus.key === 'root' && focus.offset === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getRoot"])().getChildrenSize();
}
function $isSelectionCollapsedAtFrontOfIndentedBlock(selection) {
    if (!selection.isCollapsed()) {
        return false;
    }
    const { anchor } = selection;
    if (anchor.offset !== 0) {
        return false;
    }
    const anchorNode = anchor.getNode();
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRootNode"])(anchorNode)) {
        return false;
    }
    const element = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["$getNearestBlockElementAncestorOrThrow"])(anchorNode);
    return element.getIndent() > 0 && (element.is(anchorNode) || anchorNode.is(element.getFirstDescendant()));
}
/**
 * Resets the capitalization of the selection to default.
 * Called when the user presses space, tab, or enter key.
 * @param selection The selection to reset the capitalization of.
 */ function $resetCapitalization(selection) {
    for (const format of [
        'lowercase',
        'uppercase',
        'capitalize'
    ]){
        if (selection.hasFormat(format)) {
            selection.toggleFormat(format);
        }
    }
}
function registerRichText(editor) {
    const removeListener = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["mergeRegister"])(editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CLICK_COMMAND"], (payload)=>{
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isNodeSelection"])(selection)) {
            selection.clear();
            return true;
        }
        return false;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DELETE_CHARACTER_COMMAND"], (isBackward)=>{
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            selection.deleteCharacter(isBackward);
            return true;
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isNodeSelection"])(selection)) {
            selection.deleteNodes();
            return true;
        }
        return false;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DELETE_WORD_COMMAND"], (isBackward)=>{
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            return false;
        }
        selection.deleteWord(isBackward);
        return true;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DELETE_LINE_COMMAND"], (isBackward)=>{
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            return false;
        }
        selection.deleteLine(isBackward);
        return true;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CONTROLLED_TEXT_INSERTION_COMMAND"], (eventOrText)=>{
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if (typeof eventOrText === 'string') {
            if (selection !== null) {
                selection.insertText(eventOrText);
            }
        } else {
            if (selection === null) {
                return false;
            }
            const dataTransfer = eventOrText.dataTransfer;
            if (dataTransfer != null) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$clipboard$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$clipboard$2f$LexicalClipboard$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$insertDataTransferForRichText"])(dataTransfer, selection, editor);
            } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
                const data = eventOrText.data;
                if (data) {
                    selection.insertText(data);
                }
                return true;
            }
        }
        return true;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["REMOVE_TEXT_COMMAND"], ()=>{
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            return false;
        }
        selection.removeText();
        return true;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["FORMAT_TEXT_COMMAND"], (format)=>{
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            return false;
        }
        selection.formatText(format);
        return true;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["FORMAT_ELEMENT_COMMAND"], (format)=>{
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isNodeSelection"])(selection)) {
            return false;
        }
        const nodes = selection.getNodes();
        for (const node of nodes){
            const element = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["$findMatchingParent"])(node, (parentNode)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(parentNode) && !parentNode.isInline());
            if (element !== null) {
                element.setFormat(format);
            }
        }
        return true;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["INSERT_LINE_BREAK_COMMAND"], (selectStart)=>{
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            return false;
        }
        selection.insertLineBreak(selectStart);
        return true;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["INSERT_PARAGRAPH_COMMAND"], ()=>{
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            return false;
        }
        selection.insertParagraph();
        return true;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["INSERT_TAB_COMMAND"], ()=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$insertNodes"])([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createTabNode"])()
        ]);
        return true;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["INDENT_CONTENT_COMMAND"], ()=>{
        return $handleIndentAndOutdent((block)=>{
            const indent = block.getIndent();
            block.setIndent(indent + 1);
        });
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["OUTDENT_CONTENT_COMMAND"], ()=>{
        return $handleIndentAndOutdent((block)=>{
            const indent = block.getIndent();
            if (indent > 0) {
                block.setIndent(Math.max(0, indent - 1));
            }
        });
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["KEY_ARROW_UP_COMMAND"], (event)=>{
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isNodeSelection"])(selection)) {
            // If selection is on a node, let's try and move selection
            // back to being a range selection.
            const nodes = selection.getNodes();
            if (nodes.length > 0) {
                nodes[0].selectPrevious();
                return true;
            }
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            const possibleNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getAdjacentNode"])(selection.focus, true);
            if (!event.shiftKey && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isDecoratorNode"])(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {
                possibleNode.selectPrevious();
                event.preventDefault();
                return true;
            }
        }
        return false;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["KEY_ARROW_DOWN_COMMAND"], (event)=>{
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isNodeSelection"])(selection)) {
            // If selection is on a node, let's try and move selection
            // back to being a range selection.
            const nodes = selection.getNodes();
            if (nodes.length > 0) {
                nodes[0].selectNext(0, 0);
                return true;
            }
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            if ($isSelectionAtEndOfRoot(selection)) {
                event.preventDefault();
                return true;
            }
            const possibleNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getAdjacentNode"])(selection.focus, false);
            if (!event.shiftKey && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isDecoratorNode"])(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {
                possibleNode.selectNext();
                event.preventDefault();
                return true;
            }
        }
        return false;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["KEY_ARROW_LEFT_COMMAND"], (event)=>{
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isNodeSelection"])(selection)) {
            // If selection is on a node, let's try and move selection
            // back to being a range selection.
            const nodes = selection.getNodes();
            if (nodes.length > 0) {
                event.preventDefault();
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$selection$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$selection$2f$LexicalSelection$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["$isParentRTL"])(nodes[0])) {
                    nodes[0].selectNext(0, 0);
                } else {
                    nodes[0].selectPrevious();
                }
                return true;
            }
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            return false;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$selection$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$selection$2f$LexicalSelection$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["$shouldOverrideDefaultCharacterSelection"])(selection, true)) {
            const isHoldingShift = event.shiftKey;
            event.preventDefault();
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$selection$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$selection$2f$LexicalSelection$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["$moveCharacter"])(selection, isHoldingShift, true);
            return true;
        }
        return false;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["KEY_ARROW_RIGHT_COMMAND"], (event)=>{
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isNodeSelection"])(selection)) {
            // If selection is on a node, let's try and move selection
            // back to being a range selection.
            const nodes = selection.getNodes();
            if (nodes.length > 0) {
                event.preventDefault();
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$selection$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$selection$2f$LexicalSelection$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["$isParentRTL"])(nodes[0])) {
                    nodes[0].selectPrevious();
                } else {
                    nodes[0].selectNext(0, 0);
                }
                return true;
            }
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            return false;
        }
        const isHoldingShift = event.shiftKey;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$selection$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$selection$2f$LexicalSelection$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["$shouldOverrideDefaultCharacterSelection"])(selection, false)) {
            event.preventDefault();
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$selection$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$selection$2f$LexicalSelection$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["$moveCharacter"])(selection, isHoldingShift, false);
            return true;
        }
        return false;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["KEY_BACKSPACE_COMMAND"], (event)=>{
        if ($isTargetWithinDecorator(event.target)) {
            return false;
        }
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            if ($isSelectionCollapsedAtFrontOfIndentedBlock(selection)) {
                event.preventDefault();
                return editor.dispatchCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["OUTDENT_CONTENT_COMMAND"], undefined);
            }
            // Exception handling for iOS native behavior instead of Lexical's behavior when using Korean on iOS devices.
            // more details - https://github.com/facebook/lexical/issues/5841
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
        } else if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isNodeSelection"])(selection)) {
            return false;
        }
        event.preventDefault();
        return editor.dispatchCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DELETE_CHARACTER_COMMAND"], true);
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["KEY_DELETE_COMMAND"], (event)=>{
        if ($isTargetWithinDecorator(event.target)) {
            return false;
        }
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if (!((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isNodeSelection"])(selection))) {
            return false;
        }
        event.preventDefault();
        return editor.dispatchCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DELETE_CHARACTER_COMMAND"], false);
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["KEY_ENTER_COMMAND"], (event)=>{
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            return false;
        }
        $resetCapitalization(selection);
        if (event !== null) {
            // If we have beforeinput, then we can avoid blocking
            // the default behavior. This ensures that the iOS can
            // intercept that we're actually inserting a paragraph,
            // and autocomplete, autocapitalize etc work as intended.
            // This can also cause a strange performance issue in
            // Safari, where there is a noticeable pause due to
            // preventing the key down of enter.
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            event.preventDefault();
            if (event.shiftKey) {
                return editor.dispatchCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["INSERT_LINE_BREAK_COMMAND"], false);
            }
        }
        return editor.dispatchCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["INSERT_PARAGRAPH_COMMAND"], undefined);
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["KEY_ESCAPE_COMMAND"], ()=>{
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            return false;
        }
        editor.blur();
        return true;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DROP_COMMAND"], (event)=>{
        const [, files] = eventFiles(event);
        if (files.length > 0) {
            const x = event.clientX;
            const y = event.clientY;
            const eventRange = caretFromPoint(x, y);
            if (eventRange !== null) {
                const { offset: domOffset, node: domNode } = eventRange;
                const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getNearestNodeFromDOMNode"])(domNode);
                if (node !== null) {
                    const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createRangeSelection"])();
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTextNode"])(node)) {
                        selection.anchor.set(node.getKey(), domOffset, 'text');
                        selection.focus.set(node.getKey(), domOffset, 'text');
                    } else {
                        const parentKey = node.getParentOrThrow().getKey();
                        const offset = node.getIndexWithinParent() + 1;
                        selection.anchor.set(parentKey, offset, 'element');
                        selection.focus.set(parentKey, offset, 'element');
                    }
                    const normalizedSelection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$normalizeSelection__EXPERIMENTAL"])(selection);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$setSelection"])(normalizedSelection);
                }
                editor.dispatchCommand(DRAG_DROP_PASTE, files);
            }
            event.preventDefault();
            return true;
        }
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            return true;
        }
        return false;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DRAGSTART_COMMAND"], (event)=>{
        const [isFileTransfer] = eventFiles(event);
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if (isFileTransfer && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            return false;
        }
        return true;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DRAGOVER_COMMAND"], (event)=>{
        const [isFileTransfer] = eventFiles(event);
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if (isFileTransfer && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            return false;
        }
        const x = event.clientX;
        const y = event.clientY;
        const eventRange = caretFromPoint(x, y);
        if (eventRange !== null) {
            const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getNearestNodeFromDOMNode"])(eventRange.node);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isDecoratorNode"])(node)) {
                // Show browser caret as the user is dragging the media across the screen. Won't work
                // for DecoratorNode nor it's relevant.
                event.preventDefault();
            }
        }
        return true;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["SELECT_ALL_COMMAND"], ()=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$selectAll"])();
        return true;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COPY_COMMAND"], (event)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$clipboard$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$clipboard$2f$LexicalClipboard$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["copyToClipboard"])(editor, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["objectKlassEquals"])(event, ClipboardEvent) ? event : null);
        return true;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CUT_COMMAND"], (event)=>{
        onCutForRichText(event, editor);
        return true;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["PASTE_COMMAND"], (event)=>{
        const [, files, hasTextContent] = eventFiles(event);
        if (files.length > 0 && !hasTextContent) {
            editor.dispatchCommand(DRAG_DROP_PASTE, files);
            return true;
        }
        // if inputs then paste within the input ignore creating a new node on paste event
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isDOMNode"])(event.target) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isSelectionCapturedInDecoratorInput"])(event.target)) {
            return false;
        }
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if (selection !== null) {
            onPasteForRichText(event, editor);
            return true;
        }
        return false;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["KEY_SPACE_COMMAND"], (_)=>{
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            $resetCapitalization(selection);
        }
        return false;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["KEY_TAB_COMMAND"], (_)=>{
        const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            $resetCapitalization(selection);
        }
        return false;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_EDITOR"]));
    return removeListener;
}
;
}),
"[project]/node_modules/.pnpm/escape-html@1.0.3/node_modules/escape-html/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */ /**
 * Module variables.
 * @private
 */ var matchHtmlRegExp = /["'&<>]/;
/**
 * Module exports.
 * @public
 */ module.exports = escapeHtml;
/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */ function escapeHtml(string) {
    var str = '' + string;
    var match = matchHtmlRegExp.exec(str);
    if (!match) {
        return str;
    }
    var escape;
    var html = '';
    var index = 0;
    var lastIndex = 0;
    for(index = match.index; index < str.length; index++){
        switch(str.charCodeAt(index)){
            case 34:
                escape = '&quot;';
                break;
            case 38:
                escape = '&amp;';
                break;
            case 39:
                escape = '&#39;';
                break;
            case 60:
                escape = '&lt;';
                break;
            case 62:
                escape = '&gt;';
                break;
            default:
                continue;
        }
        if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escape;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
}),
"[project]/node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/native.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
;
const __TURBOPACK__default__export__ = {
    randomUUID: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["default"].randomUUID
};
}),
"[project]/node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/rng.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>rng
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
;
const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate
let poolPtr = rnds8Pool.length;
function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["default"].randomFillSync(rnds8Pool);
        poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
}),
"[project]/node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/regex.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const __TURBOPACK__default__export__ = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
}),
"[project]/node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/validate.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uuid$40$10$2e$0$2e$0$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$regex$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/regex.js [app-rsc] (ecmascript)");
;
function validate(uuid) {
    return typeof uuid === 'string' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uuid$40$10$2e$0$2e$0$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$regex$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].test(uuid);
}
const __TURBOPACK__default__export__ = validate;
}),
"[project]/node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/stringify.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "unsafeStringify",
    ()=>unsafeStringify
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uuid$40$10$2e$0$2e$0$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$validate$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/validate.js [app-rsc] (ecmascript)");
;
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */ const byteToHex = [];
for(let i = 0; i < 256; ++i){
    byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    //
    // Note to future-self: No, you can't remove the `toLowerCase()` call.
    // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uuid$40$10$2e$0$2e$0$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$validate$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"])(uuid)) {
        throw TypeError('Stringified UUID is invalid');
    }
    return uuid;
}
const __TURBOPACK__default__export__ = stringify;
}),
"[project]/node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v4.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uuid$40$10$2e$0$2e$0$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$native$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/native.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uuid$40$10$2e$0$2e$0$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$rng$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/rng.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uuid$40$10$2e$0$2e$0$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$stringify$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/stringify.js [app-rsc] (ecmascript)");
;
;
;
function v4(options, buf, offset) {
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uuid$40$10$2e$0$2e$0$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$native$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].randomUUID && !buf && !options) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uuid$40$10$2e$0$2e$0$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$native$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uuid$40$10$2e$0$2e$0$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$rng$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"])();
    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80;
    // Copy bytes to buffer, if provided
    if (buf) {
        offset = offset || 0;
        for(let i = 0; i < 16; ++i){
            buf[offset + i] = rnds[i];
        }
        return buf;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uuid$40$10$2e$0$2e$0$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$stringify$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["unsafeStringify"])(rnds);
}
const __TURBOPACK__default__export__ = v4;
}),
"[project]/node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v4.js [app-rsc] (ecmascript) <export default as v4>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "v4",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uuid$40$10$2e$0$2e$0$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v4$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uuid$40$10$2e$0$2e$0$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v4$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-node/v4.js [app-rsc] (ecmascript)");
}),
"[project]/node_modules/.pnpm/@payloadcms+ui@3.64.0_@types+react@19.0.1_monaco-editor@0.55.1_next@16.1.0-canary.0_rea_52870c5534abe0d1ad89657769401cbb/node_modules/@payloadcms/ui/dist/forms/fieldSchemasToFormState/calculateDefaultValues/promise.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "defaultValuePromise",
    ()=>defaultValuePromise
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$getBlockSelect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/payload@3.64.0_graphql@16.12.0_typescript@5.5.2/node_modules/payload/dist/utilities/getBlockSelect.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$getDefaultValue$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/payload@3.64.0_graphql@16.12.0_typescript@5.5.2/node_modules/payload/dist/fields/getDefaultValue.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$stripUnselectedFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/payload@3.64.0_graphql@16.12.0_typescript@5.5.2/node_modules/payload/dist/utilities/stripUnselectedFields.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$config$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/payload@3.64.0_graphql@16.12.0_typescript@5.5.2/node_modules/payload/dist/fields/config/types.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$calculateDefaultValues$2f$iterateFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@payloadcms+ui@3.64.0_@types+react@19.0.1_monaco-editor@0.55.1_next@16.1.0-canary.0_rea_52870c5534abe0d1ad89657769401cbb/node_modules/@payloadcms/ui/dist/forms/fieldSchemasToFormState/calculateDefaultValues/iterateFields.js [app-rsc] (ecmascript)");
;
;
;
const defaultValuePromise = async ({ id, data, field, locale, req, select, selectMode, siblingData, user })=>{
    const shouldContinue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$stripUnselectedFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["stripUnselectedFields"])({
        field,
        select,
        selectMode,
        siblingDoc: siblingData
    });
    if (!shouldContinue) {
        return;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$config$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fieldAffectsData"])(field)) {
        if (typeof siblingData[field.name] === 'undefined' && typeof field.defaultValue !== 'undefined') {
            try {
                siblingData[field.name] = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$getDefaultValue$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDefaultValue"])({
                    defaultValue: field.defaultValue,
                    locale,
                    req,
                    user,
                    value: siblingData[field.name]
                });
            } catch (err) {
                req.payload.logger.error({
                    err,
                    msg: `Error calculating default value for field: ${field.name}`
                });
            }
        }
    }
    // Traverse subfields
    switch(field.type){
        case 'array':
            {
                const rows = siblingData[field.name];
                if (Array.isArray(rows)) {
                    const promises = [];
                    const arraySelect = select?.[field.name];
                    rows.forEach((row)=>{
                        promises.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$calculateDefaultValues$2f$iterateFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["iterateFields"])({
                            id,
                            data,
                            fields: field.fields,
                            locale,
                            req,
                            select: typeof arraySelect === 'object' ? arraySelect : undefined,
                            selectMode,
                            siblingData: row,
                            user
                        }));
                    });
                    await Promise.all(promises);
                }
                break;
            }
        case 'blocks':
            {
                const rows = siblingData[field.name];
                if (Array.isArray(rows)) {
                    const promises = [];
                    rows.forEach((row)=>{
                        const blockTypeToMatch = row.blockType;
                        const block = req.payload.blocks[blockTypeToMatch] ?? (field.blockReferences ?? field.blocks).find((blockType)=>typeof blockType !== 'string' && blockType.slug === blockTypeToMatch);
                        const { blockSelect, blockSelectMode } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$getBlockSelect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getBlockSelect"])({
                            block,
                            select: select?.[field.name],
                            selectMode
                        });
                        if (block) {
                            row.blockType = blockTypeToMatch;
                            promises.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$calculateDefaultValues$2f$iterateFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["iterateFields"])({
                                id,
                                data,
                                fields: block.fields,
                                locale,
                                req,
                                select: typeof blockSelect === 'object' ? blockSelect : undefined,
                                selectMode: blockSelectMode,
                                siblingData: row,
                                user
                            }));
                        }
                    });
                    await Promise.all(promises);
                }
                break;
            }
        case 'collapsible':
        case 'row':
            {
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$calculateDefaultValues$2f$iterateFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["iterateFields"])({
                    id,
                    data,
                    fields: field.fields,
                    locale,
                    req,
                    select,
                    selectMode,
                    siblingData,
                    user
                });
                break;
            }
        case 'group':
            {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$config$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fieldAffectsData"])(field)) {
                    if (typeof siblingData[field.name] !== 'object') {
                        siblingData[field.name] = {};
                    }
                    const groupData = siblingData[field.name];
                    const groupSelect = select?.[field.name];
                    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$calculateDefaultValues$2f$iterateFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["iterateFields"])({
                        id,
                        data,
                        fields: field.fields,
                        locale,
                        req,
                        select: typeof groupSelect === 'object' ? groupSelect : undefined,
                        selectMode,
                        siblingData: groupData,
                        user
                    });
                } else {
                    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$calculateDefaultValues$2f$iterateFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["iterateFields"])({
                        id,
                        data,
                        fields: field.fields,
                        locale,
                        req,
                        select,
                        selectMode,
                        siblingData,
                        user
                    });
                }
                break;
            }
        case 'tab':
            {
                let tabSiblingData;
                const isNamedTab = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$config$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["tabHasName"])(field);
                let tabSelect;
                if (isNamedTab) {
                    if (typeof siblingData[field.name] !== 'object') {
                        siblingData[field.name] = {};
                    }
                    tabSiblingData = siblingData[field.name];
                    if (typeof select?.[field.name] === 'object') {
                        tabSelect = select?.[field.name];
                    }
                } else {
                    tabSiblingData = siblingData;
                    tabSelect = select;
                }
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$calculateDefaultValues$2f$iterateFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["iterateFields"])({
                    id,
                    data,
                    fields: field.fields,
                    locale,
                    req,
                    select: tabSelect,
                    selectMode,
                    siblingData: tabSiblingData,
                    user
                });
                break;
            }
        case 'tabs':
            {
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$calculateDefaultValues$2f$iterateFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["iterateFields"])({
                    id,
                    data,
                    fields: field.tabs.map((tab)=>({
                            ...tab,
                            type: 'tab'
                        })),
                    locale,
                    req,
                    select,
                    selectMode,
                    siblingData,
                    user
                });
                break;
            }
        default:
            {
                break;
            }
    }
}; //# sourceMappingURL=promise.js.map
}),
"[project]/node_modules/.pnpm/@payloadcms+ui@3.64.0_@types+react@19.0.1_monaco-editor@0.55.1_next@16.1.0-canary.0_rea_52870c5534abe0d1ad89657769401cbb/node_modules/@payloadcms/ui/dist/forms/fieldSchemasToFormState/calculateDefaultValues/iterateFields.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "iterateFields",
    ()=>iterateFields
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$calculateDefaultValues$2f$promise$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@payloadcms+ui@3.64.0_@types+react@19.0.1_monaco-editor@0.55.1_next@16.1.0-canary.0_rea_52870c5534abe0d1ad89657769401cbb/node_modules/@payloadcms/ui/dist/forms/fieldSchemasToFormState/calculateDefaultValues/promise.js [app-rsc] (ecmascript)");
;
const iterateFields = async ({ id, data, fields, locale, req, select, selectMode, siblingData, user })=>{
    const promises = [];
    fields.forEach((field)=>{
        promises.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$calculateDefaultValues$2f$promise$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["defaultValuePromise"])({
            id,
            data,
            field,
            locale,
            req,
            select,
            selectMode,
            siblingData,
            user
        }));
    });
    await Promise.all(promises);
}; //# sourceMappingURL=iterateFields.js.map
}),
"[project]/node_modules/.pnpm/@payloadcms+ui@3.64.0_@types+react@19.0.1_monaco-editor@0.55.1_next@16.1.0-canary.0_rea_52870c5534abe0d1ad89657769401cbb/node_modules/@payloadcms/ui/dist/forms/fieldSchemasToFormState/calculateDefaultValues/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "calculateDefaultValues",
    ()=>calculateDefaultValues
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$calculateDefaultValues$2f$iterateFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@payloadcms+ui@3.64.0_@types+react@19.0.1_monaco-editor@0.55.1_next@16.1.0-canary.0_rea_52870c5534abe0d1ad89657769401cbb/node_modules/@payloadcms/ui/dist/forms/fieldSchemasToFormState/calculateDefaultValues/iterateFields.js [app-rsc] (ecmascript)");
;
const calculateDefaultValues = async ({ id, data, fields, locale, req, select, selectMode, user })=>{
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$calculateDefaultValues$2f$iterateFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["iterateFields"])({
        id,
        data,
        fields,
        locale,
        req,
        select,
        selectMode,
        siblingData: data,
        user
    });
    return data;
}; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/.pnpm/@payloadcms+ui@3.64.0_@types+react@19.0.1_monaco-editor@0.55.1_next@16.1.0-canary.0_rea_52870c5534abe0d1ad89657769401cbb/node_modules/@payloadcms/ui/dist/utilities/resolveFilterOptions.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "resolveFilterOptions",
    ()=>resolveFilterOptions
]);
const resolveFilterOptions = async (filterOptions, options)=>{
    const { relationTo } = options;
    const relations = Array.isArray(relationTo) ? relationTo : [
        relationTo
    ];
    const query = {};
    if (typeof filterOptions !== 'undefined') {
        await Promise.all(relations.map(async (relation)=>{
            query[relation] = typeof filterOptions === 'function' ? await filterOptions({
                ...options,
                relationTo: relation
            }) : filterOptions;
            if (query[relation] === true) {
                query[relation] = {};
            }
            // this is an ugly way to prevent results from being returned
            if (query[relation] === false) {
                query[relation] = {
                    id: {
                        exists: false
                    }
                };
            }
        }));
    }
    return query;
}; //# sourceMappingURL=resolveFilterOptions.js.map
}),
"[project]/node_modules/.pnpm/@payloadcms+ui@3.64.0_@types+react@19.0.1_monaco-editor@0.55.1_next@16.1.0-canary.0_rea_52870c5534abe0d1ad89657769401cbb/node_modules/@payloadcms/ui/dist/forms/fieldSchemasToFormState/isRowCollapsed.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isRowCollapsed",
    ()=>isRowCollapsed
]);
function isRowCollapsed({ collapsedPrefs, field, previousRow, row }) {
    if (previousRow && 'collapsed' in previousRow) {
        return previousRow.collapsed ?? false;
    }
    // If previousFormState is `undefined`, check preferences
    if (collapsedPrefs !== undefined) {
        return collapsedPrefs.includes(row.id) // Check if collapsed in preferences
        ;
    }
    // If neither exists, fallback to `field.admin.initCollapsed`
    return field.admin.initCollapsed;
} //# sourceMappingURL=isRowCollapsed.js.map
}),
"[project]/node_modules/.pnpm/@payloadcms+ui@3.64.0_@types+react@19.0.1_monaco-editor@0.55.1_next@16.1.0-canary.0_rea_52870c5534abe0d1ad89657769401cbb/node_modules/@payloadcms/ui/dist/forms/fieldSchemasToFormState/addFieldStatePromise.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addFieldStatePromise",
    ()=>addFieldStatePromise
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$bson$2d$objectid$40$2$2e$0$2e$4$2f$node_modules$2f$bson$2d$objectid$2f$objectid$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/bson-objectid@2.0.4/node_modules/bson-objectid/objectid.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$getBlockSelect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/payload@3.64.0_graphql@16.12.0_typescript@5.5.2/node_modules/payload/dist/utilities/getBlockSelect.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$stripUnselectedFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/payload@3.64.0_graphql@16.12.0_typescript@5.5.2/node_modules/payload/dist/utilities/stripUnselectedFields.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$validations$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/payload@3.64.0_graphql@16.12.0_typescript@5.5.2/node_modules/payload/dist/fields/validations.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$deepCopyObject$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/payload@3.64.0_graphql@16.12.0_typescript@5.5.2/node_modules/payload/dist/utilities/deepCopyObject.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$config$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/payload@3.64.0_graphql@16.12.0_typescript@5.5.2/node_modules/payload/dist/fields/config/types.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$getFieldPaths$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/payload@3.64.0_graphql@16.12.0_typescript@5.5.2/node_modules/payload/dist/fields/getFieldPaths.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$utilities$2f$resolveFilterOptions$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@payloadcms+ui@3.64.0_@types+react@19.0.1_monaco-editor@0.55.1_next@16.1.0-canary.0_rea_52870c5534abe0d1ad89657769401cbb/node_modules/@payloadcms/ui/dist/utilities/resolveFilterOptions.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$isRowCollapsed$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@payloadcms+ui@3.64.0_@types+react@19.0.1_monaco-editor@0.55.1_next@16.1.0-canary.0_rea_52870c5534abe0d1ad89657769401cbb/node_modules/@payloadcms/ui/dist/forms/fieldSchemasToFormState/isRowCollapsed.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$iterateFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@payloadcms+ui@3.64.0_@types+react@19.0.1_monaco-editor@0.55.1_next@16.1.0-canary.0_rea_52870c5534abe0d1ad89657769401cbb/node_modules/@payloadcms/ui/dist/forms/fieldSchemasToFormState/iterateFields.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
const ObjectId = 'default' in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$bson$2d$objectid$40$2$2e$0$2e$4$2f$node_modules$2f$bson$2d$objectid$2f$objectid$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"] ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$bson$2d$objectid$40$2$2e$0$2e$4$2f$node_modules$2f$bson$2d$objectid$2f$objectid$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].default : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$bson$2d$objectid$40$2$2e$0$2e$4$2f$node_modules$2f$bson$2d$objectid$2f$objectid$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"];
const addFieldStatePromise = async (args)=>{
    const { id, addErrorPathToParent: addErrorPathToParentArg, anyParentLocalized = false, blockData, clientFieldSchemaMap, collectionSlug, data, field, fieldSchemaMap, filter, forceFullValue = false, fullData, includeSchema = false, indexPath, mockRSCs, omitParents = false, operation, parentPath, parentPermissions, parentSchemaPath, passesCondition, path, preferences, previousFormState, readOnly, renderAllFields, renderFieldFn, req, schemaPath, select, selectMode, skipConditionChecks = false, skipValidation = false, state } = args;
    if (!args.clientFieldSchemaMap && args.renderFieldFn) {
        // eslint-disable-next-line no-console
        console.warn('clientFieldSchemaMap is not passed to addFieldStatePromise - this will reduce performance');
    }
    let fieldPermissions = true;
    const fieldState = {};
    const lastRenderedPath = previousFormState?.[path]?.lastRenderedPath;
    // Append only if true to avoid sending '$undefined' through the network
    if (lastRenderedPath) {
        fieldState.lastRenderedPath = lastRenderedPath;
    }
    // If we're rendering all fields, no need to flag this as added by server
    const addedByServer = !renderAllFields && !previousFormState?.[path];
    // Append only if true to avoid sending '$undefined' through the network
    if (addedByServer) {
        fieldState.addedByServer = true;
    }
    // Append only if true to avoid sending '$undefined' through the network
    if (passesCondition === false) {
        fieldState.passesCondition = false;
    }
    // Append only if true to avoid sending '$undefined' through the network
    if (includeSchema) {
        fieldState.fieldSchema = field;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$config$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fieldAffectsData"])(field) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$config$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fieldIsHiddenOrDisabled"])(field)) {
        fieldPermissions = parentPermissions === true ? parentPermissions : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$deepCopyObject$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepCopyObjectSimple"])(parentPermissions?.[field.name]);
        let hasPermission = fieldPermissions === true || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$deepCopyObject$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deepCopyObjectSimple"])(fieldPermissions?.read);
        if (typeof field?.access?.read === 'function') {
            hasPermission = await field.access.read({
                id,
                blockData,
                data: fullData,
                req,
                siblingData: data
            });
        } else {
            hasPermission = true;
        }
        if (!hasPermission) {
            return;
        }
        const validate = field.validate;
        let validationResult = true;
        if (typeof validate === 'function' && !skipValidation && passesCondition) {
            let jsonError;
            if (field.type === 'json' && typeof data[field.name] === 'string') {
                try {
                    JSON.parse(data[field.name]);
                } catch (e) {
                    jsonError = e;
                }
            }
            try {
                validationResult = await validate(data?.[field.name], {
                    ...field,
                    id,
                    blockData,
                    collectionSlug,
                    data: fullData,
                    event: 'onChange',
                    // @AlessioGr added `jsonError` in https://github.com/payloadcms/payload/commit/c7ea62a39473408c3ea912c4fbf73e11be4b538d
                    // @ts-expect-error-next-line
                    jsonError,
                    operation,
                    preferences,
                    previousValue: previousFormState?.[path]?.initialValue,
                    req,
                    siblingData: data
                });
            } catch (err) {
                validationResult = `Error validating field at path: ${path}`;
                req.payload.logger.error({
                    err,
                    msg: validationResult
                });
            }
        }
        /**
    * This function adds the error **path** to the current field and all its parents. If a field is invalid, all its parents are also invalid.
    * It does not add the error **message** to the current field, as that shouldn't apply to all parents.
    * This is done separately below.
    */ const addErrorPathToParent = (errorPath)=>{
            if (typeof addErrorPathToParentArg === 'function') {
                addErrorPathToParentArg(errorPath);
            }
            if (!fieldState.errorPaths) {
                fieldState.errorPaths = [];
            }
            if (!fieldState.errorPaths.includes(errorPath)) {
                fieldState.errorPaths.push(errorPath);
                fieldState.valid = false;
            }
        };
        if (typeof validationResult === 'string') {
            fieldState.errorMessage = validationResult;
            fieldState.valid = false;
            addErrorPathToParent(path);
        }
        switch(field.type){
            case 'array':
                {
                    const arrayValue = Array.isArray(data[field.name]) ? data[field.name] : [];
                    const arraySelect = select?.[field.name];
                    const { promises, rows } = arrayValue.reduce((acc, row, i)=>{
                        const parentPath = path + '.' + i;
                        row.id = row?.id || new ObjectId().toHexString();
                        if (!omitParents && (!filter || filter(args))) {
                            const idKey = parentPath + '.id';
                            state[idKey] = {
                                initialValue: row.id,
                                value: row.id
                            };
                            if (includeSchema) {
                                state[idKey].fieldSchema = field.fields.find((field)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$config$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fieldIsID"])(field));
                            }
                        }
                        acc.promises.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$iterateFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["iterateFields"])({
                            id,
                            addErrorPathToParent,
                            anyParentLocalized: field.localized || anyParentLocalized,
                            blockData,
                            clientFieldSchemaMap,
                            collectionSlug,
                            data: row,
                            fields: field.fields,
                            fieldSchemaMap,
                            filter,
                            forceFullValue,
                            fullData,
                            includeSchema,
                            mockRSCs,
                            omitParents,
                            operation,
                            parentIndexPath: '',
                            parentPassesCondition: passesCondition,
                            parentPath,
                            parentSchemaPath: schemaPath,
                            permissions: fieldPermissions === true ? fieldPermissions : fieldPermissions?.fields || {},
                            preferences,
                            previousFormState,
                            readOnly,
                            renderAllFields,
                            renderFieldFn,
                            req,
                            select: typeof arraySelect === 'object' ? arraySelect : undefined,
                            selectMode,
                            skipConditionChecks,
                            skipValidation,
                            state
                        }));
                        if (!acc.rows) {
                            acc.rows = [];
                        }
                        // First, check if `previousFormState` has a matching row
                        const previousRow = (previousFormState?.[path]?.rows || []).find((prevRow)=>prevRow.id === row.id);
                        const newRow = {
                            id: row.id,
                            isLoading: false
                        };
                        if (previousRow?.lastRenderedPath) {
                            newRow.lastRenderedPath = previousRow.lastRenderedPath;
                        }
                        // add addedByServer flag
                        if (!previousRow) {
                            newRow.addedByServer = true;
                        }
                        const isCollapsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$isRowCollapsed$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isRowCollapsed"])({
                            collapsedPrefs: preferences?.fields?.[path]?.collapsed,
                            field,
                            previousRow,
                            row
                        });
                        if (isCollapsed) {
                            newRow.collapsed = true;
                        }
                        acc.rows.push(newRow);
                        return acc;
                    }, {
                        promises: [],
                        rows: []
                    });
                    // Wait for all promises and update fields with the results
                    await Promise.all(promises);
                    if (rows) {
                        fieldState.rows = rows;
                    }
                    // Add values to field state
                    if (data[field.name] !== null) {
                        fieldState.value = forceFullValue ? arrayValue : arrayValue.length;
                        fieldState.initialValue = forceFullValue ? arrayValue : arrayValue.length;
                        if (arrayValue.length > 0) {
                            fieldState.disableFormData = true;
                        }
                    }
                    // Add field to state
                    if (!omitParents && (!filter || filter(args))) {
                        state[path] = fieldState;
                    }
                    break;
                }
            case 'blocks':
                {
                    const blocksValue = Array.isArray(data[field.name]) ? data[field.name] : [];
                    // Handle blocks filterOptions
                    let filterOptionsValidationResult = null;
                    if (field.filterOptions) {
                        filterOptionsValidationResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$validations$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["validateBlocksFilterOptions"])({
                            id,
                            data: fullData,
                            filterOptions: field.filterOptions,
                            req,
                            siblingData: data,
                            value: data[field.name]
                        });
                        fieldState.blocksFilterOptions = filterOptionsValidationResult.allowedBlockSlugs;
                    }
                    const { promises, rowMetadata } = blocksValue.reduce((acc, row, i)=>{
                        const blockTypeToMatch = row.blockType;
                        const block = req.payload.blocks[blockTypeToMatch] ?? (field.blockReferences ?? field.blocks).find((blockType)=>typeof blockType !== 'string' && blockType.slug === blockTypeToMatch);
                        if (!block) {
                            throw new Error(`Block with type "${row.blockType}" was found in block data, but no block with that type is defined in the config for field with schema path ${schemaPath}.`);
                        }
                        const { blockSelect, blockSelectMode } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$getBlockSelect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getBlockSelect"])({
                            block,
                            select: select?.[field.name],
                            selectMode
                        });
                        const parentPath = path + '.' + i;
                        if (block) {
                            row.id = row?.id || new ObjectId().toHexString();
                            if (!omitParents && (!filter || filter(args))) {
                                // Handle block `id` field
                                const idKey = parentPath + '.id';
                                state[idKey] = {
                                    initialValue: row.id,
                                    value: row.id
                                };
                                // If the blocks field fails filterOptions validation, add error paths to the individual blocks that are no longer allowed
                                if (filterOptionsValidationResult?.invalidBlockSlugs?.length && filterOptionsValidationResult.invalidBlockSlugs.includes(row.blockType)) {
                                    state[idKey].errorMessage = req.t('validation:invalidBlock', {
                                        block: row.blockType
                                    });
                                    state[idKey].valid = false;
                                    addErrorPathToParent(idKey);
                                    // If the error is due to block filterOptions, we want the blocks field (fieldState) to include all the filterOptions-related
                                    // error paths for each sub-block, not for the validation result of the block itself. Otherwise, say there are 2 invalid blocks,
                                    // the blocks field will have 3 instead of 2 error paths - one for itself, and one for each invalid block.
                                    // Instead, we want only the 2 error paths for the individual, invalid blocks.
                                    fieldState.errorPaths = fieldState.errorPaths.filter((errorPath)=>errorPath !== path);
                                }
                                if (includeSchema) {
                                    state[idKey].fieldSchema = includeSchema ? block.fields.find((blockField)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$config$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fieldIsID"])(blockField)) : undefined;
                                }
                                // Handle `blockType` field
                                const fieldKey = parentPath + '.blockType';
                                state[fieldKey] = {
                                    initialValue: row.blockType,
                                    value: row.blockType
                                };
                                if (addedByServer) {
                                    state[fieldKey].addedByServer = addedByServer;
                                }
                                if (includeSchema) {
                                    state[fieldKey].fieldSchema = block.fields.find((blockField)=>'name' in blockField && blockField.name === 'blockType');
                                }
                                // Handle `blockName` field
                                const blockNameKey = parentPath + '.blockName';
                                state[blockNameKey] = {};
                                if (row.blockName) {
                                    state[blockNameKey].initialValue = row.blockName;
                                    state[blockNameKey].value = row.blockName;
                                }
                                if (includeSchema) {
                                    state[blockNameKey].fieldSchema = block.fields.find((blockField)=>'name' in blockField && blockField.name === 'blockName');
                                }
                            }
                            acc.promises.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$iterateFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["iterateFields"])({
                                id,
                                addErrorPathToParent,
                                anyParentLocalized: field.localized || anyParentLocalized,
                                blockData: row,
                                clientFieldSchemaMap,
                                collectionSlug,
                                data: row,
                                fields: block.fields,
                                fieldSchemaMap,
                                filter,
                                forceFullValue,
                                fullData,
                                includeSchema,
                                mockRSCs,
                                omitParents,
                                operation,
                                parentIndexPath: '',
                                parentPassesCondition: passesCondition,
                                parentPath,
                                parentSchemaPath: schemaPath + '.' + block.slug,
                                permissions: fieldPermissions === true ? fieldPermissions : parentPermissions?.[field.name]?.blocks?.[block.slug] === true ? true : parentPermissions?.[field.name]?.blocks?.[block.slug]?.fields || {},
                                preferences,
                                previousFormState,
                                readOnly,
                                renderAllFields,
                                renderFieldFn,
                                req,
                                select: typeof blockSelect === 'object' ? blockSelect : undefined,
                                selectMode: blockSelectMode,
                                skipConditionChecks,
                                skipValidation,
                                state
                            }));
                            // First, check if `previousFormState` has a matching row
                            const previousRow = (previousFormState?.[path]?.rows || []).find((prevRow)=>prevRow.id === row.id);
                            const newRow = {
                                id: row.id,
                                blockType: row.blockType,
                                isLoading: false
                            };
                            if (previousRow?.lastRenderedPath) {
                                newRow.lastRenderedPath = previousRow.lastRenderedPath;
                            }
                            acc.rowMetadata.push(newRow);
                            const isCollapsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$isRowCollapsed$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isRowCollapsed"])({
                                collapsedPrefs: preferences?.fields?.[path]?.collapsed,
                                field,
                                previousRow,
                                row
                            });
                            if (isCollapsed) {
                                acc.rowMetadata[acc.rowMetadata.length - 1].collapsed = true;
                            }
                        }
                        return acc;
                    }, {
                        promises: [],
                        rowMetadata: []
                    });
                    await Promise.all(promises);
                    // Add values to field state
                    if (data[field.name] === null) {
                        fieldState.value = null;
                        fieldState.initialValue = null;
                    } else {
                        fieldState.value = forceFullValue ? blocksValue : blocksValue.length;
                        fieldState.initialValue = forceFullValue ? blocksValue : blocksValue.length;
                        if (blocksValue.length > 0) {
                            fieldState.disableFormData = true;
                        }
                    }
                    fieldState.rows = rowMetadata;
                    // Add field to state
                    if (!omitParents && (!filter || filter(args))) {
                        state[path] = fieldState;
                    }
                    break;
                }
            case 'group':
                {
                    if (!filter || filter(args)) {
                        fieldState.disableFormData = true;
                        state[path] = fieldState;
                    }
                    const groupSelect = select?.[field.name];
                    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$iterateFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["iterateFields"])({
                        id,
                        addErrorPathToParent,
                        anyParentLocalized: field.localized || anyParentLocalized,
                        blockData,
                        clientFieldSchemaMap,
                        collectionSlug,
                        data: data?.[field.name] || {},
                        fields: field.fields,
                        fieldSchemaMap,
                        filter,
                        forceFullValue,
                        fullData,
                        includeSchema,
                        mockRSCs,
                        omitParents,
                        operation,
                        parentIndexPath: '',
                        parentPassesCondition: passesCondition,
                        parentPath: path,
                        parentSchemaPath: schemaPath,
                        permissions: typeof fieldPermissions === 'boolean' ? fieldPermissions : fieldPermissions?.fields,
                        preferences,
                        previousFormState,
                        readOnly,
                        renderAllFields,
                        renderFieldFn,
                        req,
                        select: typeof groupSelect === 'object' ? groupSelect : undefined,
                        selectMode,
                        skipConditionChecks,
                        skipValidation,
                        state
                    });
                    break;
                }
            case 'relationship':
            case 'upload':
                {
                    if (field.filterOptions) {
                        if (typeof field.filterOptions === 'object') {
                            if (typeof field.relationTo === 'string') {
                                fieldState.filterOptions = {
                                    [field.relationTo]: field.filterOptions
                                };
                            } else {
                                fieldState.filterOptions = field.relationTo.reduce((acc, relation)=>{
                                    acc[relation] = field.filterOptions;
                                    return acc;
                                }, {});
                            }
                        }
                        if (typeof field.filterOptions === 'function') {
                            const query = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$utilities$2f$resolveFilterOptions$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveFilterOptions"])(field.filterOptions, {
                                id,
                                blockData,
                                data: fullData,
                                relationTo: field.relationTo,
                                req,
                                siblingData: data,
                                user: req.user
                            });
                            fieldState.filterOptions = query;
                        }
                    }
                    if (field.hasMany) {
                        const relationshipValue = Array.isArray(data[field.name]) ? data[field.name].map((relationship)=>{
                            if (Array.isArray(field.relationTo)) {
                                return {
                                    relationTo: relationship.relationTo,
                                    value: relationship.value && typeof relationship.value === 'object' ? relationship.value?.id : relationship.value
                                };
                            }
                            if (typeof relationship === 'object' && relationship !== null) {
                                return relationship.id;
                            }
                            return relationship;
                        }) : undefined;
                        fieldState.value = relationshipValue;
                        fieldState.initialValue = relationshipValue;
                    } else if (Array.isArray(field.relationTo)) {
                        if (data[field.name] && typeof data[field.name] === 'object' && 'relationTo' in data[field.name] && 'value' in data[field.name]) {
                            const value = typeof data[field.name]?.value === 'object' && data[field.name]?.value && 'id' in data[field.name].value ? data[field.name].value.id : data[field.name].value;
                            const relationshipValue = {
                                relationTo: data[field.name]?.relationTo,
                                value
                            };
                            fieldState.value = relationshipValue;
                            fieldState.initialValue = relationshipValue;
                        }
                    } else {
                        const relationshipValue = data[field.name] && typeof data[field.name] === 'object' && 'id' in data[field.name] ? data[field.name].id : data[field.name];
                        fieldState.value = relationshipValue;
                        fieldState.initialValue = relationshipValue;
                    }
                    if (!filter || filter(args)) {
                        state[path] = fieldState;
                    }
                    break;
                }
            case 'select':
                {
                    if (typeof field.filterOptions === 'function') {
                        fieldState.selectFilterOptions = field.filterOptions({
                            data: fullData,
                            options: field.options,
                            req,
                            siblingData: data
                        });
                    }
                    if (data[field.name] !== undefined) {
                        fieldState.value = data[field.name];
                        fieldState.initialValue = data[field.name];
                    }
                    if (!filter || filter(args)) {
                        state[path] = fieldState;
                    }
                    break;
                }
            default:
                {
                    if (data[field.name] !== undefined) {
                        fieldState.value = data[field.name];
                        fieldState.initialValue = data[field.name];
                    }
                    // Add field to state
                    if (!filter || filter(args)) {
                        state[path] = fieldState;
                    }
                    break;
                }
        }
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$config$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fieldHasSubFields"])(field) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$config$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fieldAffectsData"])(field)) {
        // Handle field types that do not use names (row, collapsible, unnamed group etc)
        if (!filter || filter(args)) {
            state[path] = {
                disableFormData: true
            };
            if (passesCondition === false) {
                state[path].passesCondition = false;
            }
        }
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$iterateFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["iterateFields"])({
            id,
            mockRSCs,
            select,
            selectMode,
            // passthrough parent functionality
            addErrorPathToParent: addErrorPathToParentArg,
            anyParentLocalized: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$config$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fieldIsLocalized"])(field) || anyParentLocalized,
            blockData,
            clientFieldSchemaMap,
            collectionSlug,
            data,
            fields: field.fields,
            fieldSchemaMap,
            filter,
            forceFullValue,
            fullData,
            includeSchema,
            omitParents,
            operation,
            parentIndexPath: indexPath,
            parentPassesCondition: passesCondition,
            parentPath,
            parentSchemaPath,
            permissions: parentPermissions,
            preferences,
            previousFormState,
            readOnly,
            renderAllFields,
            renderFieldFn,
            req,
            skipConditionChecks,
            skipValidation,
            state
        });
    } else if (field.type === 'tabs') {
        const promises = field.tabs.map((tab, tabIndex)=>{
            const isNamedTab = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$config$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["tabHasName"])(tab);
            let tabSelect;
            const tabField = {
                ...tab,
                type: 'tab'
            };
            const { indexPath: tabIndexPath, path: tabPath, schemaPath: tabSchemaPath } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$getFieldPaths$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getFieldPaths"])({
                field: tabField,
                index: tabIndex,
                parentIndexPath: indexPath,
                parentPath,
                parentSchemaPath
            });
            let childPermissions = undefined;
            if (isNamedTab) {
                const shouldContinue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$stripUnselectedFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["stripUnselectedFields"])({
                    field: tabField,
                    select,
                    selectMode,
                    siblingDoc: data?.[tab.name] || {}
                });
                if (!shouldContinue) {
                    return;
                }
                if (parentPermissions === true) {
                    childPermissions = true;
                } else {
                    const tabPermissions = parentPermissions?.[tab.name];
                    if (tabPermissions === true) {
                        childPermissions = true;
                    } else {
                        childPermissions = tabPermissions?.fields;
                    }
                }
                if (typeof select?.[tab.name] === 'object') {
                    tabSelect = select?.[tab.name];
                }
            } else {
                childPermissions = parentPermissions;
                tabSelect = select;
            }
            const pathSegments = path ? path.split('.') : [];
            // If passesCondition is false then this should always result to false
            // If the tab has no admin.condition provided then fallback to passesCondition and let that decide the result
            let tabPassesCondition = passesCondition;
            if (passesCondition && typeof tab.admin?.condition === 'function') {
                tabPassesCondition = tab.admin.condition(fullData, data, {
                    blockData,
                    operation,
                    path: pathSegments,
                    user: req.user
                });
            }
            if (tab?.id) {
                state[tab.id] = {
                    passesCondition: tabPassesCondition
                };
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$iterateFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["iterateFields"])({
                id,
                addErrorPathToParent: addErrorPathToParentArg,
                anyParentLocalized: tab.localized || anyParentLocalized,
                blockData,
                clientFieldSchemaMap,
                collectionSlug,
                data: isNamedTab ? data?.[tab.name] || {} : data,
                fields: tab.fields,
                fieldSchemaMap,
                filter,
                forceFullValue,
                fullData,
                includeSchema,
                mockRSCs,
                omitParents,
                operation,
                parentIndexPath: isNamedTab ? '' : tabIndexPath,
                parentPassesCondition: tabPassesCondition,
                parentPath: isNamedTab ? tabPath : parentPath,
                parentSchemaPath: isNamedTab ? tabSchemaPath : parentSchemaPath,
                permissions: childPermissions,
                preferences,
                previousFormState,
                readOnly,
                renderAllFields,
                renderFieldFn,
                req,
                select: tabSelect,
                selectMode,
                skipConditionChecks,
                skipValidation,
                state
            });
        });
        await Promise.all(promises);
    } else if (field.type === 'ui') {
        if (!filter || filter(args)) {
            state[path] = fieldState;
            state[path].disableFormData = true;
        }
    }
    if (renderFieldFn && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$config$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fieldIsHiddenOrDisabled"])(field)) {
        const fieldConfig = fieldSchemaMap.get(schemaPath);
        if (!fieldConfig && !mockRSCs) {
            if (schemaPath.endsWith('.blockType')) {
                return;
            } else {
                throw new Error(`Field config not found for ${schemaPath}`);
            }
        }
        if (!state[path]) {
            // Some fields (ie `Tab`) do not live in form state
            // therefore we cannot attach customComponents to them
            return;
        }
        if (addedByServer) {
            state[path].addedByServer = addedByServer;
        }
        renderFieldFn({
            id,
            clientFieldSchemaMap,
            collectionSlug,
            data: fullData,
            fieldConfig: fieldConfig,
            fieldSchemaMap,
            fieldState: state[path],
            formState: state,
            indexPath,
            lastRenderedPath,
            mockRSCs,
            operation,
            parentPath,
            parentSchemaPath,
            path,
            permissions: fieldPermissions,
            preferences,
            previousFieldState: previousFormState?.[path],
            readOnly,
            renderAllFields,
            req,
            schemaPath,
            siblingData: data
        });
    }
}; //# sourceMappingURL=addFieldStatePromise.js.map
}),
"[project]/node_modules/.pnpm/@payloadcms+ui@3.64.0_@types+react@19.0.1_monaco-editor@0.55.1_next@16.1.0-canary.0_rea_52870c5534abe0d1ad89657769401cbb/node_modules/@payloadcms/ui/dist/forms/fieldSchemasToFormState/iterateFields.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "iterateFields",
    ()=>iterateFields
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$stripUnselectedFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/payload@3.64.0_graphql@16.12.0_typescript@5.5.2/node_modules/payload/dist/utilities/stripUnselectedFields.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$getFieldPaths$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/payload@3.64.0_graphql@16.12.0_typescript@5.5.2/node_modules/payload/dist/fields/getFieldPaths.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$addFieldStatePromise$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@payloadcms+ui@3.64.0_@types+react@19.0.1_monaco-editor@0.55.1_next@16.1.0-canary.0_rea_52870c5534abe0d1ad89657769401cbb/node_modules/@payloadcms/ui/dist/forms/fieldSchemasToFormState/addFieldStatePromise.js [app-rsc] (ecmascript)");
;
;
;
const iterateFields = async ({ id, addErrorPathToParent: addErrorPathToParentArg, anyParentLocalized = false, blockData, clientFieldSchemaMap, collectionSlug, data, fields, fieldSchemaMap, filter, forceFullValue = false, fullData, includeSchema = false, mockRSCs, omitParents = false, operation, parentIndexPath, parentPassesCondition = true, parentPath, parentSchemaPath, permissions, preferences, previousFormState, readOnly, renderAllFields, renderFieldFn: renderFieldFn, req, select, selectMode, skipConditionChecks = false, skipValidation = false, state = {} })=>{
    const promises = [];
    fields.forEach((field, fieldIndex)=>{
        let passesCondition = true;
        const { indexPath, path, schemaPath } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$getFieldPaths$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getFieldPaths"])({
            field,
            index: fieldIndex,
            parentIndexPath: 'name' in field ? '' : parentIndexPath,
            parentPath,
            parentSchemaPath
        });
        if (path !== 'id') {
            const shouldContinue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$stripUnselectedFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["stripUnselectedFields"])({
                field,
                select,
                selectMode,
                siblingDoc: data
            });
            if (!shouldContinue) {
                return;
            }
        }
        const pathSegments = path ? path.split('.') : [];
        if (!skipConditionChecks) {
            try {
                passesCondition = Boolean((field?.admin?.condition ? Boolean(field.admin.condition(fullData || {}, data || {}, {
                    blockData,
                    operation,
                    path: pathSegments,
                    user: req.user
                })) : true) && parentPassesCondition);
            } catch (err) {
                passesCondition = false;
                req.payload.logger.error({
                    err,
                    msg: `Error evaluating field condition at path: ${path}`
                });
            }
        }
        promises.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$addFieldStatePromise$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addFieldStatePromise"])({
            id,
            addErrorPathToParent: addErrorPathToParentArg,
            anyParentLocalized,
            blockData,
            clientFieldSchemaMap,
            collectionSlug,
            data,
            field,
            fieldIndex,
            fieldSchemaMap,
            filter,
            forceFullValue,
            fullData,
            includeSchema,
            indexPath,
            mockRSCs,
            omitParents,
            operation,
            parentIndexPath,
            parentPath,
            parentPermissions: permissions,
            parentSchemaPath,
            passesCondition,
            path,
            preferences,
            previousFormState,
            readOnly,
            renderAllFields,
            renderFieldFn,
            req,
            schemaPath,
            select,
            selectMode,
            skipConditionChecks,
            skipValidation,
            state
        }));
    });
    await Promise.all(promises);
}; //# sourceMappingURL=iterateFields.js.map
}),
"[project]/node_modules/.pnpm/@payloadcms+ui@3.64.0_@types+react@19.0.1_monaco-editor@0.55.1_next@16.1.0-canary.0_rea_52870c5534abe0d1ad89657769401cbb/node_modules/@payloadcms/ui/dist/forms/fieldSchemasToFormState/index.js [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fieldSchemasToFormState",
    ()=>fieldSchemasToFormState
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$calculateDefaultValues$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@payloadcms+ui@3.64.0_@types+react@19.0.1_monaco-editor@0.55.1_next@16.1.0-canary.0_rea_52870c5534abe0d1ad89657769401cbb/node_modules/@payloadcms/ui/dist/forms/fieldSchemasToFormState/calculateDefaultValues/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$iterateFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@payloadcms+ui@3.64.0_@types+react@19.0.1_monaco-editor@0.55.1_next@16.1.0-canary.0_rea_52870c5534abe0d1ad89657769401cbb/node_modules/@payloadcms/ui/dist/forms/fieldSchemasToFormState/iterateFields.js [app-rsc] (ecmascript)");
;
;
const fieldSchemasToFormState = async ({ id, clientFieldSchemaMap, collectionSlug, data = {}, documentData, fields, fieldSchemaMap, initialBlockData, mockRSCs, operation, permissions, preferences, previousFormState, readOnly, renderAllFields, renderFieldFn, req, schemaPath, select, selectMode, skipValidation })=>{
    if (!clientFieldSchemaMap && renderFieldFn) {
        // eslint-disable-next-line no-console
        console.warn('clientFieldSchemaMap is not passed to fieldSchemasToFormState - this will reduce performance');
    }
    if (fields && fields.length) {
        const state = {};
        const dataWithDefaultValues = {
            ...data
        };
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$calculateDefaultValues$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["calculateDefaultValues"])({
            id,
            data: dataWithDefaultValues,
            fields,
            locale: req.locale,
            req,
            select,
            selectMode,
            siblingData: dataWithDefaultValues,
            user: req.user
        });
        let fullData = dataWithDefaultValues;
        if (documentData) {
            // By the time this function is used to get form state for nested forms, their default values should have already been calculated
            // => no need to run calculateDefaultValues here
            fullData = documentData;
        }
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$payloadcms$2b$ui$40$3$2e$64$2e$0_$40$types$2b$react$40$19$2e$0$2e$1_monaco$2d$editor$40$0$2e$55$2e$1_next$40$16$2e$1$2e$0$2d$canary$2e$0_rea_52870c5534abe0d1ad89657769401cbb$2f$node_modules$2f40$payloadcms$2f$ui$2f$dist$2f$forms$2f$fieldSchemasToFormState$2f$iterateFields$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["iterateFields"])({
            id,
            addErrorPathToParent: null,
            blockData: initialBlockData,
            clientFieldSchemaMap,
            collectionSlug,
            data: dataWithDefaultValues,
            fields,
            fieldSchemaMap,
            fullData,
            mockRSCs,
            operation,
            parentIndexPath: '',
            parentPassesCondition: true,
            parentPath: '',
            parentSchemaPath: schemaPath,
            permissions,
            preferences,
            previousFormState,
            readOnly,
            renderAllFields,
            renderFieldFn,
            req,
            select,
            selectMode,
            skipValidation,
            state
        });
        return state;
    }
    return {};
};
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/.pnpm/@payloadcms+ui@3.64.0_@types+react@19.0.1_monaco-editor@0.55.1_next@16.1.0-canary.0_rea_52870c5534abe0d1ad89657769401cbb/node_modules/@payloadcms/ui/dist/utilities/buildFieldSchemaMap/traverseFields.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "traverseFields",
    ()=>traverseFields
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$errors$2f$MissingEditorProp$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/payload@3.64.0_graphql@16.12.0_typescript@5.5.2/node_modules/payload/dist/errors/MissingEditorProp.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$config$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/payload@3.64.0_graphql@16.12.0_typescript@5.5.2/node_modules/payload/dist/fields/config/types.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$getFieldPaths$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/payload@3.64.0_graphql@16.12.0_typescript@5.5.2/node_modules/payload/dist/fields/getFieldPaths.js [app-rsc] (ecmascript)");
;
;
const traverseFields = ({ config, fields, i18n, parentIndexPath, parentSchemaPath, schemaMap })=>{
    for (const [index, field] of fields.entries()){
        const { indexPath, schemaPath } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$getFieldPaths$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getFieldPaths"])({
            field,
            index,
            parentIndexPath: 'name' in field ? '' : parentIndexPath,
            parentPath: '',
            parentSchemaPath
        });
        schemaMap.set(schemaPath, field);
        switch(field.type){
            case 'array':
                traverseFields({
                    config,
                    fields: field.fields,
                    i18n,
                    parentIndexPath: '',
                    parentSchemaPath: schemaPath,
                    schemaMap
                });
                break;
            case 'blocks':
                ;
                (field.blockReferences ?? field.blocks).map((_block)=>{
                    // TODO: iterate over blocks mapped to block slug in v4, or pass through payload.blocks
                    const block = typeof _block === 'string' ? config.blocks.find((b)=>b.slug === _block) : _block;
                    const blockSchemaPath = `${schemaPath}.${block.slug}`;
                    schemaMap.set(blockSchemaPath, block);
                    traverseFields({
                        config,
                        fields: block.fields,
                        i18n,
                        parentIndexPath: '',
                        parentSchemaPath: blockSchemaPath,
                        schemaMap
                    });
                });
                break;
            case 'collapsible':
            case 'row':
                traverseFields({
                    config,
                    fields: field.fields,
                    i18n,
                    parentIndexPath: indexPath,
                    parentSchemaPath,
                    schemaMap
                });
                break;
            case 'group':
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$config$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fieldAffectsData"])(field)) {
                    traverseFields({
                        config,
                        fields: field.fields,
                        i18n,
                        parentIndexPath: '',
                        parentSchemaPath: schemaPath,
                        schemaMap
                    });
                } else {
                    traverseFields({
                        config,
                        fields: field.fields,
                        i18n,
                        parentIndexPath: indexPath,
                        parentSchemaPath,
                        schemaMap
                    });
                }
                break;
            case 'richText':
                if (!field?.editor) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$errors$2f$MissingEditorProp$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["MissingEditorProp"](field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor
                    ;
                }
                if (typeof field.editor === 'function') {
                    throw new Error('Attempted to access unsanitized rich text editor.');
                }
                if (typeof field.editor.generateSchemaMap === 'function') {
                    field.editor.generateSchemaMap({
                        config,
                        field,
                        i18n,
                        schemaMap,
                        schemaPath
                    });
                }
                break;
            case 'tabs':
                field.tabs.map((tab, tabIndex)=>{
                    const isNamedTab = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$config$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["tabHasName"])(tab);
                    const { indexPath: tabIndexPath, schemaPath: tabSchemaPath } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$fields$2f$getFieldPaths$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getFieldPaths"])({
                        field: {
                            ...tab,
                            type: 'tab'
                        },
                        index: tabIndex,
                        parentIndexPath: indexPath,
                        parentPath: '',
                        parentSchemaPath
                    });
                    schemaMap.set(tabSchemaPath, tab);
                    traverseFields({
                        config,
                        fields: tab.fields,
                        i18n,
                        parentIndexPath: isNamedTab ? '' : tabIndexPath,
                        parentSchemaPath: isNamedTab ? tabSchemaPath : parentSchemaPath,
                        schemaMap
                    });
                });
                break;
        }
    }
}; //# sourceMappingURL=traverseFields.js.map
}),
"[project]/node_modules/.pnpm/@lexical+list@0.35.0/node_modules/@lexical/list/LexicalList.dev.mjs [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "$createListItemNode",
    ()=>$createListItemNode,
    "$createListNode",
    ()=>$createListNode,
    "$getListDepth",
    ()=>$getListDepth,
    "$handleListInsertParagraph",
    ()=>$handleListInsertParagraph,
    "$insertList",
    ()=>$insertList,
    "$isListItemNode",
    ()=>$isListItemNode,
    "$isListNode",
    ()=>$isListNode,
    "$removeList",
    ()=>$removeList,
    "INSERT_CHECK_LIST_COMMAND",
    ()=>INSERT_CHECK_LIST_COMMAND,
    "INSERT_ORDERED_LIST_COMMAND",
    ()=>INSERT_ORDERED_LIST_COMMAND,
    "INSERT_UNORDERED_LIST_COMMAND",
    ()=>INSERT_UNORDERED_LIST_COMMAND,
    "ListItemNode",
    ()=>ListItemNode,
    "ListNode",
    ()=>ListNode,
    "REMOVE_LIST_COMMAND",
    ()=>REMOVE_LIST_COMMAND,
    "UPDATE_LIST_START_COMMAND",
    ()=>UPDATE_LIST_START_COMMAND,
    "insertList",
    ()=>insertList,
    "registerCheckList",
    ()=>registerCheckList,
    "registerList",
    ()=>registerList,
    "registerListStrictIndentTransform",
    ()=>registerListStrictIndentTransform,
    "removeList",
    ()=>removeList
]);
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@lexical+utils@0.35.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/lexical@0.35.0/node_modules/lexical/Lexical.dev.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$selection$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$selection$2f$LexicalSelection$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@lexical+selection@0.35.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs [app-rsc] (ecmascript) <locals>");
;
;
;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ // Do not require this module directly! Use normal `invariant` calls.
function formatDevErrorMessage(message) {
    throw new Error(message);
}
/**
 * Checks the depth of listNode from the root node.
 * @param listNode - The ListNode to be checked.
 * @returns The depth of the ListNode.
 */ function $getListDepth(listNode) {
    let depth = 1;
    let parent = listNode.getParent();
    while(parent != null){
        if ($isListItemNode(parent)) {
            const parentList = parent.getParent();
            if ($isListNode(parentList)) {
                depth++;
                parent = parentList.getParent();
                continue;
            }
            {
                formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);
            }
        }
        return depth;
    }
    return depth;
}
/**
 * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.
 * @param listItem - The node to be checked.
 * @returns The ListNode found.
 */ function $getTopListNode(listItem) {
    let list = listItem.getParent();
    if (!$isListNode(list)) {
        {
            formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);
        }
    }
    let parent = list;
    while(parent !== null){
        parent = parent.getParent();
        if ($isListNode(parent)) {
            list = parent;
        }
    }
    return list;
}
/**
 * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children
 * that are of type ListItemNode and returns them in an array.
 * @param node - The ListNode to start the search.
 * @returns An array containing all nodes of type ListItemNode found.
 */ // This should probably be $getAllChildrenOfType
function $getAllListItems(node) {
    let listItemNodes = [];
    const listChildren = node.getChildren().filter($isListItemNode);
    for(let i = 0; i < listChildren.length; i++){
        const listItemNode = listChildren[i];
        const firstChild = listItemNode.getFirstChild();
        if ($isListNode(firstChild)) {
            listItemNodes = listItemNodes.concat($getAllListItems(firstChild));
        } else {
            listItemNodes.push(listItemNode);
        }
    }
    return listItemNodes;
}
/**
 * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.
 * @param node - The node to be checked.
 * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.
 */ function isNestedListNode(node) {
    return $isListItemNode(node) && $isListNode(node.getFirstChild());
}
/**
 * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first
 * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially
 * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.
 * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().
 * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.
 */ function $removeHighestEmptyListParent(sublist) {
    // Nodes may be repeatedly indented, to create deeply nested lists that each
    // contain just one bullet.
    // Our goal is to remove these (empty) deeply nested lists. The easiest
    // way to do that is crawl back up the tree until we find a node that has siblings
    // (e.g. is actually part of the list contents) and delete that, or delete
    // the root of the list (if no list nodes have siblings.)
    let emptyListPtr = sublist;
    while(emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null){
        const parent = emptyListPtr.getParent();
        if (parent == null || !($isListItemNode(parent) || $isListNode(parent))) {
            break;
        }
        emptyListPtr = parent;
    }
    emptyListPtr.remove();
}
/**
 * Wraps a node into a ListItemNode.
 * @param node - The node to be wrapped into a ListItemNode
 * @returns The ListItemNode which the passed node is wrapped in.
 */ function $wrapInListItem(node) {
    const listItemWrapper = $createListItemNode();
    return listItemWrapper.append(node);
}
function $isSelectingEmptyListItem(anchorNode, nodes) {
    return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);
}
/**
 * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of
 * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.
 * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.
 * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,
 * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with
 * a new ListNode, or create a new ListNode at the nearest root/shadow root.
 * @param listType - The type of list, "number" | "bullet" | "check".
 */ function $insertList(listType) {
    const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
    if (selection !== null) {
        let nodes = selection.getNodes();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            const anchorAndFocus = selection.getStartEndPoints();
            if (!(anchorAndFocus !== null)) {
                formatDevErrorMessage(`insertList: anchor should be defined`);
            }
            const [anchor] = anchorAndFocus;
            const anchorNode = anchor.getNode();
            const anchorNodeParent = anchorNode.getParent();
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRootOrShadowRoot"])(anchorNode)) {
                const firstChild = anchorNode.getFirstChild();
                if (firstChild) {
                    nodes = firstChild.selectStart().getNodes();
                } else {
                    const paragraph = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createParagraphNode"])();
                    anchorNode.append(paragraph);
                    nodes = paragraph.select().getNodes();
                }
            } else if ($isSelectingEmptyListItem(anchorNode, nodes)) {
                const list = $createListNode(listType);
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRootOrShadowRoot"])(anchorNodeParent)) {
                    anchorNode.replace(list);
                    const listItem = $createListItemNode();
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(anchorNode)) {
                        listItem.setFormat(anchorNode.getFormatType());
                        listItem.setIndent(anchorNode.getIndent());
                    }
                    list.append(listItem);
                } else if ($isListItemNode(anchorNode)) {
                    const parent = anchorNode.getParentOrThrow();
                    append(list, parent.getChildren());
                    parent.replace(list);
                }
                return;
            }
        }
        const handled = new Set();
        for(let i = 0; i < nodes.length; i++){
            const node = nodes[i];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {
                $createListOrMerge(node, listType);
                continue;
            }
            let parent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isLeafNode"])(node) ? node.getParent() : $isListItemNode(node) && node.isEmpty() ? node : null;
            while(parent != null){
                const parentKey = parent.getKey();
                if ($isListNode(parent)) {
                    if (!handled.has(parentKey)) {
                        const newListNode = $createListNode(listType);
                        append(newListNode, parent.getChildren());
                        parent.replace(newListNode);
                        handled.add(parentKey);
                    }
                    break;
                } else {
                    const nextParent = parent.getParent();
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRootOrShadowRoot"])(nextParent) && !handled.has(parentKey)) {
                        handled.add(parentKey);
                        $createListOrMerge(parent, listType);
                        break;
                    }
                    parent = nextParent;
                }
            }
        }
    }
}
function append(node, nodesToAppend) {
    node.splice(node.getChildrenSize(), 0, nodesToAppend);
}
function $createListOrMerge(node, listType) {
    if ($isListNode(node)) {
        return node;
    }
    const previousSibling = node.getPreviousSibling();
    const nextSibling = node.getNextSibling();
    const listItem = $createListItemNode();
    append(listItem, node.getChildren());
    let targetList;
    if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {
        previousSibling.append(listItem);
        // if the same type of list is on both sides, merge them.
        if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {
            append(previousSibling, nextSibling.getChildren());
            nextSibling.remove();
        }
        targetList = previousSibling;
    } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {
        nextSibling.getFirstChildOrThrow().insertBefore(listItem);
        targetList = nextSibling;
    } else {
        const list = $createListNode(listType);
        list.append(listItem);
        node.replace(list);
        targetList = list;
    }
    // listItem needs to be attached to root prior to setting indent
    listItem.setFormat(node.getFormatType());
    listItem.setIndent(node.getIndent());
    node.remove();
    return targetList;
}
/**
 * A recursive function that goes through each list and their children, including nested lists,
 * appending list2 children after list1 children and updating ListItemNode values.
 * @param list1 - The first list to be merged.
 * @param list2 - The second list to be merged.
 */ function mergeLists(list1, list2) {
    const listItem1 = list1.getLastChild();
    const listItem2 = list2.getFirstChild();
    if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {
        mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());
        listItem2.remove();
    }
    const toMerge = list2.getChildren();
    if (toMerge.length > 0) {
        list1.append(...toMerge);
    }
    list2.remove();
}
/**
 * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode
 * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,
 * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node
 * inside a ListItemNode will be appended to the new ParagraphNodes.
 */ function $removeList() {
    const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
        const listNodes = new Set();
        const nodes = selection.getNodes();
        const anchorNode = selection.anchor.getNode();
        if ($isSelectingEmptyListItem(anchorNode, nodes)) {
            listNodes.add($getTopListNode(anchorNode));
        } else {
            for(let i = 0; i < nodes.length; i++){
                const node = nodes[i];
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isLeafNode"])(node)) {
                    const listItemNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["$getNearestNodeOfType"])(node, ListItemNode);
                    if (listItemNode != null) {
                        listNodes.add($getTopListNode(listItemNode));
                    }
                }
            }
        }
        for (const listNode of listNodes){
            let insertionPoint = listNode;
            const listItems = $getAllListItems(listNode);
            for (const listItemNode of listItems){
                const paragraph = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createParagraphNode"])().setTextStyle(selection.style).setTextFormat(selection.format);
                append(paragraph, listItemNode.getChildren());
                insertionPoint.insertAfter(paragraph);
                insertionPoint = paragraph;
                // When the anchor and focus fall on the textNode
                // we don't have to change the selection because the textNode will be appended to
                // the newly generated paragraph.
                // When selection is in empty nested list item, selection is actually on the listItemNode.
                // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph
                // we should manually set the selection's focus and anchor to the newly generated paragraph.
                if (listItemNode.__key === selection.anchor.key) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$setPointFromCaret"])(selection.anchor, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$normalizeCaret"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getChildCaret"])(paragraph, 'next')));
                }
                if (listItemNode.__key === selection.focus.key) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$setPointFromCaret"])(selection.focus, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$normalizeCaret"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getChildCaret"])(paragraph, 'next')));
                }
                listItemNode.remove();
            }
            listNode.remove();
        }
    }
}
/**
 * Takes the value of a child ListItemNode and makes it the value the ListItemNode
 * should be if it isn't already. Also ensures that checked is undefined if the
 * parent does not have a list type of 'check'.
 * @param list - The list whose children are updated.
 */ function updateChildrenListItemValue(list) {
    const isNotChecklist = list.getListType() !== 'check';
    let value = list.getStart();
    for (const child of list.getChildren()){
        if ($isListItemNode(child)) {
            if (child.getValue() !== value) {
                child.setValue(value);
            }
            if (isNotChecklist && child.getLatest().__checked != null) {
                child.setChecked(undefined);
            }
            if (!$isListNode(child.getFirstChild())) {
                value++;
            }
        }
    }
}
/**
 * Merge the next sibling list if same type.
 * <ul> will merge with <ul>, but NOT <ul> with <ol>.
 * @param list - The list whose next sibling should be potentially merged
 */ function mergeNextSiblingListIfSameType(list) {
    const nextSibling = list.getNextSibling();
    if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {
        mergeLists(list, nextSibling);
    }
}
/**
 * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to
 * create an indent effect. Won't indent ListItemNodes that have a ListNode as
 * a child, but does merge sibling ListItemNodes if one has a nested ListNode.
 * @param listItemNode - The ListItemNode to be indented.
 */ function $handleIndent(listItemNode) {
    // go through each node and decide where to move it.
    const removed = new Set();
    if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {
        return;
    }
    const parent = listItemNode.getParent();
    // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards
    const nextSibling = listItemNode.getNextSibling();
    const previousSibling = listItemNode.getPreviousSibling();
    // if there are nested lists on either side, merge them all together.
    if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {
        const innerList = previousSibling.getFirstChild();
        if ($isListNode(innerList)) {
            innerList.append(listItemNode);
            const nextInnerList = nextSibling.getFirstChild();
            if ($isListNode(nextInnerList)) {
                const children = nextInnerList.getChildren();
                append(innerList, children);
                nextSibling.remove();
                removed.add(nextSibling.getKey());
            }
        }
    } else if (isNestedListNode(nextSibling)) {
        // if the ListItemNode is next to a nested ListNode, merge them
        const innerList = nextSibling.getFirstChild();
        if ($isListNode(innerList)) {
            const firstChild = innerList.getFirstChild();
            if (firstChild !== null) {
                firstChild.insertBefore(listItemNode);
            }
        }
    } else if (isNestedListNode(previousSibling)) {
        const innerList = previousSibling.getFirstChild();
        if ($isListNode(innerList)) {
            innerList.append(listItemNode);
        }
    } else {
        // otherwise, we need to create a new nested ListNode
        if ($isListNode(parent)) {
            const newListItem = $createListItemNode().setTextFormat(listItemNode.getTextFormat()).setTextStyle(listItemNode.getTextStyle());
            const newList = $createListNode(parent.getListType()).setTextFormat(parent.getTextFormat()).setTextStyle(parent.getTextStyle());
            newListItem.append(newList);
            newList.append(listItemNode);
            if (previousSibling) {
                previousSibling.insertAfter(newListItem);
            } else if (nextSibling) {
                nextSibling.insertBefore(newListItem);
            } else {
                parent.append(newListItem);
            }
        }
    }
}
/**
 * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode
 * has a great grandparent node of type ListNode, which is where the ListItemNode will reside
 * within as a child.
 * @param listItemNode - The ListItemNode to remove the indent (outdent).
 */ function $handleOutdent(listItemNode) {
    // go through each node and decide where to move it.
    if (isNestedListNode(listItemNode)) {
        return;
    }
    const parentList = listItemNode.getParent();
    const grandparentListItem = parentList ? parentList.getParent() : undefined;
    const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;
    // If it doesn't have these ancestors, it's not indented.
    if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {
        // if it's the first child in it's parent list, insert it into the
        // great grandparent list before the grandparent
        const firstChild = parentList ? parentList.getFirstChild() : undefined;
        const lastChild = parentList ? parentList.getLastChild() : undefined;
        if (listItemNode.is(firstChild)) {
            grandparentListItem.insertBefore(listItemNode);
            if (parentList.isEmpty()) {
                grandparentListItem.remove();
            }
        // if it's the last child in it's parent list, insert it into the
        // great grandparent list after the grandparent.
        } else if (listItemNode.is(lastChild)) {
            grandparentListItem.insertAfter(listItemNode);
            if (parentList.isEmpty()) {
                grandparentListItem.remove();
            }
        } else {
            // otherwise, we need to split the siblings into two new nested lists
            const listType = parentList.getListType();
            const previousSiblingsListItem = $createListItemNode();
            const previousSiblingsList = $createListNode(listType);
            previousSiblingsListItem.append(previousSiblingsList);
            listItemNode.getPreviousSiblings().forEach((sibling)=>previousSiblingsList.append(sibling));
            const nextSiblingsListItem = $createListItemNode();
            const nextSiblingsList = $createListNode(listType);
            nextSiblingsListItem.append(nextSiblingsList);
            append(nextSiblingsList, listItemNode.getNextSiblings());
            // put the sibling nested lists on either side of the grandparent list item in the great grandparent.
            grandparentListItem.insertBefore(previousSiblingsListItem);
            grandparentListItem.insertAfter(nextSiblingsListItem);
            // replace the grandparent list item (now between the siblings) with the outdented list item.
            grandparentListItem.replace(listItemNode);
        }
    }
}
/**
 * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode
 * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode
 * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is
 * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.
 * Throws an invariant if the selection is not a child of a ListNode.
 * @returns true if a ParagraphNode was inserted successfully, false if there is no selection
 * or the selection does not contain a ListItemNode or the node already holds text.
 */ function $handleListInsertParagraph() {
    const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection) || !selection.isCollapsed()) {
        return false;
    }
    // Only run this code on empty list items
    const anchor = selection.anchor.getNode();
    if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {
        return false;
    }
    const topListNode = $getTopListNode(anchor);
    const parent = anchor.getParent();
    if (!$isListNode(parent)) {
        formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);
    }
    const grandparent = parent.getParent();
    let replacementNode;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRootOrShadowRoot"])(grandparent)) {
        replacementNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createParagraphNode"])();
        topListNode.insertAfter(replacementNode);
    } else if ($isListItemNode(grandparent)) {
        replacementNode = $createListItemNode();
        grandparent.insertAfter(replacementNode);
    } else {
        return false;
    }
    replacementNode.setTextStyle(selection.style).setTextFormat(selection.format).select();
    const nextSiblings = anchor.getNextSiblings();
    if (nextSiblings.length > 0) {
        const newList = $createListNode(parent.getListType());
        if ($isListItemNode(replacementNode)) {
            const newListItem = $createListItemNode();
            newListItem.append(newList);
            replacementNode.insertAfter(newListItem);
        } else {
            replacementNode.insertAfter(newList);
        }
        newList.append(...nextSiblings);
    }
    // Don't leave hanging nested empty lists
    $removeHighestEmptyListParent(anchor);
    return true;
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ function normalizeClassNames(...classNames) {
    const rval = [];
    for (const className of classNames){
        if (className && typeof className === 'string') {
            for (const [s] of className.matchAll(/\S+/g)){
                rval.push(s);
            }
        }
    }
    return rval;
}
function applyMarkerStyles(dom, node, prevNode) {
    const styles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$selection$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$selection$2f$LexicalSelection$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getStyleObjectFromCSS"])(node.__textStyle);
    for(const k in styles){
        dom.style.setProperty(`--listitem-marker-${k}`, styles[k]);
    }
    if (prevNode) {
        for(const k in (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$selection$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$selection$2f$LexicalSelection$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getStyleObjectFromCSS"])(prevNode.__textStyle)){
            if (!(k in styles)) {
                dom.style.removeProperty(`--listitem-marker-${k}`);
            }
        }
    }
}
/** @noInheritDoc */ class ListItemNode extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ElementNode"] {
    /** @internal */ /** @internal */ /** @internal */ $config() {
        return this.config('listitem', {
            $transform: (node)=>{
                if (node.__checked == null) {
                    return;
                }
                const parent = node.getParent();
                if ($isListNode(parent)) {
                    if (parent.getListType() !== 'check' && node.getChecked() != null) {
                        node.setChecked(undefined);
                    }
                }
            },
            extends: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ElementNode"],
            importDOM: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["buildImportMap"])({
                li: ()=>({
                        conversion: $convertListItemElement,
                        priority: 0
                    })
            })
        });
    }
    constructor(value = 1, checked = undefined, key){
        super(key);
        this.__value = value === undefined ? 1 : value;
        this.__checked = checked;
    }
    afterCloneFrom(prevNode) {
        super.afterCloneFrom(prevNode);
        this.__value = prevNode.__value;
        this.__checked = prevNode.__checked;
    }
    createDOM(config) {
        const element = document.createElement('li');
        this.updateListItemDOM(null, element, config);
        return element;
    }
    updateListItemDOM(prevNode, dom, config) {
        const parent = this.getParent();
        if ($isListNode(parent) && parent.getListType() === 'check') {
            updateListItemChecked(dom, this, prevNode);
        }
        dom.value = this.__value;
        $setListItemThemeClassNames(dom, config.theme, this);
        const prevStyle = prevNode ? prevNode.__style : '';
        const nextStyle = this.__style;
        if (prevStyle !== nextStyle) {
            if (nextStyle === '') {
                dom.removeAttribute('style');
            } else {
                dom.style.cssText = nextStyle;
            }
        }
        applyMarkerStyles(dom, this, prevNode);
    }
    updateDOM(prevNode, dom, config) {
        // @ts-expect-error - this is always HTMLListItemElement
        const element = dom;
        this.updateListItemDOM(prevNode, element, config);
        return false;
    }
    updateFromJSON(serializedNode) {
        return super.updateFromJSON(serializedNode).setValue(serializedNode.value).setChecked(serializedNode.checked);
    }
    exportDOM(editor) {
        const element = this.createDOM(editor._config);
        const formatType = this.getFormatType();
        if (formatType) {
            element.style.textAlign = formatType;
        }
        const direction = this.getDirection();
        if (direction) {
            element.dir = direction;
        }
        return {
            element
        };
    }
    exportJSON() {
        return {
            ...super.exportJSON(),
            checked: this.getChecked(),
            value: this.getValue()
        };
    }
    append(...nodes) {
        for(let i = 0; i < nodes.length; i++){
            const node = nodes[i];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(node) && this.canMergeWith(node)) {
                const children = node.getChildren();
                this.append(...children);
                node.remove();
            } else {
                super.append(node);
            }
        }
        return this;
    }
    replace(replaceWithNode, includeChildren) {
        if ($isListItemNode(replaceWithNode)) {
            return super.replace(replaceWithNode);
        }
        this.setIndent(0);
        const list = this.getParentOrThrow();
        if (!$isListNode(list)) {
            return replaceWithNode;
        }
        if (list.__first === this.getKey()) {
            list.insertBefore(replaceWithNode);
        } else if (list.__last === this.getKey()) {
            list.insertAfter(replaceWithNode);
        } else {
            // Split the list
            const newList = $createListNode(list.getListType());
            let nextSibling = this.getNextSibling();
            while(nextSibling){
                const nodeToAppend = nextSibling;
                nextSibling = nextSibling.getNextSibling();
                newList.append(nodeToAppend);
            }
            list.insertAfter(replaceWithNode);
            replaceWithNode.insertAfter(newList);
        }
        if (includeChildren) {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(replaceWithNode)) {
                formatDevErrorMessage(`includeChildren should only be true for ElementNodes`);
            }
            this.getChildren().forEach((child)=>{
                replaceWithNode.append(child);
            });
        }
        this.remove();
        if (list.getChildrenSize() === 0) {
            list.remove();
        }
        return replaceWithNode;
    }
    insertAfter(node, restoreSelection = true) {
        const listNode = this.getParentOrThrow();
        if (!$isListNode(listNode)) {
            {
                formatDevErrorMessage(`insertAfter: list node is not parent of list item node`);
            }
        }
        if ($isListItemNode(node)) {
            return super.insertAfter(node, restoreSelection);
        }
        const siblings = this.getNextSiblings();
        // Split the lists and insert the node in between them
        listNode.insertAfter(node, restoreSelection);
        if (siblings.length !== 0) {
            const newListNode = $createListNode(listNode.getListType());
            siblings.forEach((sibling)=>newListNode.append(sibling));
            node.insertAfter(newListNode, restoreSelection);
        }
        return node;
    }
    remove(preserveEmptyParent) {
        const prevSibling = this.getPreviousSibling();
        const nextSibling = this.getNextSibling();
        super.remove(preserveEmptyParent);
        if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {
            mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());
            nextSibling.remove();
        }
    }
    insertNewAfter(_, restoreSelection = true) {
        const newElement = $createListItemNode().updateFromJSON(this.exportJSON()).setChecked(this.getChecked() ? false : undefined);
        this.insertAfter(newElement, restoreSelection);
        return newElement;
    }
    collapseAtStart(selection) {
        const paragraph = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createParagraphNode"])();
        const children = this.getChildren();
        children.forEach((child)=>paragraph.append(child));
        const listNode = this.getParentOrThrow();
        const listNodeParent = listNode.getParentOrThrow();
        const isIndented = $isListItemNode(listNodeParent);
        if (listNode.getChildrenSize() === 1) {
            if (isIndented) {
                // if the list node is nested, we just want to remove it,
                // effectively unindenting it.
                listNode.remove();
                listNodeParent.select();
            } else {
                listNode.insertBefore(paragraph);
                listNode.remove();
                // If we have selection on the list item, we'll need to move it
                // to the paragraph
                const anchor = selection.anchor;
                const focus = selection.focus;
                const key = paragraph.getKey();
                if (anchor.type === 'element' && anchor.getNode().is(this)) {
                    anchor.set(key, anchor.offset, 'element');
                }
                if (focus.type === 'element' && focus.getNode().is(this)) {
                    focus.set(key, focus.offset, 'element');
                }
            }
        } else {
            listNode.insertBefore(paragraph);
            this.remove();
        }
        return true;
    }
    getValue() {
        const self = this.getLatest();
        return self.__value;
    }
    setValue(value) {
        const self = this.getWritable();
        self.__value = value;
        return self;
    }
    getChecked() {
        const self = this.getLatest();
        let listType;
        const parent = this.getParent();
        if ($isListNode(parent)) {
            listType = parent.getListType();
        }
        return listType === 'check' ? Boolean(self.__checked) : undefined;
    }
    setChecked(checked) {
        const self = this.getWritable();
        self.__checked = checked;
        return self;
    }
    toggleChecked() {
        const self = this.getWritable();
        return self.setChecked(!self.__checked);
    }
    getIndent() {
        // If we don't have a parent, we are likely serializing
        const parent = this.getParent();
        if (parent === null || !this.isAttached()) {
            return this.getLatest().__indent;
        }
        // ListItemNode should always have a ListNode for a parent.
        let listNodeParent = parent.getParentOrThrow();
        let indentLevel = 0;
        while($isListItemNode(listNodeParent)){
            listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();
            indentLevel++;
        }
        return indentLevel;
    }
    setIndent(indent) {
        if (!(typeof indent === 'number')) {
            formatDevErrorMessage(`Invalid indent value.`);
        }
        indent = Math.floor(indent);
        if (!(indent >= 0)) {
            formatDevErrorMessage(`Indent value must be non-negative.`);
        }
        let currentIndent = this.getIndent();
        while(currentIndent !== indent){
            if (currentIndent < indent) {
                $handleIndent(this);
                currentIndent++;
            } else {
                $handleOutdent(this);
                currentIndent--;
            }
        }
        return this;
    }
    /** @deprecated @internal */ canInsertAfter(node) {
        return $isListItemNode(node);
    }
    /** @deprecated @internal */ canReplaceWith(replacement) {
        return $isListItemNode(replacement);
    }
    canMergeWith(node) {
        return $isListItemNode(node) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isParagraphNode"])(node);
    }
    extractWithChild(child, selection) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection)) {
            return false;
        }
        const anchorNode = selection.anchor.getNode();
        const focusNode = selection.focus.getNode();
        return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;
    }
    isParentRequired() {
        return true;
    }
    createParentElementNode() {
        return $createListNode('bullet');
    }
    canMergeWhenEmpty() {
        return true;
    }
}
function $setListItemThemeClassNames(dom, editorThemeClasses, node) {
    const classesToAdd = [];
    const classesToRemove = [];
    const listTheme = editorThemeClasses.list;
    const listItemClassName = listTheme ? listTheme.listitem : undefined;
    let nestedListItemClassName;
    if (listTheme && listTheme.nested) {
        nestedListItemClassName = listTheme.nested.listitem;
    }
    if (listItemClassName !== undefined) {
        classesToAdd.push(...normalizeClassNames(listItemClassName));
    }
    if (listTheme) {
        const parentNode = node.getParent();
        const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';
        const checked = node.getChecked();
        if (!isCheckList || checked) {
            classesToRemove.push(listTheme.listitemUnchecked);
        }
        if (!isCheckList || !checked) {
            classesToRemove.push(listTheme.listitemChecked);
        }
        if (isCheckList) {
            classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);
        }
    }
    if (nestedListItemClassName !== undefined) {
        const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);
        if (node.getChildren().some((child)=>$isListNode(child))) {
            classesToAdd.push(...nestedListItemClasses);
        } else {
            classesToRemove.push(...nestedListItemClasses);
        }
    }
    if (classesToRemove.length > 0) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["removeClassNamesFromElement"])(dom, ...classesToRemove);
    }
    if (classesToAdd.length > 0) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addClassNamesToElement"])(dom, ...classesToAdd);
    }
}
function updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {
    // Only add attributes for leaf list items
    if ($isListNode(listItemNode.getFirstChild())) {
        dom.removeAttribute('role');
        dom.removeAttribute('tabIndex');
        dom.removeAttribute('aria-checked');
    } else {
        dom.setAttribute('role', 'checkbox');
        dom.setAttribute('tabIndex', '-1');
        if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {
            dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');
        }
    }
}
function $convertListItemElement(domNode) {
    const isGitHubCheckList = domNode.classList.contains('task-list-item');
    if (isGitHubCheckList) {
        for (const child of domNode.children){
            if (child.tagName === 'INPUT') {
                return $convertCheckboxInput(child);
            }
        }
    }
    const ariaCheckedAttr = domNode.getAttribute('aria-checked');
    const checked = ariaCheckedAttr === 'true' ? true : ariaCheckedAttr === 'false' ? false : undefined;
    return {
        node: $createListItemNode(checked)
    };
}
function $convertCheckboxInput(domNode) {
    const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';
    if (!isCheckboxInput) {
        return {
            node: null
        };
    }
    const checked = domNode.hasAttribute('checked');
    return {
        node: $createListItemNode(checked)
    };
}
/**
 * Creates a new List Item node, passing true/false will convert it to a checkbox input.
 * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.
 * @returns The new List Item.
 */ function $createListItemNode(checked) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$applyNodeReplacement"])(new ListItemNode(undefined, checked));
}
/**
 * Checks to see if the node is a ListItemNode.
 * @param node - The node to be checked.
 * @returns true if the node is a ListItemNode, false otherwise.
 */ function $isListItemNode(node) {
    return node instanceof ListItemNode;
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ /** @noInheritDoc */ class ListNode extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ElementNode"] {
    /** @internal */ /** @internal */ /** @internal */ /** @internal */ $config() {
        return this.config('list', {
            $transform: (node)=>{
                mergeNextSiblingListIfSameType(node);
                updateChildrenListItemValue(node);
            },
            extends: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ElementNode"],
            importDOM: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["buildImportMap"])({
                ol: ()=>({
                        conversion: $convertListNode,
                        priority: 0
                    }),
                ul: ()=>({
                        conversion: $convertListNode,
                        priority: 0
                    })
            })
        });
    }
    constructor(listType = 'number', start = 1, key){
        super(key);
        const _listType = TAG_TO_LIST_TYPE[listType] || listType;
        this.__listType = _listType;
        this.__tag = _listType === 'number' ? 'ol' : 'ul';
        this.__start = start;
    }
    afterCloneFrom(prevNode) {
        super.afterCloneFrom(prevNode);
        this.__listType = prevNode.__listType;
        this.__tag = prevNode.__tag;
        this.__start = prevNode.__start;
    }
    getTag() {
        return this.getLatest().__tag;
    }
    setListType(type) {
        const writable = this.getWritable();
        writable.__listType = type;
        writable.__tag = type === 'number' ? 'ol' : 'ul';
        return writable;
    }
    getListType() {
        return this.getLatest().__listType;
    }
    getStart() {
        return this.getLatest().__start;
    }
    setStart(start) {
        const self = this.getWritable();
        self.__start = start;
        return self;
    }
    // View
    createDOM(config, _editor) {
        const tag = this.__tag;
        const dom = document.createElement(tag);
        if (this.__start !== 1) {
            dom.setAttribute('start', String(this.__start));
        }
        // @ts-expect-error Internal field.
        dom.__lexicalListType = this.__listType;
        $setListThemeClassNames(dom, config.theme, this);
        return dom;
    }
    updateDOM(prevNode, dom, config) {
        if (prevNode.__tag !== this.__tag) {
            return true;
        }
        $setListThemeClassNames(dom, config.theme, this);
        return false;
    }
    updateFromJSON(serializedNode) {
        return super.updateFromJSON(serializedNode).setListType(serializedNode.listType).setStart(serializedNode.start);
    }
    exportDOM(editor) {
        const element = this.createDOM(editor._config, editor);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(element)) {
            if (this.__start !== 1) {
                element.setAttribute('start', String(this.__start));
            }
            if (this.__listType === 'check') {
                element.setAttribute('__lexicalListType', 'check');
            }
        }
        return {
            element
        };
    }
    exportJSON() {
        return {
            ...super.exportJSON(),
            listType: this.getListType(),
            start: this.getStart(),
            tag: this.getTag()
        };
    }
    canBeEmpty() {
        return false;
    }
    canIndent() {
        return false;
    }
    splice(start, deleteCount, nodesToInsert) {
        let listItemNodesToInsert = nodesToInsert;
        for(let i = 0; i < nodesToInsert.length; i++){
            const node = nodesToInsert[i];
            if (!$isListItemNode(node)) {
                if (listItemNodesToInsert === nodesToInsert) {
                    listItemNodesToInsert = [
                        ...nodesToInsert
                    ];
                }
                listItemNodesToInsert[i] = $createListItemNode().append((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(node) && !($isListNode(node) || node.isInline()) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$createTextNode"])(node.getTextContent()) : node);
            }
        }
        return super.splice(start, deleteCount, listItemNodesToInsert);
    }
    extractWithChild(child) {
        return $isListItemNode(child);
    }
}
function $setListThemeClassNames(dom, editorThemeClasses, node) {
    const classesToAdd = [];
    const classesToRemove = [];
    const listTheme = editorThemeClasses.list;
    if (listTheme !== undefined) {
        const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];
        const listDepth = $getListDepth(node) - 1;
        const normalizedListDepth = listDepth % listLevelsClassNames.length;
        const listLevelClassName = listLevelsClassNames[normalizedListDepth];
        const listClassName = listTheme[node.__tag];
        let nestedListClassName;
        const nestedListTheme = listTheme.nested;
        const checklistClassName = listTheme.checklist;
        if (nestedListTheme !== undefined && nestedListTheme.list) {
            nestedListClassName = nestedListTheme.list;
        }
        if (listClassName !== undefined) {
            classesToAdd.push(listClassName);
        }
        if (checklistClassName !== undefined && node.__listType === 'check') {
            classesToAdd.push(checklistClassName);
        }
        if (listLevelClassName !== undefined) {
            classesToAdd.push(...normalizeClassNames(listLevelClassName));
            for(let i = 0; i < listLevelsClassNames.length; i++){
                if (i !== normalizedListDepth) {
                    classesToRemove.push(node.__tag + i);
                }
            }
        }
        if (nestedListClassName !== undefined) {
            const nestedListItemClasses = normalizeClassNames(nestedListClassName);
            if (listDepth > 1) {
                classesToAdd.push(...nestedListItemClasses);
            } else {
                classesToRemove.push(...nestedListItemClasses);
            }
        }
    }
    if (classesToRemove.length > 0) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["removeClassNamesFromElement"])(dom, ...classesToRemove);
    }
    if (classesToAdd.length > 0) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addClassNamesToElement"])(dom, ...classesToAdd);
    }
}
/*
 * This function normalizes the children of a ListNode after the conversion from HTML,
 * ensuring that they are all ListItemNodes and contain either a single nested ListNode
 * or some other inline content.
 */ function $normalizeChildren(nodes) {
    const normalizedListItems = [];
    for(let i = 0; i < nodes.length; i++){
        const node = nodes[i];
        if ($isListItemNode(node)) {
            normalizedListItems.push(node);
            const children = node.getChildren();
            if (children.length > 1) {
                children.forEach((child)=>{
                    if ($isListNode(child)) {
                        normalizedListItems.push($wrapInListItem(child));
                    }
                });
            }
        } else {
            normalizedListItems.push($wrapInListItem(node));
        }
    }
    return normalizedListItems;
}
function isDomChecklist(domNode) {
    if (domNode.getAttribute('__lexicallisttype') === 'check' || // is github checklist
    domNode.classList.contains('contains-task-list')) {
        return true;
    }
    // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.
    for (const child of domNode.childNodes){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(child) && child.hasAttribute('aria-checked')) {
            return true;
        }
    }
    return false;
}
function $convertListNode(domNode) {
    const nodeName = domNode.nodeName.toLowerCase();
    let node = null;
    if (nodeName === 'ol') {
        // @ts-ignore
        const start = domNode.start;
        node = $createListNode('number', start);
    } else if (nodeName === 'ul') {
        if (isDomChecklist(domNode)) {
            node = $createListNode('check');
        } else {
            node = $createListNode('bullet');
        }
    }
    return {
        after: $normalizeChildren,
        node
    };
}
const TAG_TO_LIST_TYPE = {
    ol: 'number',
    ul: 'bullet'
};
/**
 * Creates a ListNode of listType.
 * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.
 * @param start - Where an ordered list starts its count, start = 1 if left undefined.
 * @returns The new ListNode
 */ function $createListNode(listType = 'number', start = 1) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$applyNodeReplacement"])(new ListNode(listType, start));
}
/**
 * Checks to see if the node is a ListNode.
 * @param node - The node to be checked.
 * @returns true if the node is a ListNode, false otherwise.
 */ function $isListNode(node) {
    return node instanceof ListNode;
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ const INSERT_CHECK_LIST_COMMAND = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createCommand"])('INSERT_CHECK_LIST_COMMAND');
function registerCheckList(editor) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["mergeRegister"])(editor.registerCommand(INSERT_CHECK_LIST_COMMAND, ()=>{
        $insertList('check');
        return true;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_LOW"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["KEY_ARROW_DOWN_COMMAND"], (event)=>{
        return handleArrowUpOrDown(event, editor, false);
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_LOW"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["KEY_ARROW_UP_COMMAND"], (event)=>{
        return handleArrowUpOrDown(event, editor, true);
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_LOW"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["KEY_ESCAPE_COMMAND"], ()=>{
        const activeItem = getActiveCheckListItem();
        if (activeItem != null) {
            const rootElement = editor.getRootElement();
            if (rootElement != null) {
                rootElement.focus();
            }
            return true;
        }
        return false;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_LOW"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["KEY_SPACE_COMMAND"], (event)=>{
        const activeItem = getActiveCheckListItem();
        if (activeItem != null && editor.isEditable()) {
            editor.update(()=>{
                const listItemNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getNearestNodeFromDOMNode"])(activeItem);
                if ($isListItemNode(listItemNode)) {
                    event.preventDefault();
                    listItemNode.toggleChecked();
                }
            });
            return true;
        }
        return false;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_LOW"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["KEY_ARROW_LEFT_COMMAND"], (event)=>{
        return editor.getEditorState().read(()=>{
            const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection) && selection.isCollapsed()) {
                const { anchor } = selection;
                const isElement = anchor.type === 'element';
                if (isElement || anchor.offset === 0) {
                    const anchorNode = anchor.getNode();
                    const elementNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["$findMatchingParent"])(anchorNode, (node)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isElementNode"])(node) && !node.isInline());
                    if ($isListItemNode(elementNode)) {
                        const parent = elementNode.getParent();
                        if ($isListNode(parent) && parent.getListType() === 'check' && (isElement || elementNode.getFirstDescendant() === anchorNode)) {
                            const domNode = editor.getElementByKey(elementNode.__key);
                            if (domNode != null && document.activeElement !== domNode) {
                                domNode.focus();
                                event.preventDefault();
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        });
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_LOW"]), editor.registerRootListener((rootElement, prevElement)=>{
        if (rootElement !== null) {
            rootElement.addEventListener('click', handleClick);
            rootElement.addEventListener('pointerdown', handlePointerDown);
        }
        if (prevElement !== null) {
            prevElement.removeEventListener('click', handleClick);
            prevElement.removeEventListener('pointerdown', handlePointerDown);
        }
    }));
}
function handleCheckItemEvent(event, callback) {
    const target = event.target;
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(target)) {
        return;
    }
    // Ignore clicks on LI that have nested lists
    const firstChild = target.firstChild;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(firstChild) && (firstChild.tagName === 'UL' || firstChild.tagName === 'OL')) {
        return;
    }
    const parentNode = target.parentNode;
    // @ts-ignore internal field
    if (!parentNode || parentNode.__lexicalListType !== 'check') {
        return;
    }
    const rect = target.getBoundingClientRect();
    const zoom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["calculateZoomLevel"])(target);
    const clientX = event.clientX / zoom;
    // Use getComputedStyle if available, otherwise fallback to 0px width
    const beforeStyles = window.getComputedStyle ? window.getComputedStyle(target, '::before') : {
        width: '0px'
    };
    const beforeWidthInPixels = parseFloat(beforeStyles.width);
    // Make click area slightly larger for touch devices to improve accessibility
    const isTouchEvent = event.pointerType === 'touch';
    const clickAreaPadding = isTouchEvent ? 32 : 0; // Add 32px padding for touch events
    if (target.dir === 'rtl' ? clientX < rect.right + clickAreaPadding && clientX > rect.right - beforeWidthInPixels - clickAreaPadding : clientX > rect.left - clickAreaPadding && clientX < rect.left + beforeWidthInPixels + clickAreaPadding) {
        callback();
    }
}
function handleClick(event) {
    handleCheckItemEvent(event, ()=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(event.target)) {
            const domNode = event.target;
            const editor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getNearestEditorFromDOMNode"])(domNode);
            if (editor != null && editor.isEditable()) {
                editor.update(()=>{
                    const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getNearestNodeFromDOMNode"])(domNode);
                    if ($isListItemNode(node)) {
                        domNode.focus();
                        node.toggleChecked();
                    }
                });
            }
        }
    });
}
function handlePointerDown(event) {
    handleCheckItemEvent(event, ()=>{
        // Prevents caret moving when clicking on check mark
        event.preventDefault();
    });
}
function getActiveCheckListItem() {
    const activeElement = document.activeElement;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHTMLElement"])(activeElement) && activeElement.tagName === 'LI' && activeElement.parentNode != null && // @ts-ignore internal field
    activeElement.parentNode.__lexicalListType === 'check' ? activeElement : null;
}
function findCheckListItemSibling(node, backward) {
    let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();
    let parent = node;
    // Going up in a tree to get non-null sibling
    while(sibling == null && $isListItemNode(parent)){
        // Get li -> parent ul/ol -> parent li
        parent = parent.getParentOrThrow().getParent();
        if (parent != null) {
            sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();
        }
    }
    // Going down in a tree to get first non-nested list item
    while($isListItemNode(sibling)){
        const firstChild = backward ? sibling.getLastChild() : sibling.getFirstChild();
        if (!$isListNode(firstChild)) {
            return sibling;
        }
        sibling = backward ? firstChild.getLastChild() : firstChild.getFirstChild();
    }
    return null;
}
function handleArrowUpOrDown(event, editor, backward) {
    const activeItem = getActiveCheckListItem();
    if (activeItem != null) {
        editor.update(()=>{
            const listItem = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getNearestNodeFromDOMNode"])(activeItem);
            if (!$isListItemNode(listItem)) {
                return;
            }
            const nextListItem = findCheckListItemSibling(listItem, backward);
            if (nextListItem != null) {
                nextListItem.selectStart();
                const dom = editor.getElementByKey(nextListItem.__key);
                if (dom != null) {
                    event.preventDefault();
                    setTimeout(()=>{
                        dom.focus();
                    }, 0);
                }
            }
        });
    }
    return false;
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ const UPDATE_LIST_START_COMMAND = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createCommand"])('UPDATE_LIST_START_COMMAND');
const INSERT_UNORDERED_LIST_COMMAND = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createCommand"])('INSERT_UNORDERED_LIST_COMMAND');
const INSERT_ORDERED_LIST_COMMAND = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createCommand"])('INSERT_ORDERED_LIST_COMMAND');
const REMOVE_LIST_COMMAND = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createCommand"])('REMOVE_LIST_COMMAND');
function registerList(editor) {
    const removeListener = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["mergeRegister"])(editor.registerCommand(INSERT_ORDERED_LIST_COMMAND, ()=>{
        $insertList('number');
        return true;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_LOW"]), editor.registerCommand(UPDATE_LIST_START_COMMAND, (payload)=>{
        const { listNodeKey, newStart } = payload;
        const listNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getNodeByKey"])(listNodeKey);
        if (!$isListNode(listNode)) {
            return false;
        }
        if (listNode.getListType() === 'number') {
            listNode.setStart(newStart);
            updateChildrenListItemValue(listNode);
        }
        return true;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_LOW"]), editor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, ()=>{
        $insertList('bullet');
        return true;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_LOW"]), editor.registerCommand(REMOVE_LIST_COMMAND, ()=>{
        $removeList();
        return true;
    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_LOW"]), editor.registerCommand(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["INSERT_PARAGRAPH_COMMAND"], ()=>$handleListInsertParagraph(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["COMMAND_PRIORITY_LOW"]), editor.registerNodeTransform(ListItemNode, (node)=>{
        const firstChild = node.getFirstChild();
        if (firstChild) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isTextNode"])(firstChild)) {
                const style = firstChild.getStyle();
                const format = firstChild.getFormat();
                if (node.getTextStyle() !== style) {
                    node.setTextStyle(style);
                }
                if (node.getTextFormat() !== format) {
                    node.setTextFormat(format);
                }
            }
        } else {
            // If it's empty, check the selection
            const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$getSelection"])();
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["$isRangeSelection"])(selection) && (selection.style !== node.getTextStyle() || selection.format !== node.getTextFormat()) && selection.isCollapsed() && node.is(selection.anchor.getNode())) {
                node.setTextStyle(selection.style).setTextFormat(selection.format);
            }
        }
    }), editor.registerNodeTransform(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["TextNode"], (node)=>{
        const listItemParentNode = node.getParent();
        if ($isListItemNode(listItemParentNode) && node.is(listItemParentNode.getFirstChild())) {
            const style = node.getStyle();
            const format = node.getFormat();
            if (style !== listItemParentNode.getTextStyle() || format !== listItemParentNode.getTextFormat()) {
                listItemParentNode.setTextStyle(style).setTextFormat(format);
            }
        }
    }));
    return removeListener;
}
function registerListStrictIndentTransform(editor) {
    const $formatListIndentStrict = (listItemNode)=>{
        const listNode = listItemNode.getParent();
        if ($isListNode(listItemNode.getFirstChild()) || !$isListNode(listNode)) {
            return;
        }
        const startingListItemNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$lexical$2b$utils$40$0$2e$35$2e$0$2f$node_modules$2f40$lexical$2f$utils$2f$LexicalUtils$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["$findMatchingParent"])(listItemNode, (node)=>$isListItemNode(node) && $isListNode(node.getParent()) && $isListItemNode(node.getPreviousSibling()));
        if (startingListItemNode === null && listItemNode.getIndent() > 0) {
            listItemNode.setIndent(0);
        } else if ($isListItemNode(startingListItemNode)) {
            const prevListItemNode = startingListItemNode.getPreviousSibling();
            if ($isListItemNode(prevListItemNode)) {
                const endListItemNode = $findChildrenEndListItemNode(prevListItemNode);
                const endListNode = endListItemNode.getParent();
                if ($isListNode(endListNode)) {
                    const prevDepth = $getListDepth(endListNode);
                    const depth = $getListDepth(listNode);
                    if (prevDepth + 1 < depth) {
                        listItemNode.setIndent(prevDepth);
                    }
                }
            }
        }
    };
    const $processListWithStrictIndent = (listNode)=>{
        const queue = [
            listNode
        ];
        while(queue.length > 0){
            const node = queue.shift();
            if (!$isListNode(node)) {
                continue;
            }
            for (const child of node.getChildren()){
                if ($isListItemNode(child)) {
                    $formatListIndentStrict(child);
                    const firstChild = child.getFirstChild();
                    if ($isListNode(firstChild)) {
                        queue.push(firstChild);
                    }
                }
            }
        }
    };
    return editor.registerNodeTransform(ListNode, $processListWithStrictIndent);
}
function $findChildrenEndListItemNode(listItemNode) {
    let current = listItemNode;
    let firstChild = current.getFirstChild();
    while($isListNode(firstChild)){
        const lastChild = firstChild.getLastChild();
        if ($isListItemNode(lastChild)) {
            current = lastChild;
            firstChild = current.getFirstChild();
        } else {
            break;
        }
    }
    return current;
}
/**
 * @deprecated use {@link $insertList} from an update or command listener.
 *
 * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of
 * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.
 * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.
 * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,
 * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with
 * a new ListNode, or create a new ListNode at the nearest root/shadow root.
 * @param editor - The lexical editor.
 * @param listType - The type of list, "number" | "bullet" | "check".
 */ function insertList(editor, listType) {
    editor.update(()=>$insertList(listType));
}
/**
 * @deprecated use {@link $removeList} from an update or command listener.
 *
 * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode
 * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,
 * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node
 * inside a ListItemNode will be appended to the new ParagraphNodes.
 * @param editor - The lexical editor.
 */ function removeList(editor) {
    editor.update(()=>$removeList());
}
;
}),
"[project]/node_modules/.pnpm/@lexical+react@0.35.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_yjs@13.6.27/node_modules/@lexical/react/LexicalDecoratorBlockNode.dev.mjs [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "$isDecoratorBlockNode",
    ()=>$isDecoratorBlockNode,
    "DecoratorBlockNode",
    ()=>DecoratorBlockNode
]);
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/lexical@0.35.0/node_modules/lexical/Lexical.dev.mjs [app-rsc] (ecmascript)");
;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ class DecoratorBlockNode extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$lexical$40$0$2e$35$2e$0$2f$node_modules$2f$lexical$2f$Lexical$2e$dev$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DecoratorNode"] {
    constructor(format, key){
        super(key);
        this.__format = format || '';
    }
    exportJSON() {
        return {
            ...super.exportJSON(),
            format: this.__format || ''
        };
    }
    updateFromJSON(serializedNode) {
        return super.updateFromJSON(serializedNode).setFormat(serializedNode.format || '');
    }
    canIndent() {
        return false;
    }
    createDOM() {
        return document.createElement('div');
    }
    updateDOM() {
        return false;
    }
    setFormat(format) {
        const self = this.getWritable();
        self.__format = format;
        return self;
    }
    isInline() {
        return false;
    }
}
function $isDecoratorBlockNode(node) {
    return node instanceof DecoratorBlockNode;
}
;
}),
"[project]/node_modules/.pnpm/streamsearch@1.1.0/node_modules/streamsearch/lib/sbmh.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
  Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation
  by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool
*/ function memcmp(buf1, pos1, buf2, pos2, num) {
    for(let i = 0; i < num; ++i){
        if (buf1[pos1 + i] !== buf2[pos2 + i]) return false;
    }
    return true;
}
class SBMH {
    constructor(needle, cb){
        if (typeof cb !== 'function') throw new Error('Missing match callback');
        if (typeof needle === 'string') needle = Buffer.from(needle);
        else if (!Buffer.isBuffer(needle)) throw new Error(`Expected Buffer for needle, got ${typeof needle}`);
        const needleLen = needle.length;
        this.maxMatches = Infinity;
        this.matches = 0;
        this._cb = cb;
        this._lookbehindSize = 0;
        this._needle = needle;
        this._bufPos = 0;
        this._lookbehind = Buffer.allocUnsafe(needleLen);
        // Initialize occurrence table.
        this._occ = [
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen,
            needleLen
        ];
        // Populate occurrence table with analysis of the needle, ignoring the last
        // letter.
        if (needleLen > 1) {
            for(let i = 0; i < needleLen - 1; ++i)this._occ[needle[i]] = needleLen - 1 - i;
        }
    }
    reset() {
        this.matches = 0;
        this._lookbehindSize = 0;
        this._bufPos = 0;
    }
    push(chunk, pos) {
        let result;
        if (!Buffer.isBuffer(chunk)) chunk = Buffer.from(chunk, 'latin1');
        const chunkLen = chunk.length;
        this._bufPos = pos || 0;
        while(result !== chunkLen && this.matches < this.maxMatches)result = feed(this, chunk);
        return result;
    }
    destroy() {
        const lbSize = this._lookbehindSize;
        if (lbSize) this._cb(false, this._lookbehind, 0, lbSize, false);
        this.reset();
    }
}
function feed(self, data) {
    const len = data.length;
    const needle = self._needle;
    const needleLen = needle.length;
    // Positive: points to a position in `data`
    //           pos == 3 points to data[3]
    // Negative: points to a position in the lookbehind buffer
    //           pos == -2 points to lookbehind[lookbehindSize - 2]
    let pos = -self._lookbehindSize;
    const lastNeedleCharPos = needleLen - 1;
    const lastNeedleChar = needle[lastNeedleCharPos];
    const end = len - needleLen;
    const occ = self._occ;
    const lookbehind = self._lookbehind;
    if (pos < 0) {
        // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool
        // search with character lookup code that considers both the
        // lookbehind buffer and the current round's haystack data.
        //
        // Loop until
        //   there is a match.
        // or until
        //   we've moved past the position that requires the
        //   lookbehind buffer. In this case we switch to the
        //   optimized loop.
        // or until
        //   the character to look at lies outside the haystack.
        while(pos < 0 && pos <= end){
            const nextPos = pos + lastNeedleCharPos;
            const ch = nextPos < 0 ? lookbehind[self._lookbehindSize + nextPos] : data[nextPos];
            if (ch === lastNeedleChar && matchNeedle(self, data, pos, lastNeedleCharPos)) {
                self._lookbehindSize = 0;
                ++self.matches;
                if (pos > -self._lookbehindSize) self._cb(true, lookbehind, 0, self._lookbehindSize + pos, false);
                else self._cb(true, undefined, 0, 0, true);
                return self._bufPos = pos + needleLen;
            }
            pos += occ[ch];
        }
        // No match.
        // There's too few data for Boyer-Moore-Horspool to run,
        // so let's use a different algorithm to skip as much as
        // we can.
        // Forward pos until
        //   the trailing part of lookbehind + data
        //   looks like the beginning of the needle
        // or until
        //   pos == 0
        while(pos < 0 && !matchNeedle(self, data, pos, len - pos))++pos;
        if (pos < 0) {
            // Cut off part of the lookbehind buffer that has
            // been processed and append the entire haystack
            // into it.
            const bytesToCutOff = self._lookbehindSize + pos;
            if (bytesToCutOff > 0) {
                // The cut off data is guaranteed not to contain the needle.
                self._cb(false, lookbehind, 0, bytesToCutOff, false);
            }
            self._lookbehindSize -= bytesToCutOff;
            lookbehind.copy(lookbehind, 0, bytesToCutOff, self._lookbehindSize);
            lookbehind.set(data, self._lookbehindSize);
            self._lookbehindSize += len;
            self._bufPos = len;
            return len;
        }
        // Discard lookbehind buffer.
        self._cb(false, lookbehind, 0, self._lookbehindSize, false);
        self._lookbehindSize = 0;
    }
    pos += self._bufPos;
    const firstNeedleChar = needle[0];
    // Lookbehind buffer is now empty. Perform Boyer-Moore-Horspool
    // search with optimized character lookup code that only considers
    // the current round's haystack data.
    while(pos <= end){
        const ch = data[pos + lastNeedleCharPos];
        if (ch === lastNeedleChar && data[pos] === firstNeedleChar && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {
            ++self.matches;
            if (pos > 0) self._cb(true, data, self._bufPos, pos, true);
            else self._cb(true, undefined, 0, 0, true);
            return self._bufPos = pos + needleLen;
        }
        pos += occ[ch];
    }
    // There was no match. If there's trailing haystack data that we cannot
    // match yet using the Boyer-Moore-Horspool algorithm (because the trailing
    // data is less than the needle size) then match using a modified
    // algorithm that starts matching from the beginning instead of the end.
    // Whatever trailing data is left after running this algorithm is added to
    // the lookbehind buffer.
    while(pos < len){
        if (data[pos] !== firstNeedleChar || !memcmp(data, pos, needle, 0, len - pos)) {
            ++pos;
            continue;
        }
        data.copy(lookbehind, 0, pos, len);
        self._lookbehindSize = len - pos;
        break;
    }
    // Everything until `pos` is guaranteed not to contain needle data.
    if (pos > 0) self._cb(false, data, self._bufPos, pos < len ? pos : len, true);
    self._bufPos = len;
    return len;
}
function matchNeedle(self, data, pos, len) {
    const lb = self._lookbehind;
    const lbSize = self._lookbehindSize;
    const needle = self._needle;
    for(let i = 0; i < len; ++i, ++pos){
        const ch = pos < 0 ? lb[lbSize + pos] : data[pos];
        if (ch !== needle[i]) return false;
    }
    return true;
}
module.exports = SBMH;
}),
"[project]/node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/utils.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function parseContentType(str) {
    if (str.length === 0) return;
    const params = Object.create(null);
    let i = 0;
    // Parse type
    for(; i < str.length; ++i){
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
            if (code !== 47 /* '/' */  || i === 0) return;
            break;
        }
    }
    // Check for type without subtype
    if (i === str.length) return;
    const type = str.slice(0, i).toLowerCase();
    // Parse subtype
    const subtypeStart = ++i;
    for(; i < str.length; ++i){
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
            // Make sure we have a subtype
            if (i === subtypeStart) return;
            if (parseContentTypeParams(str, i, params) === undefined) return;
            break;
        }
    }
    // Make sure we have a subtype
    if (i === subtypeStart) return;
    const subtype = str.slice(subtypeStart, i).toLowerCase();
    return {
        type,
        subtype,
        params
    };
}
function parseContentTypeParams(str, i, params) {
    while(i < str.length){
        // Consume whitespace
        for(; i < str.length; ++i){
            const code = str.charCodeAt(i);
            if (code !== 32 /* ' ' */  && code !== 9 /* '\t' */ ) break;
        }
        // Ended on whitespace
        if (i === str.length) break;
        // Check for malformed parameter
        if (str.charCodeAt(i++) !== 59 /* ';' */ ) return;
        // Consume whitespace
        for(; i < str.length; ++i){
            const code = str.charCodeAt(i);
            if (code !== 32 /* ' ' */  && code !== 9 /* '\t' */ ) break;
        }
        // Ended on whitespace (malformed)
        if (i === str.length) return;
        let name;
        const nameStart = i;
        // Parse parameter name
        for(; i < str.length; ++i){
            const code = str.charCodeAt(i);
            if (TOKEN[code] !== 1) {
                if (code !== 61 /* '=' */ ) return;
                break;
            }
        }
        // No value (malformed)
        if (i === str.length) return;
        name = str.slice(nameStart, i);
        ++i; // Skip over '='
        // No value (malformed)
        if (i === str.length) return;
        let value = '';
        let valueStart;
        if (str.charCodeAt(i) === 34 /* '"' */ ) {
            valueStart = ++i;
            let escaping = false;
            // Parse quoted value
            for(; i < str.length; ++i){
                const code = str.charCodeAt(i);
                if (code === 92 /* '\\' */ ) {
                    if (escaping) {
                        valueStart = i;
                        escaping = false;
                    } else {
                        value += str.slice(valueStart, i);
                        escaping = true;
                    }
                    continue;
                }
                if (code === 34 /* '"' */ ) {
                    if (escaping) {
                        valueStart = i;
                        escaping = false;
                        continue;
                    }
                    value += str.slice(valueStart, i);
                    break;
                }
                if (escaping) {
                    valueStart = i - 1;
                    escaping = false;
                }
                // Invalid unescaped quoted character (malformed)
                if (QDTEXT[code] !== 1) return;
            }
            // No end quote (malformed)
            if (i === str.length) return;
            ++i; // Skip over double quote
        } else {
            valueStart = i;
            // Parse unquoted value
            for(; i < str.length; ++i){
                const code = str.charCodeAt(i);
                if (TOKEN[code] !== 1) {
                    // No value (malformed)
                    if (i === valueStart) return;
                    break;
                }
            }
            value = str.slice(valueStart, i);
        }
        name = name.toLowerCase();
        if (params[name] === undefined) params[name] = value;
    }
    return params;
}
function parseDisposition(str, defDecoder) {
    if (str.length === 0) return;
    const params = Object.create(null);
    let i = 0;
    for(; i < str.length; ++i){
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
            if (parseDispositionParams(str, i, params, defDecoder) === undefined) return;
            break;
        }
    }
    const type = str.slice(0, i).toLowerCase();
    return {
        type,
        params
    };
}
function parseDispositionParams(str, i, params, defDecoder) {
    while(i < str.length){
        // Consume whitespace
        for(; i < str.length; ++i){
            const code = str.charCodeAt(i);
            if (code !== 32 /* ' ' */  && code !== 9 /* '\t' */ ) break;
        }
        // Ended on whitespace
        if (i === str.length) break;
        // Check for malformed parameter
        if (str.charCodeAt(i++) !== 59 /* ';' */ ) return;
        // Consume whitespace
        for(; i < str.length; ++i){
            const code = str.charCodeAt(i);
            if (code !== 32 /* ' ' */  && code !== 9 /* '\t' */ ) break;
        }
        // Ended on whitespace (malformed)
        if (i === str.length) return;
        let name;
        const nameStart = i;
        // Parse parameter name
        for(; i < str.length; ++i){
            const code = str.charCodeAt(i);
            if (TOKEN[code] !== 1) {
                if (code === 61 /* '=' */ ) break;
                return;
            }
        }
        // No value (malformed)
        if (i === str.length) return;
        let value = '';
        let valueStart;
        let charset;
        //~ let lang;
        name = str.slice(nameStart, i);
        if (name.charCodeAt(name.length - 1) === 42 /* '*' */ ) {
            // Extended value
            const charsetStart = ++i;
            // Parse charset name
            for(; i < str.length; ++i){
                const code = str.charCodeAt(i);
                if (CHARSET[code] !== 1) {
                    if (code !== 39 /* '\'' */ ) return;
                    break;
                }
            }
            // Incomplete charset (malformed)
            if (i === str.length) return;
            charset = str.slice(charsetStart, i);
            ++i; // Skip over the '\''
            //~ const langStart = ++i;
            // Parse language name
            for(; i < str.length; ++i){
                const code = str.charCodeAt(i);
                if (code === 39 /* '\'' */ ) break;
            }
            // Incomplete language (malformed)
            if (i === str.length) return;
            //~ lang = str.slice(langStart, i);
            ++i; // Skip over the '\''
            // No value (malformed)
            if (i === str.length) return;
            valueStart = i;
            let encode = 0;
            // Parse value
            for(; i < str.length; ++i){
                const code = str.charCodeAt(i);
                if (EXTENDED_VALUE[code] !== 1) {
                    if (code === 37 /* '%' */ ) {
                        let hexUpper;
                        let hexLower;
                        if (i + 2 < str.length && (hexUpper = HEX_VALUES[str.charCodeAt(i + 1)]) !== -1 && (hexLower = HEX_VALUES[str.charCodeAt(i + 2)]) !== -1) {
                            const byteVal = (hexUpper << 4) + hexLower;
                            value += str.slice(valueStart, i);
                            value += String.fromCharCode(byteVal);
                            i += 2;
                            valueStart = i + 1;
                            if (byteVal >= 128) encode = 2;
                            else if (encode === 0) encode = 1;
                            continue;
                        }
                        // '%' disallowed in non-percent encoded contexts (malformed)
                        return;
                    }
                    break;
                }
            }
            value += str.slice(valueStart, i);
            value = convertToUTF8(value, charset, encode);
            if (value === undefined) return;
        } else {
            // Non-extended value
            ++i; // Skip over '='
            // No value (malformed)
            if (i === str.length) return;
            if (str.charCodeAt(i) === 34 /* '"' */ ) {
                valueStart = ++i;
                let escaping = false;
                // Parse quoted value
                for(; i < str.length; ++i){
                    const code = str.charCodeAt(i);
                    if (code === 92 /* '\\' */ ) {
                        if (escaping) {
                            valueStart = i;
                            escaping = false;
                        } else {
                            value += str.slice(valueStart, i);
                            escaping = true;
                        }
                        continue;
                    }
                    if (code === 34 /* '"' */ ) {
                        if (escaping) {
                            valueStart = i;
                            escaping = false;
                            continue;
                        }
                        value += str.slice(valueStart, i);
                        break;
                    }
                    if (escaping) {
                        valueStart = i - 1;
                        escaping = false;
                    }
                    // Invalid unescaped quoted character (malformed)
                    if (QDTEXT[code] !== 1) return;
                }
                // No end quote (malformed)
                if (i === str.length) return;
                ++i; // Skip over double quote
            } else {
                valueStart = i;
                // Parse unquoted value
                for(; i < str.length; ++i){
                    const code = str.charCodeAt(i);
                    if (TOKEN[code] !== 1) {
                        // No value (malformed)
                        if (i === valueStart) return;
                        break;
                    }
                }
                value = str.slice(valueStart, i);
            }
            value = defDecoder(value, 2);
            if (value === undefined) return;
        }
        name = name.toLowerCase();
        if (params[name] === undefined) params[name] = value;
    }
    return params;
}
function getDecoder(charset) {
    let lc;
    while(true){
        switch(charset){
            case 'utf-8':
            case 'utf8':
                return decoders.utf8;
            case 'latin1':
            case 'ascii':
            case 'us-ascii':
            case 'iso-8859-1':
            case 'iso8859-1':
            case 'iso88591':
            case 'iso_8859-1':
            case 'windows-1252':
            case 'iso_8859-1:1987':
            case 'cp1252':
            case 'x-cp1252':
                return decoders.latin1;
            case 'utf16le':
            case 'utf-16le':
            case 'ucs2':
            case 'ucs-2':
                return decoders.utf16le;
            case 'base64':
                return decoders.base64;
            default:
                if (lc === undefined) {
                    lc = true;
                    charset = charset.toLowerCase();
                    continue;
                }
                return decoders.other.bind(charset);
        }
    }
}
const decoders = {
    utf8: (data, hint)=>{
        if (data.length === 0) return '';
        if (typeof data === 'string') {
            // If `data` never had any percent-encoded bytes or never had any that
            // were outside of the ASCII range, then we can safely just return the
            // input since UTF-8 is ASCII compatible
            if (hint < 2) return data;
            data = Buffer.from(data, 'latin1');
        }
        return data.utf8Slice(0, data.length);
    },
    latin1: (data, hint)=>{
        if (data.length === 0) return '';
        if (typeof data === 'string') return data;
        return data.latin1Slice(0, data.length);
    },
    utf16le: (data, hint)=>{
        if (data.length === 0) return '';
        if (typeof data === 'string') data = Buffer.from(data, 'latin1');
        return data.ucs2Slice(0, data.length);
    },
    base64: (data, hint)=>{
        if (data.length === 0) return '';
        if (typeof data === 'string') data = Buffer.from(data, 'latin1');
        return data.base64Slice(0, data.length);
    },
    other: (data, hint)=>{
        if (data.length === 0) return '';
        if (typeof data === 'string') data = Buffer.from(data, 'latin1');
        try {
            const decoder = new TextDecoder(/*TURBOPACK member replacement*/ __turbopack_context__.e);
            return decoder.decode(data);
        } catch  {}
    }
};
function convertToUTF8(data, charset, hint) {
    const decode = getDecoder(charset);
    if (decode) return decode(data, hint);
}
function basename(path) {
    if (typeof path !== 'string') return '';
    for(let i = path.length - 1; i >= 0; --i){
        switch(path.charCodeAt(i)){
            case 0x2F:
            case 0x5C:
                path = path.slice(i + 1);
                return path === '..' || path === '.' ? '' : path;
        }
    }
    return path === '..' || path === '.' ? '' : path;
}
const TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
];
const QDTEXT = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
];
const CHARSET = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
];
const EXTENDED_VALUE = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
];
/* eslint-disable no-multi-spaces */ const HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
];
/* eslint-enable no-multi-spaces */ module.exports = {
    basename,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
};
}),
"[project]/node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/types/multipart.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { Readable, Writable } = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const StreamSearch = __turbopack_context__.r("[project]/node_modules/.pnpm/streamsearch@1.1.0/node_modules/streamsearch/lib/sbmh.js [app-rsc] (ecmascript)");
const { basename, convertToUTF8, getDecoder, parseContentType, parseDisposition } = __turbopack_context__.r("[project]/node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/utils.js [app-rsc] (ecmascript)");
const BUF_CRLF = Buffer.from('\r\n');
const BUF_CR = Buffer.from('\r');
const BUF_DASH = Buffer.from('-');
function noop() {}
const MAX_HEADER_PAIRS = 2000; // From node
const MAX_HEADER_SIZE = 16 * 1024; // From node (its default value)
const HPARSER_NAME = 0;
const HPARSER_PRE_OWS = 1;
const HPARSER_VALUE = 2;
class HeaderParser {
    constructor(cb){
        this.header = Object.create(null);
        this.pairCount = 0;
        this.byteCount = 0;
        this.state = HPARSER_NAME;
        this.name = '';
        this.value = '';
        this.crlf = 0;
        this.cb = cb;
    }
    reset() {
        this.header = Object.create(null);
        this.pairCount = 0;
        this.byteCount = 0;
        this.state = HPARSER_NAME;
        this.name = '';
        this.value = '';
        this.crlf = 0;
    }
    push(chunk, pos, end) {
        let start = pos;
        while(pos < end){
            switch(this.state){
                case HPARSER_NAME:
                    {
                        let done = false;
                        for(; pos < end; ++pos){
                            if (this.byteCount === MAX_HEADER_SIZE) return -1;
                            ++this.byteCount;
                            const code = chunk[pos];
                            if (TOKEN[code] !== 1) {
                                if (code !== 58 /* ':' */ ) return -1;
                                this.name += chunk.latin1Slice(start, pos);
                                if (this.name.length === 0) return -1;
                                ++pos;
                                done = true;
                                this.state = HPARSER_PRE_OWS;
                                break;
                            }
                        }
                        if (!done) {
                            this.name += chunk.latin1Slice(start, pos);
                            break;
                        }
                    // FALLTHROUGH
                    }
                case HPARSER_PRE_OWS:
                    {
                        // Skip optional whitespace
                        let done = false;
                        for(; pos < end; ++pos){
                            if (this.byteCount === MAX_HEADER_SIZE) return -1;
                            ++this.byteCount;
                            const code = chunk[pos];
                            if (code !== 32 /* ' ' */  && code !== 9 /* '\t' */ ) {
                                start = pos;
                                done = true;
                                this.state = HPARSER_VALUE;
                                break;
                            }
                        }
                        if (!done) break;
                    // FALLTHROUGH
                    }
                case HPARSER_VALUE:
                    switch(this.crlf){
                        case 0:
                            for(; pos < end; ++pos){
                                if (this.byteCount === MAX_HEADER_SIZE) return -1;
                                ++this.byteCount;
                                const code = chunk[pos];
                                if (FIELD_VCHAR[code] !== 1) {
                                    if (code !== 13 /* '\r' */ ) return -1;
                                    ++this.crlf;
                                    break;
                                }
                            }
                            this.value += chunk.latin1Slice(start, pos++);
                            break;
                        case 1:
                            if (this.byteCount === MAX_HEADER_SIZE) return -1;
                            ++this.byteCount;
                            if (chunk[pos++] !== 10 /* '\n' */ ) return -1;
                            ++this.crlf;
                            break;
                        case 2:
                            {
                                if (this.byteCount === MAX_HEADER_SIZE) return -1;
                                ++this.byteCount;
                                const code = chunk[pos];
                                if (code === 32 /* ' ' */  || code === 9 /* '\t' */ ) {
                                    // Folded value
                                    start = pos;
                                    this.crlf = 0;
                                } else {
                                    if (++this.pairCount < MAX_HEADER_PAIRS) {
                                        this.name = this.name.toLowerCase();
                                        if (this.header[this.name] === undefined) this.header[this.name] = [
                                            this.value
                                        ];
                                        else this.header[this.name].push(this.value);
                                    }
                                    if (code === 13 /* '\r' */ ) {
                                        ++this.crlf;
                                        ++pos;
                                    } else {
                                        // Assume start of next header field name
                                        start = pos;
                                        this.crlf = 0;
                                        this.state = HPARSER_NAME;
                                        this.name = '';
                                        this.value = '';
                                    }
                                }
                                break;
                            }
                        case 3:
                            {
                                if (this.byteCount === MAX_HEADER_SIZE) return -1;
                                ++this.byteCount;
                                if (chunk[pos++] !== 10 /* '\n' */ ) return -1;
                                // End of header
                                const header = this.header;
                                this.reset();
                                this.cb(header);
                                return pos;
                            }
                    }
                    break;
            }
        }
        return pos;
    }
}
class FileStream extends Readable {
    constructor(opts, owner){
        super(opts);
        this.truncated = false;
        this._readcb = null;
        this.once('end', ()=>{
            // We need to make sure that we call any outstanding _writecb() that is
            // associated with this file so that processing of the rest of the form
            // can continue. This may not happen if the file stream ends right after
            // backpressure kicks in, so we force it here.
            this._read();
            if (--owner._fileEndsLeft === 0 && owner._finalcb) {
                const cb = owner._finalcb;
                owner._finalcb = null;
                // Make sure other 'end' event handlers get a chance to be executed
                // before busboy's 'finish' event is emitted
                process.nextTick(cb);
            }
        });
    }
    _read(n) {
        const cb = this._readcb;
        if (cb) {
            this._readcb = null;
            cb();
        }
    }
}
const ignoreData = {
    push: (chunk, pos)=>{},
    destroy: ()=>{}
};
function callAndUnsetCb(self, err) {
    const cb = self._writecb;
    self._writecb = null;
    if (err) self.destroy(err);
    else if (cb) cb();
}
function nullDecoder(val, hint) {
    return val;
}
class Multipart extends Writable {
    constructor(cfg){
        const streamOpts = {
            autoDestroy: true,
            emitClose: true,
            highWaterMark: typeof cfg.highWaterMark === 'number' ? cfg.highWaterMark : undefined
        };
        super(streamOpts);
        if (!cfg.conType.params || typeof cfg.conType.params.boundary !== 'string') throw new Error('Multipart: Boundary not found');
        const boundary = cfg.conType.params.boundary;
        const paramDecoder = typeof cfg.defParamCharset === 'string' && cfg.defParamCharset ? getDecoder(cfg.defParamCharset) : nullDecoder;
        const defCharset = cfg.defCharset || 'utf8';
        const preservePath = cfg.preservePath;
        const fileOpts = {
            autoDestroy: true,
            emitClose: true,
            highWaterMark: typeof cfg.fileHwm === 'number' ? cfg.fileHwm : undefined
        };
        const limits = cfg.limits;
        const fieldSizeLimit = limits && typeof limits.fieldSize === 'number' ? limits.fieldSize : 1 * 1024 * 1024;
        const fileSizeLimit = limits && typeof limits.fileSize === 'number' ? limits.fileSize : Infinity;
        const filesLimit = limits && typeof limits.files === 'number' ? limits.files : Infinity;
        const fieldsLimit = limits && typeof limits.fields === 'number' ? limits.fields : Infinity;
        const partsLimit = limits && typeof limits.parts === 'number' ? limits.parts : Infinity;
        let parts = -1; // Account for initial boundary
        let fields = 0;
        let files = 0;
        let skipPart = false;
        this._fileEndsLeft = 0;
        this._fileStream = undefined;
        this._complete = false;
        let fileSize = 0;
        let field;
        let fieldSize = 0;
        let partCharset;
        let partEncoding;
        let partType;
        let partName;
        let partTruncated = false;
        let hitFilesLimit = false;
        let hitFieldsLimit = false;
        this._hparser = null;
        const hparser = new HeaderParser((header)=>{
            this._hparser = null;
            skipPart = false;
            partType = 'text/plain';
            partCharset = defCharset;
            partEncoding = '7bit';
            partName = undefined;
            partTruncated = false;
            let filename;
            if (!header['content-disposition']) {
                skipPart = true;
                return;
            }
            const disp = parseDisposition(header['content-disposition'][0], paramDecoder);
            if (!disp || disp.type !== 'form-data') {
                skipPart = true;
                return;
            }
            if (disp.params) {
                if (disp.params.name) partName = disp.params.name;
                if (disp.params['filename*']) filename = disp.params['filename*'];
                else if (disp.params.filename) filename = disp.params.filename;
                if (filename !== undefined && !preservePath) filename = basename(filename);
            }
            if (header['content-type']) {
                const conType = parseContentType(header['content-type'][0]);
                if (conType) {
                    partType = `${conType.type}/${conType.subtype}`;
                    if (conType.params && typeof conType.params.charset === 'string') partCharset = conType.params.charset.toLowerCase();
                }
            }
            if (header['content-transfer-encoding']) partEncoding = header['content-transfer-encoding'][0].toLowerCase();
            if (partType === 'application/octet-stream' || filename !== undefined) {
                // File
                if (files === filesLimit) {
                    if (!hitFilesLimit) {
                        hitFilesLimit = true;
                        this.emit('filesLimit');
                    }
                    skipPart = true;
                    return;
                }
                ++files;
                if (this.listenerCount('file') === 0) {
                    skipPart = true;
                    return;
                }
                fileSize = 0;
                this._fileStream = new FileStream(fileOpts, this);
                ++this._fileEndsLeft;
                this.emit('file', partName, this._fileStream, {
                    filename,
                    encoding: partEncoding,
                    mimeType: partType
                });
            } else {
                // Non-file
                if (fields === fieldsLimit) {
                    if (!hitFieldsLimit) {
                        hitFieldsLimit = true;
                        this.emit('fieldsLimit');
                    }
                    skipPart = true;
                    return;
                }
                ++fields;
                if (this.listenerCount('field') === 0) {
                    skipPart = true;
                    return;
                }
                field = [];
                fieldSize = 0;
            }
        });
        let matchPostBoundary = 0;
        const ssCb = (isMatch, data, start, end, isDataSafe)=>{
            retrydata: while(data){
                if (this._hparser !== null) {
                    const ret = this._hparser.push(data, start, end);
                    if (ret === -1) {
                        this._hparser = null;
                        hparser.reset();
                        this.emit('error', new Error('Malformed part header'));
                        break;
                    }
                    start = ret;
                }
                if (start === end) break;
                if (matchPostBoundary !== 0) {
                    if (matchPostBoundary === 1) {
                        switch(data[start]){
                            case 45:
                                // Try matching '--' after boundary
                                matchPostBoundary = 2;
                                ++start;
                                break;
                            case 13:
                                // Try matching CR LF before header
                                matchPostBoundary = 3;
                                ++start;
                                break;
                            default:
                                matchPostBoundary = 0;
                        }
                        if (start === end) return;
                    }
                    if (matchPostBoundary === 2) {
                        matchPostBoundary = 0;
                        if (data[start] === 45 /* '-' */ ) {
                            // End of multipart data
                            this._complete = true;
                            this._bparser = ignoreData;
                            return;
                        }
                        // We saw something other than '-', so put the dash we consumed
                        // "back"
                        const writecb = this._writecb;
                        this._writecb = noop;
                        ssCb(false, BUF_DASH, 0, 1, false);
                        this._writecb = writecb;
                    } else if (matchPostBoundary === 3) {
                        matchPostBoundary = 0;
                        if (data[start] === 10 /* '\n' */ ) {
                            ++start;
                            if (parts >= partsLimit) break;
                            // Prepare the header parser
                            this._hparser = hparser;
                            if (start === end) break;
                            continue retrydata;
                        } else {
                            // We saw something other than LF, so put the CR we consumed
                            // "back"
                            const writecb = this._writecb;
                            this._writecb = noop;
                            ssCb(false, BUF_CR, 0, 1, false);
                            this._writecb = writecb;
                        }
                    }
                }
                if (!skipPart) {
                    if (this._fileStream) {
                        let chunk;
                        const actualLen = Math.min(end - start, fileSizeLimit - fileSize);
                        if (!isDataSafe) {
                            chunk = Buffer.allocUnsafe(actualLen);
                            data.copy(chunk, 0, start, start + actualLen);
                        } else {
                            chunk = data.slice(start, start + actualLen);
                        }
                        fileSize += chunk.length;
                        if (fileSize === fileSizeLimit) {
                            if (chunk.length > 0) this._fileStream.push(chunk);
                            this._fileStream.emit('limit');
                            this._fileStream.truncated = true;
                            skipPart = true;
                        } else if (!this._fileStream.push(chunk)) {
                            if (this._writecb) this._fileStream._readcb = this._writecb;
                            this._writecb = null;
                        }
                    } else if (field !== undefined) {
                        let chunk;
                        const actualLen = Math.min(end - start, fieldSizeLimit - fieldSize);
                        if (!isDataSafe) {
                            chunk = Buffer.allocUnsafe(actualLen);
                            data.copy(chunk, 0, start, start + actualLen);
                        } else {
                            chunk = data.slice(start, start + actualLen);
                        }
                        fieldSize += actualLen;
                        field.push(chunk);
                        if (fieldSize === fieldSizeLimit) {
                            skipPart = true;
                            partTruncated = true;
                        }
                    }
                }
                break;
            }
            if (isMatch) {
                matchPostBoundary = 1;
                if (this._fileStream) {
                    // End the active file stream if the previous part was a file
                    this._fileStream.push(null);
                    this._fileStream = null;
                } else if (field !== undefined) {
                    let data;
                    switch(field.length){
                        case 0:
                            data = '';
                            break;
                        case 1:
                            data = convertToUTF8(field[0], partCharset, 0);
                            break;
                        default:
                            data = convertToUTF8(Buffer.concat(field, fieldSize), partCharset, 0);
                    }
                    field = undefined;
                    fieldSize = 0;
                    this.emit('field', partName, data, {
                        nameTruncated: false,
                        valueTruncated: partTruncated,
                        encoding: partEncoding,
                        mimeType: partType
                    });
                }
                if (++parts === partsLimit) this.emit('partsLimit');
            }
        };
        this._bparser = new StreamSearch(`\r\n--${boundary}`, ssCb);
        this._writecb = null;
        this._finalcb = null;
        // Just in case there is no preamble
        this.write(BUF_CRLF);
    }
    static detect(conType) {
        return conType.type === 'multipart' && conType.subtype === 'form-data';
    }
    _write(chunk, enc, cb) {
        this._writecb = cb;
        this._bparser.push(chunk, 0);
        if (this._writecb) callAndUnsetCb(this);
    }
    _destroy(err, cb) {
        this._hparser = null;
        this._bparser = ignoreData;
        if (!err) err = checkEndState(this);
        const fileStream = this._fileStream;
        if (fileStream) {
            this._fileStream = null;
            fileStream.destroy(err);
        }
        cb(err);
    }
    _final(cb) {
        this._bparser.destroy();
        if (!this._complete) return cb(new Error('Unexpected end of form'));
        if (this._fileEndsLeft) this._finalcb = finalcb.bind(null, this, cb);
        else finalcb(this, cb);
    }
}
function finalcb(self, cb, err) {
    if (err) return cb(err);
    err = checkEndState(self);
    cb(err);
}
function checkEndState(self) {
    if (self._hparser) return new Error('Malformed part header');
    const fileStream = self._fileStream;
    if (fileStream) {
        self._fileStream = null;
        fileStream.destroy(new Error('Unexpected end of file'));
    }
    if (!self._complete) return new Error('Unexpected end of form');
}
const TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
];
const FIELD_VCHAR = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
];
module.exports = Multipart;
}),
"[project]/node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/types/urlencoded.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { Writable } = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const { getDecoder } = __turbopack_context__.r("[project]/node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/utils.js [app-rsc] (ecmascript)");
class URLEncoded extends Writable {
    constructor(cfg){
        const streamOpts = {
            autoDestroy: true,
            emitClose: true,
            highWaterMark: typeof cfg.highWaterMark === 'number' ? cfg.highWaterMark : undefined
        };
        super(streamOpts);
        let charset = cfg.defCharset || 'utf8';
        if (cfg.conType.params && typeof cfg.conType.params.charset === 'string') charset = cfg.conType.params.charset;
        this.charset = charset;
        const limits = cfg.limits;
        this.fieldSizeLimit = limits && typeof limits.fieldSize === 'number' ? limits.fieldSize : 1 * 1024 * 1024;
        this.fieldsLimit = limits && typeof limits.fields === 'number' ? limits.fields : Infinity;
        this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === 'number' ? limits.fieldNameSize : 100;
        this._inKey = true;
        this._keyTrunc = false;
        this._valTrunc = false;
        this._bytesKey = 0;
        this._bytesVal = 0;
        this._fields = 0;
        this._key = '';
        this._val = '';
        this._byte = -2;
        this._lastPos = 0;
        this._encode = 0;
        this._decoder = getDecoder(charset);
    }
    static detect(conType) {
        return conType.type === 'application' && conType.subtype === 'x-www-form-urlencoded';
    }
    _write(chunk, enc, cb) {
        if (this._fields >= this.fieldsLimit) return cb();
        let i = 0;
        const len = chunk.length;
        this._lastPos = 0;
        // Check if we last ended mid-percent-encoded byte
        if (this._byte !== -2) {
            i = readPctEnc(this, chunk, i, len);
            if (i === -1) return cb(new Error('Malformed urlencoded form'));
            if (i >= len) return cb();
            if (this._inKey) ++this._bytesKey;
            else ++this._bytesVal;
        }
        main: while(i < len){
            if (this._inKey) {
                // Parsing key
                i = skipKeyBytes(this, chunk, i, len);
                while(i < len){
                    switch(chunk[i]){
                        case 61:
                            if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);
                            this._lastPos = ++i;
                            this._key = this._decoder(this._key, this._encode);
                            this._encode = 0;
                            this._inKey = false;
                            continue main;
                        case 38:
                            if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);
                            this._lastPos = ++i;
                            this._key = this._decoder(this._key, this._encode);
                            this._encode = 0;
                            if (this._bytesKey > 0) {
                                this.emit('field', this._key, '', {
                                    nameTruncated: this._keyTrunc,
                                    valueTruncated: false,
                                    encoding: this.charset,
                                    mimeType: 'text/plain'
                                });
                            }
                            this._key = '';
                            this._val = '';
                            this._keyTrunc = false;
                            this._valTrunc = false;
                            this._bytesKey = 0;
                            this._bytesVal = 0;
                            if (++this._fields >= this.fieldsLimit) {
                                this.emit('fieldsLimit');
                                return cb();
                            }
                            continue;
                        case 43:
                            if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);
                            this._key += ' ';
                            this._lastPos = i + 1;
                            break;
                        case 37:
                            if (this._encode === 0) this._encode = 1;
                            if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);
                            this._lastPos = i + 1;
                            this._byte = -1;
                            i = readPctEnc(this, chunk, i + 1, len);
                            if (i === -1) return cb(new Error('Malformed urlencoded form'));
                            if (i >= len) return cb();
                            ++this._bytesKey;
                            i = skipKeyBytes(this, chunk, i, len);
                            continue;
                    }
                    ++i;
                    ++this._bytesKey;
                    i = skipKeyBytes(this, chunk, i, len);
                }
                if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);
            } else {
                // Parsing value
                i = skipValBytes(this, chunk, i, len);
                while(i < len){
                    switch(chunk[i]){
                        case 38:
                            if (this._lastPos < i) this._val += chunk.latin1Slice(this._lastPos, i);
                            this._lastPos = ++i;
                            this._inKey = true;
                            this._val = this._decoder(this._val, this._encode);
                            this._encode = 0;
                            if (this._bytesKey > 0 || this._bytesVal > 0) {
                                this.emit('field', this._key, this._val, {
                                    nameTruncated: this._keyTrunc,
                                    valueTruncated: this._valTrunc,
                                    encoding: this.charset,
                                    mimeType: 'text/plain'
                                });
                            }
                            this._key = '';
                            this._val = '';
                            this._keyTrunc = false;
                            this._valTrunc = false;
                            this._bytesKey = 0;
                            this._bytesVal = 0;
                            if (++this._fields >= this.fieldsLimit) {
                                this.emit('fieldsLimit');
                                return cb();
                            }
                            continue main;
                        case 43:
                            if (this._lastPos < i) this._val += chunk.latin1Slice(this._lastPos, i);
                            this._val += ' ';
                            this._lastPos = i + 1;
                            break;
                        case 37:
                            if (this._encode === 0) this._encode = 1;
                            if (this._lastPos < i) this._val += chunk.latin1Slice(this._lastPos, i);
                            this._lastPos = i + 1;
                            this._byte = -1;
                            i = readPctEnc(this, chunk, i + 1, len);
                            if (i === -1) return cb(new Error('Malformed urlencoded form'));
                            if (i >= len) return cb();
                            ++this._bytesVal;
                            i = skipValBytes(this, chunk, i, len);
                            continue;
                    }
                    ++i;
                    ++this._bytesVal;
                    i = skipValBytes(this, chunk, i, len);
                }
                if (this._lastPos < i) this._val += chunk.latin1Slice(this._lastPos, i);
            }
        }
        cb();
    }
    _final(cb) {
        if (this._byte !== -2) return cb(new Error('Malformed urlencoded form'));
        if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {
            if (this._inKey) this._key = this._decoder(this._key, this._encode);
            else this._val = this._decoder(this._val, this._encode);
            this.emit('field', this._key, this._val, {
                nameTruncated: this._keyTrunc,
                valueTruncated: this._valTrunc,
                encoding: this.charset,
                mimeType: 'text/plain'
            });
        }
        cb();
    }
}
function readPctEnc(self, chunk, pos, len) {
    if (pos >= len) return len;
    if (self._byte === -1) {
        // We saw a '%' but no hex characters yet
        const hexUpper = HEX_VALUES[chunk[pos++]];
        if (hexUpper === -1) return -1;
        if (hexUpper >= 8) self._encode = 2; // Indicate high bits detected
        if (pos < len) {
            // Both hex characters are in this chunk
            const hexLower = HEX_VALUES[chunk[pos++]];
            if (hexLower === -1) return -1;
            if (self._inKey) self._key += String.fromCharCode((hexUpper << 4) + hexLower);
            else self._val += String.fromCharCode((hexUpper << 4) + hexLower);
            self._byte = -2;
            self._lastPos = pos;
        } else {
            // Only one hex character was available in this chunk
            self._byte = hexUpper;
        }
    } else {
        // We saw only one hex character so far
        const hexLower = HEX_VALUES[chunk[pos++]];
        if (hexLower === -1) return -1;
        if (self._inKey) self._key += String.fromCharCode((self._byte << 4) + hexLower);
        else self._val += String.fromCharCode((self._byte << 4) + hexLower);
        self._byte = -2;
        self._lastPos = pos;
    }
    return pos;
}
function skipKeyBytes(self, chunk, pos, len) {
    // Skip bytes if we've truncated
    if (self._bytesKey > self.fieldNameSizeLimit) {
        if (!self._keyTrunc) {
            if (self._lastPos < pos) self._key += chunk.latin1Slice(self._lastPos, pos - 1);
        }
        self._keyTrunc = true;
        for(; pos < len; ++pos){
            const code = chunk[pos];
            if (code === 61 /* '=' */  || code === 38 /* '&' */ ) break;
            ++self._bytesKey;
        }
        self._lastPos = pos;
    }
    return pos;
}
function skipValBytes(self, chunk, pos, len) {
    // Skip bytes if we've truncated
    if (self._bytesVal > self.fieldSizeLimit) {
        if (!self._valTrunc) {
            if (self._lastPos < pos) self._val += chunk.latin1Slice(self._lastPos, pos - 1);
        }
        self._valTrunc = true;
        for(; pos < len; ++pos){
            if (chunk[pos] === 38 /* '&' */ ) break;
            ++self._bytesVal;
        }
        self._lastPos = pos;
    }
    return pos;
}
/* eslint-disable no-multi-spaces */ const HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
];
/* eslint-enable no-multi-spaces */ module.exports = URLEncoded;
}),
"[project]/node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { parseContentType } = __turbopack_context__.r("[project]/node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/utils.js [app-rsc] (ecmascript)");
function getInstance(cfg) {
    const headers = cfg.headers;
    const conType = parseContentType(headers['content-type']);
    if (!conType) throw new Error('Malformed content type');
    for (const type of TYPES){
        const matched = type.detect(conType);
        if (!matched) continue;
        const instanceCfg = {
            limits: cfg.limits,
            headers,
            conType,
            highWaterMark: undefined,
            fileHwm: undefined,
            defCharset: undefined,
            defParamCharset: undefined,
            preservePath: false
        };
        if (cfg.highWaterMark) instanceCfg.highWaterMark = cfg.highWaterMark;
        if (cfg.fileHwm) instanceCfg.fileHwm = cfg.fileHwm;
        instanceCfg.defCharset = cfg.defCharset;
        instanceCfg.defParamCharset = cfg.defParamCharset;
        instanceCfg.preservePath = cfg.preservePath;
        return new type(instanceCfg);
    }
    throw new Error(`Unsupported content type: ${headers['content-type']}`);
}
// Note: types are explicitly listed here for easier bundling
// See: https://github.com/mscdex/busboy/issues/121
const TYPES = [
    __turbopack_context__.r("[project]/node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/types/multipart.js [app-rsc] (ecmascript)"),
    __turbopack_context__.r("[project]/node_modules/.pnpm/busboy@1.6.0/node_modules/busboy/lib/types/urlencoded.js [app-rsc] (ecmascript)")
].filter(function(typemod) {
    return typeof typemod.detect === 'function';
});
module.exports = (cfg)=>{
    if (typeof cfg !== 'object' || cfg === null) cfg = {};
    if (typeof cfg.headers !== 'object' || cfg.headers === null || typeof cfg.headers['content-type'] !== 'string') {
        throw new Error('Missing Content-Type');
    }
    return getInstance(cfg);
};
}),
"[project]/node_modules/.pnpm/ci-info@4.3.1/node_modules/ci-info/vendors.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v([{"name":"Agola CI","constant":"AGOLA","env":"AGOLA_GIT_REF","pr":"AGOLA_PULL_REQUEST_ID"},{"name":"Appcircle","constant":"APPCIRCLE","env":"AC_APPCIRCLE","pr":{"env":"AC_GIT_PR","ne":"false"}},{"name":"AppVeyor","constant":"APPVEYOR","env":"APPVEYOR","pr":"APPVEYOR_PULL_REQUEST_NUMBER"},{"name":"AWS CodeBuild","constant":"CODEBUILD","env":"CODEBUILD_BUILD_ARN","pr":{"env":"CODEBUILD_WEBHOOK_EVENT","any":["PULL_REQUEST_CREATED","PULL_REQUEST_UPDATED","PULL_REQUEST_REOPENED"]}},{"name":"Azure Pipelines","constant":"AZURE_PIPELINES","env":"TF_BUILD","pr":{"BUILD_REASON":"PullRequest"}},{"name":"Bamboo","constant":"BAMBOO","env":"bamboo_planKey"},{"name":"Bitbucket Pipelines","constant":"BITBUCKET","env":"BITBUCKET_COMMIT","pr":"BITBUCKET_PR_ID"},{"name":"Bitrise","constant":"BITRISE","env":"BITRISE_IO","pr":"BITRISE_PULL_REQUEST"},{"name":"Buddy","constant":"BUDDY","env":"BUDDY_WORKSPACE_ID","pr":"BUDDY_EXECUTION_PULL_REQUEST_ID"},{"name":"Buildkite","constant":"BUILDKITE","env":"BUILDKITE","pr":{"env":"BUILDKITE_PULL_REQUEST","ne":"false"}},{"name":"CircleCI","constant":"CIRCLE","env":"CIRCLECI","pr":"CIRCLE_PULL_REQUEST"},{"name":"Cirrus CI","constant":"CIRRUS","env":"CIRRUS_CI","pr":"CIRRUS_PR"},{"name":"Cloudflare Pages","constant":"CLOUDFLARE_PAGES","env":"CF_PAGES"},{"name":"Cloudflare Workers","constant":"CLOUDFLARE_WORKERS","env":"WORKERS_CI"},{"name":"Codefresh","constant":"CODEFRESH","env":"CF_BUILD_ID","pr":{"any":["CF_PULL_REQUEST_NUMBER","CF_PULL_REQUEST_ID"]}},{"name":"Codemagic","constant":"CODEMAGIC","env":"CM_BUILD_ID","pr":"CM_PULL_REQUEST"},{"name":"Codeship","constant":"CODESHIP","env":{"CI_NAME":"codeship"}},{"name":"Drone","constant":"DRONE","env":"DRONE","pr":{"DRONE_BUILD_EVENT":"pull_request"}},{"name":"dsari","constant":"DSARI","env":"DSARI"},{"name":"Earthly","constant":"EARTHLY","env":"EARTHLY_CI"},{"name":"Expo Application Services","constant":"EAS","env":"EAS_BUILD"},{"name":"Gerrit","constant":"GERRIT","env":"GERRIT_PROJECT"},{"name":"Gitea Actions","constant":"GITEA_ACTIONS","env":"GITEA_ACTIONS"},{"name":"GitHub Actions","constant":"GITHUB_ACTIONS","env":"GITHUB_ACTIONS","pr":{"GITHUB_EVENT_NAME":"pull_request"}},{"name":"GitLab CI","constant":"GITLAB","env":"GITLAB_CI","pr":"CI_MERGE_REQUEST_ID"},{"name":"GoCD","constant":"GOCD","env":"GO_PIPELINE_LABEL"},{"name":"Google Cloud Build","constant":"GOOGLE_CLOUD_BUILD","env":"BUILDER_OUTPUT"},{"name":"Harness CI","constant":"HARNESS","env":"HARNESS_BUILD_ID"},{"name":"Heroku","constant":"HEROKU","env":{"env":"NODE","includes":"/app/.heroku/node/bin/node"}},{"name":"Hudson","constant":"HUDSON","env":"HUDSON_URL"},{"name":"Jenkins","constant":"JENKINS","env":["JENKINS_URL","BUILD_ID"],"pr":{"any":["ghprbPullId","CHANGE_ID"]}},{"name":"LayerCI","constant":"LAYERCI","env":"LAYERCI","pr":"LAYERCI_PULL_REQUEST"},{"name":"Magnum CI","constant":"MAGNUM","env":"MAGNUM"},{"name":"Netlify CI","constant":"NETLIFY","env":"NETLIFY","pr":{"env":"PULL_REQUEST","ne":"false"}},{"name":"Nevercode","constant":"NEVERCODE","env":"NEVERCODE","pr":{"env":"NEVERCODE_PULL_REQUEST","ne":"false"}},{"name":"Prow","constant":"PROW","env":"PROW_JOB_ID"},{"name":"ReleaseHub","constant":"RELEASEHUB","env":"RELEASE_BUILD_ID"},{"name":"Render","constant":"RENDER","env":"RENDER","pr":{"IS_PULL_REQUEST":"true"}},{"name":"Sail CI","constant":"SAIL","env":"SAILCI","pr":"SAIL_PULL_REQUEST_NUMBER"},{"name":"Screwdriver","constant":"SCREWDRIVER","env":"SCREWDRIVER","pr":{"env":"SD_PULL_REQUEST","ne":"false"}},{"name":"Semaphore","constant":"SEMAPHORE","env":"SEMAPHORE","pr":"PULL_REQUEST_NUMBER"},{"name":"Sourcehut","constant":"SOURCEHUT","env":{"CI_NAME":"sourcehut"}},{"name":"Strider CD","constant":"STRIDER","env":"STRIDER"},{"name":"TaskCluster","constant":"TASKCLUSTER","env":["TASK_ID","RUN_ID"]},{"name":"TeamCity","constant":"TEAMCITY","env":"TEAMCITY_VERSION"},{"name":"Travis CI","constant":"TRAVIS","env":"TRAVIS","pr":{"env":"TRAVIS_PULL_REQUEST","ne":"false"}},{"name":"Vela","constant":"VELA","env":"VELA","pr":{"VELA_PULL_REQUEST":"1"}},{"name":"Vercel","constant":"VERCEL","env":{"any":["NOW_BUILDER","VERCEL"]},"pr":"VERCEL_GIT_PULL_REQUEST_ID"},{"name":"Visual Studio App Center","constant":"APPCENTER","env":"APPCENTER_BUILD_ID"},{"name":"Woodpecker","constant":"WOODPECKER","env":{"CI":"woodpecker"},"pr":{"CI_BUILD_EVENT":"pull_request"}},{"name":"Xcode Cloud","constant":"XCODE_CLOUD","env":"CI_XCODE_PROJECT","pr":"CI_PULL_REQUEST_NUMBER"},{"name":"Xcode Server","constant":"XCODE_SERVER","env":"XCS"}]);}),
"[project]/node_modules/.pnpm/ci-info@4.3.1/node_modules/ci-info/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const vendors = __turbopack_context__.r("[project]/node_modules/.pnpm/ci-info@4.3.1/node_modules/ci-info/vendors.json (json)");
const env = process.env;
// Used for testing only
Object.defineProperty(exports, '_vendors', {
    value: vendors.map(function(v) {
        return v.constant;
    })
});
exports.name = null;
exports.isPR = null;
exports.id = null;
if (env.CI !== 'false') {
    vendors.forEach(function(vendor) {
        const envs = Array.isArray(vendor.env) ? vendor.env : [
            vendor.env
        ];
        const isCI = envs.every(function(obj) {
            return checkEnv(obj);
        });
        exports[vendor.constant] = isCI;
        if (!isCI) {
            return;
        }
        exports.name = vendor.name;
        exports.isPR = checkPR(vendor);
        exports.id = vendor.constant;
    });
}
exports.isCI = !!(env.CI !== 'false' && // Bypass all checks if CI env is explicitly set to 'false'
(env.BUILD_ID || // Jenkins, Cloudbees
env.BUILD_NUMBER || // Jenkins, TeamCity
env.CI || // Travis CI, CircleCI, Cirrus CI, Gitlab CI, Appveyor, CodeShip, dsari, Cloudflare Pages/Workers
env.CI_APP_ID || // Appflow
env.CI_BUILD_ID || // Appflow
env.CI_BUILD_NUMBER || // Appflow
env.CI_NAME || // Codeship and others
env.CONTINUOUS_INTEGRATION || // Travis CI, Cirrus CI
env.RUN_ID || // TaskCluster, dsari
exports.name || false));
function checkEnv(obj) {
    // "env": "CIRRUS"
    if (typeof obj === 'string') return !!env[obj];
    // "env": { "env": "NODE", "includes": "/app/.heroku/node/bin/node" }
    if ('env' in obj) {
        // Currently there are no other types, uncomment when there are
        // if ('includes' in obj) {
        return env[obj.env] && env[obj.env].includes(obj.includes);
    // }
    }
    if ('any' in obj) {
        return obj.any.some(function(k) {
            return !!env[k];
        });
    }
    return Object.keys(obj).every(function(k) {
        return env[k] === obj[k];
    });
}
function checkPR(vendor) {
    switch(typeof vendor.pr){
        case 'string':
            // "pr": "CIRRUS_PR"
            return !!env[vendor.pr];
        case 'object':
            if ('env' in vendor.pr) {
                if ('any' in vendor.pr) {
                    // "pr": { "env": "CODEBUILD_WEBHOOK_EVENT", "any": ["PULL_REQUEST_CREATED", "PULL_REQUEST_UPDATED"] }
                    return vendor.pr.any.some(function(key) {
                        return env[vendor.pr.env] === key;
                    });
                } else {
                    // "pr": { "env": "BUILDKITE_PULL_REQUEST", "ne": "false" }
                    return vendor.pr.env in env && env[vendor.pr.env] !== vendor.pr.ne;
                }
            } else if ('any' in vendor.pr) {
                // "pr": { "any": ["ghprbPullId", "CHANGE_ID"] }
                return vendor.pr.any.some(function(key) {
                    return !!env[key];
                });
            } else {
                // "pr": { "DRONE_BUILD_EVENT": "pull_request" }
                return checkEnv(vendor.pr);
            }
        default:
            // PR detection not supported for this vendor
            return null;
    }
}
}),
"[project]/node_modules/.pnpm/scmp@2.1.0/node_modules/scmp/lib/scmpCompare.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function scmpCompare(a, b) {
    const len = a.length;
    let result = 0;
    for(let i = 0; i < len; ++i){
        result |= a[i] ^ b[i];
    }
    return result === 0;
};
}),
"[project]/node_modules/.pnpm/scmp@2.1.0/node_modules/scmp/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
const scmpCompare = __turbopack_context__.r("[project]/node_modules/.pnpm/scmp@2.1.0/node_modules/scmp/lib/scmpCompare.js [app-rsc] (ecmascript)");
/**
 * Does a constant-time Buffer comparison by not short-circuiting
 * on first sign of non-equivalency.
 *
 * @param {Buffer} a The first Buffer to be compared against the second
 * @param {Buffer} b The second Buffer to be compared against the first
 * @return {Boolean}
 */ module.exports = function scmp(a, b) {
    // check that both inputs are buffers
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new Error('Both scmp args must be Buffers');
    }
    // return early here if buffer lengths are not equal since timingSafeEqual
    // will throw if buffer lengths are not equal
    if (a.length !== b.length) {
        return false;
    }
    // use crypto.timingSafeEqual if available (since Node.js v6.6.0),
    // otherwise use our own scmp-internal function.
    if (crypto.timingSafeEqual) {
        return crypto.timingSafeEqual(a, b);
    }
    return scmpCompare(a, b);
};
}),
"[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/EndOfStreamError.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "EndOfStreamError",
    ()=>EndOfStreamError,
    "defaultMessages",
    ()=>defaultMessages
]);
const defaultMessages = 'End-Of-Stream';
class EndOfStreamError extends Error {
    constructor(){
        super(defaultMessages);
    }
}
}),
"[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/Deferred.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Deferred",
    ()=>Deferred
]);
class Deferred {
    constructor(){
        this.resolve = ()=>null;
        this.reject = ()=>null;
        this.promise = new Promise((resolve, reject)=>{
            this.reject = reject;
            this.resolve = resolve;
        });
    }
}
}),
"[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/AbstractStreamReader.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AbstractStreamReader",
    ()=>AbstractStreamReader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/EndOfStreamError.js [app-rsc] (ecmascript)");
;
class AbstractStreamReader {
    constructor(){
        /**
         * Maximum request length on read-stream operation
         */ this.maxStreamReadSize = 1 * 1024 * 1024;
        this.endOfStream = false;
        /**
         * Store peeked data
         * @type {Array}
         */ this.peekQueue = [];
    }
    async peek(uint8Array, offset, length) {
        const bytesRead = await this.read(uint8Array, offset, length);
        this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead)); // Put read data back to peek buffer
        return bytesRead;
    }
    async read(buffer, offset, length) {
        if (length === 0) {
            return 0;
        }
        let bytesRead = this.readFromPeekBuffer(buffer, offset, length);
        bytesRead += await this.readRemainderFromStream(buffer, offset + bytesRead, length - bytesRead);
        if (bytesRead === 0) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
        }
        return bytesRead;
    }
    /**
     * Read chunk from stream
     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
     * @param offset - Offset target
     * @param length - Number of bytes to read
     * @returns Number of bytes read
     */ readFromPeekBuffer(buffer, offset, length) {
        let remaining = length;
        let bytesRead = 0;
        // consume peeked data first
        while(this.peekQueue.length > 0 && remaining > 0){
            const peekData = this.peekQueue.pop(); // Front of queue
            if (!peekData) throw new Error('peekData should be defined');
            const lenCopy = Math.min(peekData.length, remaining);
            buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
            bytesRead += lenCopy;
            remaining -= lenCopy;
            if (lenCopy < peekData.length) {
                // remainder back to queue
                this.peekQueue.push(peekData.subarray(lenCopy));
            }
        }
        return bytesRead;
    }
    async readRemainderFromStream(buffer, offset, initialRemaining) {
        let remaining = initialRemaining;
        let bytesRead = 0;
        // Continue reading from stream if required
        while(remaining > 0 && !this.endOfStream){
            const reqLen = Math.min(remaining, this.maxStreamReadSize);
            const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);
            if (chunkLen === 0) break;
            bytesRead += chunkLen;
            remaining -= chunkLen;
        }
        return bytesRead;
    }
}
}),
"[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/StreamReader.js [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "StreamReader",
    ()=>StreamReader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/EndOfStreamError.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$Deferred$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/Deferred.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$AbstractStreamReader$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/AbstractStreamReader.js [app-rsc] (ecmascript)");
;
;
;
;
class StreamReader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$AbstractStreamReader$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AbstractStreamReader"] {
    constructor(s){
        super();
        this.s = s;
        /**
         * Deferred used for postponed read request (as not data is yet available to read)
         */ this.deferred = null;
        if (!s.read || !s.once) {
            throw new Error('Expected an instance of stream.Readable');
        }
        this.s.once('end', ()=>this.reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["EndOfStreamError"]()));
        this.s.once('error', (err)=>this.reject(err));
        this.s.once('close', ()=>this.reject(new Error('Stream closed')));
    }
    /**
     * Read chunk from stream
     * @param buffer Target Uint8Array (or Buffer) to store data read from stream in
     * @param offset Offset target
     * @param length Number of bytes to read
     * @returns Number of bytes read
     */ async readFromStream(buffer, offset, length) {
        if (this.endOfStream) {
            return 0;
        }
        const readBuffer = this.s.read(length);
        if (readBuffer) {
            buffer.set(readBuffer, offset);
            return readBuffer.length;
        }
        const request = {
            buffer,
            offset,
            length,
            deferred: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$Deferred$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Deferred"]()
        };
        this.deferred = request.deferred;
        this.s.once('readable', ()=>{
            this.readDeferred(request);
        });
        return request.deferred.promise;
    }
    /**
     * Process deferred read request
     * @param request Deferred read request
     */ readDeferred(request) {
        const readBuffer = this.s.read(request.length);
        if (readBuffer) {
            request.buffer.set(readBuffer, request.offset);
            request.deferred.resolve(readBuffer.length);
            this.deferred = null;
        } else {
            this.s.once('readable', ()=>{
                this.readDeferred(request);
            });
        }
    }
    reject(err) {
        this.endOfStream = true;
        if (this.deferred) {
            this.deferred.reject(err);
            this.deferred = null;
        }
    }
    async abort() {
        this.reject(new Error('abort'));
    }
    async close() {
        return this.abort();
    }
}
}),
"[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/WebStreamReader.js [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "WebStreamReader",
    ()=>WebStreamReader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/EndOfStreamError.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$AbstractStreamReader$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/AbstractStreamReader.js [app-rsc] (ecmascript)");
;
;
;
class WebStreamReader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$AbstractStreamReader$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AbstractStreamReader"] {
    constructor(stream){
        super();
        this.reader = stream.getReader({
            mode: 'byob'
        });
    }
    async readFromStream(buffer, offset, length) {
        if (this.endOfStream) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
        }
        const result = await this.reader.read(new Uint8Array(length));
        if (result.done) {
            this.endOfStream = result.done;
        }
        if (result.value) {
            buffer.set(result.value, offset);
            return result.value.byteLength;
        }
        return 0;
    }
    abort() {
        return this.reader.cancel(); // Signals a loss of interest in the stream by a consumer
    }
    async close() {
        await this.abort();
        this.reader.releaseLock();
    }
}
}),
"[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/index.js [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/EndOfStreamError.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$StreamReader$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/StreamReader.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$WebStreamReader$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/WebStreamReader.js [app-rsc] (ecmascript) <locals>");
;
;
;
}),
"[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/AbstractTokenizer.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AbstractTokenizer",
    ()=>AbstractTokenizer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/index.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/EndOfStreamError.js [app-rsc] (ecmascript)");
;
class AbstractTokenizer {
    /**
     * Constructor
     * @param options Tokenizer options
     * @protected
     */ constructor(options){
        /**
         * Tokenizer-stream position
         */ this.position = 0;
        this.numBuffer = new Uint8Array(8);
        this.fileInfo = options?.fileInfo ?? {};
        this.onClose = options?.onClose;
    }
    /**
     * Read a token from the tokenizer-stream
     * @param token - The token to read
     * @param position - If provided, the desired position in the tokenizer-stream
     * @returns Promise with token data
     */ async readToken(token, position = this.position) {
        const uint8Array = new Uint8Array(token.len);
        const len = await this.readBuffer(uint8Array, {
            position
        });
        if (len < token.len) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
        return token.get(uint8Array, 0);
    }
    /**
     * Peek a token from the tokenizer-stream.
     * @param token - Token to peek from the tokenizer-stream.
     * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
     * @returns Promise with token data
     */ async peekToken(token, position = this.position) {
        const uint8Array = new Uint8Array(token.len);
        const len = await this.peekBuffer(uint8Array, {
            position
        });
        if (len < token.len) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
        return token.get(uint8Array, 0);
    }
    /**
     * Read a numeric token from the stream
     * @param token - Numeric token
     * @returns Promise with number
     */ async readNumber(token) {
        const len = await this.readBuffer(this.numBuffer, {
            length: token.len
        });
        if (len < token.len) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
        return token.get(this.numBuffer, 0);
    }
    /**
     * Read a numeric token from the stream
     * @param token - Numeric token
     * @returns Promise with number
     */ async peekNumber(token) {
        const len = await this.peekBuffer(this.numBuffer, {
            length: token.len
        });
        if (len < token.len) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
        return token.get(this.numBuffer, 0);
    }
    /**
     * Ignore number of bytes, advances the pointer in under tokenizer-stream.
     * @param length - Number of bytes to ignore
     * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
     */ async ignore(length) {
        if (this.fileInfo.size !== undefined) {
            const bytesLeft = this.fileInfo.size - this.position;
            if (length > bytesLeft) {
                this.position += bytesLeft;
                return bytesLeft;
            }
        }
        this.position += length;
        return length;
    }
    async close() {
        await this.onClose?.();
    }
    normalizeOptions(uint8Array, options) {
        if (options && options.position !== undefined && options.position < this.position) {
            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
        }
        if (options) {
            return {
                mayBeLess: options.mayBeLess === true,
                offset: options.offset ? options.offset : 0,
                length: options.length ? options.length : uint8Array.length - (options.offset ? options.offset : 0),
                position: options.position ? options.position : this.position
            };
        }
        return {
            mayBeLess: false,
            offset: 0,
            length: uint8Array.length,
            position: this.position
        };
    }
}
}),
"[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/ReadStreamTokenizer.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ReadStreamTokenizer",
    ()=>ReadStreamTokenizer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$AbstractTokenizer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/AbstractTokenizer.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/index.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/EndOfStreamError.js [app-rsc] (ecmascript)");
;
;
const maxBufferSize = 256000;
class ReadStreamTokenizer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$AbstractTokenizer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AbstractTokenizer"] {
    /**
     * Constructor
     * @param streamReader stream-reader to read from
     * @param options Tokenizer options
     */ constructor(streamReader, options){
        super(options);
        this.streamReader = streamReader;
    }
    /**
     * Read buffer from tokenizer
     * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
     * @param options - Read behaviour options
     * @returns Promise with number of bytes read
     */ async readBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
            await this.ignore(skipBytes);
            return this.readBuffer(uint8Array, options);
        }
        if (skipBytes < 0) {
            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
        }
        if (normOptions.length === 0) {
            return 0;
        }
        const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
        this.position += bytesRead;
        if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
        }
        return bytesRead;
    }
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param uint8Array - Uint8Array (or Buffer) to write data to
     * @param options - Read behaviour options
     * @returns Promise with number of bytes peeked
     */ async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        let bytesRead = 0;
        if (normOptions.position) {
            const skipBytes = normOptions.position - this.position;
            if (skipBytes > 0) {
                const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
                bytesRead = await this.peekBuffer(skipBuffer, {
                    mayBeLess: normOptions.mayBeLess
                });
                uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
                return bytesRead - skipBytes;
            }
            if (skipBytes < 0) {
                throw new Error('Cannot peek from a negative offset in a stream');
            }
        }
        if (normOptions.length > 0) {
            try {
                bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
            } catch (err) {
                if (options?.mayBeLess && err instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["EndOfStreamError"]) {
                    return 0;
                }
                throw err;
            }
            if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
            }
        }
        return bytesRead;
    }
    async ignore(length) {
        // debug(`ignore ${this.position}...${this.position + length - 1}`);
        const bufSize = Math.min(maxBufferSize, length);
        const buf = new Uint8Array(bufSize);
        let totBytesRead = 0;
        while(totBytesRead < length){
            const remaining = length - totBytesRead;
            const bytesRead = await this.readBuffer(buf, {
                length: Math.min(bufSize, remaining)
            });
            if (bytesRead < 0) {
                return bytesRead;
            }
            totBytesRead += bytesRead;
        }
        return totBytesRead;
    }
}
}),
"[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/BufferTokenizer.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BufferTokenizer",
    ()=>BufferTokenizer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/index.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/EndOfStreamError.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$AbstractTokenizer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/AbstractTokenizer.js [app-rsc] (ecmascript)");
;
;
class BufferTokenizer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$AbstractTokenizer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AbstractTokenizer"] {
    /**
     * Construct BufferTokenizer
     * @param uint8Array - Uint8Array to tokenize
     * @param options Tokenizer options
     */ constructor(uint8Array, options){
        super(options);
        this.uint8Array = uint8Array;
        this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : uint8Array.length;
    }
    /**
     * Read buffer from tokenizer
     * @param uint8Array - Uint8Array to tokenize
     * @param options - Read behaviour options
     * @returns {Promise<number>}
     */ async readBuffer(uint8Array, options) {
        if (options?.position) {
            if (options.position < this.position) {
                throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
            }
            this.position = options.position;
        }
        const bytesRead = await this.peekBuffer(uint8Array, options);
        this.position += bytesRead;
        return bytesRead;
    }
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param uint8Array
     * @param options - Read behaviour options
     * @returns {Promise<number>}
     */ async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
        if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
        }
        uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);
        return bytes2read;
    }
    close() {
        return super.close();
    }
}
}),
"[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/core.js [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fromBuffer",
    ()=>fromBuffer,
    "fromStream",
    ()=>fromStream,
    "fromWebStream",
    ()=>fromWebStream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/index.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$StreamReader$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/StreamReader.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$WebStreamReader$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/WebStreamReader.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$ReadStreamTokenizer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/ReadStreamTokenizer.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$BufferTokenizer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/BufferTokenizer.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$AbstractTokenizer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/AbstractTokenizer.js [app-rsc] (ecmascript)");
;
;
;
;
;
function fromStream(stream, options) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$ReadStreamTokenizer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReadStreamTokenizer"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$StreamReader$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["StreamReader"](stream), options);
}
function fromWebStream(webStream, options) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$ReadStreamTokenizer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReadStreamTokenizer"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$WebStreamReader$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["WebStreamReader"](webStream), options);
}
function fromBuffer(uint8Array, options) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$BufferTokenizer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["BufferTokenizer"](uint8Array, options);
}
}),
"[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/FileTokenizer.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FileTokenizer",
    ()=>FileTokenizer,
    "fromFile",
    ()=>fromFile
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$AbstractTokenizer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/AbstractTokenizer.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/index.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/EndOfStreamError.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs/promises [external] (node:fs/promises, cjs)");
;
;
;
class FileTokenizer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$AbstractTokenizer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AbstractTokenizer"] {
    constructor(fileHandle, options){
        super(options);
        this.fileHandle = fileHandle;
    }
    /**
     * Read buffer from file
     * @param uint8Array - Uint8Array to write result to
     * @param options - Read behaviour options
     * @returns Promise number of bytes read
     */ async readBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        this.position = normOptions.position;
        if (normOptions.length === 0) return 0;
        const res = await this.fileHandle.read(uint8Array, normOptions.offset, normOptions.length, normOptions.position);
        this.position += res.bytesRead;
        if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
        }
        return res.bytesRead;
    }
    /**
     * Peek buffer from file
     * @param uint8Array - Uint8Array (or Buffer) to write data to
     * @param options - Read behaviour options
     * @returns Promise number of bytes read
     */ async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const res = await this.fileHandle.read(uint8Array, normOptions.offset, normOptions.length, normOptions.position);
        if (!normOptions.mayBeLess && res.bytesRead < normOptions.length) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["EndOfStreamError"]();
        }
        return res.bytesRead;
    }
    async close() {
        await this.fileHandle.close();
        return super.close();
    }
}
async function fromFile(sourceFilePath) {
    const fileHandle = await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["open"])(sourceFilePath, 'r');
    const stat = await fileHandle.stat();
    return new FileTokenizer(fileHandle, {
        fileInfo: {
            path: sourceFilePath,
            size: stat.size
        }
    });
}
}),
"[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/index.js [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fromStream",
    ()=>fromStream
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs/promises [external] (node:fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/core.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$FileTokenizer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/FileTokenizer.js [app-rsc] (ecmascript)");
;
;
;
;
async function fromStream(stream, options) {
    const augmentedOptions = options ?? {};
    augmentedOptions.fileInfo = augmentedOptions.fileInfo ?? {};
    if (stream.path) {
        const stat = await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["stat"])(stream.path);
        augmentedOptions.fileInfo.path = stream.path;
        augmentedOptions.fileInfo.size = stat.size;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromStream"])(stream, augmentedOptions);
}
}),
"[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/core.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AbstractTokenizer",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$AbstractTokenizer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["AbstractTokenizer"],
    "EndOfStreamError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["EndOfStreamError"],
    "fromBuffer",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromBuffer"],
    "fromStream",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromStream"],
    "fromWebStream",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromWebStream"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/core.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/EndOfStreamError.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$AbstractTokenizer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/AbstractTokenizer.js [app-rsc] (ecmascript)");
}),
"[project]/node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8){}
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8){}
    if (e === 0) {
        e = 1 - eBias;
    } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) {
            value += rt / c;
        } else {
            value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8){}
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8){}
    buffer[offset + i - d] |= s * 128;
};
}),
"[project]/node_modules/.pnpm/@borewit+text-codec@0.1.1/node_modules/@borewit/text-codec/lib/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "textDecode",
    ()=>textDecode,
    "textEncode",
    ()=>textEncode
]);
// text-polyfill.ts
// Minimal encode/decode for utf-8, utf-16le, ascii, latin1, windows-1252
const WINDOWS_1252_EXTRA = {
    0x80: "",
    0x82: "",
    0x83: "",
    0x84: "",
    0x85: "",
    0x86: "",
    0x87: "",
    0x88: "",
    0x89: "",
    0x8a: "",
    0x8b: "",
    0x8c: "",
    0x8e: "",
    0x91: "",
    0x92: "",
    0x93: "",
    0x94: "",
    0x95: "",
    0x96: "",
    0x97: "",
    0x98: "",
    0x99: "",
    0x9a: "",
    0x9b: "",
    0x9c: "",
    0x9e: "",
    0x9f: ""
};
const WINDOWS_1252_REVERSE = {};
for (const [code, char] of Object.entries(WINDOWS_1252_EXTRA)){
    WINDOWS_1252_REVERSE[char] = Number.parseInt(code);
}
function textDecode(bytes, encoding = "utf-8") {
    switch(encoding.toLowerCase()){
        case "utf-8":
        case "utf8":
            if (typeof globalThis.TextDecoder !== "undefined") {
                return new globalThis.TextDecoder("utf-8").decode(bytes);
            }
            return decodeUTF8(bytes);
        case "utf-16le":
            return decodeUTF16LE(bytes);
        case "ascii":
            return decodeASCII(bytes);
        case "latin1":
        case "iso-8859-1":
            return decodeLatin1(bytes);
        case "windows-1252":
            return decodeWindows1252(bytes);
        default:
            throw new RangeError(`Encoding '${encoding}' not supported`);
    }
}
function textEncode(input = "", encoding = "utf-8") {
    switch(encoding.toLowerCase()){
        case "utf-8":
        case "utf8":
            if (typeof globalThis.TextEncoder !== "undefined") {
                return new globalThis.TextEncoder().encode(input);
            }
            return encodeUTF8(input);
        case "utf-16le":
            return encodeUTF16LE(input);
        case "ascii":
            return encodeASCII(input);
        case "latin1":
        case "iso-8859-1":
            return encodeLatin1(input);
        case "windows-1252":
            return encodeWindows1252(input);
        default:
            throw new RangeError(`Encoding '${encoding}' not supported`);
    }
}
// --- Internal helpers ---
function decodeUTF8(bytes) {
    let out = "";
    let i = 0;
    while(i < bytes.length){
        const b1 = bytes[i++];
        if (b1 < 0x80) {
            out += String.fromCharCode(b1);
        } else if (b1 < 0xe0) {
            const b2 = bytes[i++] & 0x3f;
            out += String.fromCharCode((b1 & 0x1f) << 6 | b2);
        } else if (b1 < 0xf0) {
            const b2 = bytes[i++] & 0x3f;
            const b3 = bytes[i++] & 0x3f;
            out += String.fromCharCode((b1 & 0x0f) << 12 | b2 << 6 | b3);
        } else {
            const b2 = bytes[i++] & 0x3f;
            const b3 = bytes[i++] & 0x3f;
            const b4 = bytes[i++] & 0x3f;
            let cp = (b1 & 0x07) << 18 | b2 << 12 | b3 << 6 | b4;
            cp -= 0x10000;
            out += String.fromCharCode(0xd800 + (cp >> 10 & 0x3ff), 0xdc00 + (cp & 0x3ff));
        }
    }
    return out;
}
function decodeUTF16LE(bytes) {
    let out = "";
    for(let i = 0; i < bytes.length; i += 2){
        out += String.fromCharCode(bytes[i] | bytes[i + 1] << 8);
    }
    return out;
}
function decodeASCII(bytes) {
    return String.fromCharCode(...bytes.map((b)=>b & 0x7f));
}
function decodeLatin1(bytes) {
    return String.fromCharCode(...bytes);
}
function decodeWindows1252(bytes) {
    let out = "";
    for (const b of bytes){
        if (b >= 0x80 && b <= 0x9f && WINDOWS_1252_EXTRA[b]) {
            out += WINDOWS_1252_EXTRA[b];
        } else {
            out += String.fromCharCode(b);
        }
    }
    return out;
}
function encodeUTF8(str) {
    const out = [];
    for(let i = 0; i < str.length; i++){
        const cp = str.charCodeAt(i);
        if (cp < 0x80) {
            out.push(cp);
        } else if (cp < 0x800) {
            out.push(0xc0 | cp >> 6, 0x80 | cp & 0x3f);
        } else if (cp < 0x10000) {
            out.push(0xe0 | cp >> 12, 0x80 | cp >> 6 & 0x3f, 0x80 | cp & 0x3f);
        } else {
            out.push(0xf0 | cp >> 18, 0x80 | cp >> 12 & 0x3f, 0x80 | cp >> 6 & 0x3f, 0x80 | cp & 0x3f);
        }
    }
    return new Uint8Array(out);
}
function encodeUTF16LE(str) {
    const out = new Uint8Array(str.length * 2);
    for(let i = 0; i < str.length; i++){
        const code = str.charCodeAt(i);
        out[i * 2] = code & 0xff;
        out[i * 2 + 1] = code >> 8;
    }
    return out;
}
function encodeASCII(str) {
    return new Uint8Array([
        ...str
    ].map((ch)=>ch.charCodeAt(0) & 0x7f));
}
function encodeLatin1(str) {
    return new Uint8Array([
        ...str
    ].map((ch)=>ch.charCodeAt(0) & 0xff));
}
function encodeWindows1252(str) {
    return new Uint8Array([
        ...str
    ].map((ch)=>{
        const code = ch.charCodeAt(0);
        if (code <= 0xff) return code;
        if (WINDOWS_1252_REVERSE[ch] !== undefined) return WINDOWS_1252_REVERSE[ch];
        return 0x3f; // '?'
    }));
}
}),
"[project]/node_modules/.pnpm/token-types@6.1.1/node_modules/token-types/lib/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AnsiStringType",
    ()=>AnsiStringType,
    "Float16_BE",
    ()=>Float16_BE,
    "Float16_LE",
    ()=>Float16_LE,
    "Float32_BE",
    ()=>Float32_BE,
    "Float32_LE",
    ()=>Float32_LE,
    "Float64_BE",
    ()=>Float64_BE,
    "Float64_LE",
    ()=>Float64_LE,
    "Float80_BE",
    ()=>Float80_BE,
    "Float80_LE",
    ()=>Float80_LE,
    "INT16_BE",
    ()=>INT16_BE,
    "INT16_LE",
    ()=>INT16_LE,
    "INT24_BE",
    ()=>INT24_BE,
    "INT24_LE",
    ()=>INT24_LE,
    "INT32_BE",
    ()=>INT32_BE,
    "INT32_LE",
    ()=>INT32_LE,
    "INT64_BE",
    ()=>INT64_BE,
    "INT64_LE",
    ()=>INT64_LE,
    "INT8",
    ()=>INT8,
    "IgnoreType",
    ()=>IgnoreType,
    "StringType",
    ()=>StringType,
    "UINT16_BE",
    ()=>UINT16_BE,
    "UINT16_LE",
    ()=>UINT16_LE,
    "UINT24_BE",
    ()=>UINT24_BE,
    "UINT24_LE",
    ()=>UINT24_LE,
    "UINT32_BE",
    ()=>UINT32_BE,
    "UINT32_LE",
    ()=>UINT32_LE,
    "UINT64_BE",
    ()=>UINT64_BE,
    "UINT64_LE",
    ()=>UINT64_LE,
    "UINT8",
    ()=>UINT8,
    "Uint8ArrayType",
    ()=>Uint8ArrayType
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ieee754$40$1$2e$2$2e$1$2f$node_modules$2f$ieee754$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$borewit$2b$text$2d$codec$40$0$2e$1$2e$1$2f$node_modules$2f40$borewit$2f$text$2d$codec$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@borewit+text-codec@0.1.1/node_modules/@borewit/text-codec/lib/index.js [app-rsc] (ecmascript)");
;
;
// Primitive types
function dv(array) {
    return new DataView(array.buffer, array.byteOffset);
}
const UINT8 = {
    len: 1,
    get (array, offset) {
        return dv(array).getUint8(offset);
    },
    put (array, offset, value) {
        dv(array).setUint8(offset, value);
        return offset + 1;
    }
};
const UINT16_LE = {
    len: 2,
    get (array, offset) {
        return dv(array).getUint16(offset, true);
    },
    put (array, offset, value) {
        dv(array).setUint16(offset, value, true);
        return offset + 2;
    }
};
const UINT16_BE = {
    len: 2,
    get (array, offset) {
        return dv(array).getUint16(offset);
    },
    put (array, offset, value) {
        dv(array).setUint16(offset, value);
        return offset + 2;
    }
};
const UINT24_LE = {
    len: 3,
    get (array, offset) {
        const dataView = dv(array);
        return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, true) << 8);
    },
    put (array, offset, value) {
        const dataView = dv(array);
        dataView.setUint8(offset, value & 0xff);
        dataView.setUint16(offset + 1, value >> 8, true);
        return offset + 3;
    }
};
const UINT24_BE = {
    len: 3,
    get (array, offset) {
        const dataView = dv(array);
        return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);
    },
    put (array, offset, value) {
        const dataView = dv(array);
        dataView.setUint16(offset, value >> 8);
        dataView.setUint8(offset + 2, value & 0xff);
        return offset + 3;
    }
};
const UINT32_LE = {
    len: 4,
    get (array, offset) {
        return dv(array).getUint32(offset, true);
    },
    put (array, offset, value) {
        dv(array).setUint32(offset, value, true);
        return offset + 4;
    }
};
const UINT32_BE = {
    len: 4,
    get (array, offset) {
        return dv(array).getUint32(offset);
    },
    put (array, offset, value) {
        dv(array).setUint32(offset, value);
        return offset + 4;
    }
};
const INT8 = {
    len: 1,
    get (array, offset) {
        return dv(array).getInt8(offset);
    },
    put (array, offset, value) {
        dv(array).setInt8(offset, value);
        return offset + 1;
    }
};
const INT16_BE = {
    len: 2,
    get (array, offset) {
        return dv(array).getInt16(offset);
    },
    put (array, offset, value) {
        dv(array).setInt16(offset, value);
        return offset + 2;
    }
};
const INT16_LE = {
    len: 2,
    get (array, offset) {
        return dv(array).getInt16(offset, true);
    },
    put (array, offset, value) {
        dv(array).setInt16(offset, value, true);
        return offset + 2;
    }
};
const INT24_LE = {
    len: 3,
    get (array, offset) {
        const unsigned = UINT24_LE.get(array, offset);
        return unsigned > 0x7fffff ? unsigned - 0x1000000 : unsigned;
    },
    put (array, offset, value) {
        const dataView = dv(array);
        dataView.setUint8(offset, value & 0xff);
        dataView.setUint16(offset + 1, value >> 8, true);
        return offset + 3;
    }
};
const INT24_BE = {
    len: 3,
    get (array, offset) {
        const unsigned = UINT24_BE.get(array, offset);
        return unsigned > 0x7fffff ? unsigned - 0x1000000 : unsigned;
    },
    put (array, offset, value) {
        const dataView = dv(array);
        dataView.setUint16(offset, value >> 8);
        dataView.setUint8(offset + 2, value & 0xff);
        return offset + 3;
    }
};
const INT32_BE = {
    len: 4,
    get (array, offset) {
        return dv(array).getInt32(offset);
    },
    put (array, offset, value) {
        dv(array).setInt32(offset, value);
        return offset + 4;
    }
};
const INT32_LE = {
    len: 4,
    get (array, offset) {
        return dv(array).getInt32(offset, true);
    },
    put (array, offset, value) {
        dv(array).setInt32(offset, value, true);
        return offset + 4;
    }
};
const UINT64_LE = {
    len: 8,
    get (array, offset) {
        return dv(array).getBigUint64(offset, true);
    },
    put (array, offset, value) {
        dv(array).setBigUint64(offset, value, true);
        return offset + 8;
    }
};
const INT64_LE = {
    len: 8,
    get (array, offset) {
        return dv(array).getBigInt64(offset, true);
    },
    put (array, offset, value) {
        dv(array).setBigInt64(offset, value, true);
        return offset + 8;
    }
};
const UINT64_BE = {
    len: 8,
    get (array, offset) {
        return dv(array).getBigUint64(offset);
    },
    put (array, offset, value) {
        dv(array).setBigUint64(offset, value);
        return offset + 8;
    }
};
const INT64_BE = {
    len: 8,
    get (array, offset) {
        return dv(array).getBigInt64(offset);
    },
    put (array, offset, value) {
        dv(array).setBigInt64(offset, value);
        return offset + 8;
    }
};
const Float16_BE = {
    len: 2,
    get (dataView, offset) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ieee754$40$1$2e$2$2e$1$2f$node_modules$2f$ieee754$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["read"](dataView, offset, false, 10, this.len);
    },
    put (dataView, offset, value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ieee754$40$1$2e$2$2e$1$2f$node_modules$2f$ieee754$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["write"](dataView, value, offset, false, 10, this.len);
        return offset + this.len;
    }
};
const Float16_LE = {
    len: 2,
    get (array, offset) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ieee754$40$1$2e$2$2e$1$2f$node_modules$2f$ieee754$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["read"](array, offset, true, 10, this.len);
    },
    put (array, offset, value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ieee754$40$1$2e$2$2e$1$2f$node_modules$2f$ieee754$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["write"](array, value, offset, true, 10, this.len);
        return offset + this.len;
    }
};
const Float32_BE = {
    len: 4,
    get (array, offset) {
        return dv(array).getFloat32(offset);
    },
    put (array, offset, value) {
        dv(array).setFloat32(offset, value);
        return offset + 4;
    }
};
const Float32_LE = {
    len: 4,
    get (array, offset) {
        return dv(array).getFloat32(offset, true);
    },
    put (array, offset, value) {
        dv(array).setFloat32(offset, value, true);
        return offset + 4;
    }
};
const Float64_BE = {
    len: 8,
    get (array, offset) {
        return dv(array).getFloat64(offset);
    },
    put (array, offset, value) {
        dv(array).setFloat64(offset, value);
        return offset + 8;
    }
};
const Float64_LE = {
    len: 8,
    get (array, offset) {
        return dv(array).getFloat64(offset, true);
    },
    put (array, offset, value) {
        dv(array).setFloat64(offset, value, true);
        return offset + 8;
    }
};
const Float80_BE = {
    len: 10,
    get (array, offset) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ieee754$40$1$2e$2$2e$1$2f$node_modules$2f$ieee754$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["read"](array, offset, false, 63, this.len);
    },
    put (array, offset, value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ieee754$40$1$2e$2$2e$1$2f$node_modules$2f$ieee754$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["write"](array, value, offset, false, 63, this.len);
        return offset + this.len;
    }
};
const Float80_LE = {
    len: 10,
    get (array, offset) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ieee754$40$1$2e$2$2e$1$2f$node_modules$2f$ieee754$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["read"](array, offset, true, 63, this.len);
    },
    put (array, offset, value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$ieee754$40$1$2e$2$2e$1$2f$node_modules$2f$ieee754$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["write"](array, value, offset, true, 63, this.len);
        return offset + this.len;
    }
};
class IgnoreType {
    /**
     * @param len number of bytes to ignore
     */ constructor(len){
        this.len = len;
    }
    // ToDo: don't read, but skip data
    get(_array, _off) {}
}
class Uint8ArrayType {
    constructor(len){
        this.len = len;
    }
    get(array, offset) {
        return array.subarray(offset, offset + this.len);
    }
}
class StringType {
    constructor(len, encoding){
        this.len = len;
        this.encoding = encoding;
    }
    get(data, offset = 0) {
        const bytes = data.subarray(offset, offset + this.len);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$borewit$2b$text$2d$codec$40$0$2e$1$2e$1$2f$node_modules$2f40$borewit$2f$text$2d$codec$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["textDecode"])(bytes, this.encoding);
    }
}
class AnsiStringType extends StringType {
    constructor(len){
        super(len, 'windows-1252');
    }
}
}),
"[project]/node_modules/.pnpm/uint8array-extras@1.5.0/node_modules/uint8array-extras/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "areUint8ArraysEqual",
    ()=>areUint8ArraysEqual,
    "assertUint8Array",
    ()=>assertUint8Array,
    "assertUint8ArrayOrArrayBuffer",
    ()=>assertUint8ArrayOrArrayBuffer,
    "base64ToString",
    ()=>base64ToString,
    "base64ToUint8Array",
    ()=>base64ToUint8Array,
    "compareUint8Arrays",
    ()=>compareUint8Arrays,
    "concatUint8Arrays",
    ()=>concatUint8Arrays,
    "getUintBE",
    ()=>getUintBE,
    "hexToUint8Array",
    ()=>hexToUint8Array,
    "includes",
    ()=>includes,
    "indexOf",
    ()=>indexOf,
    "isUint8Array",
    ()=>isUint8Array,
    "stringToBase64",
    ()=>stringToBase64,
    "stringToUint8Array",
    ()=>stringToUint8Array,
    "toUint8Array",
    ()=>toUint8Array,
    "uint8ArrayToBase64",
    ()=>uint8ArrayToBase64,
    "uint8ArrayToHex",
    ()=>uint8ArrayToHex,
    "uint8ArrayToString",
    ()=>uint8ArrayToString
]);
const objectToString = Object.prototype.toString;
const uint8ArrayStringified = '[object Uint8Array]';
const arrayBufferStringified = '[object ArrayBuffer]';
function isType(value, typeConstructor, typeStringified) {
    if (!value) {
        return false;
    }
    if (value.constructor === typeConstructor) {
        return true;
    }
    return objectToString.call(value) === typeStringified;
}
function isUint8Array(value) {
    return isType(value, Uint8Array, uint8ArrayStringified);
}
function isArrayBuffer(value) {
    return isType(value, ArrayBuffer, arrayBufferStringified);
}
function isUint8ArrayOrArrayBuffer(value) {
    return isUint8Array(value) || isArrayBuffer(value);
}
function assertUint8Array(value) {
    if (!isUint8Array(value)) {
        throw new TypeError(`Expected \`Uint8Array\`, got \`${typeof value}\``);
    }
}
function assertUint8ArrayOrArrayBuffer(value) {
    if (!isUint8ArrayOrArrayBuffer(value)) {
        throw new TypeError(`Expected \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof value}\``);
    }
}
function toUint8Array(value) {
    if (value instanceof ArrayBuffer) {
        return new Uint8Array(value);
    }
    if (ArrayBuffer.isView(value)) {
        return new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
    }
    throw new TypeError(`Unsupported value, got \`${typeof value}\`.`);
}
function concatUint8Arrays(arrays, totalLength) {
    if (arrays.length === 0) {
        return new Uint8Array(0);
    }
    totalLength ??= arrays.reduce((accumulator, currentValue)=>accumulator + currentValue.length, 0);
    const returnValue = new Uint8Array(totalLength);
    let offset = 0;
    for (const array of arrays){
        assertUint8Array(array);
        returnValue.set(array, offset);
        offset += array.length;
    }
    return returnValue;
}
function areUint8ArraysEqual(a, b) {
    assertUint8Array(a);
    assertUint8Array(b);
    if (a === b) {
        return true;
    }
    if (a.length !== b.length) {
        return false;
    }
    // eslint-disable-next-line unicorn/no-for-loop
    for(let index = 0; index < a.length; index++){
        if (a[index] !== b[index]) {
            return false;
        }
    }
    return true;
}
function compareUint8Arrays(a, b) {
    assertUint8Array(a);
    assertUint8Array(b);
    const length = Math.min(a.length, b.length);
    for(let index = 0; index < length; index++){
        const diff = a[index] - b[index];
        if (diff !== 0) {
            return Math.sign(diff);
        }
    }
    // At this point, all the compared elements are equal.
    // The shorter array should come first if the arrays are of different lengths.
    return Math.sign(a.length - b.length);
}
const cachedDecoders = {
    utf8: new globalThis.TextDecoder('utf8')
};
function uint8ArrayToString(array, encoding = 'utf8') {
    assertUint8ArrayOrArrayBuffer(array);
    cachedDecoders[encoding] ??= new globalThis.TextDecoder(encoding);
    return cachedDecoders[encoding].decode(array);
}
function assertString(value) {
    if (typeof value !== 'string') {
        throw new TypeError(`Expected \`string\`, got \`${typeof value}\``);
    }
}
const cachedEncoder = new globalThis.TextEncoder();
function stringToUint8Array(string) {
    assertString(string);
    return cachedEncoder.encode(string);
}
function base64ToBase64Url(base64) {
    return base64.replaceAll('+', '-').replaceAll('/', '_').replace(/=+$/, '');
}
function base64UrlToBase64(base64url) {
    const base64 = base64url.replaceAll('-', '+').replaceAll('_', '/');
    const padding = (4 - base64.length % 4) % 4;
    return base64 + '='.repeat(padding);
}
// Reference: https://phuoc.ng/collection/this-vs-that/concat-vs-push/
// Important: Keep this value divisible by 3 so intermediate chunks produce no Base64 padding.
const MAX_BLOCK_SIZE = 65_535;
function uint8ArrayToBase64(array, { urlSafe = false } = {}) {
    assertUint8Array(array);
    let base64 = '';
    for(let index = 0; index < array.length; index += MAX_BLOCK_SIZE){
        const chunk = array.subarray(index, index + MAX_BLOCK_SIZE);
        // Required as `btoa` and `atob` don't properly support Unicode: https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem
        base64 += globalThis.btoa(String.fromCodePoint.apply(undefined, chunk));
    }
    return urlSafe ? base64ToBase64Url(base64) : base64;
}
function base64ToUint8Array(base64String) {
    assertString(base64String);
    return Uint8Array.from(globalThis.atob(base64UrlToBase64(base64String)), (x)=>x.codePointAt(0));
}
function stringToBase64(string, { urlSafe = false } = {}) {
    assertString(string);
    return uint8ArrayToBase64(stringToUint8Array(string), {
        urlSafe
    });
}
function base64ToString(base64String) {
    assertString(base64String);
    return uint8ArrayToString(base64ToUint8Array(base64String));
}
const byteToHexLookupTable = Array.from({
    length: 256
}, (_, index)=>index.toString(16).padStart(2, '0'));
function uint8ArrayToHex(array) {
    assertUint8Array(array);
    // Concatenating a string is faster than using an array.
    let hexString = '';
    // eslint-disable-next-line unicorn/no-for-loop -- Max performance is critical.
    for(let index = 0; index < array.length; index++){
        hexString += byteToHexLookupTable[array[index]];
    }
    return hexString;
}
const hexToDecimalLookupTable = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15
};
function hexToUint8Array(hexString) {
    assertString(hexString);
    if (hexString.length % 2 !== 0) {
        throw new Error('Invalid Hex string length.');
    }
    const resultLength = hexString.length / 2;
    const bytes = new Uint8Array(resultLength);
    for(let index = 0; index < resultLength; index++){
        const highNibble = hexToDecimalLookupTable[hexString[index * 2]];
        const lowNibble = hexToDecimalLookupTable[hexString[index * 2 + 1]];
        if (highNibble === undefined || lowNibble === undefined) {
            throw new Error(`Invalid Hex character encountered at position ${index * 2}`);
        }
        bytes[index] = highNibble << 4 | lowNibble; // eslint-disable-line no-bitwise
    }
    return bytes;
}
function getUintBE(view) {
    const { byteLength } = view;
    if (byteLength === 6) {
        return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
    }
    if (byteLength === 5) {
        return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
    }
    if (byteLength === 4) {
        return view.getUint32(0);
    }
    if (byteLength === 3) {
        return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
    }
    if (byteLength === 2) {
        return view.getUint16(0);
    }
    if (byteLength === 1) {
        return view.getUint8(0);
    }
}
function indexOf(array, value) {
    const arrayLength = array.length;
    const valueLength = value.length;
    if (valueLength === 0) {
        return -1;
    }
    if (valueLength > arrayLength) {
        return -1;
    }
    const validOffsetLength = arrayLength - valueLength;
    for(let index = 0; index <= validOffsetLength; index++){
        let isMatch = true;
        for(let index2 = 0; index2 < valueLength; index2++){
            if (array[index + index2] !== value[index2]) {
                isMatch = false;
                break;
            }
        }
        if (isMatch) {
            return index;
        }
    }
    return -1;
}
function includes(array, value) {
    return indexOf(array, value) !== -1;
}
}),
"[project]/node_modules/.pnpm/file-type@19.3.0/node_modules/file-type/util.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "stringToBytes",
    ()=>stringToBytes,
    "tarHeaderChecksumMatches",
    ()=>tarHeaderChecksumMatches,
    "uint32SyncSafeToken",
    ()=>uint32SyncSafeToken
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/token-types@6.1.1/node_modules/token-types/lib/index.js [app-rsc] (ecmascript)");
;
function stringToBytes(string) {
    return [
        ...string
    ].map((character)=>character.charCodeAt(0)); // eslint-disable-line unicorn/prefer-code-point
}
function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
    const readSum = Number.parseInt(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StringType"](6).get(arrayBuffer, 148).replace(/\0.*$/, '').trim(), 8); // Read sum in header
    if (Number.isNaN(readSum)) {
        return false;
    }
    let sum = 8 * 0x20; // Initialize signed bit sum
    for(let index = offset; index < offset + 148; index++){
        sum += arrayBuffer[index];
    }
    for(let index = offset + 156; index < offset + 512; index++){
        sum += arrayBuffer[index];
    }
    return readSum === sum;
}
const uint32SyncSafeToken = {
    get: (buffer, offset)=>buffer[offset + 3] & 0x7F | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
    len: 4
};
}),
"[project]/node_modules/.pnpm/file-type@19.3.0/node_modules/file-type/supported.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "extensions",
    ()=>extensions,
    "mimeTypes",
    ()=>mimeTypes
]);
const extensions = [
    'jpg',
    'png',
    'apng',
    'gif',
    'webp',
    'flif',
    'xcf',
    'cr2',
    'cr3',
    'orf',
    'arw',
    'dng',
    'nef',
    'rw2',
    'raf',
    'tif',
    'bmp',
    'icns',
    'jxr',
    'psd',
    'indd',
    'zip',
    'tar',
    'rar',
    'gz',
    'bz2',
    '7z',
    'dmg',
    'mp4',
    'mid',
    'mkv',
    'webm',
    'mov',
    'avi',
    'mpg',
    'mp2',
    'mp3',
    'm4a',
    'oga',
    'ogg',
    'ogv',
    'opus',
    'flac',
    'wav',
    'spx',
    'amr',
    'pdf',
    'epub',
    'elf',
    'macho',
    'exe',
    'swf',
    'rtf',
    'wasm',
    'woff',
    'woff2',
    'eot',
    'ttf',
    'otf',
    'ico',
    'flv',
    'ps',
    'xz',
    'sqlite',
    'nes',
    'crx',
    'xpi',
    'cab',
    'deb',
    'ar',
    'rpm',
    'Z',
    'lz',
    'cfb',
    'mxf',
    'mts',
    'blend',
    'bpg',
    'docx',
    'pptx',
    'xlsx',
    '3gp',
    '3g2',
    'j2c',
    'jp2',
    'jpm',
    'jpx',
    'mj2',
    'aif',
    'qcp',
    'odt',
    'ods',
    'odp',
    'xml',
    'mobi',
    'heic',
    'cur',
    'ktx',
    'ape',
    'wv',
    'dcm',
    'ics',
    'glb',
    'pcap',
    'dsf',
    'lnk',
    'alias',
    'voc',
    'ac3',
    'm4v',
    'm4p',
    'm4b',
    'f4v',
    'f4p',
    'f4b',
    'f4a',
    'mie',
    'asf',
    'ogm',
    'ogx',
    'mpc',
    'arrow',
    'shp',
    'aac',
    'mp1',
    'it',
    's3m',
    'xm',
    'ai',
    'skp',
    'avif',
    'eps',
    'lzh',
    'pgp',
    'asar',
    'stl',
    'chm',
    '3mf',
    'zst',
    'jxl',
    'vcf',
    'jls',
    'pst',
    'dwg',
    'parquet',
    'class',
    'arj',
    'cpio',
    'ace',
    'avro',
    'icc',
    'fbx',
    'vsdx'
];
const mimeTypes = [
    'image/jpeg',
    'image/png',
    'image/gif',
    'image/webp',
    'image/flif',
    'image/x-xcf',
    'image/x-canon-cr2',
    'image/x-canon-cr3',
    'image/tiff',
    'image/bmp',
    'image/vnd.ms-photo',
    'image/vnd.adobe.photoshop',
    'application/x-indesign',
    'application/epub+zip',
    'application/x-xpinstall',
    'application/vnd.oasis.opendocument.text',
    'application/vnd.oasis.opendocument.spreadsheet',
    'application/vnd.oasis.opendocument.presentation',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'application/zip',
    'application/x-tar',
    'application/x-rar-compressed',
    'application/gzip',
    'application/x-bzip2',
    'application/x-7z-compressed',
    'application/x-apple-diskimage',
    'application/x-apache-arrow',
    'video/mp4',
    'audio/midi',
    'video/x-matroska',
    'video/webm',
    'video/quicktime',
    'video/vnd.avi',
    'audio/wav',
    'audio/qcelp',
    'audio/x-ms-asf',
    'video/x-ms-asf',
    'application/vnd.ms-asf',
    'video/mpeg',
    'video/3gpp',
    'audio/mpeg',
    'audio/mp4',
    'audio/opus',
    'video/ogg',
    'audio/ogg',
    'application/ogg',
    'audio/x-flac',
    'audio/ape',
    'audio/wavpack',
    'audio/amr',
    'application/pdf',
    'application/x-elf',
    'application/x-mach-binary',
    'application/x-msdownload',
    'application/x-shockwave-flash',
    'application/rtf',
    'application/wasm',
    'font/woff',
    'font/woff2',
    'application/vnd.ms-fontobject',
    'font/ttf',
    'font/otf',
    'image/x-icon',
    'video/x-flv',
    'application/postscript',
    'application/eps',
    'application/x-xz',
    'application/x-sqlite3',
    'application/x-nintendo-nes-rom',
    'application/x-google-chrome-extension',
    'application/vnd.ms-cab-compressed',
    'application/x-deb',
    'application/x-unix-archive',
    'application/x-rpm',
    'application/x-compress',
    'application/x-lzip',
    'application/x-cfb',
    'application/x-mie',
    'application/mxf',
    'video/mp2t',
    'application/x-blender',
    'image/bpg',
    'image/j2c',
    'image/jp2',
    'image/jpx',
    'image/jpm',
    'image/mj2',
    'audio/aiff',
    'application/xml',
    'application/x-mobipocket-ebook',
    'image/heif',
    'image/heif-sequence',
    'image/heic',
    'image/heic-sequence',
    'image/icns',
    'image/ktx',
    'application/dicom',
    'audio/x-musepack',
    'text/calendar',
    'text/vcard',
    'model/gltf-binary',
    'application/vnd.tcpdump.pcap',
    'audio/x-dsf',
    'application/x.ms.shortcut',
    'application/x.apple.alias',
    'audio/x-voc',
    'audio/vnd.dolby.dd-raw',
    'audio/x-m4a',
    'image/apng',
    'image/x-olympus-orf',
    'image/x-sony-arw',
    'image/x-adobe-dng',
    'image/x-nikon-nef',
    'image/x-panasonic-rw2',
    'image/x-fujifilm-raf',
    'video/x-m4v',
    'video/3gpp2',
    'application/x-esri-shape',
    'audio/aac',
    'audio/x-it',
    'audio/x-s3m',
    'audio/x-xm',
    'video/MP1S',
    'video/MP2P',
    'application/vnd.sketchup.skp',
    'image/avif',
    'application/x-lzh-compressed',
    'application/pgp-encrypted',
    'application/x-asar',
    'model/stl',
    'application/vnd.ms-htmlhelp',
    'model/3mf',
    'image/jxl',
    'application/zstd',
    'image/jls',
    'application/vnd.ms-outlook',
    'image/vnd.dwg',
    'application/x-parquet',
    'application/java-vm',
    'application/x-arj',
    'application/x-cpio',
    'application/x-ace-compressed',
    'application/avro',
    'application/vnd.iccprofile',
    'application/x.autodesk.fbx',
    'application/vnd.visio'
];
}),
"[project]/node_modules/.pnpm/file-type@19.3.0/node_modules/file-type/core.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FileTypeParser",
    ()=>FileTypeParser,
    "fileTypeFromBlob",
    ()=>fileTypeFromBlob,
    "fileTypeFromBuffer",
    ()=>fileTypeFromBuffer,
    "fileTypeFromStream",
    ()=>fileTypeFromStream,
    "fileTypeFromTokenizer",
    ()=>fileTypeFromTokenizer,
    "reasonableDetectionSizeInBytes",
    ()=>reasonableDetectionSizeInBytes,
    "supportedExtensions",
    ()=>supportedExtensions,
    "supportedMimeTypes",
    ()=>supportedMimeTypes
]);
/**
Primary entry point, Node.js specific entry point is index.js
*/ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/token-types@6.1.1/node_modules/token-types/lib/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/core.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/peek-readable@5.4.2/node_modules/peek-readable/lib/EndOfStreamError.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uint8array$2d$extras$40$1$2e$5$2e$0$2f$node_modules$2f$uint8array$2d$extras$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/uint8array-extras@1.5.0/node_modules/uint8array-extras/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$file$2d$type$40$19$2e$3$2e$0$2f$node_modules$2f$file$2d$type$2f$util$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/file-type@19.3.0/node_modules/file-type/util.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$file$2d$type$40$19$2e$3$2e$0$2f$node_modules$2f$file$2d$type$2f$supported$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/file-type@19.3.0/node_modules/file-type/supported.js [app-rsc] (ecmascript)");
;
;
;
;
;
const reasonableDetectionSizeInBytes = 4100; // A fair amount of file-types are detectable within this range.
async function fileTypeFromStream(stream) {
    return new FileTypeParser().fromStream(stream);
}
async function fileTypeFromBuffer(input) {
    return new FileTypeParser().fromBuffer(input);
}
async function fileTypeFromBlob(blob) {
    return new FileTypeParser().fromBlob(blob);
}
function _check(buffer, headers, options) {
    options = {
        offset: 0,
        ...options
    };
    for (const [index, header] of headers.entries()){
        // If a bitmask is set
        if (options.mask) {
            // If header doesn't equal `buf` with bits masked off
            if (header !== (options.mask[index] & buffer[index + options.offset])) {
                return false;
            }
        } else if (header !== buffer[index + options.offset]) {
            return false;
        }
    }
    return true;
}
async function fileTypeFromTokenizer(tokenizer) {
    return new FileTypeParser().fromTokenizer(tokenizer);
}
class FileTypeParser {
    constructor(options){
        this.detectors = options?.customDetectors;
        this.fromTokenizer = this.fromTokenizer.bind(this);
        this.fromBuffer = this.fromBuffer.bind(this);
        this.parse = this.parse.bind(this);
    }
    async fromTokenizer(tokenizer) {
        const initialPosition = tokenizer.position;
        for (const detector of this.detectors || []){
            const fileType = await detector(tokenizer);
            if (fileType) {
                return fileType;
            }
            if (initialPosition !== tokenizer.position) {
                return undefined; // Cannot proceed scanning of the tokenizer is at an arbitrary position
            }
        }
        return this.parse(tokenizer);
    }
    async fromBuffer(input) {
        if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
            throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
        }
        const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
        if (!(buffer?.length > 1)) {
            return;
        }
        return this.fromTokenizer(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromBuffer"](buffer));
    }
    async fromBlob(blob) {
        return this.fromStream(blob.stream());
    }
    async fromStream(stream) {
        const tokenizer = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromWebStream"](stream);
        try {
            return await this.fromTokenizer(tokenizer);
        } finally{
            await tokenizer.close();
        }
    }
    check(header, options) {
        return _check(this.buffer, header, options);
    }
    checkString(header, options) {
        return this.check((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$file$2d$type$40$19$2e$3$2e$0$2f$node_modules$2f$file$2d$type$2f$util$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["stringToBytes"])(header), options);
    }
    async parse(tokenizer) {
        this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
        // Keep reading until EOF if the file size is unknown.
        if (tokenizer.fileInfo.size === undefined) {
            tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
        }
        this.tokenizer = tokenizer;
        await tokenizer.peekBuffer(this.buffer, {
            length: 12,
            mayBeLess: true
        });
        // -- 2-byte signatures --
        if (this.check([
            0x42,
            0x4D
        ])) {
            return {
                ext: 'bmp',
                mime: 'image/bmp'
            };
        }
        if (this.check([
            0x0B,
            0x77
        ])) {
            return {
                ext: 'ac3',
                mime: 'audio/vnd.dolby.dd-raw'
            };
        }
        if (this.check([
            0x78,
            0x01
        ])) {
            return {
                ext: 'dmg',
                mime: 'application/x-apple-diskimage'
            };
        }
        if (this.check([
            0x4D,
            0x5A
        ])) {
            return {
                ext: 'exe',
                mime: 'application/x-msdownload'
            };
        }
        if (this.check([
            0x25,
            0x21
        ])) {
            await tokenizer.peekBuffer(this.buffer, {
                length: 24,
                mayBeLess: true
            });
            if (this.checkString('PS-Adobe-', {
                offset: 2
            }) && this.checkString(' EPSF-', {
                offset: 14
            })) {
                return {
                    ext: 'eps',
                    mime: 'application/eps'
                };
            }
            return {
                ext: 'ps',
                mime: 'application/postscript'
            };
        }
        if (this.check([
            0x1F,
            0xA0
        ]) || this.check([
            0x1F,
            0x9D
        ])) {
            return {
                ext: 'Z',
                mime: 'application/x-compress'
            };
        }
        if (this.check([
            0xC7,
            0x71
        ])) {
            return {
                ext: 'cpio',
                mime: 'application/x-cpio'
            };
        }
        if (this.check([
            0x60,
            0xEA
        ])) {
            return {
                ext: 'arj',
                mime: 'application/x-arj'
            };
        }
        // -- 3-byte signatures --
        if (this.check([
            0xEF,
            0xBB,
            0xBF
        ])) {
            // Strip off UTF-8-BOM
            this.tokenizer.ignore(3);
            return this.parse(tokenizer);
        }
        if (this.check([
            0x47,
            0x49,
            0x46
        ])) {
            return {
                ext: 'gif',
                mime: 'image/gif'
            };
        }
        if (this.check([
            0x49,
            0x49,
            0xBC
        ])) {
            return {
                ext: 'jxr',
                mime: 'image/vnd.ms-photo'
            };
        }
        if (this.check([
            0x1F,
            0x8B,
            0x8
        ])) {
            return {
                ext: 'gz',
                mime: 'application/gzip'
            };
        }
        if (this.check([
            0x42,
            0x5A,
            0x68
        ])) {
            return {
                ext: 'bz2',
                mime: 'application/x-bzip2'
            };
        }
        if (this.checkString('ID3')) {
            await tokenizer.ignore(6); // Skip ID3 header until the header size
            const id3HeaderLength = await tokenizer.readToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$file$2d$type$40$19$2e$3$2e$0$2f$node_modules$2f$file$2d$type$2f$util$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["uint32SyncSafeToken"]);
            if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
                // Guess file type based on ID3 header for backward compatibility
                return {
                    ext: 'mp3',
                    mime: 'audio/mpeg'
                };
            }
            await tokenizer.ignore(id3HeaderLength);
            return this.fromTokenizer(tokenizer); // Skip ID3 header, recursion
        }
        // Musepack, SV7
        if (this.checkString('MP+')) {
            return {
                ext: 'mpc',
                mime: 'audio/x-musepack'
            };
        }
        if ((this.buffer[0] === 0x43 || this.buffer[0] === 0x46) && this.check([
            0x57,
            0x53
        ], {
            offset: 1
        })) {
            return {
                ext: 'swf',
                mime: 'application/x-shockwave-flash'
            };
        }
        // -- 4-byte signatures --
        // Requires a sample size of 4 bytes
        if (this.check([
            0xFF,
            0xD8,
            0xFF
        ])) {
            if (this.check([
                0xF7
            ], {
                offset: 3
            })) {
                return {
                    ext: 'jls',
                    mime: 'image/jls'
                };
            }
            return {
                ext: 'jpg',
                mime: 'image/jpeg'
            };
        }
        if (this.check([
            0x4F,
            0x62,
            0x6A,
            0x01
        ])) {
            return {
                ext: 'avro',
                mime: 'application/avro'
            };
        }
        if (this.checkString('FLIF')) {
            return {
                ext: 'flif',
                mime: 'image/flif'
            };
        }
        if (this.checkString('8BPS')) {
            return {
                ext: 'psd',
                mime: 'image/vnd.adobe.photoshop'
            };
        }
        if (this.checkString('WEBP', {
            offset: 8
        })) {
            return {
                ext: 'webp',
                mime: 'image/webp'
            };
        }
        // Musepack, SV8
        if (this.checkString('MPCK')) {
            return {
                ext: 'mpc',
                mime: 'audio/x-musepack'
            };
        }
        if (this.checkString('FORM')) {
            return {
                ext: 'aif',
                mime: 'audio/aiff'
            };
        }
        if (this.checkString('icns', {
            offset: 0
        })) {
            return {
                ext: 'icns',
                mime: 'image/icns'
            };
        }
        // Zip-based file formats
        // Need to be before the `zip` check
        if (this.check([
            0x50,
            0x4B,
            0x3,
            0x4
        ])) {
            try {
                while(tokenizer.position + 30 < tokenizer.fileInfo.size){
                    await tokenizer.readBuffer(this.buffer, {
                        length: 30
                    });
                    const view = new DataView(this.buffer.buffer);
                    // https://en.wikipedia.org/wiki/Zip_(file_format)#File_headers
                    const zipHeader = {
                        compressedSize: view.getUint32(18, true),
                        uncompressedSize: view.getUint32(22, true),
                        filenameLength: view.getUint16(26, true),
                        extraFieldLength: view.getUint16(28, true)
                    };
                    zipHeader.filename = await tokenizer.readToken(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StringType"](zipHeader.filenameLength, 'utf-8'));
                    await tokenizer.ignore(zipHeader.extraFieldLength);
                    // Assumes signed `.xpi` from addons.mozilla.org
                    if (zipHeader.filename === 'META-INF/mozilla.rsa') {
                        return {
                            ext: 'xpi',
                            mime: 'application/x-xpinstall'
                        };
                    }
                    if (zipHeader.filename.endsWith('.rels') || zipHeader.filename.endsWith('.xml')) {
                        const type = zipHeader.filename.split('/')[0];
                        switch(type){
                            case '_rels':
                                break;
                            case 'word':
                                return {
                                    ext: 'docx',
                                    mime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
                                };
                            case 'ppt':
                                return {
                                    ext: 'pptx',
                                    mime: 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
                                };
                            case 'xl':
                                return {
                                    ext: 'xlsx',
                                    mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                                };
                            case 'visio':
                                return {
                                    ext: 'vsdx',
                                    mime: 'application/vnd.visio'
                                };
                            default:
                                break;
                        }
                    }
                    if (zipHeader.filename.startsWith('xl/')) {
                        return {
                            ext: 'xlsx',
                            mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                        };
                    }
                    if (zipHeader.filename.startsWith('3D/') && zipHeader.filename.endsWith('.model')) {
                        return {
                            ext: '3mf',
                            mime: 'model/3mf'
                        };
                    }
                    // The docx, xlsx and pptx file types extend the Office Open XML file format:
                    // https://en.wikipedia.org/wiki/Office_Open_XML_file_formats
                    // We look for:
                    // - one entry named '[Content_Types].xml' or '_rels/.rels',
                    // - one entry indicating specific type of file.
                    // MS Office, OpenOffice and LibreOffice may put the parts in different order, so the check should not rely on it.
                    if (zipHeader.filename === 'mimetype' && zipHeader.compressedSize === zipHeader.uncompressedSize) {
                        let mimeType = await tokenizer.readToken(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StringType"](zipHeader.compressedSize, 'utf-8'));
                        mimeType = mimeType.trim();
                        switch(mimeType){
                            case 'application/epub+zip':
                                return {
                                    ext: 'epub',
                                    mime: 'application/epub+zip'
                                };
                            case 'application/vnd.oasis.opendocument.text':
                                return {
                                    ext: 'odt',
                                    mime: 'application/vnd.oasis.opendocument.text'
                                };
                            case 'application/vnd.oasis.opendocument.spreadsheet':
                                return {
                                    ext: 'ods',
                                    mime: 'application/vnd.oasis.opendocument.spreadsheet'
                                };
                            case 'application/vnd.oasis.opendocument.presentation':
                                return {
                                    ext: 'odp',
                                    mime: 'application/vnd.oasis.opendocument.presentation'
                                };
                            default:
                        }
                    }
                    // Try to find next header manually when current one is corrupted
                    if (zipHeader.compressedSize === 0) {
                        let nextHeaderIndex = -1;
                        while(nextHeaderIndex < 0 && tokenizer.position < tokenizer.fileInfo.size){
                            await tokenizer.peekBuffer(this.buffer, {
                                mayBeLess: true
                            });
                            nextHeaderIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uint8array$2d$extras$40$1$2e$5$2e$0$2f$node_modules$2f$uint8array$2d$extras$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["indexOf"])(this.buffer, new Uint8Array([
                                0x50,
                                0x4B,
                                0x03,
                                0x04
                            ]));
                            // Move position to the next header if found, skip the whole buffer otherwise
                            await tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : this.buffer.length);
                        }
                    } else {
                        await tokenizer.ignore(zipHeader.compressedSize);
                    }
                }
            } catch (error) {
                if (!(error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["EndOfStreamError"])) {
                    throw error;
                }
            }
            return {
                ext: 'zip',
                mime: 'application/zip'
            };
        }
        if (this.checkString('OggS')) {
            // This is an OGG container
            await tokenizer.ignore(28);
            const type = new Uint8Array(8);
            await tokenizer.readBuffer(type);
            // Needs to be before `ogg` check
            if (_check(type, [
                0x4F,
                0x70,
                0x75,
                0x73,
                0x48,
                0x65,
                0x61,
                0x64
            ])) {
                return {
                    ext: 'opus',
                    mime: 'audio/opus'
                };
            }
            // If ' theora' in header.
            if (_check(type, [
                0x80,
                0x74,
                0x68,
                0x65,
                0x6F,
                0x72,
                0x61
            ])) {
                return {
                    ext: 'ogv',
                    mime: 'video/ogg'
                };
            }
            // If '\x01video' in header.
            if (_check(type, [
                0x01,
                0x76,
                0x69,
                0x64,
                0x65,
                0x6F,
                0x00
            ])) {
                return {
                    ext: 'ogm',
                    mime: 'video/ogg'
                };
            }
            // If ' FLAC' in header  https://xiph.org/flac/faq.html
            if (_check(type, [
                0x7F,
                0x46,
                0x4C,
                0x41,
                0x43
            ])) {
                return {
                    ext: 'oga',
                    mime: 'audio/ogg'
                };
            }
            // 'Speex  ' in header https://en.wikipedia.org/wiki/Speex
            if (_check(type, [
                0x53,
                0x70,
                0x65,
                0x65,
                0x78,
                0x20,
                0x20
            ])) {
                return {
                    ext: 'spx',
                    mime: 'audio/ogg'
                };
            }
            // If '\x01vorbis' in header
            if (_check(type, [
                0x01,
                0x76,
                0x6F,
                0x72,
                0x62,
                0x69,
                0x73
            ])) {
                return {
                    ext: 'ogg',
                    mime: 'audio/ogg'
                };
            }
            // Default OGG container https://www.iana.org/assignments/media-types/application/ogg
            return {
                ext: 'ogx',
                mime: 'application/ogg'
            };
        }
        if (this.check([
            0x50,
            0x4B
        ]) && (this.buffer[2] === 0x3 || this.buffer[2] === 0x5 || this.buffer[2] === 0x7) && (this.buffer[3] === 0x4 || this.buffer[3] === 0x6 || this.buffer[3] === 0x8)) {
            return {
                ext: 'zip',
                mime: 'application/zip'
            };
        }
        //
        // File Type Box (https://en.wikipedia.org/wiki/ISO_base_media_file_format)
        // It's not required to be first, but it's recommended to be. Almost all ISO base media files start with `ftyp` box.
        // `ftyp` box must contain a brand major identifier, which must consist of ISO 8859-1 printable characters.
        // Here we check for 8859-1 printable characters (for simplicity, it's a mask which also catches one non-printable character).
        if (this.checkString('ftyp', {
            offset: 4
        }) && (this.buffer[8] & 0x60) !== 0x00 // Brand major, first character ASCII?
        ) {
            // They all can have MIME `video/mp4` except `application/mp4` special-case which is hard to detect.
            // For some cases, we're specific, everything else falls to `video/mp4` with `mp4` extension.
            const brandMajor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StringType"](4, 'latin1').get(this.buffer, 8).replace('\0', ' ').trim();
            switch(brandMajor){
                case 'avif':
                case 'avis':
                    return {
                        ext: 'avif',
                        mime: 'image/avif'
                    };
                case 'mif1':
                    return {
                        ext: 'heic',
                        mime: 'image/heif'
                    };
                case 'msf1':
                    return {
                        ext: 'heic',
                        mime: 'image/heif-sequence'
                    };
                case 'heic':
                case 'heix':
                    return {
                        ext: 'heic',
                        mime: 'image/heic'
                    };
                case 'hevc':
                case 'hevx':
                    return {
                        ext: 'heic',
                        mime: 'image/heic-sequence'
                    };
                case 'qt':
                    return {
                        ext: 'mov',
                        mime: 'video/quicktime'
                    };
                case 'M4V':
                case 'M4VH':
                case 'M4VP':
                    return {
                        ext: 'm4v',
                        mime: 'video/x-m4v'
                    };
                case 'M4P':
                    return {
                        ext: 'm4p',
                        mime: 'video/mp4'
                    };
                case 'M4B':
                    return {
                        ext: 'm4b',
                        mime: 'audio/mp4'
                    };
                case 'M4A':
                    return {
                        ext: 'm4a',
                        mime: 'audio/x-m4a'
                    };
                case 'F4V':
                    return {
                        ext: 'f4v',
                        mime: 'video/mp4'
                    };
                case 'F4P':
                    return {
                        ext: 'f4p',
                        mime: 'video/mp4'
                    };
                case 'F4A':
                    return {
                        ext: 'f4a',
                        mime: 'audio/mp4'
                    };
                case 'F4B':
                    return {
                        ext: 'f4b',
                        mime: 'audio/mp4'
                    };
                case 'crx':
                    return {
                        ext: 'cr3',
                        mime: 'image/x-canon-cr3'
                    };
                default:
                    if (brandMajor.startsWith('3g')) {
                        if (brandMajor.startsWith('3g2')) {
                            return {
                                ext: '3g2',
                                mime: 'video/3gpp2'
                            };
                        }
                        return {
                            ext: '3gp',
                            mime: 'video/3gpp'
                        };
                    }
                    return {
                        ext: 'mp4',
                        mime: 'video/mp4'
                    };
            }
        }
        if (this.checkString('MThd')) {
            return {
                ext: 'mid',
                mime: 'audio/midi'
            };
        }
        if (this.checkString('wOFF') && (this.check([
            0x00,
            0x01,
            0x00,
            0x00
        ], {
            offset: 4
        }) || this.checkString('OTTO', {
            offset: 4
        }))) {
            return {
                ext: 'woff',
                mime: 'font/woff'
            };
        }
        if (this.checkString('wOF2') && (this.check([
            0x00,
            0x01,
            0x00,
            0x00
        ], {
            offset: 4
        }) || this.checkString('OTTO', {
            offset: 4
        }))) {
            return {
                ext: 'woff2',
                mime: 'font/woff2'
            };
        }
        if (this.check([
            0xD4,
            0xC3,
            0xB2,
            0xA1
        ]) || this.check([
            0xA1,
            0xB2,
            0xC3,
            0xD4
        ])) {
            return {
                ext: 'pcap',
                mime: 'application/vnd.tcpdump.pcap'
            };
        }
        // Sony DSD Stream File (DSF)
        if (this.checkString('DSD ')) {
            return {
                ext: 'dsf',
                mime: 'audio/x-dsf'
            };
        }
        if (this.checkString('LZIP')) {
            return {
                ext: 'lz',
                mime: 'application/x-lzip'
            };
        }
        if (this.checkString('fLaC')) {
            return {
                ext: 'flac',
                mime: 'audio/x-flac'
            };
        }
        if (this.check([
            0x42,
            0x50,
            0x47,
            0xFB
        ])) {
            return {
                ext: 'bpg',
                mime: 'image/bpg'
            };
        }
        if (this.checkString('wvpk')) {
            return {
                ext: 'wv',
                mime: 'audio/wavpack'
            };
        }
        if (this.checkString('%PDF')) {
            try {
                await tokenizer.ignore(1350);
                const maxBufferSize = 10 * 1024 * 1024;
                const buffer = new Uint8Array(Math.min(maxBufferSize, tokenizer.fileInfo.size));
                await tokenizer.readBuffer(buffer, {
                    mayBeLess: true
                });
                // Check if this is an Adobe Illustrator file
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uint8array$2d$extras$40$1$2e$5$2e$0$2f$node_modules$2f$uint8array$2d$extras$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["includes"])(buffer, new TextEncoder().encode('AIPrivateData'))) {
                    return {
                        ext: 'ai',
                        mime: 'application/postscript'
                    };
                }
            } catch (error) {
                // Swallow end of stream error if file is too small for the Adobe AI check
                if (!(error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$peek$2d$readable$40$5$2e$4$2e$2$2f$node_modules$2f$peek$2d$readable$2f$lib$2f$EndOfStreamError$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["EndOfStreamError"])) {
                    throw error;
                }
            }
            // Assume this is just a normal PDF
            return {
                ext: 'pdf',
                mime: 'application/pdf'
            };
        }
        if (this.check([
            0x00,
            0x61,
            0x73,
            0x6D
        ])) {
            return {
                ext: 'wasm',
                mime: 'application/wasm'
            };
        }
        // TIFF, little-endian type
        if (this.check([
            0x49,
            0x49
        ])) {
            const fileType = await this.readTiffHeader(false);
            if (fileType) {
                return fileType;
            }
        }
        // TIFF, big-endian type
        if (this.check([
            0x4D,
            0x4D
        ])) {
            const fileType = await this.readTiffHeader(true);
            if (fileType) {
                return fileType;
            }
        }
        if (this.checkString('MAC ')) {
            return {
                ext: 'ape',
                mime: 'audio/ape'
            };
        }
        // https://github.com/file/file/blob/master/magic/Magdir/matroska
        if (this.check([
            0x1A,
            0x45,
            0xDF,
            0xA3
        ])) {
            async function readField() {
                const msb = await tokenizer.peekNumber(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["UINT8"]);
                let mask = 0x80;
                let ic = 0; // 0 = A, 1 = B, 2 = C, 3 = D
                while((msb & mask) === 0 && mask !== 0){
                    ++ic;
                    mask >>= 1;
                }
                const id = new Uint8Array(ic + 1);
                await tokenizer.readBuffer(id);
                return id;
            }
            async function readElement() {
                const idField = await readField();
                const lengthField = await readField();
                lengthField[0] ^= 0x80 >> lengthField.length - 1;
                const nrLength = Math.min(6, lengthField.length); // JavaScript can max read 6 bytes integer
                const idView = new DataView(idField.buffer);
                const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);
                return {
                    id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uint8array$2d$extras$40$1$2e$5$2e$0$2f$node_modules$2f$uint8array$2d$extras$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getUintBE"])(idView),
                    len: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uint8array$2d$extras$40$1$2e$5$2e$0$2f$node_modules$2f$uint8array$2d$extras$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getUintBE"])(lengthView)
                };
            }
            async function readChildren(children) {
                while(children > 0){
                    const element = await readElement();
                    if (element.id === 0x42_82) {
                        const rawValue = await tokenizer.readToken(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StringType"](element.len));
                        return rawValue.replaceAll(/\00.*$/g, ''); // Return DocType
                    }
                    await tokenizer.ignore(element.len); // ignore payload
                    --children;
                }
            }
            const re = await readElement();
            const docType = await readChildren(re.len);
            switch(docType){
                case 'webm':
                    return {
                        ext: 'webm',
                        mime: 'video/webm'
                    };
                case 'matroska':
                    return {
                        ext: 'mkv',
                        mime: 'video/x-matroska'
                    };
                default:
                    return;
            }
        }
        // RIFF file format which might be AVI, WAV, QCP, etc
        if (this.check([
            0x52,
            0x49,
            0x46,
            0x46
        ])) {
            if (this.check([
                0x41,
                0x56,
                0x49
            ], {
                offset: 8
            })) {
                return {
                    ext: 'avi',
                    mime: 'video/vnd.avi'
                };
            }
            if (this.check([
                0x57,
                0x41,
                0x56,
                0x45
            ], {
                offset: 8
            })) {
                return {
                    ext: 'wav',
                    mime: 'audio/wav'
                };
            }
            // QLCM, QCP file
            if (this.check([
                0x51,
                0x4C,
                0x43,
                0x4D
            ], {
                offset: 8
            })) {
                return {
                    ext: 'qcp',
                    mime: 'audio/qcelp'
                };
            }
        }
        if (this.checkString('SQLi')) {
            return {
                ext: 'sqlite',
                mime: 'application/x-sqlite3'
            };
        }
        if (this.check([
            0x4E,
            0x45,
            0x53,
            0x1A
        ])) {
            return {
                ext: 'nes',
                mime: 'application/x-nintendo-nes-rom'
            };
        }
        if (this.checkString('Cr24')) {
            return {
                ext: 'crx',
                mime: 'application/x-google-chrome-extension'
            };
        }
        if (this.checkString('MSCF') || this.checkString('ISc(')) {
            return {
                ext: 'cab',
                mime: 'application/vnd.ms-cab-compressed'
            };
        }
        if (this.check([
            0xED,
            0xAB,
            0xEE,
            0xDB
        ])) {
            return {
                ext: 'rpm',
                mime: 'application/x-rpm'
            };
        }
        if (this.check([
            0xC5,
            0xD0,
            0xD3,
            0xC6
        ])) {
            return {
                ext: 'eps',
                mime: 'application/eps'
            };
        }
        if (this.check([
            0x28,
            0xB5,
            0x2F,
            0xFD
        ])) {
            return {
                ext: 'zst',
                mime: 'application/zstd'
            };
        }
        if (this.check([
            0x7F,
            0x45,
            0x4C,
            0x46
        ])) {
            return {
                ext: 'elf',
                mime: 'application/x-elf'
            };
        }
        if (this.check([
            0x21,
            0x42,
            0x44,
            0x4E
        ])) {
            return {
                ext: 'pst',
                mime: 'application/vnd.ms-outlook'
            };
        }
        if (this.checkString('PAR1')) {
            return {
                ext: 'parquet',
                mime: 'application/x-parquet'
            };
        }
        if (this.check([
            0xCF,
            0xFA,
            0xED,
            0xFE
        ])) {
            return {
                ext: 'macho',
                mime: 'application/x-mach-binary'
            };
        }
        // -- 5-byte signatures --
        if (this.check([
            0x4F,
            0x54,
            0x54,
            0x4F,
            0x00
        ])) {
            return {
                ext: 'otf',
                mime: 'font/otf'
            };
        }
        if (this.checkString('#!AMR')) {
            return {
                ext: 'amr',
                mime: 'audio/amr'
            };
        }
        if (this.checkString('{\\rtf')) {
            return {
                ext: 'rtf',
                mime: 'application/rtf'
            };
        }
        if (this.check([
            0x46,
            0x4C,
            0x56,
            0x01
        ])) {
            return {
                ext: 'flv',
                mime: 'video/x-flv'
            };
        }
        if (this.checkString('IMPM')) {
            return {
                ext: 'it',
                mime: 'audio/x-it'
            };
        }
        if (this.checkString('-lh0-', {
            offset: 2
        }) || this.checkString('-lh1-', {
            offset: 2
        }) || this.checkString('-lh2-', {
            offset: 2
        }) || this.checkString('-lh3-', {
            offset: 2
        }) || this.checkString('-lh4-', {
            offset: 2
        }) || this.checkString('-lh5-', {
            offset: 2
        }) || this.checkString('-lh6-', {
            offset: 2
        }) || this.checkString('-lh7-', {
            offset: 2
        }) || this.checkString('-lzs-', {
            offset: 2
        }) || this.checkString('-lz4-', {
            offset: 2
        }) || this.checkString('-lz5-', {
            offset: 2
        }) || this.checkString('-lhd-', {
            offset: 2
        })) {
            return {
                ext: 'lzh',
                mime: 'application/x-lzh-compressed'
            };
        }
        // MPEG program stream (PS or MPEG-PS)
        if (this.check([
            0x00,
            0x00,
            0x01,
            0xBA
        ])) {
            //  MPEG-PS, MPEG-1 Part 1
            if (this.check([
                0x21
            ], {
                offset: 4,
                mask: [
                    0xF1
                ]
            })) {
                return {
                    ext: 'mpg',
                    mime: 'video/MP1S'
                };
            }
            // MPEG-PS, MPEG-2 Part 1
            if (this.check([
                0x44
            ], {
                offset: 4,
                mask: [
                    0xC4
                ]
            })) {
                return {
                    ext: 'mpg',
                    mime: 'video/MP2P'
                };
            }
        }
        if (this.checkString('ITSF')) {
            return {
                ext: 'chm',
                mime: 'application/vnd.ms-htmlhelp'
            };
        }
        if (this.check([
            0xCA,
            0xFE,
            0xBA,
            0xBE
        ])) {
            return {
                ext: 'class',
                mime: 'application/java-vm'
            };
        }
        // -- 6-byte signatures --
        if (this.check([
            0xFD,
            0x37,
            0x7A,
            0x58,
            0x5A,
            0x00
        ])) {
            return {
                ext: 'xz',
                mime: 'application/x-xz'
            };
        }
        if (this.checkString('<?xml ')) {
            return {
                ext: 'xml',
                mime: 'application/xml'
            };
        }
        if (this.check([
            0x37,
            0x7A,
            0xBC,
            0xAF,
            0x27,
            0x1C
        ])) {
            return {
                ext: '7z',
                mime: 'application/x-7z-compressed'
            };
        }
        if (this.check([
            0x52,
            0x61,
            0x72,
            0x21,
            0x1A,
            0x7
        ]) && (this.buffer[6] === 0x0 || this.buffer[6] === 0x1)) {
            return {
                ext: 'rar',
                mime: 'application/x-rar-compressed'
            };
        }
        if (this.checkString('solid ')) {
            return {
                ext: 'stl',
                mime: 'model/stl'
            };
        }
        if (this.checkString('AC')) {
            const version = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StringType"](4, 'latin1').get(this.buffer, 2);
            if (version.match('^d*') && version >= 1000 && version <= 1050) {
                return {
                    ext: 'dwg',
                    mime: 'image/vnd.dwg'
                };
            }
        }
        if (this.checkString('070707')) {
            return {
                ext: 'cpio',
                mime: 'application/x-cpio'
            };
        }
        // -- 7-byte signatures --
        if (this.checkString('BLENDER')) {
            return {
                ext: 'blend',
                mime: 'application/x-blender'
            };
        }
        if (this.checkString('!<arch>')) {
            await tokenizer.ignore(8);
            const string = await tokenizer.readToken(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StringType"](13, 'ascii'));
            if (string === 'debian-binary') {
                return {
                    ext: 'deb',
                    mime: 'application/x-deb'
                };
            }
            return {
                ext: 'ar',
                mime: 'application/x-unix-archive'
            };
        }
        if (this.checkString('**ACE', {
            offset: 7
        })) {
            await tokenizer.peekBuffer(this.buffer, {
                length: 14,
                mayBeLess: true
            });
            if (this.checkString('**', {
                offset: 12
            })) {
                return {
                    ext: 'ace',
                    mime: 'application/x-ace-compressed'
                };
            }
        }
        // -- 8-byte signatures --
        if (this.check([
            0x89,
            0x50,
            0x4E,
            0x47,
            0x0D,
            0x0A,
            0x1A,
            0x0A
        ])) {
            // APNG format (https://wiki.mozilla.org/APNG_Specification)
            // 1. Find the first IDAT (image data) chunk (49 44 41 54)
            // 2. Check if there is an "acTL" chunk before the IDAT one (61 63 54 4C)
            // Offset calculated as follows:
            // - 8 bytes: PNG signature
            // - 4 (length) + 4 (chunk type) + 13 (chunk data) + 4 (CRC): IHDR chunk
            await tokenizer.ignore(8); // ignore PNG signature
            async function readChunkHeader() {
                return {
                    length: await tokenizer.readToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["INT32_BE"]),
                    type: await tokenizer.readToken(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StringType"](4, 'latin1'))
                };
            }
            do {
                const chunk = await readChunkHeader();
                if (chunk.length < 0) {
                    return; // Invalid chunk length
                }
                switch(chunk.type){
                    case 'IDAT':
                        return {
                            ext: 'png',
                            mime: 'image/png'
                        };
                    case 'acTL':
                        return {
                            ext: 'apng',
                            mime: 'image/apng'
                        };
                    default:
                        await tokenizer.ignore(chunk.length + 4); // Ignore chunk-data + CRC
                }
            }while (tokenizer.position + 8 < tokenizer.fileInfo.size)
            return {
                ext: 'png',
                mime: 'image/png'
            };
        }
        if (this.check([
            0x41,
            0x52,
            0x52,
            0x4F,
            0x57,
            0x31,
            0x00,
            0x00
        ])) {
            return {
                ext: 'arrow',
                mime: 'application/x-apache-arrow'
            };
        }
        if (this.check([
            0x67,
            0x6C,
            0x54,
            0x46,
            0x02,
            0x00,
            0x00,
            0x00
        ])) {
            return {
                ext: 'glb',
                mime: 'model/gltf-binary'
            };
        }
        // `mov` format variants
        if (this.check([
            0x66,
            0x72,
            0x65,
            0x65
        ], {
            offset: 4
        }) // `free`
         || this.check([
            0x6D,
            0x64,
            0x61,
            0x74
        ], {
            offset: 4
        }) // `mdat` MJPEG
         || this.check([
            0x6D,
            0x6F,
            0x6F,
            0x76
        ], {
            offset: 4
        }) // `moov`
         || this.check([
            0x77,
            0x69,
            0x64,
            0x65
        ], {
            offset: 4
        }) // `wide`
        ) {
            return {
                ext: 'mov',
                mime: 'video/quicktime'
            };
        }
        // -- 9-byte signatures --
        if (this.check([
            0x49,
            0x49,
            0x52,
            0x4F,
            0x08,
            0x00,
            0x00,
            0x00,
            0x18
        ])) {
            return {
                ext: 'orf',
                mime: 'image/x-olympus-orf'
            };
        }
        if (this.checkString('gimp xcf ')) {
            return {
                ext: 'xcf',
                mime: 'image/x-xcf'
            };
        }
        // -- 12-byte signatures --
        if (this.check([
            0x49,
            0x49,
            0x55,
            0x00,
            0x18,
            0x00,
            0x00,
            0x00,
            0x88,
            0xE7,
            0x74,
            0xD8
        ])) {
            return {
                ext: 'rw2',
                mime: 'image/x-panasonic-rw2'
            };
        }
        // ASF_Header_Object first 80 bytes
        if (this.check([
            0x30,
            0x26,
            0xB2,
            0x75,
            0x8E,
            0x66,
            0xCF,
            0x11,
            0xA6,
            0xD9
        ])) {
            async function readHeader() {
                const guid = new Uint8Array(16);
                await tokenizer.readBuffer(guid);
                return {
                    id: guid,
                    size: Number(await tokenizer.readToken(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["UINT64_LE"]))
                };
            }
            await tokenizer.ignore(30);
            // Search for header should be in first 1KB of file.
            while(tokenizer.position + 24 < tokenizer.fileInfo.size){
                const header = await readHeader();
                let payload = header.size - 24;
                if (_check(header.id, [
                    0x91,
                    0x07,
                    0xDC,
                    0xB7,
                    0xB7,
                    0xA9,
                    0xCF,
                    0x11,
                    0x8E,
                    0xE6,
                    0x00,
                    0xC0,
                    0x0C,
                    0x20,
                    0x53,
                    0x65
                ])) {
                    // Sync on Stream-Properties-Object (B7DC0791-A9B7-11CF-8EE6-00C00C205365)
                    const typeId = new Uint8Array(16);
                    payload -= await tokenizer.readBuffer(typeId);
                    if (_check(typeId, [
                        0x40,
                        0x9E,
                        0x69,
                        0xF8,
                        0x4D,
                        0x5B,
                        0xCF,
                        0x11,
                        0xA8,
                        0xFD,
                        0x00,
                        0x80,
                        0x5F,
                        0x5C,
                        0x44,
                        0x2B
                    ])) {
                        // Found audio:
                        return {
                            ext: 'asf',
                            mime: 'audio/x-ms-asf'
                        };
                    }
                    if (_check(typeId, [
                        0xC0,
                        0xEF,
                        0x19,
                        0xBC,
                        0x4D,
                        0x5B,
                        0xCF,
                        0x11,
                        0xA8,
                        0xFD,
                        0x00,
                        0x80,
                        0x5F,
                        0x5C,
                        0x44,
                        0x2B
                    ])) {
                        // Found video:
                        return {
                            ext: 'asf',
                            mime: 'video/x-ms-asf'
                        };
                    }
                    break;
                }
                await tokenizer.ignore(payload);
            }
            // Default to ASF generic extension
            return {
                ext: 'asf',
                mime: 'application/vnd.ms-asf'
            };
        }
        if (this.check([
            0xAB,
            0x4B,
            0x54,
            0x58,
            0x20,
            0x31,
            0x31,
            0xBB,
            0x0D,
            0x0A,
            0x1A,
            0x0A
        ])) {
            return {
                ext: 'ktx',
                mime: 'image/ktx'
            };
        }
        if ((this.check([
            0x7E,
            0x10,
            0x04
        ]) || this.check([
            0x7E,
            0x18,
            0x04
        ])) && this.check([
            0x30,
            0x4D,
            0x49,
            0x45
        ], {
            offset: 4
        })) {
            return {
                ext: 'mie',
                mime: 'application/x-mie'
            };
        }
        if (this.check([
            0x27,
            0x0A,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00
        ], {
            offset: 2
        })) {
            return {
                ext: 'shp',
                mime: 'application/x-esri-shape'
            };
        }
        if (this.check([
            0xFF,
            0x4F,
            0xFF,
            0x51
        ])) {
            return {
                ext: 'j2c',
                mime: 'image/j2c'
            };
        }
        if (this.check([
            0x00,
            0x00,
            0x00,
            0x0C,
            0x6A,
            0x50,
            0x20,
            0x20,
            0x0D,
            0x0A,
            0x87,
            0x0A
        ])) {
            // JPEG-2000 family
            await tokenizer.ignore(20);
            const type = await tokenizer.readToken(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["StringType"](4, 'ascii'));
            switch(type){
                case 'jp2 ':
                    return {
                        ext: 'jp2',
                        mime: 'image/jp2'
                    };
                case 'jpx ':
                    return {
                        ext: 'jpx',
                        mime: 'image/jpx'
                    };
                case 'jpm ':
                    return {
                        ext: 'jpm',
                        mime: 'image/jpm'
                    };
                case 'mjp2':
                    return {
                        ext: 'mj2',
                        mime: 'image/mj2'
                    };
                default:
                    return;
            }
        }
        if (this.check([
            0xFF,
            0x0A
        ]) || this.check([
            0x00,
            0x00,
            0x00,
            0x0C,
            0x4A,
            0x58,
            0x4C,
            0x20,
            0x0D,
            0x0A,
            0x87,
            0x0A
        ])) {
            return {
                ext: 'jxl',
                mime: 'image/jxl'
            };
        }
        if (this.check([
            0xFE,
            0xFF
        ])) {
            if (this.check([
                0,
                60,
                0,
                63,
                0,
                120,
                0,
                109,
                0,
                108
            ], {
                offset: 2
            })) {
                return {
                    ext: 'xml',
                    mime: 'application/xml'
                };
            }
            return undefined; // Some unknown text based format
        }
        // -- Unsafe signatures --
        if (this.check([
            0x0,
            0x0,
            0x1,
            0xBA
        ]) || this.check([
            0x0,
            0x0,
            0x1,
            0xB3
        ])) {
            return {
                ext: 'mpg',
                mime: 'video/mpeg'
            };
        }
        if (this.check([
            0x00,
            0x01,
            0x00,
            0x00,
            0x00
        ])) {
            return {
                ext: 'ttf',
                mime: 'font/ttf'
            };
        }
        if (this.check([
            0x00,
            0x00,
            0x01,
            0x00
        ])) {
            return {
                ext: 'ico',
                mime: 'image/x-icon'
            };
        }
        if (this.check([
            0x00,
            0x00,
            0x02,
            0x00
        ])) {
            return {
                ext: 'cur',
                mime: 'image/x-icon'
            };
        }
        if (this.check([
            0xD0,
            0xCF,
            0x11,
            0xE0,
            0xA1,
            0xB1,
            0x1A,
            0xE1
        ])) {
            // Detected Microsoft Compound File Binary File (MS-CFB) Format.
            return {
                ext: 'cfb',
                mime: 'application/x-cfb'
            };
        }
        // Increase sample size from 12 to 256.
        await tokenizer.peekBuffer(this.buffer, {
            length: Math.min(256, tokenizer.fileInfo.size),
            mayBeLess: true
        });
        if (this.check([
            0x61,
            0x63,
            0x73,
            0x70
        ], {
            offset: 36
        })) {
            return {
                ext: 'icc',
                mime: 'application/vnd.iccprofile'
            };
        }
        // -- 15-byte signatures --
        if (this.checkString('BEGIN:')) {
            if (this.checkString('VCARD', {
                offset: 6
            })) {
                return {
                    ext: 'vcf',
                    mime: 'text/vcard'
                };
            }
            if (this.checkString('VCALENDAR', {
                offset: 6
            })) {
                return {
                    ext: 'ics',
                    mime: 'text/calendar'
                };
            }
        }
        // `raf` is here just to keep all the raw image detectors together.
        if (this.checkString('FUJIFILMCCD-RAW')) {
            return {
                ext: 'raf',
                mime: 'image/x-fujifilm-raf'
            };
        }
        if (this.checkString('Extended Module:')) {
            return {
                ext: 'xm',
                mime: 'audio/x-xm'
            };
        }
        if (this.checkString('Creative Voice File')) {
            return {
                ext: 'voc',
                mime: 'audio/x-voc'
            };
        }
        if (this.check([
            0x04,
            0x00,
            0x00,
            0x00
        ]) && this.buffer.length >= 16) {
            const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
            if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
                try {
                    const header = new TextDecoder().decode(this.buffer.slice(16, jsonSize + 16));
                    const json = JSON.parse(header);
                    // Check if Pickle is ASAR
                    if (json.files) {
                        return {
                            ext: 'asar',
                            mime: 'application/x-asar'
                        };
                    }
                } catch  {}
            }
        }
        if (this.check([
            0x06,
            0x0E,
            0x2B,
            0x34,
            0x02,
            0x05,
            0x01,
            0x01,
            0x0D,
            0x01,
            0x02,
            0x01,
            0x01,
            0x02
        ])) {
            return {
                ext: 'mxf',
                mime: 'application/mxf'
            };
        }
        if (this.checkString('SCRM', {
            offset: 44
        })) {
            return {
                ext: 's3m',
                mime: 'audio/x-s3m'
            };
        }
        // Raw MPEG-2 transport stream (188-byte packets)
        if (this.check([
            0x47
        ]) && this.check([
            0x47
        ], {
            offset: 188
        })) {
            return {
                ext: 'mts',
                mime: 'video/mp2t'
            };
        }
        // Blu-ray Disc Audio-Video (BDAV) MPEG-2 transport stream has 4-byte TP_extra_header before each 188-byte packet
        if (this.check([
            0x47
        ], {
            offset: 4
        }) && this.check([
            0x47
        ], {
            offset: 196
        })) {
            return {
                ext: 'mts',
                mime: 'video/mp2t'
            };
        }
        if (this.check([
            0x42,
            0x4F,
            0x4F,
            0x4B,
            0x4D,
            0x4F,
            0x42,
            0x49
        ], {
            offset: 60
        })) {
            return {
                ext: 'mobi',
                mime: 'application/x-mobipocket-ebook'
            };
        }
        if (this.check([
            0x44,
            0x49,
            0x43,
            0x4D
        ], {
            offset: 128
        })) {
            return {
                ext: 'dcm',
                mime: 'application/dicom'
            };
        }
        if (this.check([
            0x4C,
            0x00,
            0x00,
            0x00,
            0x01,
            0x14,
            0x02,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xC0,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x46
        ])) {
            return {
                ext: 'lnk',
                mime: 'application/x.ms.shortcut'
            };
        }
        if (this.check([
            0x62,
            0x6F,
            0x6F,
            0x6B,
            0x00,
            0x00,
            0x00,
            0x00,
            0x6D,
            0x61,
            0x72,
            0x6B,
            0x00,
            0x00,
            0x00,
            0x00
        ])) {
            return {
                ext: 'alias',
                mime: 'application/x.apple.alias'
            };
        }
        if (this.checkString('Kaydara FBX Binary  \u0000')) {
            return {
                ext: 'fbx',
                mime: 'application/x.autodesk.fbx'
            };
        }
        if (this.check([
            0x4C,
            0x50
        ], {
            offset: 34
        }) && (this.check([
            0x00,
            0x00,
            0x01
        ], {
            offset: 8
        }) || this.check([
            0x01,
            0x00,
            0x02
        ], {
            offset: 8
        }) || this.check([
            0x02,
            0x00,
            0x02
        ], {
            offset: 8
        }))) {
            return {
                ext: 'eot',
                mime: 'application/vnd.ms-fontobject'
            };
        }
        if (this.check([
            0x06,
            0x06,
            0xED,
            0xF5,
            0xD8,
            0x1D,
            0x46,
            0xE5,
            0xBD,
            0x31,
            0xEF,
            0xE7,
            0xFE,
            0x74,
            0xB7,
            0x1D
        ])) {
            return {
                ext: 'indd',
                mime: 'application/x-indesign'
            };
        }
        // Increase sample size from 256 to 512
        await tokenizer.peekBuffer(this.buffer, {
            length: Math.min(512, tokenizer.fileInfo.size),
            mayBeLess: true
        });
        // Requires a buffer size of 512 bytes
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$file$2d$type$40$19$2e$3$2e$0$2f$node_modules$2f$file$2d$type$2f$util$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["tarHeaderChecksumMatches"])(this.buffer)) {
            return {
                ext: 'tar',
                mime: 'application/x-tar'
            };
        }
        if (this.check([
            0xFF,
            0xFE
        ])) {
            if (this.check([
                60,
                0,
                63,
                0,
                120,
                0,
                109,
                0,
                108,
                0
            ], {
                offset: 2
            })) {
                return {
                    ext: 'xml',
                    mime: 'application/xml'
                };
            }
            if (this.check([
                0xFF,
                0x0E,
                0x53,
                0x00,
                0x6B,
                0x00,
                0x65,
                0x00,
                0x74,
                0x00,
                0x63,
                0x00,
                0x68,
                0x00,
                0x55,
                0x00,
                0x70,
                0x00,
                0x20,
                0x00,
                0x4D,
                0x00,
                0x6F,
                0x00,
                0x64,
                0x00,
                0x65,
                0x00,
                0x6C,
                0x00
            ], {
                offset: 2
            })) {
                return {
                    ext: 'skp',
                    mime: 'application/vnd.sketchup.skp'
                };
            }
            return undefined; // Some text based format
        }
        if (this.checkString('-----BEGIN PGP MESSAGE-----')) {
            return {
                ext: 'pgp',
                mime: 'application/pgp-encrypted'
            };
        }
        // Check MPEG 1 or 2 Layer 3 header, or 'layer 0' for ADTS (MPEG sync-word 0xFFE)
        if (this.buffer.length >= 2 && this.check([
            0xFF,
            0xE0
        ], {
            offset: 0,
            mask: [
                0xFF,
                0xE0
            ]
        })) {
            if (this.check([
                0x10
            ], {
                offset: 1,
                mask: [
                    0x16
                ]
            })) {
                // Check for (ADTS) MPEG-2
                if (this.check([
                    0x08
                ], {
                    offset: 1,
                    mask: [
                        0x08
                    ]
                })) {
                    return {
                        ext: 'aac',
                        mime: 'audio/aac'
                    };
                }
                // Must be (ADTS) MPEG-4
                return {
                    ext: 'aac',
                    mime: 'audio/aac'
                };
            }
            // MPEG 1 or 2 Layer 3 header
            // Check for MPEG layer 3
            if (this.check([
                0x02
            ], {
                offset: 1,
                mask: [
                    0x06
                ]
            })) {
                return {
                    ext: 'mp3',
                    mime: 'audio/mpeg'
                };
            }
            // Check for MPEG layer 2
            if (this.check([
                0x04
            ], {
                offset: 1,
                mask: [
                    0x06
                ]
            })) {
                return {
                    ext: 'mp2',
                    mime: 'audio/mpeg'
                };
            }
            // Check for MPEG layer 1
            if (this.check([
                0x06
            ], {
                offset: 1,
                mask: [
                    0x06
                ]
            })) {
                return {
                    ext: 'mp1',
                    mime: 'audio/mpeg'
                };
            }
        }
    }
    async readTiffTag(bigEndian) {
        const tagId = await this.tokenizer.readToken(bigEndian ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["UINT16_BE"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["UINT16_LE"]);
        this.tokenizer.ignore(10);
        switch(tagId){
            case 50_341:
                return {
                    ext: 'arw',
                    mime: 'image/x-sony-arw'
                };
            case 50_706:
                return {
                    ext: 'dng',
                    mime: 'image/x-adobe-dng'
                };
            default:
        }
    }
    async readTiffIFD(bigEndian) {
        const numberOfTags = await this.tokenizer.readToken(bigEndian ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["UINT16_BE"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["UINT16_LE"]);
        for(let n = 0; n < numberOfTags; ++n){
            const fileType = await this.readTiffTag(bigEndian);
            if (fileType) {
                return fileType;
            }
        }
    }
    async readTiffHeader(bigEndian) {
        const version = (bigEndian ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["UINT16_BE"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["UINT16_LE"]).get(this.buffer, 2);
        const ifdOffset = (bigEndian ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["UINT32_BE"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$token$2d$types$40$6$2e$1$2e$1$2f$node_modules$2f$token$2d$types$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["UINT32_LE"]).get(this.buffer, 4);
        if (version === 42) {
            // TIFF file header
            if (ifdOffset >= 6) {
                if (this.checkString('CR', {
                    offset: 8
                })) {
                    return {
                        ext: 'cr2',
                        mime: 'image/x-canon-cr2'
                    };
                }
                if (ifdOffset >= 8 && (this.check([
                    0x1C,
                    0x00,
                    0xFE,
                    0x00
                ], {
                    offset: 8
                }) || this.check([
                    0x1F,
                    0x00,
                    0x0B,
                    0x00
                ], {
                    offset: 8
                }))) {
                    return {
                        ext: 'nef',
                        mime: 'image/x-nikon-nef'
                    };
                }
            }
            await this.tokenizer.ignore(ifdOffset);
            const fileType = await this.readTiffIFD(bigEndian);
            return fileType ?? {
                ext: 'tif',
                mime: 'image/tiff'
            };
        }
        if (version === 43) {
            return {
                ext: 'tif',
                mime: 'image/tiff'
            };
        }
    }
}
const supportedExtensions = new Set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$file$2d$type$40$19$2e$3$2e$0$2f$node_modules$2f$file$2d$type$2f$supported$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["extensions"]);
const supportedMimeTypes = new Set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$file$2d$type$40$19$2e$3$2e$0$2f$node_modules$2f$file$2d$type$2f$supported$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["mimeTypes"]);
}),
"[project]/node_modules/.pnpm/file-type@19.3.0/node_modules/file-type/index.js [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "NodeFileTypeParser",
    ()=>NodeFileTypeParser,
    "fileTypeFromFile",
    ()=>fileTypeFromFile,
    "fileTypeFromStream",
    ()=>fileTypeFromStream,
    "fileTypeStream",
    ()=>fileTypeStream
]);
/**
Node.js specific entry point.
*/ var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream$2f$web__$5b$external$5d$__$28$node$3a$stream$2f$web$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream/web [external] (node:stream/web, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/index.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/core.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$FileTokenizer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/strtok3@8.1.0/node_modules/strtok3/lib/FileTokenizer.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$file$2d$type$40$19$2e$3$2e$0$2f$node_modules$2f$file$2d$type$2f$core$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/file-type@19.3.0/node_modules/file-type/core.js [app-rsc] (ecmascript)");
;
;
;
class NodeFileTypeParser extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$file$2d$type$40$19$2e$3$2e$0$2f$node_modules$2f$file$2d$type$2f$core$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["FileTypeParser"] {
    async fromStream(stream) {
        const tokenizer = await (stream instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream$2f$web__$5b$external$5d$__$28$node$3a$stream$2f$web$2c$__cjs$29$__["ReadableStream"] ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fromWebStream"](stream) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromStream"](stream));
        try {
            return super.fromTokenizer(tokenizer);
        } finally{
            await tokenizer.close();
        }
    }
    async fromFile(path) {
        const tokenizer = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$FileTokenizer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["fromFile"](path);
        try {
            return await super.fromTokenizer(tokenizer);
        } finally{
            await tokenizer.close();
        }
    }
    async toDetectionStream(readableStream, options = {}) {
        const { default: stream } = await __turbopack_context__.A("[externals]/node:stream [external] (node:stream, cjs, async loader)");
        const { sampleSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$file$2d$type$40$19$2e$3$2e$0$2f$node_modules$2f$file$2d$type$2f$core$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["reasonableDetectionSizeInBytes"] } = options;
        return new Promise((resolve, reject)=>{
            readableStream.on('error', reject);
            readableStream.once('readable', ()=>{
                (async ()=>{
                    try {
                        // Set up output stream
                        const pass = new stream.PassThrough();
                        const outputStream = stream.pipeline ? stream.pipeline(readableStream, pass, ()=>{}) : readableStream.pipe(pass);
                        // Read the input stream and detect the filetype
                        const chunk = readableStream.read(sampleSize) ?? readableStream.read() ?? new Uint8Array(0);
                        try {
                            pass.fileType = await this.fromBuffer(chunk);
                        } catch (error) {
                            if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$strtok3$40$8$2e$1$2e$0$2f$node_modules$2f$strtok3$2f$lib$2f$core$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["EndOfStreamError"]) {
                                pass.fileType = undefined;
                            } else {
                                reject(error);
                            }
                        }
                        resolve(outputStream);
                    } catch (error) {
                        reject(error);
                    }
                })();
            });
        });
    }
}
async function fileTypeFromFile(path, fileTypeOptions) {
    return new NodeFileTypeParser(fileTypeOptions).fromFile(path, fileTypeOptions);
}
async function fileTypeFromStream(stream, fileTypeOptions) {
    return new NodeFileTypeParser(fileTypeOptions).fromStream(stream);
}
async function fileTypeStream(readableStream, options = {}) {
    return new NodeFileTypeParser().toDetectionStream(readableStream, options);
}
;
}),
"[project]/node_modules/.pnpm/truncate-utf8-bytes@1.0.2/node_modules/truncate-utf8-bytes/lib/truncate.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function isHighSurrogate(codePoint) {
    return codePoint >= 0xd800 && codePoint <= 0xdbff;
}
function isLowSurrogate(codePoint) {
    return codePoint >= 0xdc00 && codePoint <= 0xdfff;
}
// Truncate string by size in bytes
module.exports = function truncate(getLength, string, byteLength) {
    if (typeof string !== "string") {
        throw new Error("Input must be string");
    }
    var charLength = string.length;
    var curByteLength = 0;
    var codePoint;
    var segment;
    for(var i = 0; i < charLength; i += 1){
        codePoint = string.charCodeAt(i);
        segment = string[i];
        if (isHighSurrogate(codePoint) && isLowSurrogate(string.charCodeAt(i + 1))) {
            i += 1;
            segment += string[i];
        }
        curByteLength += getLength(segment);
        if (curByteLength === byteLength) {
            return string.slice(0, i + 1);
        } else if (curByteLength > byteLength) {
            return string.slice(0, i - segment.length + 1);
        }
    }
    return string;
};
}),
"[project]/node_modules/.pnpm/truncate-utf8-bytes@1.0.2/node_modules/truncate-utf8-bytes/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var truncate = __turbopack_context__.r("[project]/node_modules/.pnpm/truncate-utf8-bytes@1.0.2/node_modules/truncate-utf8-bytes/lib/truncate.js [app-rsc] (ecmascript)");
var getLength = Buffer.byteLength.bind(Buffer);
module.exports = truncate.bind(null, getLength);
}),
"[project]/node_modules/.pnpm/sanitize-filename@1.6.3/node_modules/sanitize-filename/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*jshint node:true*/ /**
 * Replaces characters in strings that are illegal/unsafe for filenames.
 * Unsafe characters are either removed or replaced by a substitute set
 * in the optional `options` object.
 *
 * Illegal Characters on Various Operating Systems
 * / ? < > \ : * | "
 * https://kb.acronis.com/content/39790
 *
 * Unicode Control codes
 * C0 0x00-0x1f & C1 (0x80-0x9f)
 * http://en.wikipedia.org/wiki/C0_and_C1_control_codes
 *
 * Reserved filenames on Unix-based systems (".", "..")
 * Reserved filenames in Windows ("CON", "PRN", "AUX", "NUL", "COM1",
 * "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9",
 * "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", and
 * "LPT9") case-insesitively and with or without filename extensions.
 *
 * Capped at 255 characters in length.
 * http://unix.stackexchange.com/questions/32795/what-is-the-maximum-allowed-filename-and-folder-size-with-ecryptfs
 *
 * @param  {String} input   Original filename
 * @param  {Object} options {replacement: String | Function }
 * @return {String}         Sanitized filename
 */ var truncate = __turbopack_context__.r("[project]/node_modules/.pnpm/truncate-utf8-bytes@1.0.2/node_modules/truncate-utf8-bytes/index.js [app-rsc] (ecmascript)");
var illegalRe = /[\/\?<>\\:\*\|"]/g;
var controlRe = /[\x00-\x1f\x80-\x9f]/g;
var reservedRe = /^\.+$/;
var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
var windowsTrailingRe = /[\. ]+$/;
function sanitize(input, replacement) {
    if (typeof input !== 'string') {
        throw new Error('Input must be string');
    }
    var sanitized = input.replace(illegalRe, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
    return truncate(sanitized, 255);
}
module.exports = function(input, options) {
    var replacement = options && options.replacement || '';
    var output = sanitize(input, replacement);
    if (replacement === '') {
        return output;
    }
    return sanitize(output, '');
};
}),
"[project]/node_modules/.pnpm/ipaddr.js@2.2.0/node_modules/ipaddr.js/lib/ipaddr.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

(function(root) {
    'use strict';
    // A list of regular expressions that match arbitrary IPv4 addresses,
    // for which a number of weird notations exist.
    // Note that an address like 0010.0xa5.1.1 is considered legal.
    const ipv4Part = '(0?\\d+|0x[a-f0-9]+)';
    const ipv4Regexes = {
        fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, 'i'),
        threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, 'i'),
        twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, 'i'),
        longValue: new RegExp(`^${ipv4Part}$`, 'i')
    };
    // Regular Expression for checking Octal numbers
    const octalRegex = new RegExp(`^0[0-7]+$`, 'i');
    const hexRegex = new RegExp(`^0x[a-f0-9]+$`, 'i');
    const zoneIndex = '%[0-9a-z]{1,}';
    // IPv6-matching regular expressions.
    // For IPv6, the task is simpler: it is enough to match the colon-delimited
    // hexadecimal IPv6 and a transitional variant with dotted-decimal IPv4 at
    // the end.
    const ipv6Part = '(?:[0-9a-f]+::?)+';
    const ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, 'i'),
        'native': new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, 'i'),
        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, 'i'),
        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, 'i')
    };
    // Expand :: in an IPv6 address or address part consisting of `parts` groups.
    function expandIPv6(string, parts) {
        // More than one '::' means invalid adddress
        if (string.indexOf('::') !== string.lastIndexOf('::')) {
            return null;
        }
        let colonCount = 0;
        let lastColon = -1;
        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];
        let replacement, replacementCount;
        // Remove zone index and save it for later
        if (zoneId) {
            zoneId = zoneId.substring(1);
            string = string.replace(/%.+$/, '');
        }
        // How many parts do we already have?
        while((lastColon = string.indexOf(':', lastColon + 1)) >= 0){
            colonCount++;
        }
        // 0::0 is two parts more than ::
        if (string.substr(0, 2) === '::') {
            colonCount--;
        }
        if (string.substr(-2, 2) === '::') {
            colonCount--;
        }
        // The following loop would hang if colonCount > parts
        if (colonCount > parts) {
            return null;
        }
        // replacement = ':' + '0:' * (parts - colonCount)
        replacementCount = parts - colonCount;
        replacement = ':';
        while(replacementCount--){
            replacement += '0:';
        }
        // Insert the missing zeroes
        string = string.replace('::', replacement);
        // Trim any garbage which may be hanging around if :: was at the edge in
        // the source strin
        if (string[0] === ':') {
            string = string.slice(1);
        }
        if (string[string.length - 1] === ':') {
            string = string.slice(0, -1);
        }
        parts = function() {
            const ref = string.split(':');
            const results = [];
            for(let i = 0; i < ref.length; i++){
                results.push(parseInt(ref[i], 16));
            }
            return results;
        }();
        return {
            parts: parts,
            zoneId: zoneId
        };
    }
    // A generic CIDR (Classless Inter-Domain Routing) RFC1518 range matcher.
    function matchCIDR(first, second, partSize, cidrBits) {
        if (first.length !== second.length) {
            throw new Error('ipaddr: cannot match CIDR for objects with different lengths');
        }
        let part = 0;
        let shift;
        while(cidrBits > 0){
            shift = partSize - cidrBits;
            if (shift < 0) {
                shift = 0;
            }
            if (first[part] >> shift !== second[part] >> shift) {
                return false;
            }
            cidrBits -= partSize;
            part += 1;
        }
        return true;
    }
    function parseIntAuto(string) {
        // Hexadedimal base 16 (0x#)
        if (hexRegex.test(string)) {
            return parseInt(string, 16);
        }
        // While octal representation is discouraged by ECMAScript 3
        // and forbidden by ECMAScript 5, we silently allow it to
        // work only if the rest of the string has numbers less than 8.
        if (string[0] === '0' && !isNaN(parseInt(string[1], 10))) {
            if (octalRegex.test(string)) {
                return parseInt(string, 8);
            }
            throw new Error(`ipaddr: cannot parse ${string} as octal`);
        }
        // Always include the base 10 radix!
        return parseInt(string, 10);
    }
    function padPart(part, length) {
        while(part.length < length){
            part = `0${part}`;
        }
        return part;
    }
    const ipaddr = {};
    // An IPv4 address (RFC791).
    ipaddr.IPv4 = function() {
        // Constructs a new IPv4 address from an array of four octets
        // in network order (MSB first)
        // Verifies the input.
        function IPv4(octets) {
            if (octets.length !== 4) {
                throw new Error('ipaddr: ipv4 octet count should be 4');
            }
            let i, octet;
            for(i = 0; i < octets.length; i++){
                octet = octets[i];
                if (!(0 <= octet && octet <= 255)) {
                    throw new Error('ipaddr: ipv4 octet should fit in 8 bits');
                }
            }
            this.octets = octets;
        }
        // Special IPv4 address ranges.
        // See also https://en.wikipedia.org/wiki/Reserved_IP_addresses
        IPv4.prototype.SpecialRanges = {
            unspecified: [
                [
                    new IPv4([
                        0,
                        0,
                        0,
                        0
                    ]),
                    8
                ]
            ],
            broadcast: [
                [
                    new IPv4([
                        255,
                        255,
                        255,
                        255
                    ]),
                    32
                ]
            ],
            // RFC3171
            multicast: [
                [
                    new IPv4([
                        224,
                        0,
                        0,
                        0
                    ]),
                    4
                ]
            ],
            // RFC3927
            linkLocal: [
                [
                    new IPv4([
                        169,
                        254,
                        0,
                        0
                    ]),
                    16
                ]
            ],
            // RFC5735
            loopback: [
                [
                    new IPv4([
                        127,
                        0,
                        0,
                        0
                    ]),
                    8
                ]
            ],
            // RFC6598
            carrierGradeNat: [
                [
                    new IPv4([
                        100,
                        64,
                        0,
                        0
                    ]),
                    10
                ]
            ],
            // RFC1918
            'private': [
                [
                    new IPv4([
                        10,
                        0,
                        0,
                        0
                    ]),
                    8
                ],
                [
                    new IPv4([
                        172,
                        16,
                        0,
                        0
                    ]),
                    12
                ],
                [
                    new IPv4([
                        192,
                        168,
                        0,
                        0
                    ]),
                    16
                ]
            ],
            // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700
            reserved: [
                [
                    new IPv4([
                        192,
                        0,
                        0,
                        0
                    ]),
                    24
                ],
                [
                    new IPv4([
                        192,
                        0,
                        2,
                        0
                    ]),
                    24
                ],
                [
                    new IPv4([
                        192,
                        88,
                        99,
                        0
                    ]),
                    24
                ],
                [
                    new IPv4([
                        198,
                        18,
                        0,
                        0
                    ]),
                    15
                ],
                [
                    new IPv4([
                        198,
                        51,
                        100,
                        0
                    ]),
                    24
                ],
                [
                    new IPv4([
                        203,
                        0,
                        113,
                        0
                    ]),
                    24
                ],
                [
                    new IPv4([
                        240,
                        0,
                        0,
                        0
                    ]),
                    4
                ]
            ],
            // RFC7534, RFC7535
            as112: [
                [
                    new IPv4([
                        192,
                        175,
                        48,
                        0
                    ]),
                    24
                ],
                [
                    new IPv4([
                        192,
                        31,
                        196,
                        0
                    ]),
                    24
                ]
            ],
            // RFC7450
            amt: [
                [
                    new IPv4([
                        192,
                        52,
                        193,
                        0
                    ]),
                    24
                ]
            ]
        };
        // The 'kind' method exists on both IPv4 and IPv6 classes.
        IPv4.prototype.kind = function() {
            return 'ipv4';
        };
        // Checks if this address matches other one within given CIDR range.
        IPv4.prototype.match = function(other, cidrRange) {
            let ref;
            if (cidrRange === undefined) {
                ref = other;
                other = ref[0];
                cidrRange = ref[1];
            }
            if (other.kind() !== 'ipv4') {
                throw new Error('ipaddr: cannot match ipv4 address with non-ipv4 one');
            }
            return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        // returns a number of leading ones in IPv4 address, making sure that
        // the rest is a solid sequence of 0's (valid netmask)
        // returns either the CIDR length or null if mask is not valid
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
            let cidr = 0;
            // non-zero encountered stop scanning for zeroes
            let stop = false;
            // number of zeroes in octet
            const zerotable = {
                0: 8,
                128: 7,
                192: 6,
                224: 5,
                240: 4,
                248: 3,
                252: 2,
                254: 1,
                255: 0
            };
            let i, octet, zeros;
            for(i = 3; i >= 0; i -= 1){
                octet = this.octets[i];
                if (octet in zerotable) {
                    zeros = zerotable[octet];
                    if (stop && zeros !== 0) {
                        return null;
                    }
                    if (zeros !== 8) {
                        stop = true;
                    }
                    cidr += zeros;
                } else {
                    return null;
                }
            }
            return 32 - cidr;
        };
        // Checks if the address corresponds to one of the special ranges.
        IPv4.prototype.range = function() {
            return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        // Returns an array of byte-sized values in network order (MSB first)
        IPv4.prototype.toByteArray = function() {
            return this.octets.slice(0);
        };
        // Converts this IPv4 address to an IPv4-mapped IPv6 address.
        IPv4.prototype.toIPv4MappedAddress = function() {
            return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);
        };
        // Symmetrical method strictly for aligning with the IPv6 methods.
        IPv4.prototype.toNormalizedString = function() {
            return this.toString();
        };
        // Returns the address in convenient, decimal-dotted format.
        IPv4.prototype.toString = function() {
            return this.octets.join('.');
        };
        return IPv4;
    }();
    // A utility function to return broadcast address given the IPv4 interface and prefix length in CIDR notation
    ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
        try {
            const cidr = this.parseCIDR(string);
            const ipInterfaceOctets = cidr[0].toByteArray();
            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
            const octets = [];
            let i = 0;
            while(i < 4){
                // Broadcast address is bitwise OR between ip interface and inverted mask
                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
                i++;
            }
            return new this(octets);
        } catch (e) {
            throw new Error('ipaddr: the address does not have IPv4 CIDR format');
        }
    };
    // Checks if a given string is formatted like IPv4 address.
    ipaddr.IPv4.isIPv4 = function(string) {
        return this.parser(string) !== null;
    };
    // Checks if a given string is a valid IPv4 address.
    ipaddr.IPv4.isValid = function(string) {
        try {
            new this(this.parser(string));
            return true;
        } catch (e) {
            return false;
        }
    };
    // Checks if a given string is a valid IPv4 address in CIDR notation.
    ipaddr.IPv4.isValidCIDR = function(string) {
        try {
            this.parseCIDR(string);
            return true;
        } catch (e) {
            return false;
        }
    };
    // Checks if a given string is a full four-part IPv4 Address.
    ipaddr.IPv4.isValidFourPartDecimal = function(string) {
        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
            return true;
        } else {
            return false;
        }
    };
    // A utility function to return network address given the IPv4 interface and prefix length in CIDR notation
    ipaddr.IPv4.networkAddressFromCIDR = function(string) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
            cidr = this.parseCIDR(string);
            ipInterfaceOctets = cidr[0].toByteArray();
            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
            octets = [];
            i = 0;
            while(i < 4){
                // Network address is bitwise AND between ip interface and mask
                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
                i++;
            }
            return new this(octets);
        } catch (e) {
            throw new Error('ipaddr: the address does not have IPv4 CIDR format');
        }
    };
    // Tries to parse and validate a string with IPv4 address.
    // Throws an error if it fails.
    ipaddr.IPv4.parse = function(string) {
        const parts = this.parser(string);
        if (parts === null) {
            throw new Error('ipaddr: string is not formatted like an IPv4 Address');
        }
        return new this(parts);
    };
    // Parses the string as an IPv4 Address with CIDR Notation.
    ipaddr.IPv4.parseCIDR = function(string) {
        let match;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
            const maskLength = parseInt(match[2]);
            if (maskLength >= 0 && maskLength <= 32) {
                const parsed = [
                    this.parse(match[1]),
                    maskLength
                ];
                Object.defineProperty(parsed, 'toString', {
                    value: function() {
                        return this.join('/');
                    }
                });
                return parsed;
            }
        }
        throw new Error('ipaddr: string is not formatted like an IPv4 CIDR range');
    };
    // Classful variants (like a.b, where a is an octet, and b is a 24-bit
    // value representing last three octets; this corresponds to a class C
    // address) are omitted due to classless nature of modern Internet.
    ipaddr.IPv4.parser = function(string) {
        let match, part, value;
        // parseInt recognizes all that octal & hexadecimal weirdness for us
        if (match = string.match(ipv4Regexes.fourOctet)) {
            return function() {
                const ref = match.slice(1, 6);
                const results = [];
                for(let i = 0; i < ref.length; i++){
                    part = ref[i];
                    results.push(parseIntAuto(part));
                }
                return results;
            }();
        } else if (match = string.match(ipv4Regexes.longValue)) {
            value = parseIntAuto(match[1]);
            if (value > 0xffffffff || value < 0) {
                throw new Error('ipaddr: address outside defined range');
            }
            return (function() {
                const results = [];
                let shift;
                for(shift = 0; shift <= 24; shift += 8){
                    results.push(value >> shift & 0xff);
                }
                return results;
            })().reverse();
        } else if (match = string.match(ipv4Regexes.twoOctet)) {
            return function() {
                const ref = match.slice(1, 4);
                const results = [];
                value = parseIntAuto(ref[1]);
                if (value > 0xffffff || value < 0) {
                    throw new Error('ipaddr: address outside defined range');
                }
                results.push(parseIntAuto(ref[0]));
                results.push(value >> 16 & 0xff);
                results.push(value >> 8 & 0xff);
                results.push(value & 0xff);
                return results;
            }();
        } else if (match = string.match(ipv4Regexes.threeOctet)) {
            return function() {
                const ref = match.slice(1, 5);
                const results = [];
                value = parseIntAuto(ref[2]);
                if (value > 0xffff || value < 0) {
                    throw new Error('ipaddr: address outside defined range');
                }
                results.push(parseIntAuto(ref[0]));
                results.push(parseIntAuto(ref[1]));
                results.push(value >> 8 & 0xff);
                results.push(value & 0xff);
                return results;
            }();
        } else {
            return null;
        }
    };
    // A utility function to return subnet mask in IPv4 format given the prefix length
    ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
            throw new Error('ipaddr: invalid IPv4 prefix length');
        }
        const octets = [
            0,
            0,
            0,
            0
        ];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while(j < filledOctetCount){
            octets[j] = 255;
            j++;
        }
        if (filledOctetCount < 4) {
            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
    };
    // An IPv6 address (RFC2460)
    ipaddr.IPv6 = function() {
        // Constructs an IPv6 address from an array of eight 16 - bit parts
        // or sixteen 8 - bit parts in network order(MSB first).
        // Throws an error if the input is invalid.
        function IPv6(parts, zoneId) {
            let i, part;
            if (parts.length === 16) {
                this.parts = [];
                for(i = 0; i <= 14; i += 2){
                    this.parts.push(parts[i] << 8 | parts[i + 1]);
                }
            } else if (parts.length === 8) {
                this.parts = parts;
            } else {
                throw new Error('ipaddr: ipv6 part count should be 8 or 16');
            }
            for(i = 0; i < this.parts.length; i++){
                part = this.parts[i];
                if (!(0 <= part && part <= 0xffff)) {
                    throw new Error('ipaddr: ipv6 part should fit in 16 bits');
                }
            }
            if (zoneId) {
                this.zoneId = zoneId;
            }
        }
        // Special IPv6 ranges
        IPv6.prototype.SpecialRanges = {
            // RFC4291, here and after
            unspecified: [
                new IPv6([
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]),
                128
            ],
            linkLocal: [
                new IPv6([
                    0xfe80,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]),
                10
            ],
            multicast: [
                new IPv6([
                    0xff00,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]),
                8
            ],
            loopback: [
                new IPv6([
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1
                ]),
                128
            ],
            uniqueLocal: [
                new IPv6([
                    0xfc00,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]),
                7
            ],
            ipv4Mapped: [
                new IPv6([
                    0,
                    0,
                    0,
                    0,
                    0,
                    0xffff,
                    0,
                    0
                ]),
                96
            ],
            // RFC6666
            discard: [
                new IPv6([
                    0x100,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]),
                64
            ],
            // RFC6145
            rfc6145: [
                new IPv6([
                    0,
                    0,
                    0,
                    0,
                    0xffff,
                    0,
                    0,
                    0
                ]),
                96
            ],
            // RFC6052
            rfc6052: [
                new IPv6([
                    0x64,
                    0xff9b,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]),
                96
            ],
            // RFC3056
            '6to4': [
                new IPv6([
                    0x2002,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]),
                16
            ],
            // RFC6052, RFC6146
            teredo: [
                new IPv6([
                    0x2001,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]),
                32
            ],
            // RFC5180
            benchmarking: [
                new IPv6([
                    0x2001,
                    0x2,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]),
                48
            ],
            // RFC7450
            amt: [
                new IPv6([
                    0x2001,
                    0x3,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]),
                32
            ],
            as112v6: [
                [
                    new IPv6([
                        0x2001,
                        0x4,
                        0x112,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]),
                    48
                ],
                [
                    new IPv6([
                        0x2620,
                        0x4f,
                        0x8000,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]),
                    48
                ]
            ],
            deprecated: [
                new IPv6([
                    0x2001,
                    0x10,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]),
                28
            ],
            orchid2: [
                new IPv6([
                    0x2001,
                    0x20,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]),
                28
            ],
            droneRemoteIdProtocolEntityTags: [
                new IPv6([
                    0x2001,
                    0x30,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]),
                28
            ],
            reserved: [
                // RFC3849
                [
                    new IPv6([
                        0x2001,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]),
                    23
                ],
                // RFC2928
                [
                    new IPv6([
                        0x2001,
                        0xdb8,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]),
                    32
                ]
            ]
        };
        // Checks if this address is an IPv4-mapped IPv6 address.
        IPv6.prototype.isIPv4MappedAddress = function() {
            return this.range() === 'ipv4Mapped';
        };
        // The 'kind' method exists on both IPv4 and IPv6 classes.
        IPv6.prototype.kind = function() {
            return 'ipv6';
        };
        // Checks if this address matches other one within given CIDR range.
        IPv6.prototype.match = function(other, cidrRange) {
            let ref;
            if (cidrRange === undefined) {
                ref = other;
                other = ref[0];
                cidrRange = ref[1];
            }
            if (other.kind() !== 'ipv6') {
                throw new Error('ipaddr: cannot match ipv6 address with non-ipv6 one');
            }
            return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        // returns a number of leading ones in IPv6 address, making sure that
        // the rest is a solid sequence of 0's (valid netmask)
        // returns either the CIDR length or null if mask is not valid
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
            let cidr = 0;
            // non-zero encountered stop scanning for zeroes
            let stop = false;
            // number of zeroes in octet
            const zerotable = {
                0: 16,
                32768: 15,
                49152: 14,
                57344: 13,
                61440: 12,
                63488: 11,
                64512: 10,
                65024: 9,
                65280: 8,
                65408: 7,
                65472: 6,
                65504: 5,
                65520: 4,
                65528: 3,
                65532: 2,
                65534: 1,
                65535: 0
            };
            let part, zeros;
            for(let i = 7; i >= 0; i -= 1){
                part = this.parts[i];
                if (part in zerotable) {
                    zeros = zerotable[part];
                    if (stop && zeros !== 0) {
                        return null;
                    }
                    if (zeros !== 16) {
                        stop = true;
                    }
                    cidr += zeros;
                } else {
                    return null;
                }
            }
            return 128 - cidr;
        };
        // Checks if the address corresponds to one of the special ranges.
        IPv6.prototype.range = function() {
            return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        // Returns an array of byte-sized values in network order (MSB first)
        IPv6.prototype.toByteArray = function() {
            let part;
            const bytes = [];
            const ref = this.parts;
            for(let i = 0; i < ref.length; i++){
                part = ref[i];
                bytes.push(part >> 8);
                bytes.push(part & 0xff);
            }
            return bytes;
        };
        // Returns the address in expanded format with all zeroes included, like
        // 2001:0db8:0008:0066:0000:0000:0000:0001
        IPv6.prototype.toFixedLengthString = function() {
            const addr = (function() {
                const results = [];
                for(let i = 0; i < this.parts.length; i++){
                    results.push(padPart(this.parts[i].toString(16), 4));
                }
                return results;
            }).call(this).join(':');
            let suffix = '';
            if (this.zoneId) {
                suffix = `%${this.zoneId}`;
            }
            return addr + suffix;
        };
        // Converts this address to IPv4 address if it is an IPv4-mapped IPv6 address.
        // Throws an error otherwise.
        IPv6.prototype.toIPv4Address = function() {
            if (!this.isIPv4MappedAddress()) {
                throw new Error('ipaddr: trying to convert a generic ipv6 address to ipv4');
            }
            const ref = this.parts.slice(-2);
            const high = ref[0];
            const low = ref[1];
            return new ipaddr.IPv4([
                high >> 8,
                high & 0xff,
                low >> 8,
                low & 0xff
            ]);
        };
        // Returns the address in expanded format with all zeroes included, like
        // 2001:db8:8:66:0:0:0:1
        //
        // Deprecated: use toFixedLengthString() instead.
        IPv6.prototype.toNormalizedString = function() {
            const addr = (function() {
                const results = [];
                for(let i = 0; i < this.parts.length; i++){
                    results.push(this.parts[i].toString(16));
                }
                return results;
            }).call(this).join(':');
            let suffix = '';
            if (this.zoneId) {
                suffix = `%${this.zoneId}`;
            }
            return addr + suffix;
        };
        // Returns the address in compact, human-readable format like
        // 2001:db8:8:66::1
        // in line with RFC 5952 (see https://tools.ietf.org/html/rfc5952#section-4)
        IPv6.prototype.toRFC5952String = function() {
            const regex = /((^|:)(0(:|$)){2,})/g;
            const string = this.toNormalizedString();
            let bestMatchIndex = 0;
            let bestMatchLength = -1;
            let match;
            while(match = regex.exec(string)){
                if (match[0].length > bestMatchLength) {
                    bestMatchIndex = match.index;
                    bestMatchLength = match[0].length;
                }
            }
            if (bestMatchLength < 0) {
                return string;
            }
            return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;
        };
        // Returns the address in compact, human-readable format like
        // 2001:db8:8:66::1
        // Calls toRFC5952String under the hood.
        IPv6.prototype.toString = function() {
            return this.toRFC5952String();
        };
        return IPv6;
    }();
    // A utility function to return broadcast address given the IPv6 interface and prefix length in CIDR notation
    ipaddr.IPv6.broadcastAddressFromCIDR = function(string) {
        try {
            const cidr = this.parseCIDR(string);
            const ipInterfaceOctets = cidr[0].toByteArray();
            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
            const octets = [];
            let i = 0;
            while(i < 16){
                // Broadcast address is bitwise OR between ip interface and inverted mask
                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
                i++;
            }
            return new this(octets);
        } catch (e) {
            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
    };
    // Checks if a given string is formatted like IPv6 address.
    ipaddr.IPv6.isIPv6 = function(string) {
        return this.parser(string) !== null;
    };
    // Checks to see if string is a valid IPv6 Address
    ipaddr.IPv6.isValid = function(string) {
        // Since IPv6.isValid is always called first, this shortcut
        // provides a substantial performance gain.
        if (typeof string === 'string' && string.indexOf(':') === -1) {
            return false;
        }
        try {
            const addr = this.parser(string);
            new this(addr.parts, addr.zoneId);
            return true;
        } catch (e) {
            return false;
        }
    };
    // Checks if a given string is a valid IPv6 address in CIDR notation.
    ipaddr.IPv6.isValidCIDR = function(string) {
        // See note in IPv6.isValid
        if (typeof string === 'string' && string.indexOf(':') === -1) {
            return false;
        }
        try {
            this.parseCIDR(string);
            return true;
        } catch (e) {
            return false;
        }
    };
    // A utility function to return network address given the IPv6 interface and prefix length in CIDR notation
    ipaddr.IPv6.networkAddressFromCIDR = function(string) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
            cidr = this.parseCIDR(string);
            ipInterfaceOctets = cidr[0].toByteArray();
            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
            octets = [];
            i = 0;
            while(i < 16){
                // Network address is bitwise AND between ip interface and mask
                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
                i++;
            }
            return new this(octets);
        } catch (e) {
            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
    };
    // Tries to parse and validate a string with IPv6 address.
    // Throws an error if it fails.
    ipaddr.IPv6.parse = function(string) {
        const addr = this.parser(string);
        if (addr.parts === null) {
            throw new Error('ipaddr: string is not formatted like an IPv6 Address');
        }
        return new this(addr.parts, addr.zoneId);
    };
    ipaddr.IPv6.parseCIDR = function(string) {
        let maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
            maskLength = parseInt(match[2]);
            if (maskLength >= 0 && maskLength <= 128) {
                parsed = [
                    this.parse(match[1]),
                    maskLength
                ];
                Object.defineProperty(parsed, 'toString', {
                    value: function() {
                        return this.join('/');
                    }
                });
                return parsed;
            }
        }
        throw new Error('ipaddr: string is not formatted like an IPv6 CIDR range');
    };
    // Parse an IPv6 address.
    ipaddr.IPv6.parser = function(string) {
        let addr, i, match, octet, octets, zoneId;
        if (match = string.match(ipv6Regexes.deprecatedTransitional)) {
            return this.parser(`::ffff:${match[1]}`);
        }
        if (ipv6Regexes.native.test(string)) {
            return expandIPv6(string, 8);
        }
        if (match = string.match(ipv6Regexes.transitional)) {
            zoneId = match[6] || '';
            addr = match[1];
            if (!match[1].endsWith('::')) {
                addr = addr.slice(0, -1);
            }
            addr = expandIPv6(addr + zoneId, 6);
            if (addr.parts) {
                octets = [
                    parseInt(match[2]),
                    parseInt(match[3]),
                    parseInt(match[4]),
                    parseInt(match[5])
                ];
                for(i = 0; i < octets.length; i++){
                    octet = octets[i];
                    if (!(0 <= octet && octet <= 255)) {
                        return null;
                    }
                }
                addr.parts.push(octets[0] << 8 | octets[1]);
                addr.parts.push(octets[2] << 8 | octets[3]);
                return {
                    parts: addr.parts,
                    zoneId: addr.zoneId
                };
            }
        }
        return null;
    };
    // A utility function to return subnet mask in IPv6 format given the prefix length
    ipaddr.IPv6.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 128) {
            throw new Error('ipaddr: invalid IPv6 prefix length');
        }
        const octets = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while(j < filledOctetCount){
            octets[j] = 255;
            j++;
        }
        if (filledOctetCount < 16) {
            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
    };
    // Try to parse an array in network order (MSB first) for IPv4 and IPv6
    ipaddr.fromByteArray = function(bytes) {
        const length = bytes.length;
        if (length === 4) {
            return new ipaddr.IPv4(bytes);
        } else if (length === 16) {
            return new ipaddr.IPv6(bytes);
        } else {
            throw new Error('ipaddr: the binary input is neither an IPv6 nor IPv4 address');
        }
    };
    // Checks if the address is valid IP address
    ipaddr.isValid = function(string) {
        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
    };
    // Checks if the address is valid IP address in CIDR notation
    ipaddr.isValidCIDR = function(string) {
        return ipaddr.IPv6.isValidCIDR(string) || ipaddr.IPv4.isValidCIDR(string);
    };
    // Attempts to parse an IP Address, first through IPv6 then IPv4.
    // Throws an error if it could not be parsed.
    ipaddr.parse = function(string) {
        if (ipaddr.IPv6.isValid(string)) {
            return ipaddr.IPv6.parse(string);
        } else if (ipaddr.IPv4.isValid(string)) {
            return ipaddr.IPv4.parse(string);
        } else {
            throw new Error('ipaddr: the address has neither IPv6 nor IPv4 format');
        }
    };
    // Attempt to parse CIDR notation, first through IPv6 then IPv4.
    // Throws an error if it could not be parsed.
    ipaddr.parseCIDR = function(string) {
        try {
            return ipaddr.IPv6.parseCIDR(string);
        } catch (e) {
            try {
                return ipaddr.IPv4.parseCIDR(string);
            } catch (e2) {
                throw new Error('ipaddr: the address has neither IPv6 nor IPv4 CIDR format');
            }
        }
    };
    // Parse an address and return plain IPv4 address if it is an IPv4-mapped address
    ipaddr.process = function(string) {
        const addr = this.parse(string);
        if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
            return addr.toIPv4Address();
        } else {
            return addr;
        }
    };
    // An utility function to ease named range matching. See examples below.
    // rangeList can contain both IPv4 and IPv6 subnet entries and will not throw errors
    // on matching IPv4 addresses to IPv6 ranges or vice versa.
    ipaddr.subnetMatch = function(address, rangeList, defaultName) {
        let i, rangeName, rangeSubnets, subnet;
        if (defaultName === undefined || defaultName === null) {
            defaultName = 'unicast';
        }
        for(rangeName in rangeList){
            if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
                rangeSubnets = rangeList[rangeName];
                // ECMA5 Array.isArray isn't available everywhere
                if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
                    rangeSubnets = [
                        rangeSubnets
                    ];
                }
                for(i = 0; i < rangeSubnets.length; i++){
                    subnet = rangeSubnets[i];
                    if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
                        return rangeName;
                    }
                }
            }
        }
        return defaultName;
    };
    // Export for both the CommonJS and browser-like environment
    if (("TURBOPACK compile-time value", "object") !== 'undefined' && module.exports) {
        module.exports = ipaddr;
    } else {
        root.ipaddr = ipaddr;
    }
})(/*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/node_modules/.pnpm/image-size@2.0.2/node_modules/image-size/dist/index.mjs [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>imageSize,
    "disableTypes",
    ()=>disableTypes,
    "imageSize",
    ()=>imageSize,
    "types",
    ()=>types
]);
// lib/types/utils.ts
var decoder = new TextDecoder();
var toUTF8String = (input, start = 0, end = input.length)=>decoder.decode(input.slice(start, end));
var toHexString = (input, start = 0, end = input.length)=>input.slice(start, end).reduce((memo, i)=>memo + `0${i.toString(16)}`.slice(-2), "");
var getView = (input, offset)=>new DataView(input.buffer, input.byteOffset + offset);
var readInt16LE = (input, offset = 0)=>getView(input, offset).getInt16(0, true);
var readUInt16BE = (input, offset = 0)=>getView(input, offset).getUint16(0, false);
var readUInt16LE = (input, offset = 0)=>getView(input, offset).getUint16(0, true);
var readUInt24LE = (input, offset = 0)=>{
    const view = getView(input, offset);
    return view.getUint16(0, true) + (view.getUint8(2) << 16);
};
var readInt32LE = (input, offset = 0)=>getView(input, offset).getInt32(0, true);
var readUInt32BE = (input, offset = 0)=>getView(input, offset).getUint32(0, false);
var readUInt32LE = (input, offset = 0)=>getView(input, offset).getUint32(0, true);
var readUInt64 = (input, offset, isBigEndian)=>getView(input, offset).getBigUint64(0, !isBigEndian);
var methods = {
    readUInt16BE,
    readUInt16LE,
    readUInt32BE,
    readUInt32LE
};
function readUInt(input, bits, offset = 0, isBigEndian = false) {
    const endian = isBigEndian ? "BE" : "LE";
    const methodName = `readUInt${bits}${endian}`;
    return methods[methodName](input, offset);
}
function readBox(input, offset) {
    if (input.length - offset < 4) return;
    const boxSize = readUInt32BE(input, offset);
    if (input.length - offset < boxSize) return;
    return {
        name: toUTF8String(input, 4 + offset, 8 + offset),
        offset,
        size: boxSize
    };
}
function findBox(input, boxName, currentOffset) {
    while(currentOffset < input.length){
        const box = readBox(input, currentOffset);
        if (!box) break;
        if (box.name === boxName) return box;
        currentOffset += box.size > 0 ? box.size : 8;
    }
}
// lib/types/bmp.ts
var BMP = {
    validate: (input)=>toUTF8String(input, 0, 2) === "BM",
    calculate: (input)=>({
            height: Math.abs(readInt32LE(input, 22)),
            width: readUInt32LE(input, 18)
        })
};
// lib/types/ico.ts
var TYPE_ICON = 1;
var SIZE_HEADER = 2 + 2 + 2;
var SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4;
function getSizeFromOffset(input, offset) {
    const value = input[offset];
    return value === 0 ? 256 : value;
}
function getImageSize(input, imageIndex) {
    const offset = SIZE_HEADER + imageIndex * SIZE_IMAGE_ENTRY;
    return {
        height: getSizeFromOffset(input, offset + 1),
        width: getSizeFromOffset(input, offset)
    };
}
var ICO = {
    validate (input) {
        const reserved = readUInt16LE(input, 0);
        const imageCount = readUInt16LE(input, 4);
        if (reserved !== 0 || imageCount === 0) return false;
        const imageType = readUInt16LE(input, 2);
        return imageType === TYPE_ICON;
    },
    calculate (input) {
        const nbImages = readUInt16LE(input, 4);
        const imageSize2 = getImageSize(input, 0);
        if (nbImages === 1) return imageSize2;
        const images = [];
        for(let imageIndex = 0; imageIndex < nbImages; imageIndex += 1){
            images.push(getImageSize(input, imageIndex));
        }
        return {
            width: imageSize2.width,
            height: imageSize2.height,
            images
        };
    }
};
// lib/types/cur.ts
var TYPE_CURSOR = 2;
var CUR = {
    validate (input) {
        const reserved = readUInt16LE(input, 0);
        const imageCount = readUInt16LE(input, 4);
        if (reserved !== 0 || imageCount === 0) return false;
        const imageType = readUInt16LE(input, 2);
        return imageType === TYPE_CURSOR;
    },
    calculate: (input)=>ICO.calculate(input)
};
// lib/types/dds.ts
var DDS = {
    validate: (input)=>readUInt32LE(input, 0) === 542327876,
    calculate: (input)=>({
            height: readUInt32LE(input, 12),
            width: readUInt32LE(input, 16)
        })
};
// lib/types/gif.ts
var gifRegexp = /^GIF8[79]a/;
var GIF = {
    validate: (input)=>gifRegexp.test(toUTF8String(input, 0, 6)),
    calculate: (input)=>({
            height: readUInt16LE(input, 8),
            width: readUInt16LE(input, 6)
        })
};
// lib/types/heif.ts
var brandMap = {
    avif: "avif",
    mif1: "heif",
    msf1: "heif",
    // heif-sequence
    heic: "heic",
    heix: "heic",
    hevc: "heic",
    // heic-sequence
    hevx: "heic"
};
var HEIF = {
    validate (input) {
        const boxType = toUTF8String(input, 4, 8);
        if (boxType !== "ftyp") return false;
        const ftypBox = findBox(input, "ftyp", 0);
        if (!ftypBox) return false;
        const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
        return brand in brandMap;
    },
    calculate (input) {
        const metaBox = findBox(input, "meta", 0);
        const iprpBox = metaBox && findBox(input, "iprp", metaBox.offset + 12);
        const ipcoBox = iprpBox && findBox(input, "ipco", iprpBox.offset + 8);
        if (!ipcoBox) {
            throw new TypeError("Invalid HEIF, no ipco box found");
        }
        const type = toUTF8String(input, 8, 12);
        const images = [];
        let currentOffset = ipcoBox.offset + 8;
        while(currentOffset < ipcoBox.offset + ipcoBox.size){
            const ispeBox = findBox(input, "ispe", currentOffset);
            if (!ispeBox) break;
            const rawWidth = readUInt32BE(input, ispeBox.offset + 12);
            const rawHeight = readUInt32BE(input, ispeBox.offset + 16);
            const clapBox = findBox(input, "clap", currentOffset);
            let width = rawWidth;
            let height = rawHeight;
            if (clapBox && clapBox.offset < ipcoBox.offset + ipcoBox.size) {
                const cropRight = readUInt32BE(input, clapBox.offset + 12);
                width = rawWidth - cropRight;
            }
            images.push({
                height,
                width
            });
            currentOffset = ispeBox.offset + ispeBox.size;
        }
        if (images.length === 0) {
            throw new TypeError("Invalid HEIF, no sizes found");
        }
        return {
            width: images[0].width,
            height: images[0].height,
            type,
            ...images.length > 1 ? {
                images
            } : {}
        };
    }
};
// lib/types/icns.ts
var SIZE_HEADER2 = 4 + 4;
var FILE_LENGTH_OFFSET = 4;
var ENTRY_LENGTH_OFFSET = 4;
var ICON_TYPE_SIZE = {
    ICON: 32,
    "ICN#": 32,
    // m => 16 x 16
    "icm#": 16,
    icm4: 16,
    icm8: 16,
    // s => 16 x 16
    "ics#": 16,
    ics4: 16,
    ics8: 16,
    is32: 16,
    s8mk: 16,
    icp4: 16,
    // l => 32 x 32
    icl4: 32,
    icl8: 32,
    il32: 32,
    l8mk: 32,
    icp5: 32,
    ic11: 32,
    // h => 48 x 48
    ich4: 48,
    ich8: 48,
    ih32: 48,
    h8mk: 48,
    // . => 64 x 64
    icp6: 64,
    ic12: 32,
    // t => 128 x 128
    it32: 128,
    t8mk: 128,
    ic07: 128,
    // . => 256 x 256
    ic08: 256,
    ic13: 256,
    // . => 512 x 512
    ic09: 512,
    ic14: 512,
    // . => 1024 x 1024
    ic10: 1024
};
function readImageHeader(input, imageOffset) {
    const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;
    return [
        toUTF8String(input, imageOffset, imageLengthOffset),
        readUInt32BE(input, imageLengthOffset)
    ];
}
function getImageSize2(type) {
    const size = ICON_TYPE_SIZE[type];
    return {
        width: size,
        height: size,
        type
    };
}
var ICNS = {
    validate: (input)=>toUTF8String(input, 0, 4) === "icns",
    calculate (input) {
        const inputLength = input.length;
        const fileLength = readUInt32BE(input, FILE_LENGTH_OFFSET);
        let imageOffset = SIZE_HEADER2;
        const images = [];
        while(imageOffset < fileLength && imageOffset < inputLength){
            const imageHeader = readImageHeader(input, imageOffset);
            const imageSize2 = getImageSize2(imageHeader[0]);
            images.push(imageSize2);
            imageOffset += imageHeader[1];
        }
        if (images.length === 0) {
            throw new TypeError("Invalid ICNS, no sizes found");
        }
        return {
            width: images[0].width,
            height: images[0].height,
            ...images.length > 1 ? {
                images
            } : {}
        };
    }
};
// lib/types/j2c.ts
var J2C = {
    // TODO: this doesn't seem right. SIZ marker doesn't have to be right after the SOC
    validate: (input)=>readUInt32BE(input, 0) === 4283432785,
    calculate: (input)=>({
            height: readUInt32BE(input, 12),
            width: readUInt32BE(input, 8)
        })
};
// lib/types/jp2.ts
var JP2 = {
    validate (input) {
        const boxType = toUTF8String(input, 4, 8);
        if (boxType !== "jP  ") return false;
        const ftypBox = findBox(input, "ftyp", 0);
        if (!ftypBox) return false;
        const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
        return brand === "jp2 ";
    },
    calculate (input) {
        const jp2hBox = findBox(input, "jp2h", 0);
        const ihdrBox = jp2hBox && findBox(input, "ihdr", jp2hBox.offset + 8);
        if (ihdrBox) {
            return {
                height: readUInt32BE(input, ihdrBox.offset + 8),
                width: readUInt32BE(input, ihdrBox.offset + 12)
            };
        }
        throw new TypeError("Unsupported JPEG 2000 format");
    }
};
// lib/types/jpg.ts
var EXIF_MARKER = "45786966";
var APP1_DATA_SIZE_BYTES = 2;
var EXIF_HEADER_BYTES = 6;
var TIFF_BYTE_ALIGN_BYTES = 2;
var BIG_ENDIAN_BYTE_ALIGN = "4d4d";
var LITTLE_ENDIAN_BYTE_ALIGN = "4949";
var IDF_ENTRY_BYTES = 12;
var NUM_DIRECTORY_ENTRIES_BYTES = 2;
function isEXIF(input) {
    return toHexString(input, 2, 6) === EXIF_MARKER;
}
function extractSize(input, index) {
    return {
        height: readUInt16BE(input, index),
        width: readUInt16BE(input, index + 2)
    };
}
function extractOrientation(exifBlock, isBigEndian) {
    const idfOffset = 8;
    const offset = EXIF_HEADER_BYTES + idfOffset;
    const idfDirectoryEntries = readUInt(exifBlock, 16, offset, isBigEndian);
    for(let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++){
        const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;
        const end = start + IDF_ENTRY_BYTES;
        if (start > exifBlock.length) {
            return;
        }
        const block = exifBlock.slice(start, end);
        const tagNumber = readUInt(block, 16, 0, isBigEndian);
        if (tagNumber === 274) {
            const dataFormat = readUInt(block, 16, 2, isBigEndian);
            if (dataFormat !== 3) {
                return;
            }
            const numberOfComponents = readUInt(block, 32, 4, isBigEndian);
            if (numberOfComponents !== 1) {
                return;
            }
            return readUInt(block, 16, 8, isBigEndian);
        }
    }
}
function validateExifBlock(input, index) {
    const exifBlock = input.slice(APP1_DATA_SIZE_BYTES, index);
    const byteAlign = toHexString(exifBlock, EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES);
    const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;
    const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;
    if (isBigEndian || isLittleEndian) {
        return extractOrientation(exifBlock, isBigEndian);
    }
}
function validateInput(input, index) {
    if (index > input.length) {
        throw new TypeError("Corrupt JPG, exceeded buffer limits");
    }
}
var JPG = {
    validate: (input)=>toHexString(input, 0, 2) === "ffd8",
    calculate (_input) {
        let input = _input.slice(4);
        let orientation;
        let next;
        while(input.length){
            const i = readUInt16BE(input, 0);
            validateInput(input, i);
            if (input[i] !== 255) {
                input = input.slice(1);
                continue;
            }
            if (isEXIF(input)) {
                orientation = validateExifBlock(input, i);
            }
            next = input[i + 1];
            if (next === 192 || next === 193 || next === 194) {
                const size = extractSize(input, i + 5);
                if (!orientation) {
                    return size;
                }
                return {
                    height: size.height,
                    orientation,
                    width: size.width
                };
            }
            input = input.slice(i + 2);
        }
        throw new TypeError("Invalid JPG, no size found");
    }
};
// lib/utils/bit-reader.ts
var BitReader = class {
    constructor(input, endianness){
        this.input = input;
        this.endianness = endianness;
        // Skip the first 16 bits (2 bytes) of signature
        this.byteOffset = 2;
        this.bitOffset = 0;
    }
    /** Reads a specified number of bits, and move the offset */ getBits(length = 1) {
        let result = 0;
        let bitsRead = 0;
        while(bitsRead < length){
            if (this.byteOffset >= this.input.length) {
                throw new Error("Reached end of input");
            }
            const currentByte = this.input[this.byteOffset];
            const bitsLeft = 8 - this.bitOffset;
            const bitsToRead = Math.min(length - bitsRead, bitsLeft);
            if (this.endianness === "little-endian") {
                const mask = (1 << bitsToRead) - 1;
                const bits = currentByte >> this.bitOffset & mask;
                result |= bits << bitsRead;
            } else {
                const mask = (1 << bitsToRead) - 1 << 8 - this.bitOffset - bitsToRead;
                const bits = (currentByte & mask) >> 8 - this.bitOffset - bitsToRead;
                result = result << bitsToRead | bits;
            }
            bitsRead += bitsToRead;
            this.bitOffset += bitsToRead;
            if (this.bitOffset === 8) {
                this.byteOffset++;
                this.bitOffset = 0;
            }
        }
        return result;
    }
};
// lib/types/jxl-stream.ts
function calculateImageDimension(reader, isSmallImage) {
    if (isSmallImage) {
        return 8 * (1 + reader.getBits(5));
    }
    const sizeClass = reader.getBits(2);
    const extraBits = [
        9,
        13,
        18,
        30
    ][sizeClass];
    return 1 + reader.getBits(extraBits);
}
function calculateImageWidth(reader, isSmallImage, widthMode, height) {
    if (isSmallImage && widthMode === 0) {
        return 8 * (1 + reader.getBits(5));
    }
    if (widthMode === 0) {
        return calculateImageDimension(reader, false);
    }
    const aspectRatios = [
        1,
        1.2,
        4 / 3,
        1.5,
        16 / 9,
        5 / 4,
        2
    ];
    return Math.floor(height * aspectRatios[widthMode - 1]);
}
var JXLStream = {
    validate: (input)=>{
        return toHexString(input, 0, 2) === "ff0a";
    },
    calculate (input) {
        const reader = new BitReader(input, "little-endian");
        const isSmallImage = reader.getBits(1) === 1;
        const height = calculateImageDimension(reader, isSmallImage);
        const widthMode = reader.getBits(3);
        const width = calculateImageWidth(reader, isSmallImage, widthMode, height);
        return {
            width,
            height
        };
    }
};
// lib/types/jxl.ts
function extractCodestream(input) {
    const jxlcBox = findBox(input, "jxlc", 0);
    if (jxlcBox) {
        return input.slice(jxlcBox.offset + 8, jxlcBox.offset + jxlcBox.size);
    }
    const partialStreams = extractPartialStreams(input);
    if (partialStreams.length > 0) {
        return concatenateCodestreams(partialStreams);
    }
    return void 0;
}
function extractPartialStreams(input) {
    const partialStreams = [];
    let offset = 0;
    while(offset < input.length){
        const jxlpBox = findBox(input, "jxlp", offset);
        if (!jxlpBox) break;
        partialStreams.push(input.slice(jxlpBox.offset + 12, jxlpBox.offset + jxlpBox.size));
        offset = jxlpBox.offset + jxlpBox.size;
    }
    return partialStreams;
}
function concatenateCodestreams(partialCodestreams) {
    const totalLength = partialCodestreams.reduce((acc, curr)=>acc + curr.length, 0);
    const codestream = new Uint8Array(totalLength);
    let position = 0;
    for (const partial of partialCodestreams){
        codestream.set(partial, position);
        position += partial.length;
    }
    return codestream;
}
var JXL = {
    validate: (input)=>{
        const boxType = toUTF8String(input, 4, 8);
        if (boxType !== "JXL ") return false;
        const ftypBox = findBox(input, "ftyp", 0);
        if (!ftypBox) return false;
        const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
        return brand === "jxl ";
    },
    calculate (input) {
        const codestream = extractCodestream(input);
        if (codestream) return JXLStream.calculate(codestream);
        throw new Error("No codestream found in JXL container");
    }
};
// lib/types/ktx.ts
var KTX = {
    validate: (input)=>{
        const signature = toUTF8String(input, 1, 7);
        return [
            "KTX 11",
            "KTX 20"
        ].includes(signature);
    },
    calculate: (input)=>{
        const type = input[5] === 49 ? "ktx" : "ktx2";
        const offset = type === "ktx" ? 36 : 20;
        return {
            height: readUInt32LE(input, offset + 4),
            width: readUInt32LE(input, offset),
            type
        };
    }
};
// lib/types/png.ts
var pngSignature = "PNG\r\n\n";
var pngImageHeaderChunkName = "IHDR";
var pngFriedChunkName = "CgBI";
var PNG = {
    validate (input) {
        if (pngSignature === toUTF8String(input, 1, 8)) {
            let chunkName = toUTF8String(input, 12, 16);
            if (chunkName === pngFriedChunkName) {
                chunkName = toUTF8String(input, 28, 32);
            }
            if (chunkName !== pngImageHeaderChunkName) {
                throw new TypeError("Invalid PNG");
            }
            return true;
        }
        return false;
    },
    calculate (input) {
        if (toUTF8String(input, 12, 16) === pngFriedChunkName) {
            return {
                height: readUInt32BE(input, 36),
                width: readUInt32BE(input, 32)
            };
        }
        return {
            height: readUInt32BE(input, 20),
            width: readUInt32BE(input, 16)
        };
    }
};
// lib/types/pnm.ts
var PNMTypes = {
    P1: "pbm/ascii",
    P2: "pgm/ascii",
    P3: "ppm/ascii",
    P4: "pbm",
    P5: "pgm",
    P6: "ppm",
    P7: "pam",
    PF: "pfm"
};
var handlers = {
    default: (lines)=>{
        let dimensions = [];
        while(lines.length > 0){
            const line = lines.shift();
            if (line[0] === "#") {
                continue;
            }
            dimensions = line.split(" ");
            break;
        }
        if (dimensions.length === 2) {
            return {
                height: Number.parseInt(dimensions[1], 10),
                width: Number.parseInt(dimensions[0], 10)
            };
        }
        throw new TypeError("Invalid PNM");
    },
    pam: (lines)=>{
        const size = {};
        while(lines.length > 0){
            const line = lines.shift();
            if (line.length > 16 || line.charCodeAt(0) > 128) {
                continue;
            }
            const [key, value] = line.split(" ");
            if (key && value) {
                size[key.toLowerCase()] = Number.parseInt(value, 10);
            }
            if (size.height && size.width) {
                break;
            }
        }
        if (size.height && size.width) {
            return {
                height: size.height,
                width: size.width
            };
        }
        throw new TypeError("Invalid PAM");
    }
};
var PNM = {
    validate: (input)=>toUTF8String(input, 0, 2) in PNMTypes,
    calculate (input) {
        const signature = toUTF8String(input, 0, 2);
        const type = PNMTypes[signature];
        const lines = toUTF8String(input, 3).split(/[\r\n]+/);
        const handler = handlers[type] || handlers.default;
        return handler(lines);
    }
};
// lib/types/psd.ts
var PSD = {
    validate: (input)=>toUTF8String(input, 0, 4) === "8BPS",
    calculate: (input)=>({
            height: readUInt32BE(input, 14),
            width: readUInt32BE(input, 18)
        })
};
// lib/types/svg.ts
var svgReg = /<svg\s([^>"']|"[^"]*"|'[^']*')*>/;
var extractorRegExps = {
    height: /\sheight=(['"])([^%]+?)\1/,
    root: svgReg,
    viewbox: /\sviewBox=(['"])(.+?)\1/i,
    width: /\swidth=(['"])([^%]+?)\1/
};
var INCH_CM = 2.54;
var units = {
    in: 96,
    cm: 96 / INCH_CM,
    em: 16,
    ex: 8,
    m: 96 / INCH_CM * 100,
    mm: 96 / INCH_CM / 10,
    pc: 96 / 72 / 12,
    pt: 96 / 72,
    px: 1
};
var unitsReg = new RegExp(`^([0-9.]+(?:e\\d+)?)(${Object.keys(units).join("|")})?$`);
function parseLength(len) {
    const m = unitsReg.exec(len);
    if (!m) {
        return void 0;
    }
    return Math.round(Number(m[1]) * (units[m[2]] || 1));
}
function parseViewbox(viewbox) {
    const bounds = viewbox.split(" ");
    return {
        height: parseLength(bounds[3]),
        width: parseLength(bounds[2])
    };
}
function parseAttributes(root) {
    const width = root.match(extractorRegExps.width);
    const height = root.match(extractorRegExps.height);
    const viewbox = root.match(extractorRegExps.viewbox);
    return {
        height: height && parseLength(height[2]),
        viewbox: viewbox && parseViewbox(viewbox[2]),
        width: width && parseLength(width[2])
    };
}
function calculateByDimensions(attrs) {
    return {
        height: attrs.height,
        width: attrs.width
    };
}
function calculateByViewbox(attrs, viewbox) {
    const ratio = viewbox.width / viewbox.height;
    if (attrs.width) {
        return {
            height: Math.floor(attrs.width / ratio),
            width: attrs.width
        };
    }
    if (attrs.height) {
        return {
            height: attrs.height,
            width: Math.floor(attrs.height * ratio)
        };
    }
    return {
        height: viewbox.height,
        width: viewbox.width
    };
}
var SVG = {
    // Scan only the first kilo-byte to speed up the check on larger files
    validate: (input)=>svgReg.test(toUTF8String(input, 0, 1e3)),
    calculate (input) {
        const root = toUTF8String(input).match(extractorRegExps.root);
        if (root) {
            const attrs = parseAttributes(root[0]);
            if (attrs.width && attrs.height) {
                return calculateByDimensions(attrs);
            }
            if (attrs.viewbox) {
                return calculateByViewbox(attrs, attrs.viewbox);
            }
        }
        throw new TypeError("Invalid SVG");
    }
};
// lib/types/tga.ts
var TGA = {
    validate (input) {
        return readUInt16LE(input, 0) === 0 && readUInt16LE(input, 4) === 0;
    },
    calculate (input) {
        return {
            height: readUInt16LE(input, 14),
            width: readUInt16LE(input, 12)
        };
    }
};
// lib/types/tiff.ts
var CONSTANTS = {
    TAG: {
        WIDTH: 256,
        HEIGHT: 257,
        COMPRESSION: 259
    },
    TYPE: {
        SHORT: 3,
        LONG: 4,
        LONG8: 16
    },
    ENTRY_SIZE: {
        STANDARD: 12,
        BIG: 20
    },
    COUNT_SIZE: {
        STANDARD: 2,
        BIG: 8
    }
};
function readIFD(input, { isBigEndian, isBigTiff }) {
    const ifdOffset = isBigTiff ? Number(readUInt64(input, 8, isBigEndian)) : readUInt(input, 32, 4, isBigEndian);
    const entryCountSize = isBigTiff ? CONSTANTS.COUNT_SIZE.BIG : CONSTANTS.COUNT_SIZE.STANDARD;
    return input.slice(ifdOffset + entryCountSize);
}
function readTagValue(input, type, offset, isBigEndian) {
    switch(type){
        case CONSTANTS.TYPE.SHORT:
            return readUInt(input, 16, offset, isBigEndian);
        case CONSTANTS.TYPE.LONG:
            return readUInt(input, 32, offset, isBigEndian);
        case CONSTANTS.TYPE.LONG8:
            {
                const value = Number(readUInt64(input, offset, isBigEndian));
                if (value > Number.MAX_SAFE_INTEGER) {
                    throw new TypeError("Value too large");
                }
                return value;
            }
        default:
            return 0;
    }
}
function nextTag(input, isBigTiff) {
    const entrySize = isBigTiff ? CONSTANTS.ENTRY_SIZE.BIG : CONSTANTS.ENTRY_SIZE.STANDARD;
    if (input.length > entrySize) {
        return input.slice(entrySize);
    }
}
function extractTags(input, { isBigEndian, isBigTiff }) {
    const tags = {};
    let temp = input;
    while(temp?.length){
        const code = readUInt(temp, 16, 0, isBigEndian);
        const type = readUInt(temp, 16, 2, isBigEndian);
        const length = isBigTiff ? Number(readUInt64(temp, 4, isBigEndian)) : readUInt(temp, 32, 4, isBigEndian);
        if (code === 0) break;
        if (length === 1 && (type === CONSTANTS.TYPE.SHORT || type === CONSTANTS.TYPE.LONG || isBigTiff && type === CONSTANTS.TYPE.LONG8)) {
            const valueOffset = isBigTiff ? 12 : 8;
            tags[code] = readTagValue(temp, type, valueOffset, isBigEndian);
        }
        temp = nextTag(temp, isBigTiff);
    }
    return tags;
}
function determineFormat(input) {
    const signature = toUTF8String(input, 0, 2);
    const version = readUInt(input, 16, 2, signature === "MM");
    return {
        isBigEndian: signature === "MM",
        isBigTiff: version === 43
    };
}
function validateBigTIFFHeader(input, isBigEndian) {
    const byteSize = readUInt(input, 16, 4, isBigEndian);
    const reserved = readUInt(input, 16, 6, isBigEndian);
    if (byteSize !== 8 || reserved !== 0) {
        throw new TypeError("Invalid BigTIFF header");
    }
}
var signatures = /* @__PURE__ */ new Set([
    "49492a00",
    // Little Endian
    "4d4d002a",
    // Big Endian
    "49492b00",
    // BigTIFF Little Endian
    "4d4d002b"
]);
var TIFF = {
    validate: (input)=>{
        const signature = toHexString(input, 0, 4);
        return signatures.has(signature);
    },
    calculate (input) {
        const format = determineFormat(input);
        if (format.isBigTiff) {
            validateBigTIFFHeader(input, format.isBigEndian);
        }
        const ifdBuffer = readIFD(input, format);
        const tags = extractTags(ifdBuffer, format);
        const info = {
            height: tags[CONSTANTS.TAG.HEIGHT],
            width: tags[CONSTANTS.TAG.WIDTH],
            type: format.isBigTiff ? "bigtiff" : "tiff"
        };
        if (tags[CONSTANTS.TAG.COMPRESSION]) {
            info.compression = tags[CONSTANTS.TAG.COMPRESSION];
        }
        if (!info.width || !info.height) {
            throw new TypeError("Invalid Tiff. Missing tags");
        }
        return info;
    }
};
// lib/types/webp.ts
function calculateExtended(input) {
    return {
        height: 1 + readUInt24LE(input, 7),
        width: 1 + readUInt24LE(input, 4)
    };
}
function calculateLossless(input) {
    return {
        height: 1 + ((input[4] & 15) << 10 | input[3] << 2 | (input[2] & 192) >> 6),
        width: 1 + ((input[2] & 63) << 8 | input[1])
    };
}
function calculateLossy(input) {
    return {
        height: readInt16LE(input, 8) & 16383,
        width: readInt16LE(input, 6) & 16383
    };
}
var WEBP = {
    validate (input) {
        const riffHeader = "RIFF" === toUTF8String(input, 0, 4);
        const webpHeader = "WEBP" === toUTF8String(input, 8, 12);
        const vp8Header = "VP8" === toUTF8String(input, 12, 15);
        return riffHeader && webpHeader && vp8Header;
    },
    calculate (_input) {
        const chunkHeader = toUTF8String(_input, 12, 16);
        const input = _input.slice(20, 30);
        if (chunkHeader === "VP8X") {
            const extendedHeader = input[0];
            const validStart = (extendedHeader & 192) === 0;
            const validEnd = (extendedHeader & 1) === 0;
            if (validStart && validEnd) {
                return calculateExtended(input);
            }
            throw new TypeError("Invalid WebP");
        }
        if (chunkHeader === "VP8 " && input[0] !== 47) {
            return calculateLossy(input);
        }
        const signature = toHexString(input, 3, 6);
        if (chunkHeader === "VP8L" && signature !== "9d012a") {
            return calculateLossless(input);
        }
        throw new TypeError("Invalid WebP");
    }
};
// lib/types/index.ts
var typeHandlers = /* @__PURE__ */ new Map([
    [
        "bmp",
        BMP
    ],
    [
        "cur",
        CUR
    ],
    [
        "dds",
        DDS
    ],
    [
        "gif",
        GIF
    ],
    [
        "heif",
        HEIF
    ],
    [
        "icns",
        ICNS
    ],
    [
        "ico",
        ICO
    ],
    [
        "j2c",
        J2C
    ],
    [
        "jp2",
        JP2
    ],
    [
        "jpg",
        JPG
    ],
    [
        "jxl",
        JXL
    ],
    [
        "jxl-stream",
        JXLStream
    ],
    [
        "ktx",
        KTX
    ],
    [
        "png",
        PNG
    ],
    [
        "pnm",
        PNM
    ],
    [
        "psd",
        PSD
    ],
    [
        "svg",
        SVG
    ],
    [
        "tga",
        TGA
    ],
    [
        "tiff",
        TIFF
    ],
    [
        "webp",
        WEBP
    ]
]);
var types = Array.from(typeHandlers.keys());
// lib/detector.ts
var firstBytes = /* @__PURE__ */ new Map([
    [
        0,
        "heif"
    ],
    [
        56,
        "psd"
    ],
    [
        66,
        "bmp"
    ],
    [
        68,
        "dds"
    ],
    [
        71,
        "gif"
    ],
    [
        73,
        "tiff"
    ],
    [
        77,
        "tiff"
    ],
    [
        82,
        "webp"
    ],
    [
        105,
        "icns"
    ],
    [
        137,
        "png"
    ],
    [
        255,
        "jpg"
    ]
]);
function detector(input) {
    const byte = input[0];
    const type = firstBytes.get(byte);
    if (type && typeHandlers.get(type).validate(input)) {
        return type;
    }
    return types.find((type2)=>typeHandlers.get(type2).validate(input));
}
// lib/lookup.ts
var globalOptions = {
    disabledTypes: []
};
function imageSize(input) {
    const type = detector(input);
    if (typeof type !== "undefined") {
        if (globalOptions.disabledTypes.indexOf(type) > -1) {
            throw new TypeError(`disabled file type: ${type}`);
        }
        const size = typeHandlers.get(type).calculate(input);
        if (size !== void 0) {
            size.type = size.type ?? type;
            if (size.images && size.images.length > 1) {
                const largestImage = size.images.reduce((largest, current)=>{
                    return current.width * current.height > largest.width * largest.height ? current : largest;
                }, size.images[0]);
                size.width = largestImage.width;
                size.height = largestImage.height;
            }
            return size;
        }
    }
    throw new TypeError(`unsupported file type: ${type}`);
}
var disableTypes = (types2)=>{
    globalOptions.disabledTypes = types2;
};
;
}),
"[project]/node_modules/.pnpm/image-size@2.0.2/node_modules/image-size/dist/fromFile.mjs [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "imageSizeFromFile",
    ()=>imageSizeFromFile,
    "setConcurrency",
    ()=>setConcurrency
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
;
;
// lib/fromFile.ts
// lib/types/utils.ts
var decoder = new TextDecoder();
var toUTF8String = (input, start = 0, end = input.length)=>decoder.decode(input.slice(start, end));
var toHexString = (input, start = 0, end = input.length)=>input.slice(start, end).reduce((memo, i)=>memo + `0${i.toString(16)}`.slice(-2), "");
var getView = (input, offset)=>new DataView(input.buffer, input.byteOffset + offset);
var readInt16LE = (input, offset = 0)=>getView(input, offset).getInt16(0, true);
var readUInt16BE = (input, offset = 0)=>getView(input, offset).getUint16(0, false);
var readUInt16LE = (input, offset = 0)=>getView(input, offset).getUint16(0, true);
var readUInt24LE = (input, offset = 0)=>{
    const view = getView(input, offset);
    return view.getUint16(0, true) + (view.getUint8(2) << 16);
};
var readInt32LE = (input, offset = 0)=>getView(input, offset).getInt32(0, true);
var readUInt32BE = (input, offset = 0)=>getView(input, offset).getUint32(0, false);
var readUInt32LE = (input, offset = 0)=>getView(input, offset).getUint32(0, true);
var readUInt64 = (input, offset, isBigEndian)=>getView(input, offset).getBigUint64(0, !isBigEndian);
var methods = {
    readUInt16BE,
    readUInt16LE,
    readUInt32BE,
    readUInt32LE
};
function readUInt(input, bits, offset = 0, isBigEndian = false) {
    const endian = isBigEndian ? "BE" : "LE";
    const methodName = `readUInt${bits}${endian}`;
    return methods[methodName](input, offset);
}
function readBox(input, offset) {
    if (input.length - offset < 4) return;
    const boxSize = readUInt32BE(input, offset);
    if (input.length - offset < boxSize) return;
    return {
        name: toUTF8String(input, 4 + offset, 8 + offset),
        offset,
        size: boxSize
    };
}
function findBox(input, boxName, currentOffset) {
    while(currentOffset < input.length){
        const box = readBox(input, currentOffset);
        if (!box) break;
        if (box.name === boxName) return box;
        currentOffset += box.size > 0 ? box.size : 8;
    }
}
// lib/types/bmp.ts
var BMP = {
    validate: (input)=>toUTF8String(input, 0, 2) === "BM",
    calculate: (input)=>({
            height: Math.abs(readInt32LE(input, 22)),
            width: readUInt32LE(input, 18)
        })
};
// lib/types/ico.ts
var TYPE_ICON = 1;
var SIZE_HEADER = 2 + 2 + 2;
var SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4;
function getSizeFromOffset(input, offset) {
    const value = input[offset];
    return value === 0 ? 256 : value;
}
function getImageSize(input, imageIndex) {
    const offset = SIZE_HEADER + imageIndex * SIZE_IMAGE_ENTRY;
    return {
        height: getSizeFromOffset(input, offset + 1),
        width: getSizeFromOffset(input, offset)
    };
}
var ICO = {
    validate (input) {
        const reserved = readUInt16LE(input, 0);
        const imageCount = readUInt16LE(input, 4);
        if (reserved !== 0 || imageCount === 0) return false;
        const imageType = readUInt16LE(input, 2);
        return imageType === TYPE_ICON;
    },
    calculate (input) {
        const nbImages = readUInt16LE(input, 4);
        const imageSize2 = getImageSize(input, 0);
        if (nbImages === 1) return imageSize2;
        const images = [];
        for(let imageIndex = 0; imageIndex < nbImages; imageIndex += 1){
            images.push(getImageSize(input, imageIndex));
        }
        return {
            width: imageSize2.width,
            height: imageSize2.height,
            images
        };
    }
};
// lib/types/cur.ts
var TYPE_CURSOR = 2;
var CUR = {
    validate (input) {
        const reserved = readUInt16LE(input, 0);
        const imageCount = readUInt16LE(input, 4);
        if (reserved !== 0 || imageCount === 0) return false;
        const imageType = readUInt16LE(input, 2);
        return imageType === TYPE_CURSOR;
    },
    calculate: (input)=>ICO.calculate(input)
};
// lib/types/dds.ts
var DDS = {
    validate: (input)=>readUInt32LE(input, 0) === 542327876,
    calculate: (input)=>({
            height: readUInt32LE(input, 12),
            width: readUInt32LE(input, 16)
        })
};
// lib/types/gif.ts
var gifRegexp = /^GIF8[79]a/;
var GIF = {
    validate: (input)=>gifRegexp.test(toUTF8String(input, 0, 6)),
    calculate: (input)=>({
            height: readUInt16LE(input, 8),
            width: readUInt16LE(input, 6)
        })
};
// lib/types/heif.ts
var brandMap = {
    avif: "avif",
    mif1: "heif",
    msf1: "heif",
    // heif-sequence
    heic: "heic",
    heix: "heic",
    hevc: "heic",
    // heic-sequence
    hevx: "heic"
};
var HEIF = {
    validate (input) {
        const boxType = toUTF8String(input, 4, 8);
        if (boxType !== "ftyp") return false;
        const ftypBox = findBox(input, "ftyp", 0);
        if (!ftypBox) return false;
        const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
        return brand in brandMap;
    },
    calculate (input) {
        const metaBox = findBox(input, "meta", 0);
        const iprpBox = metaBox && findBox(input, "iprp", metaBox.offset + 12);
        const ipcoBox = iprpBox && findBox(input, "ipco", iprpBox.offset + 8);
        if (!ipcoBox) {
            throw new TypeError("Invalid HEIF, no ipco box found");
        }
        const type = toUTF8String(input, 8, 12);
        const images = [];
        let currentOffset = ipcoBox.offset + 8;
        while(currentOffset < ipcoBox.offset + ipcoBox.size){
            const ispeBox = findBox(input, "ispe", currentOffset);
            if (!ispeBox) break;
            const rawWidth = readUInt32BE(input, ispeBox.offset + 12);
            const rawHeight = readUInt32BE(input, ispeBox.offset + 16);
            const clapBox = findBox(input, "clap", currentOffset);
            let width = rawWidth;
            let height = rawHeight;
            if (clapBox && clapBox.offset < ipcoBox.offset + ipcoBox.size) {
                const cropRight = readUInt32BE(input, clapBox.offset + 12);
                width = rawWidth - cropRight;
            }
            images.push({
                height,
                width
            });
            currentOffset = ispeBox.offset + ispeBox.size;
        }
        if (images.length === 0) {
            throw new TypeError("Invalid HEIF, no sizes found");
        }
        return {
            width: images[0].width,
            height: images[0].height,
            type,
            ...images.length > 1 ? {
                images
            } : {}
        };
    }
};
// lib/types/icns.ts
var SIZE_HEADER2 = 4 + 4;
var FILE_LENGTH_OFFSET = 4;
var ENTRY_LENGTH_OFFSET = 4;
var ICON_TYPE_SIZE = {
    ICON: 32,
    "ICN#": 32,
    // m => 16 x 16
    "icm#": 16,
    icm4: 16,
    icm8: 16,
    // s => 16 x 16
    "ics#": 16,
    ics4: 16,
    ics8: 16,
    is32: 16,
    s8mk: 16,
    icp4: 16,
    // l => 32 x 32
    icl4: 32,
    icl8: 32,
    il32: 32,
    l8mk: 32,
    icp5: 32,
    ic11: 32,
    // h => 48 x 48
    ich4: 48,
    ich8: 48,
    ih32: 48,
    h8mk: 48,
    // . => 64 x 64
    icp6: 64,
    ic12: 32,
    // t => 128 x 128
    it32: 128,
    t8mk: 128,
    ic07: 128,
    // . => 256 x 256
    ic08: 256,
    ic13: 256,
    // . => 512 x 512
    ic09: 512,
    ic14: 512,
    // . => 1024 x 1024
    ic10: 1024
};
function readImageHeader(input, imageOffset) {
    const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;
    return [
        toUTF8String(input, imageOffset, imageLengthOffset),
        readUInt32BE(input, imageLengthOffset)
    ];
}
function getImageSize2(type) {
    const size = ICON_TYPE_SIZE[type];
    return {
        width: size,
        height: size,
        type
    };
}
var ICNS = {
    validate: (input)=>toUTF8String(input, 0, 4) === "icns",
    calculate (input) {
        const inputLength = input.length;
        const fileLength = readUInt32BE(input, FILE_LENGTH_OFFSET);
        let imageOffset = SIZE_HEADER2;
        const images = [];
        while(imageOffset < fileLength && imageOffset < inputLength){
            const imageHeader = readImageHeader(input, imageOffset);
            const imageSize2 = getImageSize2(imageHeader[0]);
            images.push(imageSize2);
            imageOffset += imageHeader[1];
        }
        if (images.length === 0) {
            throw new TypeError("Invalid ICNS, no sizes found");
        }
        return {
            width: images[0].width,
            height: images[0].height,
            ...images.length > 1 ? {
                images
            } : {}
        };
    }
};
// lib/types/j2c.ts
var J2C = {
    // TODO: this doesn't seem right. SIZ marker doesn't have to be right after the SOC
    validate: (input)=>readUInt32BE(input, 0) === 4283432785,
    calculate: (input)=>({
            height: readUInt32BE(input, 12),
            width: readUInt32BE(input, 8)
        })
};
// lib/types/jp2.ts
var JP2 = {
    validate (input) {
        const boxType = toUTF8String(input, 4, 8);
        if (boxType !== "jP  ") return false;
        const ftypBox = findBox(input, "ftyp", 0);
        if (!ftypBox) return false;
        const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
        return brand === "jp2 ";
    },
    calculate (input) {
        const jp2hBox = findBox(input, "jp2h", 0);
        const ihdrBox = jp2hBox && findBox(input, "ihdr", jp2hBox.offset + 8);
        if (ihdrBox) {
            return {
                height: readUInt32BE(input, ihdrBox.offset + 8),
                width: readUInt32BE(input, ihdrBox.offset + 12)
            };
        }
        throw new TypeError("Unsupported JPEG 2000 format");
    }
};
// lib/types/jpg.ts
var EXIF_MARKER = "45786966";
var APP1_DATA_SIZE_BYTES = 2;
var EXIF_HEADER_BYTES = 6;
var TIFF_BYTE_ALIGN_BYTES = 2;
var BIG_ENDIAN_BYTE_ALIGN = "4d4d";
var LITTLE_ENDIAN_BYTE_ALIGN = "4949";
var IDF_ENTRY_BYTES = 12;
var NUM_DIRECTORY_ENTRIES_BYTES = 2;
function isEXIF(input) {
    return toHexString(input, 2, 6) === EXIF_MARKER;
}
function extractSize(input, index) {
    return {
        height: readUInt16BE(input, index),
        width: readUInt16BE(input, index + 2)
    };
}
function extractOrientation(exifBlock, isBigEndian) {
    const idfOffset = 8;
    const offset = EXIF_HEADER_BYTES + idfOffset;
    const idfDirectoryEntries = readUInt(exifBlock, 16, offset, isBigEndian);
    for(let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++){
        const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;
        const end = start + IDF_ENTRY_BYTES;
        if (start > exifBlock.length) {
            return;
        }
        const block = exifBlock.slice(start, end);
        const tagNumber = readUInt(block, 16, 0, isBigEndian);
        if (tagNumber === 274) {
            const dataFormat = readUInt(block, 16, 2, isBigEndian);
            if (dataFormat !== 3) {
                return;
            }
            const numberOfComponents = readUInt(block, 32, 4, isBigEndian);
            if (numberOfComponents !== 1) {
                return;
            }
            return readUInt(block, 16, 8, isBigEndian);
        }
    }
}
function validateExifBlock(input, index) {
    const exifBlock = input.slice(APP1_DATA_SIZE_BYTES, index);
    const byteAlign = toHexString(exifBlock, EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES);
    const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;
    const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;
    if (isBigEndian || isLittleEndian) {
        return extractOrientation(exifBlock, isBigEndian);
    }
}
function validateInput(input, index) {
    if (index > input.length) {
        throw new TypeError("Corrupt JPG, exceeded buffer limits");
    }
}
var JPG = {
    validate: (input)=>toHexString(input, 0, 2) === "ffd8",
    calculate (_input) {
        let input = _input.slice(4);
        let orientation;
        let next;
        while(input.length){
            const i = readUInt16BE(input, 0);
            validateInput(input, i);
            if (input[i] !== 255) {
                input = input.slice(1);
                continue;
            }
            if (isEXIF(input)) {
                orientation = validateExifBlock(input, i);
            }
            next = input[i + 1];
            if (next === 192 || next === 193 || next === 194) {
                const size = extractSize(input, i + 5);
                if (!orientation) {
                    return size;
                }
                return {
                    height: size.height,
                    orientation,
                    width: size.width
                };
            }
            input = input.slice(i + 2);
        }
        throw new TypeError("Invalid JPG, no size found");
    }
};
// lib/utils/bit-reader.ts
var BitReader = class {
    constructor(input, endianness){
        this.input = input;
        this.endianness = endianness;
        // Skip the first 16 bits (2 bytes) of signature
        this.byteOffset = 2;
        this.bitOffset = 0;
    }
    /** Reads a specified number of bits, and move the offset */ getBits(length = 1) {
        let result = 0;
        let bitsRead = 0;
        while(bitsRead < length){
            if (this.byteOffset >= this.input.length) {
                throw new Error("Reached end of input");
            }
            const currentByte = this.input[this.byteOffset];
            const bitsLeft = 8 - this.bitOffset;
            const bitsToRead = Math.min(length - bitsRead, bitsLeft);
            if (this.endianness === "little-endian") {
                const mask = (1 << bitsToRead) - 1;
                const bits = currentByte >> this.bitOffset & mask;
                result |= bits << bitsRead;
            } else {
                const mask = (1 << bitsToRead) - 1 << 8 - this.bitOffset - bitsToRead;
                const bits = (currentByte & mask) >> 8 - this.bitOffset - bitsToRead;
                result = result << bitsToRead | bits;
            }
            bitsRead += bitsToRead;
            this.bitOffset += bitsToRead;
            if (this.bitOffset === 8) {
                this.byteOffset++;
                this.bitOffset = 0;
            }
        }
        return result;
    }
};
// lib/types/jxl-stream.ts
function calculateImageDimension(reader, isSmallImage) {
    if (isSmallImage) {
        return 8 * (1 + reader.getBits(5));
    }
    const sizeClass = reader.getBits(2);
    const extraBits = [
        9,
        13,
        18,
        30
    ][sizeClass];
    return 1 + reader.getBits(extraBits);
}
function calculateImageWidth(reader, isSmallImage, widthMode, height) {
    if (isSmallImage && widthMode === 0) {
        return 8 * (1 + reader.getBits(5));
    }
    if (widthMode === 0) {
        return calculateImageDimension(reader, false);
    }
    const aspectRatios = [
        1,
        1.2,
        4 / 3,
        1.5,
        16 / 9,
        5 / 4,
        2
    ];
    return Math.floor(height * aspectRatios[widthMode - 1]);
}
var JXLStream = {
    validate: (input)=>{
        return toHexString(input, 0, 2) === "ff0a";
    },
    calculate (input) {
        const reader = new BitReader(input, "little-endian");
        const isSmallImage = reader.getBits(1) === 1;
        const height = calculateImageDimension(reader, isSmallImage);
        const widthMode = reader.getBits(3);
        const width = calculateImageWidth(reader, isSmallImage, widthMode, height);
        return {
            width,
            height
        };
    }
};
// lib/types/jxl.ts
function extractCodestream(input) {
    const jxlcBox = findBox(input, "jxlc", 0);
    if (jxlcBox) {
        return input.slice(jxlcBox.offset + 8, jxlcBox.offset + jxlcBox.size);
    }
    const partialStreams = extractPartialStreams(input);
    if (partialStreams.length > 0) {
        return concatenateCodestreams(partialStreams);
    }
    return void 0;
}
function extractPartialStreams(input) {
    const partialStreams = [];
    let offset = 0;
    while(offset < input.length){
        const jxlpBox = findBox(input, "jxlp", offset);
        if (!jxlpBox) break;
        partialStreams.push(input.slice(jxlpBox.offset + 12, jxlpBox.offset + jxlpBox.size));
        offset = jxlpBox.offset + jxlpBox.size;
    }
    return partialStreams;
}
function concatenateCodestreams(partialCodestreams) {
    const totalLength = partialCodestreams.reduce((acc, curr)=>acc + curr.length, 0);
    const codestream = new Uint8Array(totalLength);
    let position = 0;
    for (const partial of partialCodestreams){
        codestream.set(partial, position);
        position += partial.length;
    }
    return codestream;
}
var JXL = {
    validate: (input)=>{
        const boxType = toUTF8String(input, 4, 8);
        if (boxType !== "JXL ") return false;
        const ftypBox = findBox(input, "ftyp", 0);
        if (!ftypBox) return false;
        const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
        return brand === "jxl ";
    },
    calculate (input) {
        const codestream = extractCodestream(input);
        if (codestream) return JXLStream.calculate(codestream);
        throw new Error("No codestream found in JXL container");
    }
};
// lib/types/ktx.ts
var KTX = {
    validate: (input)=>{
        const signature = toUTF8String(input, 1, 7);
        return [
            "KTX 11",
            "KTX 20"
        ].includes(signature);
    },
    calculate: (input)=>{
        const type = input[5] === 49 ? "ktx" : "ktx2";
        const offset = type === "ktx" ? 36 : 20;
        return {
            height: readUInt32LE(input, offset + 4),
            width: readUInt32LE(input, offset),
            type
        };
    }
};
// lib/types/png.ts
var pngSignature = "PNG\r\n\n";
var pngImageHeaderChunkName = "IHDR";
var pngFriedChunkName = "CgBI";
var PNG = {
    validate (input) {
        if (pngSignature === toUTF8String(input, 1, 8)) {
            let chunkName = toUTF8String(input, 12, 16);
            if (chunkName === pngFriedChunkName) {
                chunkName = toUTF8String(input, 28, 32);
            }
            if (chunkName !== pngImageHeaderChunkName) {
                throw new TypeError("Invalid PNG");
            }
            return true;
        }
        return false;
    },
    calculate (input) {
        if (toUTF8String(input, 12, 16) === pngFriedChunkName) {
            return {
                height: readUInt32BE(input, 36),
                width: readUInt32BE(input, 32)
            };
        }
        return {
            height: readUInt32BE(input, 20),
            width: readUInt32BE(input, 16)
        };
    }
};
// lib/types/pnm.ts
var PNMTypes = {
    P1: "pbm/ascii",
    P2: "pgm/ascii",
    P3: "ppm/ascii",
    P4: "pbm",
    P5: "pgm",
    P6: "ppm",
    P7: "pam",
    PF: "pfm"
};
var handlers = {
    default: (lines)=>{
        let dimensions = [];
        while(lines.length > 0){
            const line = lines.shift();
            if (line[0] === "#") {
                continue;
            }
            dimensions = line.split(" ");
            break;
        }
        if (dimensions.length === 2) {
            return {
                height: Number.parseInt(dimensions[1], 10),
                width: Number.parseInt(dimensions[0], 10)
            };
        }
        throw new TypeError("Invalid PNM");
    },
    pam: (lines)=>{
        const size = {};
        while(lines.length > 0){
            const line = lines.shift();
            if (line.length > 16 || line.charCodeAt(0) > 128) {
                continue;
            }
            const [key, value] = line.split(" ");
            if (key && value) {
                size[key.toLowerCase()] = Number.parseInt(value, 10);
            }
            if (size.height && size.width) {
                break;
            }
        }
        if (size.height && size.width) {
            return {
                height: size.height,
                width: size.width
            };
        }
        throw new TypeError("Invalid PAM");
    }
};
var PNM = {
    validate: (input)=>toUTF8String(input, 0, 2) in PNMTypes,
    calculate (input) {
        const signature = toUTF8String(input, 0, 2);
        const type = PNMTypes[signature];
        const lines = toUTF8String(input, 3).split(/[\r\n]+/);
        const handler = handlers[type] || handlers.default;
        return handler(lines);
    }
};
// lib/types/psd.ts
var PSD = {
    validate: (input)=>toUTF8String(input, 0, 4) === "8BPS",
    calculate: (input)=>({
            height: readUInt32BE(input, 14),
            width: readUInt32BE(input, 18)
        })
};
// lib/types/svg.ts
var svgReg = /<svg\s([^>"']|"[^"]*"|'[^']*')*>/;
var extractorRegExps = {
    height: /\sheight=(['"])([^%]+?)\1/,
    root: svgReg,
    viewbox: /\sviewBox=(['"])(.+?)\1/i,
    width: /\swidth=(['"])([^%]+?)\1/
};
var INCH_CM = 2.54;
var units = {
    in: 96,
    cm: 96 / INCH_CM,
    em: 16,
    ex: 8,
    m: 96 / INCH_CM * 100,
    mm: 96 / INCH_CM / 10,
    pc: 96 / 72 / 12,
    pt: 96 / 72,
    px: 1
};
var unitsReg = new RegExp(`^([0-9.]+(?:e\\d+)?)(${Object.keys(units).join("|")})?$`);
function parseLength(len) {
    const m = unitsReg.exec(len);
    if (!m) {
        return void 0;
    }
    return Math.round(Number(m[1]) * (units[m[2]] || 1));
}
function parseViewbox(viewbox) {
    const bounds = viewbox.split(" ");
    return {
        height: parseLength(bounds[3]),
        width: parseLength(bounds[2])
    };
}
function parseAttributes(root) {
    const width = root.match(extractorRegExps.width);
    const height = root.match(extractorRegExps.height);
    const viewbox = root.match(extractorRegExps.viewbox);
    return {
        height: height && parseLength(height[2]),
        viewbox: viewbox && parseViewbox(viewbox[2]),
        width: width && parseLength(width[2])
    };
}
function calculateByDimensions(attrs) {
    return {
        height: attrs.height,
        width: attrs.width
    };
}
function calculateByViewbox(attrs, viewbox) {
    const ratio = viewbox.width / viewbox.height;
    if (attrs.width) {
        return {
            height: Math.floor(attrs.width / ratio),
            width: attrs.width
        };
    }
    if (attrs.height) {
        return {
            height: attrs.height,
            width: Math.floor(attrs.height * ratio)
        };
    }
    return {
        height: viewbox.height,
        width: viewbox.width
    };
}
var SVG = {
    // Scan only the first kilo-byte to speed up the check on larger files
    validate: (input)=>svgReg.test(toUTF8String(input, 0, 1e3)),
    calculate (input) {
        const root = toUTF8String(input).match(extractorRegExps.root);
        if (root) {
            const attrs = parseAttributes(root[0]);
            if (attrs.width && attrs.height) {
                return calculateByDimensions(attrs);
            }
            if (attrs.viewbox) {
                return calculateByViewbox(attrs, attrs.viewbox);
            }
        }
        throw new TypeError("Invalid SVG");
    }
};
// lib/types/tga.ts
var TGA = {
    validate (input) {
        return readUInt16LE(input, 0) === 0 && readUInt16LE(input, 4) === 0;
    },
    calculate (input) {
        return {
            height: readUInt16LE(input, 14),
            width: readUInt16LE(input, 12)
        };
    }
};
// lib/types/tiff.ts
var CONSTANTS = {
    TAG: {
        WIDTH: 256,
        HEIGHT: 257,
        COMPRESSION: 259
    },
    TYPE: {
        SHORT: 3,
        LONG: 4,
        LONG8: 16
    },
    ENTRY_SIZE: {
        STANDARD: 12,
        BIG: 20
    },
    COUNT_SIZE: {
        STANDARD: 2,
        BIG: 8
    }
};
function readIFD(input, { isBigEndian, isBigTiff }) {
    const ifdOffset = isBigTiff ? Number(readUInt64(input, 8, isBigEndian)) : readUInt(input, 32, 4, isBigEndian);
    const entryCountSize = isBigTiff ? CONSTANTS.COUNT_SIZE.BIG : CONSTANTS.COUNT_SIZE.STANDARD;
    return input.slice(ifdOffset + entryCountSize);
}
function readTagValue(input, type, offset, isBigEndian) {
    switch(type){
        case CONSTANTS.TYPE.SHORT:
            return readUInt(input, 16, offset, isBigEndian);
        case CONSTANTS.TYPE.LONG:
            return readUInt(input, 32, offset, isBigEndian);
        case CONSTANTS.TYPE.LONG8:
            {
                const value = Number(readUInt64(input, offset, isBigEndian));
                if (value > Number.MAX_SAFE_INTEGER) {
                    throw new TypeError("Value too large");
                }
                return value;
            }
        default:
            return 0;
    }
}
function nextTag(input, isBigTiff) {
    const entrySize = isBigTiff ? CONSTANTS.ENTRY_SIZE.BIG : CONSTANTS.ENTRY_SIZE.STANDARD;
    if (input.length > entrySize) {
        return input.slice(entrySize);
    }
}
function extractTags(input, { isBigEndian, isBigTiff }) {
    const tags = {};
    let temp = input;
    while(temp?.length){
        const code = readUInt(temp, 16, 0, isBigEndian);
        const type = readUInt(temp, 16, 2, isBigEndian);
        const length = isBigTiff ? Number(readUInt64(temp, 4, isBigEndian)) : readUInt(temp, 32, 4, isBigEndian);
        if (code === 0) break;
        if (length === 1 && (type === CONSTANTS.TYPE.SHORT || type === CONSTANTS.TYPE.LONG || isBigTiff && type === CONSTANTS.TYPE.LONG8)) {
            const valueOffset = isBigTiff ? 12 : 8;
            tags[code] = readTagValue(temp, type, valueOffset, isBigEndian);
        }
        temp = nextTag(temp, isBigTiff);
    }
    return tags;
}
function determineFormat(input) {
    const signature = toUTF8String(input, 0, 2);
    const version = readUInt(input, 16, 2, signature === "MM");
    return {
        isBigEndian: signature === "MM",
        isBigTiff: version === 43
    };
}
function validateBigTIFFHeader(input, isBigEndian) {
    const byteSize = readUInt(input, 16, 4, isBigEndian);
    const reserved = readUInt(input, 16, 6, isBigEndian);
    if (byteSize !== 8 || reserved !== 0) {
        throw new TypeError("Invalid BigTIFF header");
    }
}
var signatures = /* @__PURE__ */ new Set([
    "49492a00",
    // Little Endian
    "4d4d002a",
    // Big Endian
    "49492b00",
    // BigTIFF Little Endian
    "4d4d002b"
]);
var TIFF = {
    validate: (input)=>{
        const signature = toHexString(input, 0, 4);
        return signatures.has(signature);
    },
    calculate (input) {
        const format = determineFormat(input);
        if (format.isBigTiff) {
            validateBigTIFFHeader(input, format.isBigEndian);
        }
        const ifdBuffer = readIFD(input, format);
        const tags = extractTags(ifdBuffer, format);
        const info = {
            height: tags[CONSTANTS.TAG.HEIGHT],
            width: tags[CONSTANTS.TAG.WIDTH],
            type: format.isBigTiff ? "bigtiff" : "tiff"
        };
        if (tags[CONSTANTS.TAG.COMPRESSION]) {
            info.compression = tags[CONSTANTS.TAG.COMPRESSION];
        }
        if (!info.width || !info.height) {
            throw new TypeError("Invalid Tiff. Missing tags");
        }
        return info;
    }
};
// lib/types/webp.ts
function calculateExtended(input) {
    return {
        height: 1 + readUInt24LE(input, 7),
        width: 1 + readUInt24LE(input, 4)
    };
}
function calculateLossless(input) {
    return {
        height: 1 + ((input[4] & 15) << 10 | input[3] << 2 | (input[2] & 192) >> 6),
        width: 1 + ((input[2] & 63) << 8 | input[1])
    };
}
function calculateLossy(input) {
    return {
        height: readInt16LE(input, 8) & 16383,
        width: readInt16LE(input, 6) & 16383
    };
}
var WEBP = {
    validate (input) {
        const riffHeader = "RIFF" === toUTF8String(input, 0, 4);
        const webpHeader = "WEBP" === toUTF8String(input, 8, 12);
        const vp8Header = "VP8" === toUTF8String(input, 12, 15);
        return riffHeader && webpHeader && vp8Header;
    },
    calculate (_input) {
        const chunkHeader = toUTF8String(_input, 12, 16);
        const input = _input.slice(20, 30);
        if (chunkHeader === "VP8X") {
            const extendedHeader = input[0];
            const validStart = (extendedHeader & 192) === 0;
            const validEnd = (extendedHeader & 1) === 0;
            if (validStart && validEnd) {
                return calculateExtended(input);
            }
            throw new TypeError("Invalid WebP");
        }
        if (chunkHeader === "VP8 " && input[0] !== 47) {
            return calculateLossy(input);
        }
        const signature = toHexString(input, 3, 6);
        if (chunkHeader === "VP8L" && signature !== "9d012a") {
            return calculateLossless(input);
        }
        throw new TypeError("Invalid WebP");
    }
};
// lib/types/index.ts
var typeHandlers = /* @__PURE__ */ new Map([
    [
        "bmp",
        BMP
    ],
    [
        "cur",
        CUR
    ],
    [
        "dds",
        DDS
    ],
    [
        "gif",
        GIF
    ],
    [
        "heif",
        HEIF
    ],
    [
        "icns",
        ICNS
    ],
    [
        "ico",
        ICO
    ],
    [
        "j2c",
        J2C
    ],
    [
        "jp2",
        JP2
    ],
    [
        "jpg",
        JPG
    ],
    [
        "jxl",
        JXL
    ],
    [
        "jxl-stream",
        JXLStream
    ],
    [
        "ktx",
        KTX
    ],
    [
        "png",
        PNG
    ],
    [
        "pnm",
        PNM
    ],
    [
        "psd",
        PSD
    ],
    [
        "svg",
        SVG
    ],
    [
        "tga",
        TGA
    ],
    [
        "tiff",
        TIFF
    ],
    [
        "webp",
        WEBP
    ]
]);
var types = Array.from(typeHandlers.keys());
// lib/detector.ts
var firstBytes = /* @__PURE__ */ new Map([
    [
        0,
        "heif"
    ],
    [
        56,
        "psd"
    ],
    [
        66,
        "bmp"
    ],
    [
        68,
        "dds"
    ],
    [
        71,
        "gif"
    ],
    [
        73,
        "tiff"
    ],
    [
        77,
        "tiff"
    ],
    [
        82,
        "webp"
    ],
    [
        105,
        "icns"
    ],
    [
        137,
        "png"
    ],
    [
        255,
        "jpg"
    ]
]);
function detector(input) {
    const byte = input[0];
    const type = firstBytes.get(byte);
    if (type && typeHandlers.get(type).validate(input)) {
        return type;
    }
    return types.find((type2)=>typeHandlers.get(type2).validate(input));
}
// lib/lookup.ts
var globalOptions = {
    disabledTypes: []
};
function imageSize(input) {
    const type = detector(input);
    if (typeof type !== "undefined") {
        if (globalOptions.disabledTypes.indexOf(type) > -1) {
            throw new TypeError(`disabled file type: ${type}`);
        }
        const size = typeHandlers.get(type).calculate(input);
        if (size !== void 0) {
            size.type = size.type ?? type;
            if (size.images && size.images.length > 1) {
                const largestImage = size.images.reduce((largest, current)=>{
                    return current.width * current.height > largest.width * largest.height ? current : largest;
                }, size.images[0]);
                size.width = largestImage.width;
                size.height = largestImage.height;
            }
            return size;
        }
    }
    throw new TypeError(`unsupported file type: ${type}`);
}
// lib/fromFile.ts
var MaxInputSize = 512 * 1024;
var queue = [];
var concurrency = 100;
var setConcurrency = (c)=>{
    concurrency = c;
};
var processQueue = async ()=>{
    const jobs = queue.splice(0, concurrency);
    const promises2 = jobs.map(async ({ filePath, resolve: resolve2, reject })=>{
        let handle;
        try {
            handle = await __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["promises"].open(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["resolve"](filePath), "r");
        } catch (err) {
            return reject(err);
        }
        try {
            const { size } = await handle.stat();
            if (size <= 0) {
                throw new Error("Empty file");
            }
            const inputSize = Math.min(size, MaxInputSize);
            const input = new Uint8Array(inputSize);
            await handle.read(input, 0, inputSize, 0);
            resolve2(imageSize(input));
        } catch (err) {
            reject(err);
        } finally{
            await handle.close();
        }
    });
    await Promise.allSettled(promises2);
    if (queue.length) setTimeout(processQueue, 100);
};
var imageSizeFromFile = async (filePath)=>new Promise((resolve2, reject)=>{
        queue.push({
            filePath,
            resolve: resolve2,
            reject
        });
        processQueue();
    });
;
}),
"[project]/node_modules/.pnpm/croner@9.1.0/node_modules/croner/dist/croner.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Cron",
    ()=>R,
    "CronDate",
    ()=>f,
    "CronPattern",
    ()=>d,
    "scheduledJobs",
    ()=>y
]);
function h(n, t, e, r, s, i, a, l) {
    return h.fromTZ(h.tp(n, t, e, r, s, i, a), l);
}
h.fromTZISO = (n, t, e)=>h.fromTZ(k(n, t), e);
h.fromTZ = function(n, t) {
    let e = new Date(Date.UTC(n.y, n.m - 1, n.d, n.h, n.i, n.s)), r = D(n.tz, e), s = new Date(e.getTime() - r), i = D(n.tz, s);
    if (i - r === 0) return s;
    {
        let a = new Date(e.getTime() - i), l = D(n.tz, a);
        if (l - i === 0) return a;
        if (!t && l - i > 0) return a;
        if (t) throw new Error("Invalid date passed to fromTZ()");
        return s;
    }
};
h.toTZ = function(n, t) {
    let e = n.toLocaleString("en-US", {
        timeZone: t
    }).replace(/[\u202f]/, " "), r = new Date(e);
    return {
        y: r.getFullYear(),
        m: r.getMonth() + 1,
        d: r.getDate(),
        h: r.getHours(),
        i: r.getMinutes(),
        s: r.getSeconds(),
        tz: t
    };
};
h.tp = (n, t, e, r, s, i, a)=>({
        y: n,
        m: t,
        d: e,
        h: r,
        i: s,
        s: i,
        tz: a
    });
function D(n, t = new Date) {
    let e = t.toLocaleString("en-US", {
        timeZone: n,
        timeZoneName: "shortOffset"
    }).split(" ").slice(-1)[0], r = t.toLocaleString("en-US").replace(/[\u202f]/, " ");
    return Date.parse(`${r} GMT`) - Date.parse(`${r} ${e}`);
}
function k(n, t) {
    let e = new Date(Date.parse(n));
    if (isNaN(e)) throw new Error("minitz: Invalid ISO8601 passed to parser.");
    let r = n.substring(9);
    return n.includes("Z") || r.includes("-") || r.includes("+") ? h.tp(e.getUTCFullYear(), e.getUTCMonth() + 1, e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds(), "Etc/UTC") : h.tp(e.getFullYear(), e.getMonth() + 1, e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), t);
}
h.minitz = h;
var b = 32, p = 31 | b, v = [
    1,
    2,
    4,
    8,
    16
], d = class {
    pattern;
    timezone;
    second;
    minute;
    hour;
    day;
    month;
    dayOfWeek;
    lastDayOfMonth;
    starDOM;
    starDOW;
    constructor(t, e){
        this.pattern = t, this.timezone = e, this.second = Array(60).fill(0), this.minute = Array(60).fill(0), this.hour = Array(24).fill(0), this.day = Array(31).fill(0), this.month = Array(12).fill(0), this.dayOfWeek = Array(7).fill(0), this.lastDayOfMonth = !1, this.starDOM = !1, this.starDOW = !1, this.parse();
    }
    parse() {
        if (!(typeof this.pattern == "string" || this.pattern instanceof String)) throw new TypeError("CronPattern: Pattern has to be of type string.");
        this.pattern.indexOf("@") >= 0 && (this.pattern = this.handleNicknames(this.pattern).trim());
        let t = this.pattern.replace(/\s+/g, " ").split(" ");
        if (t.length < 5 || t.length > 6) throw new TypeError("CronPattern: invalid configuration format ('" + this.pattern + "'), exactly five or six space separated parts are required.");
        if (t.length === 5 && t.unshift("0"), t[3].indexOf("L") >= 0 && (t[3] = t[3].replace("L", ""), this.lastDayOfMonth = !0), t[3] == "*" && (this.starDOM = !0), t[4].length >= 3 && (t[4] = this.replaceAlphaMonths(t[4])), t[5].length >= 3 && (t[5] = this.replaceAlphaDays(t[5])), t[5] == "*" && (this.starDOW = !0), this.pattern.indexOf("?") >= 0) {
            let e = new f(new Date, this.timezone).getDate(!0);
            t[0] = t[0].replace("?", e.getSeconds().toString()), t[1] = t[1].replace("?", e.getMinutes().toString()), t[2] = t[2].replace("?", e.getHours().toString()), this.starDOM || (t[3] = t[3].replace("?", e.getDate().toString())), t[4] = t[4].replace("?", (e.getMonth() + 1).toString()), this.starDOW || (t[5] = t[5].replace("?", e.getDay().toString()));
        }
        this.throwAtIllegalCharacters(t), this.partToArray("second", t[0], 0, 1), this.partToArray("minute", t[1], 0, 1), this.partToArray("hour", t[2], 0, 1), this.partToArray("day", t[3], -1, 1), this.partToArray("month", t[4], -1, 1), this.partToArray("dayOfWeek", t[5], 0, p), this.dayOfWeek[7] && (this.dayOfWeek[0] = this.dayOfWeek[7]);
    }
    partToArray(t, e, r, s) {
        let i = this[t], a = t === "day" && this.lastDayOfMonth;
        if (e === "" && !a) throw new TypeError("CronPattern: configuration entry " + t + " (" + e + ") is empty, check for trailing spaces.");
        if (e === "*") return i.fill(s);
        let l = e.split(",");
        if (l.length > 1) for(let o = 0; o < l.length; o++)this.partToArray(t, l[o], r, s);
        else e.indexOf("-") !== -1 && e.indexOf("/") !== -1 ? this.handleRangeWithStepping(e, t, r, s) : e.indexOf("-") !== -1 ? this.handleRange(e, t, r, s) : e.indexOf("/") !== -1 ? this.handleStepping(e, t, r, s) : e !== "" && this.handleNumber(e, t, r, s);
    }
    throwAtIllegalCharacters(t) {
        for(let e = 0; e < t.length; e++)if ((e === 5 ? /[^/*0-9,\-#L]+/ : /[^/*0-9,-]+/).test(t[e])) throw new TypeError("CronPattern: configuration entry " + e + " (" + t[e] + ") contains illegal characters.");
    }
    handleNumber(t, e, r, s) {
        let i = this.extractNth(t, e), a = parseInt(i[0], 10) + r;
        if (isNaN(a)) throw new TypeError("CronPattern: " + e + " is not a number: '" + t + "'");
        this.setPart(e, a, i[1] || s);
    }
    setPart(t, e, r) {
        if (!Object.prototype.hasOwnProperty.call(this, t)) throw new TypeError("CronPattern: Invalid part specified: " + t);
        if (t === "dayOfWeek") {
            if (e === 7 && (e = 0), e < 0 || e > 6) throw new RangeError("CronPattern: Invalid value for dayOfWeek: " + e);
            this.setNthWeekdayOfMonth(e, r);
            return;
        }
        if (t === "second" || t === "minute") {
            if (e < 0 || e >= 60) throw new RangeError("CronPattern: Invalid value for " + t + ": " + e);
        } else if (t === "hour") {
            if (e < 0 || e >= 24) throw new RangeError("CronPattern: Invalid value for " + t + ": " + e);
        } else if (t === "day") {
            if (e < 0 || e >= 31) throw new RangeError("CronPattern: Invalid value for " + t + ": " + e);
        } else if (t === "month" && (e < 0 || e >= 12)) throw new RangeError("CronPattern: Invalid value for " + t + ": " + e);
        this[t][e] = r;
    }
    handleRangeWithStepping(t, e, r, s) {
        let i = this.extractNth(t, e), a = i[0].match(/^(\d+)-(\d+)\/(\d+)$/);
        if (a === null) throw new TypeError("CronPattern: Syntax error, illegal range with stepping: '" + t + "'");
        let [, l, o, u] = a, c = parseInt(l, 10) + r, w = parseInt(o, 10) + r, C = parseInt(u, 10);
        if (isNaN(c)) throw new TypeError("CronPattern: Syntax error, illegal lower range (NaN)");
        if (isNaN(w)) throw new TypeError("CronPattern: Syntax error, illegal upper range (NaN)");
        if (isNaN(C)) throw new TypeError("CronPattern: Syntax error, illegal stepping: (NaN)");
        if (C === 0) throw new TypeError("CronPattern: Syntax error, illegal stepping: 0");
        if (C > this[e].length) throw new TypeError("CronPattern: Syntax error, steps cannot be greater than maximum value of part (" + this[e].length + ")");
        if (c > w) throw new TypeError("CronPattern: From value is larger than to value: '" + t + "'");
        for(let T = c; T <= w; T += C)this.setPart(e, T, i[1] || s);
    }
    extractNth(t, e) {
        let r = t, s;
        if (r.includes("#")) {
            if (e !== "dayOfWeek") throw new Error("CronPattern: nth (#) only allowed in day-of-week field");
            s = r.split("#")[1], r = r.split("#")[0];
        }
        return [
            r,
            s
        ];
    }
    handleRange(t, e, r, s) {
        let i = this.extractNth(t, e), a = i[0].split("-");
        if (a.length !== 2) throw new TypeError("CronPattern: Syntax error, illegal range: '" + t + "'");
        let l = parseInt(a[0], 10) + r, o = parseInt(a[1], 10) + r;
        if (isNaN(l)) throw new TypeError("CronPattern: Syntax error, illegal lower range (NaN)");
        if (isNaN(o)) throw new TypeError("CronPattern: Syntax error, illegal upper range (NaN)");
        if (l > o) throw new TypeError("CronPattern: From value is larger than to value: '" + t + "'");
        for(let u = l; u <= o; u++)this.setPart(e, u, i[1] || s);
    }
    handleStepping(t, e, r, s) {
        let i = this.extractNth(t, e), a = i[0].split("/");
        if (a.length !== 2) throw new TypeError("CronPattern: Syntax error, illegal stepping: '" + t + "'");
        a[0] === "" && (a[0] = "*");
        let l = 0;
        a[0] !== "*" && (l = parseInt(a[0], 10) + r);
        let o = parseInt(a[1], 10);
        if (isNaN(o)) throw new TypeError("CronPattern: Syntax error, illegal stepping: (NaN)");
        if (o === 0) throw new TypeError("CronPattern: Syntax error, illegal stepping: 0");
        if (o > this[e].length) throw new TypeError("CronPattern: Syntax error, max steps for part is (" + this[e].length + ")");
        for(let u = l; u < this[e].length; u += o)this.setPart(e, u, i[1] || s);
    }
    replaceAlphaDays(t) {
        return t.replace(/-sun/gi, "-7").replace(/sun/gi, "0").replace(/mon/gi, "1").replace(/tue/gi, "2").replace(/wed/gi, "3").replace(/thu/gi, "4").replace(/fri/gi, "5").replace(/sat/gi, "6");
    }
    replaceAlphaMonths(t) {
        return t.replace(/jan/gi, "1").replace(/feb/gi, "2").replace(/mar/gi, "3").replace(/apr/gi, "4").replace(/may/gi, "5").replace(/jun/gi, "6").replace(/jul/gi, "7").replace(/aug/gi, "8").replace(/sep/gi, "9").replace(/oct/gi, "10").replace(/nov/gi, "11").replace(/dec/gi, "12");
    }
    handleNicknames(t) {
        let e = t.trim().toLowerCase();
        return e === "@yearly" || e === "@annually" ? "0 0 1 1 *" : e === "@monthly" ? "0 0 1 * *" : e === "@weekly" ? "0 0 * * 0" : e === "@daily" ? "0 0 * * *" : e === "@hourly" ? "0 * * * *" : t;
    }
    setNthWeekdayOfMonth(t, e) {
        if (typeof e != "number" && e === "L") this.dayOfWeek[t] = this.dayOfWeek[t] | b;
        else if (e === p) this.dayOfWeek[t] = p;
        else if (e < 6 && e > 0) this.dayOfWeek[t] = this.dayOfWeek[t] | v[e - 1];
        else throw new TypeError(`CronPattern: nth weekday out of range, should be 1-5 or L. Value: ${e}, Type: ${typeof e}`);
    }
};
var O = [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
], m = [
    [
        "month",
        "year",
        0
    ],
    [
        "day",
        "month",
        -1
    ],
    [
        "hour",
        "day",
        0
    ],
    [
        "minute",
        "hour",
        0
    ],
    [
        "second",
        "minute",
        0
    ]
], f = class n {
    tz;
    ms;
    second;
    minute;
    hour;
    day;
    month;
    year;
    constructor(t, e){
        if (this.tz = e, t && t instanceof Date) if (!isNaN(t)) this.fromDate(t);
        else throw new TypeError("CronDate: Invalid date passed to CronDate constructor");
        else if (t === void 0) this.fromDate(new Date);
        else if (t && typeof t == "string") this.fromString(t);
        else if (t instanceof n) this.fromCronDate(t);
        else throw new TypeError("CronDate: Invalid type (" + typeof t + ") passed to CronDate constructor");
    }
    isNthWeekdayOfMonth(t, e, r, s) {
        let a = new Date(Date.UTC(t, e, r)).getUTCDay(), l = 0;
        for(let o = 1; o <= r; o++)new Date(Date.UTC(t, e, o)).getUTCDay() === a && l++;
        if (s & p && v[l - 1] & s) return !0;
        if (s & b) {
            let o = new Date(Date.UTC(t, e + 1, 0)).getUTCDate();
            for(let u = r + 1; u <= o; u++)if (new Date(Date.UTC(t, e, u)).getUTCDay() === a) return !1;
            return !0;
        }
        return !1;
    }
    fromDate(t) {
        if (this.tz !== void 0) if (typeof this.tz == "number") this.ms = t.getUTCMilliseconds(), this.second = t.getUTCSeconds(), this.minute = t.getUTCMinutes() + this.tz, this.hour = t.getUTCHours(), this.day = t.getUTCDate(), this.month = t.getUTCMonth(), this.year = t.getUTCFullYear(), this.apply();
        else {
            let e = h.toTZ(t, this.tz);
            this.ms = t.getMilliseconds(), this.second = e.s, this.minute = e.i, this.hour = e.h, this.day = e.d, this.month = e.m - 1, this.year = e.y;
        }
        else this.ms = t.getMilliseconds(), this.second = t.getSeconds(), this.minute = t.getMinutes(), this.hour = t.getHours(), this.day = t.getDate(), this.month = t.getMonth(), this.year = t.getFullYear();
    }
    fromCronDate(t) {
        this.tz = t.tz, this.year = t.year, this.month = t.month, this.day = t.day, this.hour = t.hour, this.minute = t.minute, this.second = t.second, this.ms = t.ms;
    }
    apply() {
        if (this.month > 11 || this.day > O[this.month] || this.hour > 59 || this.minute > 59 || this.second > 59 || this.hour < 0 || this.minute < 0 || this.second < 0) {
            let t = new Date(Date.UTC(this.year, this.month, this.day, this.hour, this.minute, this.second, this.ms));
            return this.ms = t.getUTCMilliseconds(), this.second = t.getUTCSeconds(), this.minute = t.getUTCMinutes(), this.hour = t.getUTCHours(), this.day = t.getUTCDate(), this.month = t.getUTCMonth(), this.year = t.getUTCFullYear(), !0;
        } else return !1;
    }
    fromString(t) {
        if (typeof this.tz == "number") {
            let e = h.fromTZISO(t);
            this.ms = e.getUTCMilliseconds(), this.second = e.getUTCSeconds(), this.minute = e.getUTCMinutes(), this.hour = e.getUTCHours(), this.day = e.getUTCDate(), this.month = e.getUTCMonth(), this.year = e.getUTCFullYear(), this.apply();
        } else return this.fromDate(h.fromTZISO(t, this.tz));
    }
    findNext(t, e, r, s) {
        let i = this[e], a;
        r.lastDayOfMonth && (this.month !== 1 ? a = O[this.month] : a = new Date(Date.UTC(this.year, this.month + 1, 0, 0, 0, 0, 0)).getUTCDate());
        let l = !r.starDOW && e == "day" ? new Date(Date.UTC(this.year, this.month, 1, 0, 0, 0, 0)).getUTCDay() : void 0;
        for(let o = this[e] + s; o < r[e].length; o++){
            let u = r[e][o];
            if (e === "day" && r.lastDayOfMonth && o - s == a && (u = 1), e === "day" && !r.starDOW) {
                let c = r.dayOfWeek[(l + (o - s - 1)) % 7];
                if (c && c & p) c = this.isNthWeekdayOfMonth(this.year, this.month, o - s, c) ? 1 : 0;
                else if (c) throw new Error(`CronDate: Invalid value for dayOfWeek encountered. ${c}`);
                t.legacyMode && !r.starDOM ? u = u || c : u = u && c;
            }
            if (u) return this[e] = o - s, i !== this[e] ? 2 : 1;
        }
        return 3;
    }
    recurse(t, e, r) {
        let s = this.findNext(e, m[r][0], t, m[r][2]);
        if (s > 1) {
            let i = r + 1;
            for(; i < m.length;)this[m[i][0]] = -m[i][2], i++;
            if (s === 3) return this[m[r][1]]++, this[m[r][0]] = -m[r][2], this.apply(), this.recurse(t, e, 0);
            if (this.apply()) return this.recurse(t, e, r - 1);
        }
        return r += 1, r >= m.length ? this : this.year >= 3e3 ? null : this.recurse(t, e, r);
    }
    increment(t, e, r) {
        return this.second += e.interval !== void 0 && e.interval > 1 && r ? e.interval : 1, this.ms = 0, this.apply(), this.recurse(t, e, 0);
    }
    getDate(t) {
        return t || this.tz === void 0 ? new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.ms) : typeof this.tz == "number" ? new Date(Date.UTC(this.year, this.month, this.day, this.hour, this.minute - this.tz, this.second, this.ms)) : h.fromTZ(h.tp(this.year, this.month + 1, this.day, this.hour, this.minute, this.second, this.tz), !1);
    }
    getTime() {
        return this.getDate(!1).getTime();
    }
};
function N(n) {
    if (n === void 0 && (n = {}), delete n.name, n.legacyMode = n.legacyMode === void 0 ? !0 : n.legacyMode, n.paused = n.paused === void 0 ? !1 : n.paused, n.maxRuns = n.maxRuns === void 0 ? 1 / 0 : n.maxRuns, n.catch = n.catch === void 0 ? !1 : n.catch, n.interval = n.interval === void 0 ? 0 : parseInt(n.interval.toString(), 10), n.utcOffset = n.utcOffset === void 0 ? void 0 : parseInt(n.utcOffset.toString(), 10), n.unref = n.unref === void 0 ? !1 : n.unref, n.startAt && (n.startAt = new f(n.startAt, n.timezone)), n.stopAt && (n.stopAt = new f(n.stopAt, n.timezone)), n.interval !== null) {
        if (isNaN(n.interval)) throw new Error("CronOptions: Supplied value for interval is not a number");
        if (n.interval < 0) throw new Error("CronOptions: Supplied value for interval can not be negative");
    }
    if (n.utcOffset !== void 0) {
        if (isNaN(n.utcOffset)) throw new Error("CronOptions: Invalid value passed for utcOffset, should be number representing minutes offset from UTC.");
        if (n.utcOffset < -870 || n.utcOffset > 870) throw new Error("CronOptions: utcOffset out of bounds.");
        if (n.utcOffset !== void 0 && n.timezone) throw new Error("CronOptions: Combining 'utcOffset' with 'timezone' is not allowed.");
    }
    if (n.unref !== !0 && n.unref !== !1) throw new Error("CronOptions: Unref should be either true, false or undefined(false).");
    return n;
}
function g(n) {
    return Object.prototype.toString.call(n) === "[object Function]" || typeof n == "function" || n instanceof Function;
}
function S(n) {
    return g(n);
}
function P(n) {
    typeof Deno < "u" && typeof Deno.unrefTimer < "u" ? Deno.unrefTimer(n) : n && typeof n.unref < "u" && n.unref();
}
var _ = 30 * 1e3, y = [], R = class {
    name;
    options;
    _states;
    fn;
    constructor(t, e, r){
        let s, i;
        if (g(e)) i = e;
        else if (typeof e == "object") s = e;
        else if (e !== void 0) throw new Error("Cron: Invalid argument passed for optionsIn. Should be one of function, or object (options).");
        if (g(r)) i = r;
        else if (typeof r == "object") s = r;
        else if (r !== void 0) throw new Error("Cron: Invalid argument passed for funcIn. Should be one of function, or object (options).");
        if (this.name = s?.name, this.options = N(s), this._states = {
            kill: !1,
            blocking: !1,
            previousRun: void 0,
            currentRun: void 0,
            once: void 0,
            currentTimeout: void 0,
            maxRuns: s ? s.maxRuns : void 0,
            paused: s ? s.paused : !1,
            pattern: new d("* * * * *")
        }, t && (t instanceof Date || typeof t == "string" && t.indexOf(":") > 0) ? this._states.once = new f(t, this.options.timezone || this.options.utcOffset) : this._states.pattern = new d(t, this.options.timezone), this.name) {
            if (y.find((l)=>l.name === this.name)) throw new Error("Cron: Tried to initialize new named job '" + this.name + "', but name already taken.");
            y.push(this);
        }
        return i !== void 0 && S(i) && (this.fn = i, this.schedule()), this;
    }
    nextRun(t) {
        let e = this._next(t);
        return e ? e.getDate(!1) : null;
    }
    nextRuns(t, e) {
        this._states.maxRuns !== void 0 && t > this._states.maxRuns && (t = this._states.maxRuns);
        let r = [], s = e || this._states.currentRun || void 0;
        for(; t-- && (s = this.nextRun(s));)r.push(s);
        return r;
    }
    getPattern() {
        return this._states.pattern ? this._states.pattern.pattern : void 0;
    }
    isRunning() {
        let t = this.nextRun(this._states.currentRun), e = !this._states.paused, r = this.fn !== void 0, s = !this._states.kill;
        return e && r && s && t !== null;
    }
    isStopped() {
        return this._states.kill;
    }
    isBusy() {
        return this._states.blocking;
    }
    currentRun() {
        return this._states.currentRun ? this._states.currentRun.getDate() : null;
    }
    previousRun() {
        return this._states.previousRun ? this._states.previousRun.getDate() : null;
    }
    msToNext(t) {
        let e = this._next(t);
        return e ? t instanceof f || t instanceof Date ? e.getTime() - t.getTime() : e.getTime() - new f(t).getTime() : null;
    }
    stop() {
        this._states.kill = !0, this._states.currentTimeout && clearTimeout(this._states.currentTimeout);
        let t = y.indexOf(this);
        t >= 0 && y.splice(t, 1);
    }
    pause() {
        return this._states.paused = !0, !this._states.kill;
    }
    resume() {
        return this._states.paused = !1, !this._states.kill;
    }
    schedule(t) {
        if (t && this.fn) throw new Error("Cron: It is not allowed to schedule two functions using the same Croner instance.");
        t && (this.fn = t);
        let e = this.msToNext(), r = this.nextRun(this._states.currentRun);
        return e == null || isNaN(e) || r === null ? this : (e > _ && (e = _), this._states.currentTimeout = setTimeout(()=>this._checkTrigger(r), e), this._states.currentTimeout && this.options.unref && P(this._states.currentTimeout), this);
    }
    async _trigger(t) {
        if (this._states.blocking = !0, this._states.currentRun = new f(void 0, this.options.timezone || this.options.utcOffset), this.options.catch) try {
            this.fn !== void 0 && await this.fn(this, this.options.context);
        } catch (e) {
            g(this.options.catch) && this.options.catch(e, this);
        }
        else this.fn !== void 0 && await this.fn(this, this.options.context);
        this._states.previousRun = new f(t, this.options.timezone || this.options.utcOffset), this._states.blocking = !1;
    }
    async trigger() {
        await this._trigger();
    }
    runsLeft() {
        return this._states.maxRuns;
    }
    _checkTrigger(t) {
        let e = new Date, r = !this._states.paused && e.getTime() >= t.getTime(), s = this._states.blocking && this.options.protect;
        r && !s ? (this._states.maxRuns !== void 0 && this._states.maxRuns--, this._trigger()) : r && s && g(this.options.protect) && setTimeout(()=>this.options.protect(this), 0), this.schedule();
    }
    _next(t) {
        let e = !!(t || this._states.currentRun), r = !1;
        !t && this.options.startAt && this.options.interval && ([t, e] = this._calculatePreviousRun(t, e), r = !t), t = new f(t, this.options.timezone || this.options.utcOffset), this.options.startAt && t && t.getTime() < this.options.startAt.getTime() && (t = this.options.startAt);
        let s = this._states.once || new f(t, this.options.timezone || this.options.utcOffset);
        return !r && s !== this._states.once && (s = s.increment(this._states.pattern, this.options, e)), this._states.once && this._states.once.getTime() <= t.getTime() || s === null || this._states.maxRuns !== void 0 && this._states.maxRuns <= 0 || this._states.kill || this.options.stopAt && s.getTime() >= this.options.stopAt.getTime() ? null : s;
    }
    _calculatePreviousRun(t, e) {
        let r = new f(void 0, this.options.timezone || this.options.utcOffset), s = t;
        if (this.options.startAt.getTime() <= r.getTime()) {
            s = this.options.startAt;
            let i = s.getTime() + this.options.interval * 1e3;
            for(; i <= r.getTime();)s = new f(s, this.options.timezone || this.options.utcOffset).increment(this._states.pattern, this.options, !0), i = s.getTime() + this.options.interval * 1e3;
            e = !0;
        }
        return s === null && (s = void 0), [
            s,
            e
        ];
    }
};
;
}),
"[project]/node_modules/.pnpm/qs-esm@7.0.2/node_modules/qs-esm/lib/formats.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RFC1738",
    ()=>RFC1738,
    "RFC3986",
    ()=>RFC3986,
    "default",
    ()=>__TURBOPACK__default__export__,
    "formatters",
    ()=>formatters
]);
'use strict';
const replace = String.prototype.replace;
const percentTwenties = /%20/g;
const Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};
const formatters = {
    RFC1738: function(value) {
        return replace.call(value, percentTwenties, '+');
    },
    RFC3986: function(value) {
        return String(value);
    }
};
const RFC1738 = Format.RFC1738;
const RFC3986 = Format.RFC3986;
const __TURBOPACK__default__export__ = Format.RFC3986;
}),
"[project]/node_modules/.pnpm/qs-esm@7.0.2/node_modules/qs-esm/lib/utils.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "arrayToObject",
    ()=>arrayToObject,
    "assign",
    ()=>assign,
    "combine",
    ()=>combine,
    "compact",
    ()=>compact,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "isBuffer",
    ()=>isBuffer,
    "isRegExp",
    ()=>isRegExp,
    "maybeMap",
    ()=>maybeMap,
    "merge",
    ()=>merge
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$qs$2d$esm$40$7$2e$0$2e$2$2f$node_modules$2f$qs$2d$esm$2f$lib$2f$formats$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/qs-esm@7.0.2/node_modules/qs-esm/lib/formats.js [app-rsc] (ecmascript)");
'use strict';
;
const has = Object.prototype.hasOwnProperty;
const isArray = Array.isArray;
const hexTable = function() {
    const array = [];
    for(let i = 0; i < 256; ++i){
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }
    return array;
}();
const compactQueue = function compactQueue(queue) {
    while(queue.length > 1){
        const item = queue.pop();
        const obj = item.obj[item.prop];
        if (isArray(obj)) {
            const compacted = [];
            for(let j = 0; j < obj.length; ++j){
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }
            item.obj[item.prop] = compacted;
        }
    }
};
const arrayToObject = function arrayToObject(source, options) {
    const obj = options && options.plainObjects ? Object.create(null) : {};
    for(let i = 0; i < source.length; ++i){
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }
    return obj;
};
const merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */ if (!source) {
        return target;
    }
    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [
                target,
                source
            ];
        }
        return target;
    }
    if (!target || typeof target !== 'object') {
        return [
            target
        ].concat(source);
    }
    let mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }
    if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
            if (has.call(target, i)) {
                const targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
        const value = source[key];
        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};
const assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};
const decode = function(str, decoder, charset) {
    const strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};
const limit = 1024;
const encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }
    let string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }
    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }
    let out = '';
    for(let j = 0; j < string.length; j += limit){
        const segment = string.length >= limit ? string.slice(j, j + limit) : string;
        const arr = [];
        for(let i = 0; i < segment.length; ++i){
            let c = segment.charCodeAt(i);
            if (c === 0x2d || // -
            c === 0x2e || // .
            c === 0x5f || // _
            c === 0x7e || c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c >= 0x61 && c <= 0x7a || format === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$qs$2d$esm$40$7$2e$0$2e$2$2f$node_modules$2f$qs$2d$esm$2f$lib$2f$formats$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RFC1738"] && (c === 0x28 || c === 0x29) // ( )
            ) {
                arr[arr.length] = segment.charAt(i);
                continue;
            }
            if (c < 0x80) {
                arr[arr.length] = hexTable[c];
                continue;
            }
            if (c < 0x800) {
                arr[arr.length] = hexTable[0xc0 | c >> 6] + hexTable[0x80 | c & 0x3f];
                continue;
            }
            if (c < 0xd800 || c >= 0xe000) {
                arr[arr.length] = hexTable[0xe0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3f] + hexTable[0x80 | c & 0x3f];
                continue;
            }
            i += 1;
            c = 0x10000 + ((c & 0x3ff) << 10 | segment.charCodeAt(i) & 0x3ff);
            arr[arr.length] = hexTable[0xf0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3f] + hexTable[0x80 | c >> 6 & 0x3f] + hexTable[0x80 | c & 0x3f];
        }
        out += arr.join('');
    }
    return out;
};
const compact = function compact(value) {
    const queue = [
        {
            obj: {
                o: value
            },
            prop: 'o'
        }
    ];
    const refs = [];
    for(let i = 0; i < queue.length; ++i){
        const item = queue[i];
        const obj = item.obj[item.prop];
        const keys = Object.keys(obj);
        for(let j = 0; j < keys.length; ++j){
            const key = keys[j];
            const val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({
                    obj: obj,
                    prop: key
                });
                refs.push(val);
            }
        }
    }
    compactQueue(queue);
    return value;
};
const isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};
const isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
const combine = function combine(a, b) {
    return [].concat(a, b);
};
const maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        const mapped = [];
        for(let i = 0; i < val.length; i += 1){
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};
}),
"[project]/node_modules/.pnpm/qs-esm@7.0.2/node_modules/qs-esm/lib/parse.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parse",
    ()=>parse
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$qs$2d$esm$40$7$2e$0$2e$2$2f$node_modules$2f$qs$2d$esm$2f$lib$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/qs-esm@7.0.2/node_modules/qs-esm/lib/utils.js [app-rsc] (ecmascript)");
'use strict';
;
const has = Object.prototype.hasOwnProperty;
const isArray = Array.isArray;
const defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$qs$2d$esm$40$7$2e$0$2e$2$2f$node_modules$2f$qs$2d$esm$2f$lib$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["decode"],
    delimiter: '&',
    depth: 5,
    duplicates: 'combine',
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};
const interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};
const parseArrayValue = function(val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }
    return val;
};
// This is what browsers will submit when the  character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the  character, such as us-ascii.
const isoSentinel = 'utf8=%26%2310003%3B' // encodeURIComponent('&#10003;')
;
// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
const charsetSentinel = 'utf8=%E2%9C%93' // encodeURIComponent('')
;
const parseValues = function parseQueryStringValues(str, options) {
    const obj = {
        __proto__: null
    };
    const cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    const limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    const parts = cleanStr.split(options.delimiter, limit);
    let skipIndex = -1 // Keep track of where the utf8 sentinel was found
    ;
    let i;
    let charset = options.charset;
    if (options.charsetSentinel) {
        for(i = 0; i < parts.length; ++i){
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }
    for(i = 0; i < parts.length; ++i){
        if (i === skipIndex) {
            continue;
        }
        const part = parts[i];
        const bracketEqualsPos = part.indexOf(']=');
        const pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;
        let key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$qs$2d$esm$40$7$2e$0$2e$2$2f$node_modules$2f$qs$2d$esm$2f$lib$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["maybeMap"](parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
                return options.decoder(encodedVal, defaults.decoder, charset, 'value');
            });
        }
        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }
        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [
                val
            ] : val;
        }
        const existing = has.call(obj, key);
        if (existing && options.duplicates === 'combine') {
            obj[key] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$qs$2d$esm$40$7$2e$0$2e$2$2f$node_modules$2f$qs$2d$esm$2f$lib$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["combine"](obj[key], val);
        } else if (!existing || options.duplicates === 'last') {
            obj[key] = val;
        }
    }
    return obj;
};
const parseObject = function(chain, val, options, valuesParsed) {
    let leaf = valuesParsed ? val : parseArrayValue(val, options);
    for(let i = chain.length - 1; i >= 0; --i){
        let obj;
        const root = chain[i];
        if (root === '[]' && options.parseArrays) {
            obj = options.allowEmptyArrays && leaf === '' ? [] : [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            const cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            const decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
            const index = parseInt(decodedRoot, 10);
            if (!options.parseArrays && decodedRoot === '') {
                obj = {
                    0: leaf
                };
            } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
                obj = [];
                obj[index] = leaf;
            } else if (decodedRoot !== '__proto__') {
                obj[decodedRoot] = leaf;
            }
        }
        leaf = obj;
    }
    return leaf;
};
const parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }
    // Transform dot notation to bracket notation
    const key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;
    // The regex chunks
    const brackets = /(\[[^[\]]*])/;
    const child = /(\[[^[\]]*])/g;
    // Get the parent
    let segment = options.depth > 0 && brackets.exec(key);
    const parent = segment ? key.slice(0, segment.index) : key;
    // Stash the parent if it exists
    const keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(parent);
    }
    // Loop through children appending to the array until we hit depth
    let i = 0;
    while(options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth){
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }
    // If there's a remainder, just add whatever is left
    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }
    return parseObject(keys, val, options, valuesParsed);
};
const normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }
    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }
    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
    }
    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    const charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;
    const duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;
    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
        throw new TypeError('The duplicates option must be either combine, first, or last');
    }
    const allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$qs$2d$esm$40$7$2e$0$2e$2$2f$node_modules$2f$qs$2d$esm$2f$lib$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isRegExp"](opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === 'number' || opts.depth === false ? +opts.depth : defaults.depth,
        duplicates: duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};
function parse(str, opts) {
    const options = normalizeParseOptions(opts);
    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }
    const tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    let obj = options.plainObjects ? Object.create(null) : {};
    // Iterate over the keys and setup the new object
    const keys = Object.keys(tempObj);
    for(let i = 0; i < keys.length; ++i){
        const key = keys[i];
        const newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$qs$2d$esm$40$7$2e$0$2e$2$2f$node_modules$2f$qs$2d$esm$2f$lib$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["merge"](obj, newObj, options);
    }
    if (options.allowSparse === true) {
        return obj;
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$qs$2d$esm$40$7$2e$0$2e$2$2f$node_modules$2f$qs$2d$esm$2f$lib$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["compact"](obj);
}
}),
"[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/caller.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function noOpPrepareStackTrace(_, stack) {
    return stack;
}
module.exports = function getCallers() {
    const originalPrepare = Error.prepareStackTrace;
    Error.prepareStackTrace = noOpPrepareStackTrace;
    const stack = new Error().stack;
    Error.prepareStackTrace = originalPrepare;
    if (!Array.isArray(stack)) {
        return undefined;
    }
    const entries = stack.slice(2);
    const fileNames = [];
    for (const entry of entries){
        if (!entry) {
            continue;
        }
        fileNames.push(entry.getFileName());
    }
    return fileNames;
};
}),
"[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/transport.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { createRequire } = __turbopack_context__.r("[externals]/module [external] (module, cjs)");
const getCallers = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/caller.js [app-rsc] (ecmascript)");
const { join, isAbsolute, sep } = __turbopack_context__.r("[externals]/node:path [external] (node:path, cjs)");
const sleep = __turbopack_context__.r("[project]/node_modules/.pnpm/atomic-sleep@1.0.0/node_modules/atomic-sleep/index.js [app-rsc] (ecmascript)");
const onExit = __turbopack_context__.r("[project]/node_modules/.pnpm/on-exit-leak-free@2.1.2/node_modules/on-exit-leak-free/index.js [app-rsc] (ecmascript)");
const ThreadStream = __turbopack_context__.r("[project]/node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/index.js [app-rsc] (ecmascript)");
function setupOnExit(stream) {
    // This is leak free, it does not leave event handlers
    onExit.register(stream, autoEnd);
    onExit.registerBeforeExit(stream, flush);
    stream.on('close', function() {
        onExit.unregister(stream);
    });
}
function buildStream(filename, workerData, workerOpts, sync) {
    const stream = new ThreadStream({
        filename,
        workerData,
        workerOpts,
        sync
    });
    stream.on('ready', onReady);
    stream.on('close', function() {
        process.removeListener('exit', onExit);
    });
    process.on('exit', onExit);
    function onReady() {
        process.removeListener('exit', onExit);
        stream.unref();
        if (workerOpts.autoEnd !== false) {
            setupOnExit(stream);
        }
    }
    function onExit() {
        /* istanbul ignore next */ if (stream.closed) {
            return;
        }
        stream.flushSync();
        // Apparently there is a very sporadic race condition
        // that in certain OS would prevent the messages to be flushed
        // because the thread might not have been created still.
        // Unfortunately we need to sleep(100) in this case.
        sleep(100);
        stream.end();
    }
    return stream;
}
function autoEnd(stream) {
    stream.ref();
    stream.flushSync();
    stream.end();
    stream.once('close', function() {
        stream.unref();
    });
}
function flush(stream) {
    stream.flushSync();
}
function transport(fullOptions) {
    const { pipeline, targets, levels, dedupe, worker = {}, caller = getCallers(), sync = false } = fullOptions;
    const options = {
        ...fullOptions.options
    };
    // Backwards compatibility
    const callers = typeof caller === 'string' ? [
        caller
    ] : caller;
    // This will be eventually modified by bundlers
    const bundlerOverrides = '__bundlerPathsOverrides' in globalThis ? globalThis.__bundlerPathsOverrides : {};
    let target = fullOptions.target;
    if (target && targets) {
        throw new Error('only one of target or targets can be specified');
    }
    if (targets) {
        target = bundlerOverrides['pino-worker'] || join(("TURBOPACK compile-time value", "/ROOT/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib"), 'worker.js');
        options.targets = targets.filter((dest)=>dest.target).map((dest)=>{
            return {
                ...dest,
                target: fixTarget(dest.target)
            };
        });
        options.pipelines = targets.filter((dest)=>dest.pipeline).map((dest)=>{
            return dest.pipeline.map((t)=>{
                return {
                    ...t,
                    level: dest.level,
                    target: fixTarget(t.target)
                };
            });
        });
    } else if (pipeline) {
        target = bundlerOverrides['pino-worker'] || join(("TURBOPACK compile-time value", "/ROOT/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib"), 'worker.js');
        options.pipelines = [
            pipeline.map((dest)=>{
                return {
                    ...dest,
                    target: fixTarget(dest.target)
                };
            })
        ];
    }
    if (levels) {
        options.levels = levels;
    }
    if (dedupe) {
        options.dedupe = dedupe;
    }
    options.pinoWillSendConfig = true;
    return buildStream(fixTarget(target), options, worker, sync);
    //TURBOPACK unreachable
    ;
    function fixTarget(origin) {
        origin = bundlerOverrides[origin] || origin;
        if (isAbsolute(origin) || origin.indexOf('file://') === 0) {
            return origin;
        }
        if (origin === 'pino/file') {
            return join(("TURBOPACK compile-time value", "/ROOT/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib"), '..', 'file.js');
        }
        let fixTarget;
        for (const filePath of callers){
            try {
                const context = filePath === 'node:repl' ? process.cwd() + sep : filePath;
                fixTarget = createRequire(context).resolve(origin);
                break;
            } catch (err) {
                continue;
            }
        }
        if (!fixTarget) {
            throw new Error(`unable to determine transport target for "${origin}"`);
        }
        return fixTarget;
    }
}
module.exports = transport;
}),
"[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/constants.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Represents default log level values
 *
 * @enum {number}
 */ const DEFAULT_LEVELS = {
    trace: 10,
    debug: 20,
    info: 30,
    warn: 40,
    error: 50,
    fatal: 60
};
/**
 * Represents sort order direction: `ascending` or `descending`
 *
 * @enum {string}
 */ const SORTING_ORDER = {
    ASC: 'ASC',
    DESC: 'DESC'
};
module.exports = {
    DEFAULT_LEVELS,
    SORTING_ORDER
};
}),
"[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/multistream.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const metadata = Symbol.for('pino.metadata');
const { DEFAULT_LEVELS } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/constants.js [app-rsc] (ecmascript)");
const DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;
function multistream(streamsArray, opts) {
    streamsArray = streamsArray || [];
    opts = opts || {
        dedupe: false
    };
    const streamLevels = Object.create(DEFAULT_LEVELS);
    streamLevels.silent = Infinity;
    if (opts.levels && typeof opts.levels === 'object') {
        Object.keys(opts.levels).forEach((i)=>{
            streamLevels[i] = opts.levels[i];
        });
    }
    const res = {
        write,
        add,
        remove,
        emit,
        flushSync,
        end,
        minLevel: 0,
        lastId: 0,
        streams: [],
        clone,
        [metadata]: true,
        streamLevels
    };
    if (Array.isArray(streamsArray)) {
        streamsArray.forEach(add, res);
    } else {
        add.call(res, streamsArray);
    }
    // clean this object up
    // or it will stay allocated forever
    // as it is closed on the following closures
    streamsArray = null;
    return res;
    //TURBOPACK unreachable
    ;
    // we can exit early because the streams are ordered by level
    function write(data) {
        let dest;
        const level = this.lastLevel;
        const { streams } = this;
        // for handling situation when several streams has the same level
        let recordedLevel = 0;
        let stream;
        // if dedupe set to true we send logs to the stream with the highest level
        // therefore, we have to change sorting order
        for(let i = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)){
            dest = streams[i];
            if (dest.level <= level) {
                if (recordedLevel !== 0 && recordedLevel !== dest.level) {
                    break;
                }
                stream = dest.stream;
                if (stream[metadata]) {
                    const { lastTime, lastMsg, lastObj, lastLogger } = this;
                    stream.lastLevel = level;
                    stream.lastTime = lastTime;
                    stream.lastMsg = lastMsg;
                    stream.lastObj = lastObj;
                    stream.lastLogger = lastLogger;
                }
                stream.write(data);
                if (opts.dedupe) {
                    recordedLevel = dest.level;
                }
            } else if (!opts.dedupe) {
                break;
            }
        }
    }
    function emit(...args) {
        for (const { stream } of this.streams){
            if (typeof stream.emit === 'function') {
                stream.emit(...args);
            }
        }
    }
    function flushSync() {
        for (const { stream } of this.streams){
            if (typeof stream.flushSync === 'function') {
                stream.flushSync();
            }
        }
    }
    function add(dest) {
        if (!dest) {
            return res;
        }
        // Check that dest implements either StreamEntry or DestinationStream
        const isStream = typeof dest.write === 'function' || dest.stream;
        const stream_ = dest.write ? dest : dest.stream;
        // This is necessary to provide a meaningful error message, otherwise it throws somewhere inside write()
        if (!isStream) {
            throw Error('stream object needs to implement either StreamEntry or DestinationStream interface');
        }
        const { streams, streamLevels } = this;
        let level;
        if (typeof dest.levelVal === 'number') {
            level = dest.levelVal;
        } else if (typeof dest.level === 'string') {
            level = streamLevels[dest.level];
        } else if (typeof dest.level === 'number') {
            level = dest.level;
        } else {
            level = DEFAULT_INFO_LEVEL;
        }
        const dest_ = {
            stream: stream_,
            level,
            levelVal: undefined,
            id: ++res.lastId
        };
        streams.unshift(dest_);
        streams.sort(compareByLevel);
        this.minLevel = streams[0].level;
        return res;
    }
    function remove(id) {
        const { streams } = this;
        const index = streams.findIndex((s)=>s.id === id);
        if (index >= 0) {
            streams.splice(index, 1);
            streams.sort(compareByLevel);
            this.minLevel = streams.length > 0 ? streams[0].level : -1;
        }
        return res;
    }
    function end() {
        for (const { stream } of this.streams){
            if (typeof stream.flushSync === 'function') {
                stream.flushSync();
            }
            stream.end();
        }
    }
    function clone(level) {
        const streams = new Array(this.streams.length);
        for(let i = 0; i < streams.length; i++){
            streams[i] = {
                level,
                stream: this.streams[i].stream
            };
        }
        return {
            write,
            add,
            remove,
            minLevel: level,
            streams,
            clone,
            emit,
            flushSync,
            [metadata]: true
        };
    }
}
function compareByLevel(a, b) {
    return a.level - b.level;
}
function initLoopVar(length, dedupe) {
    return dedupe ? length - 1 : 0;
}
function adjustLoopVar(i, dedupe) {
    return dedupe ? i - 1 : i + 1;
}
function checkLoopVar(i, length, dedupe) {
    return dedupe ? i >= 0 : i < length;
}
module.exports = multistream;
}),
"[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/symbols.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const setLevelSym = Symbol('pino.setLevel');
const getLevelSym = Symbol('pino.getLevel');
const levelValSym = Symbol('pino.levelVal');
const levelCompSym = Symbol('pino.levelComp');
const useLevelLabelsSym = Symbol('pino.useLevelLabels');
const useOnlyCustomLevelsSym = Symbol('pino.useOnlyCustomLevels');
const mixinSym = Symbol('pino.mixin');
const lsCacheSym = Symbol('pino.lsCache');
const chindingsSym = Symbol('pino.chindings');
const asJsonSym = Symbol('pino.asJson');
const writeSym = Symbol('pino.write');
const redactFmtSym = Symbol('pino.redactFmt');
const timeSym = Symbol('pino.time');
const timeSliceIndexSym = Symbol('pino.timeSliceIndex');
const streamSym = Symbol('pino.stream');
const stringifySym = Symbol('pino.stringify');
const stringifySafeSym = Symbol('pino.stringifySafe');
const stringifiersSym = Symbol('pino.stringifiers');
const endSym = Symbol('pino.end');
const formatOptsSym = Symbol('pino.formatOpts');
const messageKeySym = Symbol('pino.messageKey');
const errorKeySym = Symbol('pino.errorKey');
const nestedKeySym = Symbol('pino.nestedKey');
const nestedKeyStrSym = Symbol('pino.nestedKeyStr');
const mixinMergeStrategySym = Symbol('pino.mixinMergeStrategy');
const msgPrefixSym = Symbol('pino.msgPrefix');
const wildcardFirstSym = Symbol('pino.wildcardFirst');
// public symbols, no need to use the same pino
// version for these
const serializersSym = Symbol.for('pino.serializers');
const formattersSym = Symbol.for('pino.formatters');
const hooksSym = Symbol.for('pino.hooks');
const needsMetadataGsym = Symbol.for('pino.metadata');
module.exports = {
    setLevelSym,
    getLevelSym,
    levelValSym,
    levelCompSym,
    useLevelLabelsSym,
    mixinSym,
    lsCacheSym,
    chindingsSym,
    asJsonSym,
    writeSym,
    serializersSym,
    redactFmtSym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    stringifySym,
    stringifySafeSym,
    stringifiersSym,
    endSym,
    formatOptsSym,
    messageKeySym,
    errorKeySym,
    nestedKeySym,
    wildcardFirstSym,
    needsMetadataGsym,
    useOnlyCustomLevelsSym,
    formattersSym,
    hooksSym,
    nestedKeyStrSym,
    mixinMergeStrategySym,
    msgPrefixSym
};
}),
"[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/redaction.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Redact = __turbopack_context__.r("[project]/node_modules/.pnpm/@pinojs+redact@0.4.0/node_modules/@pinojs/redact/index.js [app-rsc] (ecmascript)");
const { redactFmtSym, wildcardFirstSym } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/symbols.js [app-rsc] (ecmascript)");
// Custom rx regex equivalent to fast-redact's rx
const rx = /[^.[\]]+|\[([^[\]]*?)\]/g;
const CENSOR = '[Redacted]';
const strict = false // TODO should this be configurable?
;
function redaction(opts, serialize) {
    const { paths, censor, remove } = handle(opts);
    const shape = paths.reduce((o, str)=>{
        rx.lastIndex = 0;
        const first = rx.exec(str);
        const next = rx.exec(str);
        // ns is the top-level path segment, brackets + quoting removed.
        let ns = first[1] !== undefined ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, '$1') : first[0];
        if (ns === '*') {
            ns = wildcardFirstSym;
        }
        // top level key:
        if (next === null) {
            o[ns] = null;
            return o;
        }
        // path with at least two segments:
        // if ns is already redacted at the top level, ignore lower level redactions
        if (o[ns] === null) {
            return o;
        }
        const { index } = next;
        const nextPath = `${str.substr(index, str.length - 1)}`;
        o[ns] = o[ns] || [];
        // shape is a mix of paths beginning with literal values and wildcard
        // paths [ "a.b.c", "*.b.z" ] should reduce to a shape of
        // { "a": [ "b.c", "b.z" ], *: [ "b.z" ] }
        // note: "b.z" is in both "a" and * arrays because "a" matches the wildcard.
        // (* entry has wildcardFirstSym as key)
        if (ns !== wildcardFirstSym && o[ns].length === 0) {
            // first time ns's get all '*' redactions so far
            o[ns].push(...o[wildcardFirstSym] || []);
        }
        if (ns === wildcardFirstSym) {
            // new * path gets added to all previously registered literal ns's.
            Object.keys(o).forEach(function(k) {
                if (o[k]) {
                    o[k].push(nextPath);
                }
            });
        }
        o[ns].push(nextPath);
        return o;
    }, {});
    // the redactor assigned to the format symbol key
    // provides top level redaction for instances where
    // an object is interpolated into the msg string
    const result = {
        [redactFmtSym]: Redact({
            paths,
            censor,
            serialize,
            strict,
            remove
        })
    };
    const topCensor = (...args)=>{
        return typeof censor === 'function' ? serialize(censor(...args)) : serialize(censor);
    };
    return [
        ...Object.keys(shape),
        ...Object.getOwnPropertySymbols(shape)
    ].reduce((o, k)=>{
        // top level key:
        if (shape[k] === null) {
            o[k] = (value)=>topCensor(value, [
                    k
                ]);
        } else {
            const wrappedCensor = typeof censor === 'function' ? (value, path)=>{
                return censor(value, [
                    k,
                    ...path
                ]);
            } : censor;
            o[k] = Redact({
                paths: shape[k],
                censor: wrappedCensor,
                serialize,
                strict,
                remove
            });
        }
        return o;
    }, result);
}
function handle(opts) {
    if (Array.isArray(opts)) {
        opts = {
            paths: opts,
            censor: CENSOR
        };
        return opts;
    }
    let { paths, censor = CENSOR, remove } = opts;
    if (Array.isArray(paths) === false) {
        throw Error('pino  redact must contain an array of strings');
    }
    if (remove === true) censor = undefined;
    return {
        paths,
        censor,
        remove
    };
}
module.exports = redaction;
}),
"[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/time.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const nullTime = ()=>'';
const epochTime = ()=>`,"time":${Date.now()}`;
const unixTime = ()=>`,"time":${Math.round(Date.now() / 1000.0)}`;
const isoTime = ()=>`,"time":"${new Date(Date.now()).toISOString()}"` // using Date.now() for testability
;
const NS_PER_MS = 1_000_000n;
const NS_PER_SEC = 1_000_000_000n;
const startWallTimeNs = BigInt(Date.now()) * NS_PER_MS;
const startHrTime = process.hrtime.bigint();
const isoTimeNano = ()=>{
    const elapsedNs = process.hrtime.bigint() - startHrTime;
    const currentTimeNs = startWallTimeNs + elapsedNs;
    const secondsSinceEpoch = currentTimeNs / NS_PER_SEC;
    const nanosWithinSecond = currentTimeNs % NS_PER_SEC;
    const msSinceEpoch = Number(secondsSinceEpoch * 1000n + nanosWithinSecond / 1_000_000n);
    const date = new Date(msSinceEpoch);
    const year = date.getUTCFullYear();
    const month = (date.getUTCMonth() + 1).toString().padStart(2, '0');
    const day = date.getUTCDate().toString().padStart(2, '0');
    const hours = date.getUTCHours().toString().padStart(2, '0');
    const minutes = date.getUTCMinutes().toString().padStart(2, '0');
    const seconds = date.getUTCSeconds().toString().padStart(2, '0');
    return `,"time":"${year}-${month}-${day}T${hours}:${minutes}:${seconds}.${nanosWithinSecond.toString().padStart(9, '0')}Z"`;
};
module.exports = {
    nullTime,
    epochTime,
    unixTime,
    isoTime,
    isoTimeNano
};
}),
"[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/tools.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint no-prototype-builtins: 0 */ const diagChan = __turbopack_context__.r("[externals]/node:diagnostics_channel [external] (node:diagnostics_channel, cjs)");
const format = __turbopack_context__.r("[project]/node_modules/.pnpm/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js [app-rsc] (ecmascript)");
const { mapHttpRequest, mapHttpResponse } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/index.js [app-rsc] (ecmascript)");
const SonicBoom = __turbopack_context__.r("[project]/node_modules/.pnpm/sonic-boom@4.2.0/node_modules/sonic-boom/index.js [app-rsc] (ecmascript)");
const onExit = __turbopack_context__.r("[project]/node_modules/.pnpm/on-exit-leak-free@2.1.2/node_modules/on-exit-leak-free/index.js [app-rsc] (ecmascript)");
const { lsCacheSym, chindingsSym, writeSym, serializersSym, formatOptsSym, endSym, stringifiersSym, stringifySym, stringifySafeSym, wildcardFirstSym, nestedKeySym, formattersSym, messageKeySym, errorKeySym, nestedKeyStrSym, msgPrefixSym } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/symbols.js [app-rsc] (ecmascript)");
const { isMainThread } = __turbopack_context__.r("[externals]/worker_threads [external] (worker_threads, cjs)");
const transport = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/transport.js [app-rsc] (ecmascript)");
let asJsonChan;
// Node >= 18.19 supports diagnostics_channel.tracingChannel
if (typeof diagChan.tracingChannel === 'function') {
    asJsonChan = diagChan.tracingChannel('pino_asJson');
} else {
    // Older Node 18.x (e.g. 18.18), provided a no-op fallback
    asJsonChan = {
        hasSubscribers: false,
        traceSync (fn, store, thisArg, ...args) {
            return fn.call(thisArg, ...args);
        }
    };
}
function noop() {}
function genLog(level, hook) {
    if (!hook) return LOG;
    return function hookWrappedLog(...args) {
        hook.call(this, args, LOG, level);
    };
    //TURBOPACK unreachable
    ;
    function LOG(o, ...n) {
        if (typeof o === 'object') {
            let msg = o;
            if (o !== null) {
                if (o.method && o.headers && o.socket) {
                    o = mapHttpRequest(o);
                } else if (typeof o.setHeader === 'function') {
                    o = mapHttpResponse(o);
                }
            }
            let formatParams;
            if (msg === null && n.length === 0) {
                formatParams = [
                    null
                ];
            } else {
                msg = n.shift();
                formatParams = n;
            }
            // We do not use a coercive check for `msg` as it is
            // measurably slower than the explicit checks.
            if (typeof this[msgPrefixSym] === 'string' && msg !== undefined && msg !== null) {
                msg = this[msgPrefixSym] + msg;
            }
            this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level);
        } else {
            let msg = o === undefined ? n.shift() : o;
            // We do not use a coercive check for `msg` as it is
            // measurably slower than the explicit checks.
            if (typeof this[msgPrefixSym] === 'string' && msg !== undefined && msg !== null) {
                msg = this[msgPrefixSym] + msg;
            }
            this[writeSym](null, format(msg, n, this[formatOptsSym]), level);
        }
    }
}
// magically escape strings for json
// relying on their charCodeAt
// everything below 32 needs JSON.stringify()
// 34 and 92 happens all the time, so we
// have a fast case for them
function asString(str) {
    let result = '';
    let last = 0;
    let found = false;
    let point = 255;
    const l = str.length;
    if (l > 100) {
        return JSON.stringify(str);
    }
    for(var i = 0; i < l && point >= 32; i++){
        point = str.charCodeAt(i);
        if (point === 34 || point === 92) {
            result += str.slice(last, i) + '\\';
            last = i;
            found = true;
        }
    }
    if (!found) {
        result = str;
    } else {
        result += str.slice(last);
    }
    return point < 32 ? JSON.stringify(str) : '"' + result + '"';
}
/**
 * `asJson` wraps `_asJson` in order to facilitate generating diagnostics.
 *
 * @param {object} obj The merging object passed to the log method.
 * @param {string} msg The log message passed to the log method.
 * @param {number} num The log level number.
 * @param {number} time The log time in milliseconds.
 *
 * @returns {string}
 */ function asJson(obj, msg, num, time) {
    if (asJsonChan.hasSubscribers === false) {
        return _asJson.call(this, obj, msg, num, time);
    }
    const store = {
        instance: this,
        arguments
    };
    return asJsonChan.traceSync(_asJson, store, this, obj, msg, num, time);
}
/**
 * `_asJson` parses all collected data and generates the finalized newline
 * delimited JSON string.
 *
 * @param {object} obj The merging object passed to the log method.
 * @param {string} msg The log message passed to the log method.
 * @param {number} num The log level number.
 * @param {number} time The log time in milliseconds.
 *
 * @returns {string} The finalized log string terminated with a newline.
 * @private
 */ function _asJson(obj, msg, num, time) {
    const stringify = this[stringifySym];
    const stringifySafe = this[stringifySafeSym];
    const stringifiers = this[stringifiersSym];
    const end = this[endSym];
    const chindings = this[chindingsSym];
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const messageKey = this[messageKeySym];
    const errorKey = this[errorKeySym];
    let data = this[lsCacheSym][num] + time;
    // we need the child bindings added to the output first so instance logged
    // objects can take precedence when JSON.parse-ing the resulting log line
    data = data + chindings;
    let value;
    if (formatters.log) {
        obj = formatters.log(obj);
    }
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    let propStr = '';
    for(const key in obj){
        value = obj[key];
        if (Object.prototype.hasOwnProperty.call(obj, key) && value !== undefined) {
            if (serializers[key]) {
                value = serializers[key](value);
            } else if (key === errorKey && serializers.err) {
                value = serializers.err(value);
            }
            const stringifier = stringifiers[key] || wildcardStringifier;
            switch(typeof value){
                case 'undefined':
                case 'function':
                    continue;
                case 'number':
                    /* eslint no-fallthrough: "off" */ if (Number.isFinite(value) === false) {
                        value = null;
                    }
                // this case explicitly falls through to the next one
                case 'boolean':
                    if (stringifier) value = stringifier(value);
                    break;
                case 'string':
                    value = (stringifier || asString)(value);
                    break;
                default:
                    value = (stringifier || stringify)(value, stringifySafe);
            }
            if (value === undefined) continue;
            const strKey = asString(key);
            propStr += ',' + strKey + ':' + value;
        }
    }
    let msgStr = '';
    if (msg !== undefined) {
        value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
        const stringifier = stringifiers[messageKey] || wildcardStringifier;
        switch(typeof value){
            case 'function':
                break;
            case 'number':
                /* eslint no-fallthrough: "off" */ if (Number.isFinite(value) === false) {
                    value = null;
                }
            // this case explicitly falls through to the next one
            case 'boolean':
                if (stringifier) value = stringifier(value);
                msgStr = ',"' + messageKey + '":' + value;
                break;
            case 'string':
                value = (stringifier || asString)(value);
                msgStr = ',"' + messageKey + '":' + value;
                break;
            default:
                value = (stringifier || stringify)(value, stringifySafe);
                msgStr = ',"' + messageKey + '":' + value;
        }
    }
    if (this[nestedKeySym] && propStr) {
        // place all the obj properties under the specified key
        // the nested key is already formatted from the constructor
        return data + this[nestedKeyStrSym] + propStr.slice(1) + '}' + msgStr + end;
    } else {
        return data + propStr + msgStr + end;
    }
}
function asChindings(instance, bindings) {
    let value;
    let data = instance[chindingsSym];
    const stringify = instance[stringifySym];
    const stringifySafe = instance[stringifySafeSym];
    const stringifiers = instance[stringifiersSym];
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    const serializers = instance[serializersSym];
    const formatter = instance[formattersSym].bindings;
    bindings = formatter(bindings);
    for(const key in bindings){
        value = bindings[key];
        const valid = (key.length < 5 || key !== 'level' && key !== 'serializers' && key !== 'formatters' && key !== 'customLevels') && bindings.hasOwnProperty(key) && value !== undefined;
        if (valid === true) {
            value = serializers[key] ? serializers[key](value) : value;
            value = (stringifiers[key] || wildcardStringifier || stringify)(value, stringifySafe);
            if (value === undefined) continue;
            data += ',"' + key + '":' + value;
        }
    }
    return data;
}
function hasBeenTampered(stream) {
    return stream.write !== stream.constructor.prototype.write;
}
function buildSafeSonicBoom(opts) {
    const stream = new SonicBoom(opts);
    stream.on('error', filterBrokenPipe);
    // If we are sync: false, we must flush on exit
    if (!opts.sync && isMainThread) {
        onExit.register(stream, autoEnd);
        stream.on('close', function() {
            onExit.unregister(stream);
        });
    }
    return stream;
    //TURBOPACK unreachable
    ;
    function filterBrokenPipe(err) {
        // Impossible to replicate across all operating systems
        /* istanbul ignore next */ if (err.code === 'EPIPE') {
            // If we get EPIPE, we should stop logging here
            // however we have no control to the consumer of
            // SonicBoom, so we just overwrite the write method
            stream.write = noop;
            stream.end = noop;
            stream.flushSync = noop;
            stream.destroy = noop;
            return;
        }
        stream.removeListener('error', filterBrokenPipe);
        stream.emit('error', err);
    }
}
function autoEnd(stream, eventName) {
    // This check is needed only on some platforms
    /* istanbul ignore next */ if (stream.destroyed) {
        return;
    }
    if (eventName === 'beforeExit') {
        // We still have an event loop, let's use it
        stream.flush();
        stream.on('drain', function() {
            stream.end();
        });
    } else {
        // For some reason istanbul is not detecting this, but it's there
        /* istanbul ignore next */ // We do not have an event loop, so flush synchronously
        stream.flushSync();
    }
}
function createArgsNormalizer(defaultOptions) {
    return function normalizeArgs(instance, caller, opts = {}, stream) {
        // support stream as a string
        if (typeof opts === 'string') {
            stream = buildSafeSonicBoom({
                dest: opts
            });
            opts = {};
        } else if (typeof stream === 'string') {
            if (opts && opts.transport) {
                throw Error('only one of option.transport or stream can be specified');
            }
            stream = buildSafeSonicBoom({
                dest: stream
            });
        } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
            stream = opts;
            opts = {};
        } else if (opts.transport) {
            if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
                throw Error('option.transport do not allow stream, please pass to option directly. e.g. pino(transport)');
            }
            if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === 'function') {
                throw Error('option.transport.targets do not allow custom level formatters');
            }
            let customLevels;
            if (opts.customLevels) {
                customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
            }
            stream = transport({
                caller,
                ...opts.transport,
                levels: customLevels
            });
        }
        opts = Object.assign({}, defaultOptions, opts);
        opts.serializers = Object.assign({}, defaultOptions.serializers, opts.serializers);
        opts.formatters = Object.assign({}, defaultOptions.formatters, opts.formatters);
        if (opts.prettyPrint) {
            throw new Error('prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)');
        }
        const { enabled, onChild } = opts;
        if (enabled === false) opts.level = 'silent';
        if (!onChild) opts.onChild = noop;
        if (!stream) {
            if (!hasBeenTampered(process.stdout)) {
                // If process.stdout.fd is undefined, it means that we are running
                // in a worker thread. Let's assume we are logging to file descriptor 1.
                stream = buildSafeSonicBoom({
                    fd: process.stdout.fd || 1
                });
            } else {
                stream = process.stdout;
            }
        }
        return {
            opts,
            stream
        };
    };
}
function stringify(obj, stringifySafeFn) {
    try {
        return JSON.stringify(obj);
    } catch (_) {
        try {
            const stringify = stringifySafeFn || this[stringifySafeSym];
            return stringify(obj);
        } catch (_) {
            return '"[unable to serialize, circular reference is too complex to analyze]"';
        }
    }
}
function buildFormatters(level, bindings, log) {
    return {
        level,
        bindings,
        log
    };
}
/**
 * Convert a string integer file descriptor to a proper native integer
 * file descriptor.
 *
 * @param {string} destination The file descriptor string to attempt to convert.
 *
 * @returns {Number}
 */ function normalizeDestFileDescriptor(destination) {
    const fd = Number(destination);
    if (typeof destination === 'string' && Number.isFinite(fd)) {
        return fd;
    }
    // destination could be undefined if we are in a worker
    if (destination === undefined) {
        // This is stdout in UNIX systems
        return 1;
    }
    return destination;
}
module.exports = {
    noop,
    buildSafeSonicBoom,
    asChindings,
    asJson,
    genLog,
    createArgsNormalizer,
    stringify,
    buildFormatters,
    normalizeDestFileDescriptor
};
}),
"[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/levels.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint no-prototype-builtins: 0 */ const { lsCacheSym, levelValSym, useOnlyCustomLevelsSym, streamSym, formattersSym, hooksSym, levelCompSym } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/symbols.js [app-rsc] (ecmascript)");
const { noop, genLog } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/tools.js [app-rsc] (ecmascript)");
const { DEFAULT_LEVELS, SORTING_ORDER } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/constants.js [app-rsc] (ecmascript)");
const levelMethods = {
    fatal: (hook)=>{
        const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
        return function(...args) {
            const stream = this[streamSym];
            logFatal.call(this, ...args);
            if (typeof stream.flushSync === 'function') {
                try {
                    stream.flushSync();
                } catch (e) {
                // https://github.com/pinojs/pino/pull/740#discussion_r346788313
                }
            }
        };
    },
    error: (hook)=>genLog(DEFAULT_LEVELS.error, hook),
    warn: (hook)=>genLog(DEFAULT_LEVELS.warn, hook),
    info: (hook)=>genLog(DEFAULT_LEVELS.info, hook),
    debug: (hook)=>genLog(DEFAULT_LEVELS.debug, hook),
    trace: (hook)=>genLog(DEFAULT_LEVELS.trace, hook)
};
const nums = Object.keys(DEFAULT_LEVELS).reduce((o, k)=>{
    o[DEFAULT_LEVELS[k]] = k;
    return o;
}, {});
const initialLsCache = Object.keys(nums).reduce((o, k)=>{
    o[k] = '{"level":' + Number(k);
    return o;
}, {});
function genLsCache(instance) {
    const formatter = instance[formattersSym].level;
    const { labels } = instance.levels;
    const cache = {};
    for(const label in labels){
        const level = formatter(labels[label], Number(label));
        cache[label] = JSON.stringify(level).slice(0, -1);
    }
    instance[lsCacheSym] = cache;
    return instance;
}
function isStandardLevel(level, useOnlyCustomLevels) {
    if (useOnlyCustomLevels) {
        return false;
    }
    switch(level){
        case 'fatal':
        case 'error':
        case 'warn':
        case 'info':
        case 'debug':
        case 'trace':
            return true;
        default:
            return false;
    }
}
function setLevel(level) {
    const { labels, values } = this.levels;
    if (typeof level === 'number') {
        if (labels[level] === undefined) throw Error('unknown level value' + level);
        level = labels[level];
    }
    if (values[level] === undefined) throw Error('unknown level ' + level);
    const preLevelVal = this[levelValSym];
    const levelVal = this[levelValSym] = values[level];
    const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
    const levelComparison = this[levelCompSym];
    const hook = this[hooksSym].logMethod;
    for(const key in values){
        if (levelComparison(values[key], levelVal) === false) {
            this[key] = noop;
            continue;
        }
        this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
    }
    this.emit('level-change', level, levelVal, labels[preLevelVal], preLevelVal, this);
}
function getLevel(level) {
    const { levels, levelVal } = this;
    // protection against potential loss of Pino scope from serializers (edge case with circular refs - https://github.com/pinojs/pino/issues/833)
    return levels && levels.labels ? levels.labels[levelVal] : '';
}
function isLevelEnabled(logLevel) {
    const { values } = this.levels;
    const logLevelVal = values[logLevel];
    return logLevelVal !== undefined && this[levelCompSym](logLevelVal, this[levelValSym]);
}
/**
 * Determine if the given `current` level is enabled by comparing it
 * against the current threshold (`expected`).
 *
 * @param {SORTING_ORDER} direction comparison direction "ASC" or "DESC"
 * @param {number} current current log level number representation
 * @param {number} expected threshold value to compare with
 * @returns {boolean}
 */ function compareLevel(direction, current, expected) {
    if (direction === SORTING_ORDER.DESC) {
        return current <= expected;
    }
    return current >= expected;
}
/**
 * Create a level comparison function based on `levelComparison`
 * it could a default function which compares levels either in "ascending" or "descending" order or custom comparison function
 *
 * @param {SORTING_ORDER | Function} levelComparison sort levels order direction or custom comparison function
 * @returns Function
 */ function genLevelComparison(levelComparison) {
    if (typeof levelComparison === 'string') {
        return compareLevel.bind(null, levelComparison);
    }
    return levelComparison;
}
function mappings(customLevels = null, useOnlyCustomLevels = false) {
    const customNums = customLevels ? Object.keys(customLevels).reduce((o, k)=>{
        o[customLevels[k]] = k;
        return o;
    }, {}) : null;
    /* eslint-enable */ const labels = Object.assign(Object.create(Object.prototype, {
        Infinity: {
            value: 'silent'
        }
    }), useOnlyCustomLevels ? null : nums, customNums);
    const values = Object.assign(Object.create(Object.prototype, {
        silent: {
            value: Infinity
        }
    }), useOnlyCustomLevels ? null : DEFAULT_LEVELS, customLevels);
    return {
        labels,
        values
    };
}
function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
    if (typeof defaultLevel === 'number') {
        const values = [].concat(Object.keys(customLevels || {}).map((key)=>customLevels[key]), useOnlyCustomLevels ? [] : Object.keys(nums).map((level)=>+level), Infinity);
        if (!values.includes(defaultLevel)) {
            throw Error(`default level:${defaultLevel} must be included in custom levels`);
        }
        return;
    }
    const labels = Object.assign(Object.create(Object.prototype, {
        silent: {
            value: Infinity
        }
    }), useOnlyCustomLevels ? null : DEFAULT_LEVELS, customLevels);
    if (!(defaultLevel in labels)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
    }
}
function assertNoLevelCollisions(levels, customLevels) {
    const { labels, values } = levels;
    for(const k in customLevels){
        if (k in values) {
            throw Error('levels cannot be overridden');
        }
        if (customLevels[k] in labels) {
            throw Error('pre-existing level values cannot be used for new levels');
        }
    }
}
/**
 * Validates whether `levelComparison` is correct
 *
 * @throws Error
 * @param {SORTING_ORDER | Function} levelComparison - value to validate
 * @returns
 */ function assertLevelComparison(levelComparison) {
    if (typeof levelComparison === 'function') {
        return;
    }
    if (typeof levelComparison === 'string' && Object.values(SORTING_ORDER).includes(levelComparison)) {
        return;
    }
    throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
}
module.exports = {
    initialLsCache,
    genLsCache,
    levelMethods,
    getLevel,
    setLevel,
    isLevelEnabled,
    mappings,
    assertNoLevelCollisions,
    assertDefaultLevelFound,
    genLevelComparison,
    assertLevelComparison
};
}),
"[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/meta.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {
    version: '9.14.0'
};
}),
"[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/proto.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint no-prototype-builtins: 0 */ const { EventEmitter } = __turbopack_context__.r("[externals]/node:events [external] (node:events, cjs)");
const { lsCacheSym, levelValSym, setLevelSym, getLevelSym, chindingsSym, parsedChindingsSym, mixinSym, asJsonSym, writeSym, mixinMergeStrategySym, timeSym, timeSliceIndexSym, streamSym, serializersSym, formattersSym, errorKeySym, messageKeySym, useOnlyCustomLevelsSym, needsMetadataGsym, redactFmtSym, stringifySym, formatOptsSym, stringifiersSym, msgPrefixSym, hooksSym } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/symbols.js [app-rsc] (ecmascript)");
const { getLevel, setLevel, isLevelEnabled, mappings, initialLsCache, genLsCache, assertNoLevelCollisions } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/levels.js [app-rsc] (ecmascript)");
const { asChindings, asJson, buildFormatters, stringify, noop } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/tools.js [app-rsc] (ecmascript)");
const { version } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/meta.js [app-rsc] (ecmascript)");
const redaction = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/redaction.js [app-rsc] (ecmascript)");
// note: use of class is satirical
// https://github.com/pinojs/pino/pull/433#pullrequestreview-127703127
const constructor = class Pino {
};
const prototype = {
    constructor,
    child,
    bindings,
    setBindings,
    flush,
    isLevelEnabled,
    version,
    get level () {
        return this[getLevelSym]();
    },
    set level (lvl){
        this[setLevelSym](lvl);
    },
    get levelVal () {
        return this[levelValSym];
    },
    set levelVal (n){
        throw Error('levelVal is read-only');
    },
    get msgPrefix () {
        return this[msgPrefixSym];
    },
    get [Symbol.toStringTag] () {
        return 'Pino';
    },
    [lsCacheSym]: initialLsCache,
    [writeSym]: write,
    [asJsonSym]: asJson,
    [getLevelSym]: getLevel,
    [setLevelSym]: setLevel
};
Object.setPrototypeOf(prototype, EventEmitter.prototype);
// exporting and consuming the prototype object using factory pattern fixes scoping issues with getters when serializing
module.exports = function() {
    return Object.create(prototype);
};
const resetChildingsFormatter = (bindings)=>bindings;
function child(bindings, options) {
    if (!bindings) {
        throw Error('missing bindings for child Pino');
    }
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const instance = Object.create(this);
    // If an `options` object was not supplied, we can improve
    // the performance of child creation by skipping
    // the checks for set options and simply return
    // a baseline instance.
    if (options == null) {
        if (instance[formattersSym].bindings !== resetChildingsFormatter) {
            instance[formattersSym] = buildFormatters(formatters.level, resetChildingsFormatter, formatters.log);
        }
        instance[chindingsSym] = asChindings(instance, bindings);
        // Always call setLevel to ensure child gets own method references
        // This prevents issues when parent methods are wrapped (e.g., by Sinon)
        instance[setLevelSym](this.level);
        if (this.onChild !== noop) {
            this.onChild(instance);
        }
        return instance;
    }
    if (options.hasOwnProperty('serializers') === true) {
        instance[serializersSym] = Object.create(null);
        for(const k in serializers){
            instance[serializersSym][k] = serializers[k];
        }
        const parentSymbols = Object.getOwnPropertySymbols(serializers);
        /* eslint no-var: off */ for(var i = 0; i < parentSymbols.length; i++){
            const ks = parentSymbols[i];
            instance[serializersSym][ks] = serializers[ks];
        }
        for(const bk in options.serializers){
            instance[serializersSym][bk] = options.serializers[bk];
        }
        const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
        for(var bi = 0; bi < bindingsSymbols.length; bi++){
            const bks = bindingsSymbols[bi];
            instance[serializersSym][bks] = options.serializers[bks];
        }
    } else instance[serializersSym] = serializers;
    if (options.hasOwnProperty('formatters')) {
        const { level, bindings: chindings, log } = options.formatters;
        instance[formattersSym] = buildFormatters(level || formatters.level, chindings || resetChildingsFormatter, log || formatters.log);
    } else {
        instance[formattersSym] = buildFormatters(formatters.level, resetChildingsFormatter, formatters.log);
    }
    if (options.hasOwnProperty('customLevels') === true) {
        assertNoLevelCollisions(this.levels, options.customLevels);
        instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
        genLsCache(instance);
    }
    // redact must place before asChindings and only replace if exist
    if (typeof options.redact === 'object' && options.redact !== null || Array.isArray(options.redact)) {
        instance.redact = options.redact; // replace redact directly
        const stringifiers = redaction(instance.redact, stringify);
        const formatOpts = {
            stringify: stringifiers[redactFmtSym]
        };
        instance[stringifySym] = stringify;
        instance[stringifiersSym] = stringifiers;
        instance[formatOptsSym] = formatOpts;
    }
    if (typeof options.msgPrefix === 'string') {
        instance[msgPrefixSym] = (this[msgPrefixSym] || '') + options.msgPrefix;
    }
    instance[chindingsSym] = asChindings(instance, bindings);
    const childLevel = options.level || this.level;
    instance[setLevelSym](childLevel);
    this.onChild(instance);
    return instance;
}
function bindings() {
    const chindings = this[chindingsSym];
    const chindingsJson = `{${chindings.substr(1)}}` // at least contains ,"pid":7068,"hostname":"myMac"
    ;
    const bindingsFromJson = JSON.parse(chindingsJson);
    delete bindingsFromJson.pid;
    delete bindingsFromJson.hostname;
    return bindingsFromJson;
}
function setBindings(newBindings) {
    const chindings = asChindings(this, newBindings);
    this[chindingsSym] = chindings;
    delete this[parsedChindingsSym];
}
/**
 * Default strategy for creating `mergeObject` from arguments and the result from `mixin()`.
 * Fields from `mergeObject` have higher priority in this strategy.
 *
 * @param {Object} mergeObject The object a user has supplied to the logging function.
 * @param {Object} mixinObject The result of the `mixin` method.
 * @return {Object}
 */ function defaultMixinMergeStrategy(mergeObject, mixinObject) {
    return Object.assign(mixinObject, mergeObject);
}
function write(_obj, msg, num) {
    const t = this[timeSym]();
    const mixin = this[mixinSym];
    const errorKey = this[errorKeySym];
    const messageKey = this[messageKeySym];
    const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
    let obj;
    const streamWriteHook = this[hooksSym].streamWrite;
    if (_obj === undefined || _obj === null) {
        obj = {};
    } else if (_obj instanceof Error) {
        obj = {
            [errorKey]: _obj
        };
        if (msg === undefined) {
            msg = _obj.message;
        }
    } else {
        obj = _obj;
        if (msg === undefined && _obj[messageKey] === undefined && _obj[errorKey]) {
            msg = _obj[errorKey].message;
        }
    }
    if (mixin) {
        obj = mixinMergeStrategy(obj, mixin(obj, num, this));
    }
    const s = this[asJsonSym](obj, msg, num, t);
    const stream = this[streamSym];
    if (stream[needsMetadataGsym] === true) {
        stream.lastLevel = num;
        stream.lastObj = obj;
        stream.lastMsg = msg;
        stream.lastTime = t.slice(this[timeSliceIndexSym]);
        stream.lastLogger = this; // for child loggers
    }
    stream.write(streamWriteHook ? streamWriteHook(s) : s);
}
function flush(cb) {
    if (cb != null && typeof cb !== 'function') {
        throw Error('callback must be a function');
    }
    const stream = this[streamSym];
    if (typeof stream.flush === 'function') {
        stream.flush(cb || noop);
    } else if (cb) cb();
}
}),
"[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/pino.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const os = __turbopack_context__.r("[externals]/node:os [external] (node:os, cjs)");
const stdSerializers = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/index.js [app-rsc] (ecmascript)");
const caller = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/caller.js [app-rsc] (ecmascript)");
const redaction = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/redaction.js [app-rsc] (ecmascript)");
const time = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/time.js [app-rsc] (ecmascript)");
const proto = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/proto.js [app-rsc] (ecmascript)");
const symbols = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/symbols.js [app-rsc] (ecmascript)");
const { configure } = __turbopack_context__.r("[project]/node_modules/.pnpm/safe-stable-stringify@2.5.0/node_modules/safe-stable-stringify/index.js [app-rsc] (ecmascript)");
const { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/levels.js [app-rsc] (ecmascript)");
const { DEFAULT_LEVELS, SORTING_ORDER } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/constants.js [app-rsc] (ecmascript)");
const { createArgsNormalizer, asChindings, buildSafeSonicBoom, buildFormatters, stringify, normalizeDestFileDescriptor, noop } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/tools.js [app-rsc] (ecmascript)");
const { version } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/meta.js [app-rsc] (ecmascript)");
const { chindingsSym, redactFmtSym, serializersSym, timeSym, timeSliceIndexSym, streamSym, stringifySym, stringifySafeSym, stringifiersSym, setLevelSym, endSym, formatOptsSym, messageKeySym, errorKeySym, nestedKeySym, mixinSym, levelCompSym, useOnlyCustomLevelsSym, formattersSym, hooksSym, nestedKeyStrSym, mixinMergeStrategySym, msgPrefixSym } = symbols;
const { epochTime, nullTime } = time;
const { pid } = process;
const hostname = os.hostname();
const defaultErrorSerializer = stdSerializers.err;
const defaultOptions = {
    level: 'info',
    levelComparison: SORTING_ORDER.ASC,
    levels: DEFAULT_LEVELS,
    messageKey: 'msg',
    errorKey: 'err',
    nestedKey: null,
    enabled: true,
    base: {
        pid,
        hostname
    },
    serializers: Object.assign(Object.create(null), {
        err: defaultErrorSerializer
    }),
    formatters: Object.assign(Object.create(null), {
        bindings (bindings) {
            return bindings;
        },
        level (label, number) {
            return {
                level: number
            };
        }
    }),
    hooks: {
        logMethod: undefined,
        streamWrite: undefined
    },
    timestamp: epochTime,
    name: undefined,
    redact: null,
    customLevels: null,
    useOnlyCustomLevels: false,
    depthLimit: 5,
    edgeLimit: 100
};
const normalize = createArgsNormalizer(defaultOptions);
const serializers = Object.assign(Object.create(null), stdSerializers);
function pino(...args) {
    const instance = {};
    const { opts, stream } = normalize(instance, caller(), ...args);
    if (opts.level && typeof opts.level === 'string' && DEFAULT_LEVELS[opts.level.toLowerCase()] !== undefined) opts.level = opts.level.toLowerCase();
    const { redact, crlf, serializers, timestamp, messageKey, errorKey, nestedKey, base, name, level, customLevels, levelComparison, mixin, mixinMergeStrategy, useOnlyCustomLevels, formatters, hooks, depthLimit, edgeLimit, onChild, msgPrefix } = opts;
    const stringifySafe = configure({
        maximumDepth: depthLimit,
        maximumBreadth: edgeLimit
    });
    const allFormatters = buildFormatters(formatters.level, formatters.bindings, formatters.log);
    const stringifyFn = stringify.bind({
        [stringifySafeSym]: stringifySafe
    });
    const stringifiers = redact ? redaction(redact, stringifyFn) : {};
    const formatOpts = redact ? {
        stringify: stringifiers[redactFmtSym]
    } : {
        stringify: stringifyFn
    };
    const end = '}' + (crlf ? '\r\n' : '\n');
    const coreChindings = asChindings.bind(null, {
        [chindingsSym]: '',
        [serializersSym]: serializers,
        [stringifiersSym]: stringifiers,
        [stringifySym]: stringify,
        [stringifySafeSym]: stringifySafe,
        [formattersSym]: allFormatters
    });
    let chindings = '';
    if (base !== null) {
        if (name === undefined) {
            chindings = coreChindings(base);
        } else {
            chindings = coreChindings(Object.assign({}, base, {
                name
            }));
        }
    }
    const time = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
    const timeSliceIndex = time().indexOf(':') + 1;
    if (useOnlyCustomLevels && !customLevels) throw Error('customLevels is required if useOnlyCustomLevels is set true');
    if (mixin && typeof mixin !== 'function') throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
    if (msgPrefix && typeof msgPrefix !== 'string') throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
    assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
    const levels = mappings(customLevels, useOnlyCustomLevels);
    if (typeof stream.emit === 'function') {
        stream.emit('message', {
            code: 'PINO_CONFIG',
            config: {
                levels,
                messageKey,
                errorKey
            }
        });
    }
    assertLevelComparison(levelComparison);
    const levelCompFunc = genLevelComparison(levelComparison);
    Object.assign(instance, {
        levels,
        [levelCompSym]: levelCompFunc,
        [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
        [streamSym]: stream,
        [timeSym]: time,
        [timeSliceIndexSym]: timeSliceIndex,
        [stringifySym]: stringify,
        [stringifySafeSym]: stringifySafe,
        [stringifiersSym]: stringifiers,
        [endSym]: end,
        [formatOptsSym]: formatOpts,
        [messageKeySym]: messageKey,
        [errorKeySym]: errorKey,
        [nestedKeySym]: nestedKey,
        // protect against injection
        [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : '',
        [serializersSym]: serializers,
        [mixinSym]: mixin,
        [mixinMergeStrategySym]: mixinMergeStrategy,
        [chindingsSym]: chindings,
        [formattersSym]: allFormatters,
        [hooksSym]: hooks,
        silent: noop,
        onChild,
        [msgPrefixSym]: msgPrefix
    });
    Object.setPrototypeOf(instance, proto());
    genLsCache(instance);
    instance[setLevelSym](level);
    return instance;
}
module.exports = pino;
module.exports.destination = (dest = process.stdout.fd)=>{
    if (typeof dest === 'object') {
        dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
        return buildSafeSonicBoom(dest);
    } else {
        return buildSafeSonicBoom({
            dest: normalizeDestFileDescriptor(dest),
            minLength: 0
        });
    }
};
module.exports.transport = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/transport.js [app-rsc] (ecmascript)");
module.exports.multistream = __turbopack_context__.r("[project]/node_modules/.pnpm/pino@9.14.0/node_modules/pino/lib/multistream.js [app-rsc] (ecmascript)");
module.exports.levels = mappings();
module.exports.stdSerializers = serializers;
module.exports.stdTimeFunctions = Object.assign({}, time);
module.exports.symbols = symbols;
module.exports.version = version;
// Enables default and name export with TypeScript and Babel
module.exports.default = pino;
module.exports.pino = pino;
}),
"[project]/node_modules/.pnpm/atomic-sleep@1.0.0/node_modules/atomic-sleep/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* global SharedArrayBuffer, Atomics */ if (typeof SharedArrayBuffer !== 'undefined' && typeof Atomics !== 'undefined') {
    const nil = new Int32Array(new SharedArrayBuffer(4));
    function sleep(ms) {
        // also filters out NaN, non-number types, including empty strings, but allows bigints
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
            if (typeof ms !== 'number' && typeof ms !== 'bigint') {
                throw TypeError('sleep: ms must be a number');
            }
            throw RangeError('sleep: ms must be a number that is greater than 0 but less than Infinity');
        }
        Atomics.wait(nil, 0, 0, Number(ms));
    }
    module.exports = sleep;
} else {
    function sleep1(ms) {
        // also filters out NaN, non-number types, including empty strings, but allows bigints
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
            if (typeof ms !== 'number' && typeof ms !== 'bigint') {
                throw TypeError('sleep: ms must be a number');
            }
            throw RangeError('sleep: ms must be a number that is greater than 0 but less than Infinity');
        }
        const target = Date.now() + Number(ms);
        while(target > Date.now()){}
    }
    module.exports = sleep1;
}
}),
"[project]/node_modules/.pnpm/on-exit-leak-free@2.1.2/node_modules/on-exit-leak-free/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const refs = {
    exit: [],
    beforeExit: []
};
const functions = {
    exit: onExit,
    beforeExit: onBeforeExit
};
let registry;
function ensureRegistry() {
    if (registry === undefined) {
        registry = new FinalizationRegistry(clear);
    }
}
function install(event) {
    if (refs[event].length > 0) {
        return;
    }
    process.on(event, functions[event]);
}
function uninstall(event) {
    if (refs[event].length > 0) {
        return;
    }
    process.removeListener(event, functions[event]);
    if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
        registry = undefined;
    }
}
function onExit() {
    callRefs('exit');
}
function onBeforeExit() {
    callRefs('beforeExit');
}
function callRefs(event) {
    for (const ref of refs[event]){
        const obj = ref.deref();
        const fn = ref.fn;
        // This should always happen, however GC is
        // undeterministic so it might not happen.
        /* istanbul ignore else */ if (obj !== undefined) {
            fn(obj, event);
        }
    }
    refs[event] = [];
}
function clear(ref) {
    for (const event of [
        'exit',
        'beforeExit'
    ]){
        const index = refs[event].indexOf(ref);
        refs[event].splice(index, index + 1);
        uninstall(event);
    }
}
function _register(event, obj, fn) {
    if (obj === undefined) {
        throw new Error('the object can\'t be undefined');
    }
    install(event);
    const ref = new WeakRef(obj);
    ref.fn = fn;
    ensureRegistry();
    registry.register(obj, ref);
    refs[event].push(ref);
}
function register(obj, fn) {
    _register('exit', obj, fn);
}
function registerBeforeExit(obj, fn) {
    _register('beforeExit', obj, fn);
}
function unregister(obj) {
    if (registry === undefined) {
        return;
    }
    registry.unregister(obj);
    for (const event of [
        'exit',
        'beforeExit'
    ]){
        refs[event] = refs[event].filter((ref)=>{
            const _obj = ref.deref();
            return _obj && _obj !== obj;
        });
        uninstall(event);
    }
}
module.exports = {
    register,
    registerBeforeExit,
    unregister
};
}),
"[project]/node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/package.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"name":"thread-stream","version":"3.1.0","description":"A streaming way to send data to a Node.js Worker Thread","main":"index.js","types":"index.d.ts","dependencies":{"real-require":"^0.2.0"},"devDependencies":{"@types/node":"^20.1.0","@types/tap":"^15.0.0","@yao-pkg/pkg":"^5.11.5","desm":"^1.3.0","fastbench":"^1.0.1","husky":"^9.0.6","pino-elasticsearch":"^8.0.0","sonic-boom":"^4.0.1","standard":"^17.0.0","tap":"^16.2.0","ts-node":"^10.8.0","typescript":"^5.3.2","why-is-node-running":"^2.2.2"},"scripts":{"build":"tsc --noEmit","test":"standard && npm run build && npm run transpile && tap \"test/**/*.test.*js\" && tap --ts test/*.test.*ts","test:ci":"standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts","test:ci:js":"tap --no-check-coverage --timeout=120 --coverage-report=lcovonly \"test/**/*.test.*js\"","test:ci:ts":"tap --ts --no-check-coverage --coverage-report=lcovonly \"test/**/*.test.*ts\"","test:yarn":"npm run transpile && tap \"test/**/*.test.js\" --no-check-coverage","transpile":"sh ./test/ts/transpile.sh","prepare":"husky install"},"standard":{"ignore":["test/ts/**/*","test/syntax-error.mjs"]},"repository":{"type":"git","url":"git+https://github.com/mcollina/thread-stream.git"},"keywords":["worker","thread","threads","stream"],"author":"Matteo Collina <hello@matteocollina.com>","license":"MIT","bugs":{"url":"https://github.com/mcollina/thread-stream/issues"},"homepage":"https://github.com/mcollina/thread-stream#readme"});}),
"[project]/node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/lib/wait.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const MAX_TIMEOUT = 1000;
function wait(state, index, expected, timeout, done) {
    const max = Date.now() + timeout;
    let current = Atomics.load(state, index);
    if (current === expected) {
        done(null, 'ok');
        return;
    }
    let prior = current;
    const check = (backoff)=>{
        if (Date.now() > max) {
            done(null, 'timed-out');
        } else {
            setTimeout(()=>{
                prior = current;
                current = Atomics.load(state, index);
                if (current === prior) {
                    check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
                } else {
                    if (current === expected) done(null, 'ok');
                    else done(null, 'not-equal');
                }
            }, backoff);
        }
    };
    check(1);
}
// let waitDiffCount = 0
function waitDiff(state, index, expected, timeout, done) {
    // const id = waitDiffCount++
    // process._rawDebug(`>>> waitDiff ${id}`)
    const max = Date.now() + timeout;
    let current = Atomics.load(state, index);
    if (current !== expected) {
        done(null, 'ok');
        return;
    }
    const check = (backoff)=>{
        // process._rawDebug(`${id} ${index} current ${current} expected ${expected}`)
        // process._rawDebug('' + backoff)
        if (Date.now() > max) {
            done(null, 'timed-out');
        } else {
            setTimeout(()=>{
                current = Atomics.load(state, index);
                if (current !== expected) {
                    done(null, 'ok');
                } else {
                    check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
                }
            }, backoff);
        }
    };
    check(1);
}
module.exports = {
    wait,
    waitDiff
};
}),
"[project]/node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/lib/indexes.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const WRITE_INDEX = 4;
const READ_INDEX = 8;
module.exports = {
    WRITE_INDEX,
    READ_INDEX
};
}),
"[project]/node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { version } = __turbopack_context__.r("[project]/node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/package.json (json)");
const { EventEmitter } = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const { Worker } = __turbopack_context__.r("[externals]/worker_threads [external] (worker_threads, cjs)");
const { join } = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const { pathToFileURL } = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
const { wait } = __turbopack_context__.r("[project]/node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/lib/wait.js [app-rsc] (ecmascript)");
const { WRITE_INDEX, READ_INDEX } = __turbopack_context__.r("[project]/node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream/lib/indexes.js [app-rsc] (ecmascript)");
const buffer = __turbopack_context__.r("[externals]/buffer [external] (buffer, cjs)");
const assert = __turbopack_context__.r("[externals]/assert [external] (assert, cjs)");
const kImpl = Symbol('kImpl');
// V8 limit for string size
const MAX_STRING = buffer.constants.MAX_STRING_LENGTH;
class FakeWeakRef {
    constructor(value){
        this._value = value;
    }
    deref() {
        return this._value;
    }
}
class FakeFinalizationRegistry {
    register() {}
    unregister() {}
}
// Currently using FinalizationRegistry with code coverage breaks the world
// Ref: https://github.com/nodejs/node/issues/49344
const FinalizationRegistry = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : /*TURBOPACK member replacement*/ __turbopack_context__.g.FinalizationRegistry || FakeFinalizationRegistry;
const WeakRef = process.env.NODE_V8_COVERAGE ? FakeWeakRef : /*TURBOPACK member replacement*/ __turbopack_context__.g.WeakRef || FakeWeakRef;
const registry = new FinalizationRegistry((worker)=>{
    if (worker.exited) {
        return;
    }
    worker.terminate();
});
function createWorker(stream, opts) {
    const { filename, workerData } = opts;
    const bundlerOverrides = '__bundlerPathsOverrides' in globalThis ? globalThis.__bundlerPathsOverrides : {};
    const toExecute = bundlerOverrides['thread-stream-worker'] || join(("TURBOPACK compile-time value", "/ROOT/node_modules/.pnpm/thread-stream@3.1.0/node_modules/thread-stream"), 'lib', 'worker.js');
    const worker = new Worker(toExecute, {
        ...opts.workerOpts,
        trackUnmanagedFds: false,
        workerData: {
            filename: filename.indexOf('file://') === 0 ? filename : pathToFileURL(filename).href,
            dataBuf: stream[kImpl].dataBuf,
            stateBuf: stream[kImpl].stateBuf,
            workerData: {
                $context: {
                    threadStreamVersion: version
                },
                ...workerData
            }
        }
    });
    // We keep a strong reference for now,
    // we need to start writing first
    worker.stream = new FakeWeakRef(stream);
    worker.on('message', onWorkerMessage);
    worker.on('exit', onWorkerExit);
    registry.register(stream, worker);
    return worker;
}
function drain(stream) {
    assert(!stream[kImpl].sync);
    if (stream[kImpl].needDrain) {
        stream[kImpl].needDrain = false;
        stream.emit('drain');
    }
}
function nextFlush(stream) {
    const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    let leftover = stream[kImpl].data.length - writeIndex;
    if (leftover > 0) {
        if (stream[kImpl].buf.length === 0) {
            stream[kImpl].flushing = false;
            if (stream[kImpl].ending) {
                end(stream);
            } else if (stream[kImpl].needDrain) {
                process.nextTick(drain, stream);
            }
            return;
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
            stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
            // process._rawDebug('writing ' + toWrite.length)
            write(stream, toWrite, nextFlush.bind(null, stream));
        } else {
            // multi-byte utf-8
            stream.flush(()=>{
                // err is already handled in flush()
                if (stream.destroyed) {
                    return;
                }
                Atomics.store(stream[kImpl].state, READ_INDEX, 0);
                Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
                // Find a toWrite length that fits the buffer
                // it must exists as the buffer is at least 4 bytes length
                // and the max utf-8 length for a char is 4 bytes.
                while(toWriteBytes > stream[kImpl].data.length){
                    leftover = leftover / 2;
                    toWrite = stream[kImpl].buf.slice(0, leftover);
                    toWriteBytes = Buffer.byteLength(toWrite);
                }
                stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
                write(stream, toWrite, nextFlush.bind(null, stream));
            });
        }
    } else if (leftover === 0) {
        if (writeIndex === 0 && stream[kImpl].buf.length === 0) {
            // we had a flushSync in the meanwhile
            return;
        }
        stream.flush(()=>{
            Atomics.store(stream[kImpl].state, READ_INDEX, 0);
            Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
            nextFlush(stream);
        });
    } else {
        // This should never happen
        destroy(stream, new Error('overwritten'));
    }
}
function onWorkerMessage(msg) {
    const stream = this.stream.deref();
    if (stream === undefined) {
        this.exited = true;
        // Terminate the worker.
        this.terminate();
        return;
    }
    switch(msg.code){
        case 'READY':
            // Replace the FakeWeakRef with a
            // proper one.
            this.stream = new WeakRef(stream);
            stream.flush(()=>{
                stream[kImpl].ready = true;
                stream.emit('ready');
            });
            break;
        case 'ERROR':
            destroy(stream, msg.err);
            break;
        case 'EVENT':
            if (Array.isArray(msg.args)) {
                stream.emit(msg.name, ...msg.args);
            } else {
                stream.emit(msg.name, msg.args);
            }
            break;
        case 'WARNING':
            process.emitWarning(msg.err);
            break;
        default:
            destroy(stream, new Error('this should not happen: ' + msg.code));
    }
}
function onWorkerExit(code) {
    const stream = this.stream.deref();
    if (stream === undefined) {
        // Nothing to do, the worker already exit
        return;
    }
    registry.unregister(stream);
    stream.worker.exited = true;
    stream.worker.off('exit', onWorkerExit);
    destroy(stream, code !== 0 ? new Error('the worker thread exited') : null);
}
class ThreadStream extends EventEmitter {
    constructor(opts = {}){
        super();
        if (opts.bufferSize < 4) {
            throw new Error('bufferSize must at least fit a 4-byte utf-8 char');
        }
        this[kImpl] = {};
        this[kImpl].stateBuf = new SharedArrayBuffer(128);
        this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
        this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
        this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
        this[kImpl].sync = opts.sync || false;
        this[kImpl].ending = false;
        this[kImpl].ended = false;
        this[kImpl].needDrain = false;
        this[kImpl].destroyed = false;
        this[kImpl].flushing = false;
        this[kImpl].ready = false;
        this[kImpl].finished = false;
        this[kImpl].errored = null;
        this[kImpl].closed = false;
        this[kImpl].buf = '';
        // TODO (fix): Make private?
        this.worker = createWorker(this, opts); // TODO (fix): make private
        this.on('message', (message, transferList)=>{
            this.worker.postMessage(message, transferList);
        });
    }
    write(data) {
        if (this[kImpl].destroyed) {
            error(this, new Error('the worker has exited'));
            return false;
        }
        if (this[kImpl].ending) {
            error(this, new Error('the worker is ending'));
            return false;
        }
        if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
            try {
                writeSync(this);
                this[kImpl].flushing = true;
            } catch (err) {
                destroy(this, err);
                return false;
            }
        }
        this[kImpl].buf += data;
        if (this[kImpl].sync) {
            try {
                writeSync(this);
                return true;
            } catch (err) {
                destroy(this, err);
                return false;
            }
        }
        if (!this[kImpl].flushing) {
            this[kImpl].flushing = true;
            setImmediate(nextFlush, this);
        }
        this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
        return !this[kImpl].needDrain;
    }
    end() {
        if (this[kImpl].destroyed) {
            return;
        }
        this[kImpl].ending = true;
        end(this);
    }
    flush(cb) {
        if (this[kImpl].destroyed) {
            if (typeof cb === 'function') {
                process.nextTick(cb, new Error('the worker has exited'));
            }
            return;
        }
        // TODO write all .buf
        const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
        // process._rawDebug(`(flush) readIndex (${Atomics.load(this.state, READ_INDEX)}) writeIndex (${Atomics.load(this.state, WRITE_INDEX)})`)
        wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res)=>{
            if (err) {
                destroy(this, err);
                process.nextTick(cb, err);
                return;
            }
            if (res === 'not-equal') {
                // TODO handle deadlock
                this.flush(cb);
                return;
            }
            process.nextTick(cb);
        });
    }
    flushSync() {
        if (this[kImpl].destroyed) {
            return;
        }
        writeSync(this);
        flushSync(this);
    }
    unref() {
        this.worker.unref();
    }
    ref() {
        this.worker.ref();
    }
    get ready() {
        return this[kImpl].ready;
    }
    get destroyed() {
        return this[kImpl].destroyed;
    }
    get closed() {
        return this[kImpl].closed;
    }
    get writable() {
        return !this[kImpl].destroyed && !this[kImpl].ending;
    }
    get writableEnded() {
        return this[kImpl].ending;
    }
    get writableFinished() {
        return this[kImpl].finished;
    }
    get writableNeedDrain() {
        return this[kImpl].needDrain;
    }
    get writableObjectMode() {
        return false;
    }
    get writableErrored() {
        return this[kImpl].errored;
    }
}
function error(stream, err) {
    setImmediate(()=>{
        stream.emit('error', err);
    });
}
function destroy(stream, err) {
    if (stream[kImpl].destroyed) {
        return;
    }
    stream[kImpl].destroyed = true;
    if (err) {
        stream[kImpl].errored = err;
        error(stream, err);
    }
    if (!stream.worker.exited) {
        stream.worker.terminate().catch(()=>{}).then(()=>{
            stream[kImpl].closed = true;
            stream.emit('close');
        });
    } else {
        setImmediate(()=>{
            stream[kImpl].closed = true;
            stream.emit('close');
        });
    }
}
function write(stream, data, cb) {
    // data is smaller than the shared buffer length
    const current = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    const length = Buffer.byteLength(data);
    stream[kImpl].data.write(data, current);
    Atomics.store(stream[kImpl].state, WRITE_INDEX, current + length);
    Atomics.notify(stream[kImpl].state, WRITE_INDEX);
    cb();
    return true;
}
function end(stream) {
    if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing) {
        return;
    }
    stream[kImpl].ended = true;
    try {
        stream.flushSync();
        let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        // process._rawDebug('writing index')
        Atomics.store(stream[kImpl].state, WRITE_INDEX, -1);
        // process._rawDebug(`(end) readIndex (${Atomics.load(stream.state, READ_INDEX)}) writeIndex (${Atomics.load(stream.state, WRITE_INDEX)})`)
        Atomics.notify(stream[kImpl].state, WRITE_INDEX);
        // Wait for the process to complete
        let spins = 0;
        while(readIndex !== -1){
            // process._rawDebug(`read = ${read}`)
            Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1000);
            readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
            if (readIndex === -2) {
                destroy(stream, new Error('end() failed'));
                return;
            }
            if (++spins === 10) {
                destroy(stream, new Error('end() took too long (10s)'));
                return;
            }
        }
        process.nextTick(()=>{
            stream[kImpl].finished = true;
            stream.emit('finish');
        });
    } catch (err) {
        destroy(stream, err);
    }
// process._rawDebug('end finished...')
}
function writeSync(stream) {
    const cb = ()=>{
        if (stream[kImpl].ending) {
            end(stream);
        } else if (stream[kImpl].needDrain) {
            process.nextTick(drain, stream);
        }
    };
    stream[kImpl].flushing = false;
    while(stream[kImpl].buf.length !== 0){
        const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
        let leftover = stream[kImpl].data.length - writeIndex;
        if (leftover === 0) {
            flushSync(stream);
            Atomics.store(stream[kImpl].state, READ_INDEX, 0);
            Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
            continue;
        } else if (leftover < 0) {
            // stream should never happen
            throw new Error('overwritten');
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
            stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
            // process._rawDebug('writing ' + toWrite.length)
            write(stream, toWrite, cb);
        } else {
            // multi-byte utf-8
            flushSync(stream);
            Atomics.store(stream[kImpl].state, READ_INDEX, 0);
            Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
            // Find a toWrite length that fits the buffer
            // it must exists as the buffer is at least 4 bytes length
            // and the max utf-8 length for a char is 4 bytes.
            while(toWriteBytes > stream[kImpl].buf.length){
                leftover = leftover / 2;
                toWrite = stream[kImpl].buf.slice(0, leftover);
                toWriteBytes = Buffer.byteLength(toWrite);
            }
            stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
            write(stream, toWrite, cb);
        }
    }
}
function flushSync(stream) {
    if (stream[kImpl].flushing) {
        throw new Error('unable to flush while flushing');
    }
    // process._rawDebug('flushSync started')
    const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    let spins = 0;
    // TODO handle deadlock
    while(true){
        const readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
            throw Error('_flushSync failed');
        }
        // process._rawDebug(`(flushSync) readIndex (${readIndex}) writeIndex (${writeIndex})`)
        if (readIndex !== writeIndex) {
            // TODO stream timeouts for some reason.
            Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1000);
        } else {
            break;
        }
        if (++spins === 10) {
            throw new Error('_flushSync took too long (10s)');
        }
    }
// process._rawDebug('flushSync finished')
}
module.exports = ThreadStream;
}),
"[project]/node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/err-helpers.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// **************************************************************
// * Code initially copied/adapted from "pony-cause" npm module *
// * Please upstream improvements there                         *
// **************************************************************
const isErrorLike = (err)=>{
    return err && typeof err.message === 'string';
};
/**
 * @param {Error|{ cause?: unknown|(()=>err)}} err
 * @returns {Error|Object|undefined}
 */ const getErrorCause = (err)=>{
    if (!err) return;
    /** @type {unknown} */ // @ts-ignore
    const cause = err.cause;
    // VError / NError style causes
    if (typeof cause === 'function') {
        // @ts-ignore
        const causeResult = err.cause();
        return isErrorLike(causeResult) ? causeResult : undefined;
    } else {
        return isErrorLike(cause) ? cause : undefined;
    }
};
/**
 * Internal method that keeps a track of which error we have already added, to avoid circular recursion
 *
 * @private
 * @param {Error} err
 * @param {Set<Error>} seen
 * @returns {string}
 */ const _stackWithCauses = (err, seen)=>{
    if (!isErrorLike(err)) return '';
    const stack = err.stack || '';
    // Ensure we don't go circular or crazily deep
    if (seen.has(err)) {
        return stack + '\ncauses have become circular...';
    }
    const cause = getErrorCause(err);
    if (cause) {
        seen.add(err);
        return stack + '\ncaused by: ' + _stackWithCauses(cause, seen);
    } else {
        return stack;
    }
};
/**
 * @param {Error} err
 * @returns {string}
 */ const stackWithCauses = (err)=>_stackWithCauses(err, new Set());
/**
 * Internal method that keeps a track of which error we have already added, to avoid circular recursion
 *
 * @private
 * @param {Error} err
 * @param {Set<Error>} seen
 * @param {boolean} [skip]
 * @returns {string}
 */ const _messageWithCauses = (err, seen, skip)=>{
    if (!isErrorLike(err)) return '';
    const message = skip ? '' : err.message || '';
    // Ensure we don't go circular or crazily deep
    if (seen.has(err)) {
        return message + ': ...';
    }
    const cause = getErrorCause(err);
    if (cause) {
        seen.add(err);
        // @ts-ignore
        const skipIfVErrorStyleCause = typeof err.cause === 'function';
        return message + (skipIfVErrorStyleCause ? '' : ': ') + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
    } else {
        return message;
    }
};
/**
 * @param {Error} err
 * @returns {string}
 */ const messageWithCauses = (err)=>_messageWithCauses(err, new Set());
module.exports = {
    isErrorLike,
    getErrorCause,
    stackWithCauses,
    messageWithCauses
};
}),
"[project]/node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/err-proto.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const seen = Symbol('circular-ref-tag');
const rawSymbol = Symbol('pino-raw-err-ref');
const pinoErrProto = Object.create({}, {
    type: {
        enumerable: true,
        writable: true,
        value: undefined
    },
    message: {
        enumerable: true,
        writable: true,
        value: undefined
    },
    stack: {
        enumerable: true,
        writable: true,
        value: undefined
    },
    aggregateErrors: {
        enumerable: true,
        writable: true,
        value: undefined
    },
    raw: {
        enumerable: false,
        get: function() {
            return this[rawSymbol];
        },
        set: function(val) {
            this[rawSymbol] = val;
        }
    }
});
Object.defineProperty(pinoErrProto, rawSymbol, {
    writable: true,
    value: {}
});
module.exports = {
    pinoErrProto,
    pinoErrorSymbols: {
        seen,
        rawSymbol
    }
};
}),
"[project]/node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/err.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = errSerializer;
const { messageWithCauses, stackWithCauses, isErrorLike } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/err-helpers.js [app-rsc] (ecmascript)");
const { pinoErrProto, pinoErrorSymbols } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/err-proto.js [app-rsc] (ecmascript)");
const { seen } = pinoErrorSymbols;
const { toString } = Object.prototype;
function errSerializer(err) {
    if (!isErrorLike(err)) {
        return err;
    }
    err[seen] = undefined; // tag to prevent re-looking at this
    const _err = Object.create(pinoErrProto);
    _err.type = toString.call(err.constructor) === '[object Function]' ? err.constructor.name : err.name;
    _err.message = messageWithCauses(err);
    _err.stack = stackWithCauses(err);
    if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err)=>errSerializer(err));
    }
    for(const key in err){
        if (_err[key] === undefined) {
            const val = err[key];
            if (isErrorLike(val)) {
                // We append cause messages and stacks to _err, therefore skipping causes here
                if (key !== 'cause' && !Object.prototype.hasOwnProperty.call(val, seen)) {
                    _err[key] = errSerializer(val);
                }
            } else {
                _err[key] = val;
            }
        }
    }
    delete err[seen]; // clean up tag in case err is serialized again later
    _err.raw = err;
    return _err;
}
}),
"[project]/node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/err-with-cause.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = errWithCauseSerializer;
const { isErrorLike } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/err-helpers.js [app-rsc] (ecmascript)");
const { pinoErrProto, pinoErrorSymbols } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/err-proto.js [app-rsc] (ecmascript)");
const { seen } = pinoErrorSymbols;
const { toString } = Object.prototype;
function errWithCauseSerializer(err) {
    if (!isErrorLike(err)) {
        return err;
    }
    err[seen] = undefined; // tag to prevent re-looking at this
    const _err = Object.create(pinoErrProto);
    _err.type = toString.call(err.constructor) === '[object Function]' ? err.constructor.name : err.name;
    _err.message = err.message;
    _err.stack = err.stack;
    if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err)=>errWithCauseSerializer(err));
    }
    if (isErrorLike(err.cause) && !Object.prototype.hasOwnProperty.call(err.cause, seen)) {
        _err.cause = errWithCauseSerializer(err.cause);
    }
    for(const key in err){
        if (_err[key] === undefined) {
            const val = err[key];
            if (isErrorLike(val)) {
                if (!Object.prototype.hasOwnProperty.call(val, seen)) {
                    _err[key] = errWithCauseSerializer(val);
                }
            } else {
                _err[key] = val;
            }
        }
    }
    delete err[seen]; // clean up tag in case err is serialized again later
    _err.raw = err;
    return _err;
}
}),
"[project]/node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/req.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {
    mapHttpRequest,
    reqSerializer
};
const rawSymbol = Symbol('pino-raw-req-ref');
const pinoReqProto = Object.create({}, {
    id: {
        enumerable: true,
        writable: true,
        value: ''
    },
    method: {
        enumerable: true,
        writable: true,
        value: ''
    },
    url: {
        enumerable: true,
        writable: true,
        value: ''
    },
    query: {
        enumerable: true,
        writable: true,
        value: ''
    },
    params: {
        enumerable: true,
        writable: true,
        value: ''
    },
    headers: {
        enumerable: true,
        writable: true,
        value: {}
    },
    remoteAddress: {
        enumerable: true,
        writable: true,
        value: ''
    },
    remotePort: {
        enumerable: true,
        writable: true,
        value: ''
    },
    raw: {
        enumerable: false,
        get: function() {
            return this[rawSymbol];
        },
        set: function(val) {
            this[rawSymbol] = val;
        }
    }
});
Object.defineProperty(pinoReqProto, rawSymbol, {
    writable: true,
    value: {}
});
function reqSerializer(req) {
    // req.info is for hapi compat.
    const connection = req.info || req.socket;
    const _req = Object.create(pinoReqProto);
    _req.id = typeof req.id === 'function' ? req.id() : req.id || (req.info ? req.info.id : undefined);
    _req.method = req.method;
    // req.originalUrl is for expressjs compat.
    if (req.originalUrl) {
        _req.url = req.originalUrl;
    } else {
        const path = req.path;
        // path for safe hapi compat.
        _req.url = typeof path === 'string' ? path : req.url ? req.url.path || req.url : undefined;
    }
    if (req.query) {
        _req.query = req.query;
    }
    if (req.params) {
        _req.params = req.params;
    }
    _req.headers = req.headers;
    _req.remoteAddress = connection && connection.remoteAddress;
    _req.remotePort = connection && connection.remotePort;
    // req.raw is  for hapi compat/equivalence
    _req.raw = req.raw || req;
    return _req;
}
function mapHttpRequest(req) {
    return {
        req: reqSerializer(req)
    };
}
}),
"[project]/node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/res.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {
    mapHttpResponse,
    resSerializer
};
const rawSymbol = Symbol('pino-raw-res-ref');
const pinoResProto = Object.create({}, {
    statusCode: {
        enumerable: true,
        writable: true,
        value: 0
    },
    headers: {
        enumerable: true,
        writable: true,
        value: ''
    },
    raw: {
        enumerable: false,
        get: function() {
            return this[rawSymbol];
        },
        set: function(val) {
            this[rawSymbol] = val;
        }
    }
});
Object.defineProperty(pinoResProto, rawSymbol, {
    writable: true,
    value: {}
});
function resSerializer(res) {
    const _res = Object.create(pinoResProto);
    _res.statusCode = res.headersSent ? res.statusCode : null;
    _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
    _res.raw = res;
    return _res;
}
function mapHttpResponse(res) {
    return {
        res: resSerializer(res)
    };
}
}),
"[project]/node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const errSerializer = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/err.js [app-rsc] (ecmascript)");
const errWithCauseSerializer = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/err-with-cause.js [app-rsc] (ecmascript)");
const reqSerializers = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/req.js [app-rsc] (ecmascript)");
const resSerializers = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-std-serializers@7.0.0/node_modules/pino-std-serializers/lib/res.js [app-rsc] (ecmascript)");
module.exports = {
    err: errSerializer,
    errWithCause: errWithCauseSerializer,
    mapHttpRequest: reqSerializers.mapHttpRequest,
    mapHttpResponse: resSerializers.mapHttpResponse,
    req: reqSerializers.reqSerializer,
    res: resSerializers.resSerializer,
    wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
        if (customSerializer === errSerializer) return customSerializer;
        return function wrapErrSerializer(err) {
            return customSerializer(errSerializer(err));
        };
    },
    wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
        if (customSerializer === reqSerializers.reqSerializer) return customSerializer;
        return function wrappedReqSerializer(req) {
            return customSerializer(reqSerializers.reqSerializer(req));
        };
    },
    wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
        if (customSerializer === resSerializers.resSerializer) return customSerializer;
        return function wrappedResSerializer(res) {
            return customSerializer(resSerializers.resSerializer(res));
        };
    }
};
}),
"[project]/node_modules/.pnpm/@pinojs+redact@0.4.0/node_modules/@pinojs/redact/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function deepClone(obj) {
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    if (obj instanceof Date) {
        return new Date(obj.getTime());
    }
    if (obj instanceof Array) {
        const cloned = [];
        for(let i = 0; i < obj.length; i++){
            cloned[i] = deepClone(obj[i]);
        }
        return cloned;
    }
    if (typeof obj === 'object') {
        const cloned = Object.create(Object.getPrototypeOf(obj));
        for(const key in obj){
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                cloned[key] = deepClone(obj[key]);
            }
        }
        return cloned;
    }
    return obj;
}
function parsePath(path) {
    const parts = [];
    let current = '';
    let inBrackets = false;
    let inQuotes = false;
    let quoteChar = '';
    for(let i = 0; i < path.length; i++){
        const char = path[i];
        if (!inBrackets && char === '.') {
            if (current) {
                parts.push(current);
                current = '';
            }
        } else if (char === '[') {
            if (current) {
                parts.push(current);
                current = '';
            }
            inBrackets = true;
        } else if (char === ']' && inBrackets) {
            // Always push the current value when closing brackets, even if it's an empty string
            parts.push(current);
            current = '';
            inBrackets = false;
            inQuotes = false;
        } else if ((char === '"' || char === "'") && inBrackets) {
            if (!inQuotes) {
                inQuotes = true;
                quoteChar = char;
            } else if (char === quoteChar) {
                inQuotes = false;
                quoteChar = '';
            } else {
                current += char;
            }
        } else {
            current += char;
        }
    }
    if (current) {
        parts.push(current);
    }
    return parts;
}
function setValue(obj, parts, value) {
    let current = obj;
    for(let i = 0; i < parts.length - 1; i++){
        const key = parts[i];
        // Type safety: Check if current is an object before using 'in' operator
        if (typeof current !== 'object' || current === null || !(key in current)) {
            return false // Path doesn't exist, don't create it
            ;
        }
        if (typeof current[key] !== 'object' || current[key] === null) {
            return false // Path doesn't exist properly
            ;
        }
        current = current[key];
    }
    const lastKey = parts[parts.length - 1];
    if (lastKey === '*') {
        if (Array.isArray(current)) {
            for(let i = 0; i < current.length; i++){
                current[i] = value;
            }
        } else if (typeof current === 'object' && current !== null) {
            for(const key in current){
                if (Object.prototype.hasOwnProperty.call(current, key)) {
                    current[key] = value;
                }
            }
        }
    } else {
        // Type safety: Check if current is an object before using 'in' operator
        if (typeof current === 'object' && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {
            current[lastKey] = value;
        }
    }
    return true;
}
function removeKey(obj, parts) {
    let current = obj;
    for(let i = 0; i < parts.length - 1; i++){
        const key = parts[i];
        // Type safety: Check if current is an object before using 'in' operator
        if (typeof current !== 'object' || current === null || !(key in current)) {
            return false // Path doesn't exist, don't create it
            ;
        }
        if (typeof current[key] !== 'object' || current[key] === null) {
            return false // Path doesn't exist properly
            ;
        }
        current = current[key];
    }
    const lastKey = parts[parts.length - 1];
    if (lastKey === '*') {
        if (Array.isArray(current)) {
            // For arrays, we can't really "remove" all items as that would change indices
            // Instead, we set them to undefined which will be omitted by JSON.stringify
            for(let i = 0; i < current.length; i++){
                current[i] = undefined;
            }
        } else if (typeof current === 'object' && current !== null) {
            for(const key in current){
                if (Object.prototype.hasOwnProperty.call(current, key)) {
                    delete current[key];
                }
            }
        }
    } else {
        // Type safety: Check if current is an object before using 'in' operator
        if (typeof current === 'object' && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {
            delete current[lastKey];
        }
    }
    return true;
}
// Sentinel object to distinguish between undefined value and non-existent path
const PATH_NOT_FOUND = Symbol('PATH_NOT_FOUND');
function getValueIfExists(obj, parts) {
    let current = obj;
    for (const part of parts){
        if (current === null || current === undefined) {
            return PATH_NOT_FOUND;
        }
        // Type safety: Check if current is an object before property access
        if (typeof current !== 'object' || current === null) {
            return PATH_NOT_FOUND;
        }
        // Check if the property exists before accessing it
        if (!(part in current)) {
            return PATH_NOT_FOUND;
        }
        current = current[part];
    }
    return current;
}
function getValue(obj, parts) {
    let current = obj;
    for (const part of parts){
        if (current === null || current === undefined) {
            return undefined;
        }
        // Type safety: Check if current is an object before property access
        if (typeof current !== 'object' || current === null) {
            return undefined;
        }
        current = current[part];
    }
    return current;
}
function redactPaths(obj, paths, censor, remove = false) {
    for (const path of paths){
        const parts = parsePath(path);
        if (parts.includes('*')) {
            redactWildcardPath(obj, parts, censor, path, remove);
        } else {
            if (remove) {
                removeKey(obj, parts);
            } else {
                // Get value only if path exists - single traversal
                const value = getValueIfExists(obj, parts);
                if (value === PATH_NOT_FOUND) {
                    continue;
                }
                const actualCensor = typeof censor === 'function' ? censor(value, parts) : censor;
                setValue(obj, parts, actualCensor);
            }
        }
    }
}
function redactWildcardPath(obj, parts, censor, originalPath, remove = false) {
    const wildcardIndex = parts.indexOf('*');
    if (wildcardIndex === parts.length - 1) {
        const parentParts = parts.slice(0, -1);
        let current = obj;
        for (const part of parentParts){
            if (current === null || current === undefined) return;
            // Type safety: Check if current is an object before property access
            if (typeof current !== 'object' || current === null) return;
            current = current[part];
        }
        if (Array.isArray(current)) {
            if (remove) {
                // For arrays, set all items to undefined which will be omitted by JSON.stringify
                for(let i = 0; i < current.length; i++){
                    current[i] = undefined;
                }
            } else {
                for(let i = 0; i < current.length; i++){
                    const indexPath = [
                        ...parentParts,
                        i.toString()
                    ];
                    const actualCensor = typeof censor === 'function' ? censor(current[i], indexPath) : censor;
                    current[i] = actualCensor;
                }
            }
        } else if (typeof current === 'object' && current !== null) {
            if (remove) {
                // Collect keys to delete to avoid issues with deleting during iteration
                const keysToDelete = [];
                for(const key in current){
                    if (Object.prototype.hasOwnProperty.call(current, key)) {
                        keysToDelete.push(key);
                    }
                }
                for (const key of keysToDelete){
                    delete current[key];
                }
            } else {
                for(const key in current){
                    const keyPath = [
                        ...parentParts,
                        key
                    ];
                    const actualCensor = typeof censor === 'function' ? censor(current[key], keyPath) : censor;
                    current[key] = actualCensor;
                }
            }
        }
    } else {
        redactIntermediateWildcard(obj, parts, censor, wildcardIndex, originalPath, remove);
    }
}
function redactIntermediateWildcard(obj, parts, censor, wildcardIndex, originalPath, remove = false) {
    const beforeWildcard = parts.slice(0, wildcardIndex);
    const afterWildcard = parts.slice(wildcardIndex + 1);
    const pathArray = [] // Cached array to avoid allocations
    ;
    function traverse(current, pathLength) {
        if (pathLength === beforeWildcard.length) {
            if (Array.isArray(current)) {
                for(let i = 0; i < current.length; i++){
                    pathArray[pathLength] = i.toString();
                    traverse(current[i], pathLength + 1);
                }
            } else if (typeof current === 'object' && current !== null) {
                for(const key in current){
                    pathArray[pathLength] = key;
                    traverse(current[key], pathLength + 1);
                }
            }
        } else if (pathLength < beforeWildcard.length) {
            const nextKey = beforeWildcard[pathLength];
            // Type safety: Check if current is an object before using 'in' operator
            if (current && typeof current === 'object' && current !== null && nextKey in current) {
                pathArray[pathLength] = nextKey;
                traverse(current[nextKey], pathLength + 1);
            }
        } else {
            // Check if afterWildcard contains more wildcards
            if (afterWildcard.includes('*')) {
                // Recursively handle remaining wildcards
                // Wrap censor to prepend current path context
                const wrappedCensor = typeof censor === 'function' ? (value, path)=>{
                    const fullPath = [
                        ...pathArray.slice(0, pathLength),
                        ...path
                    ];
                    return censor(value, fullPath);
                } : censor;
                redactWildcardPath(current, afterWildcard, wrappedCensor, originalPath, remove);
            } else {
                // No more wildcards, apply the redaction directly
                if (remove) {
                    removeKey(current, afterWildcard);
                } else {
                    const actualCensor = typeof censor === 'function' ? censor(getValue(current, afterWildcard), [
                        ...pathArray.slice(0, pathLength),
                        ...afterWildcard
                    ]) : censor;
                    setValue(current, afterWildcard, actualCensor);
                }
            }
        }
    }
    if (beforeWildcard.length === 0) {
        traverse(obj, 0);
    } else {
        let current = obj;
        for(let i = 0; i < beforeWildcard.length; i++){
            const part = beforeWildcard[i];
            if (current === null || current === undefined) return;
            // Type safety: Check if current is an object before property access
            if (typeof current !== 'object' || current === null) return;
            current = current[part];
            pathArray[i] = part;
        }
        if (current !== null && current !== undefined) {
            traverse(current, beforeWildcard.length);
        }
    }
}
function buildPathStructure(pathsToClone) {
    if (pathsToClone.length === 0) {
        return null // No paths to redact
        ;
    }
    // Parse all paths and organize by depth
    const pathStructure = new Map();
    for (const path of pathsToClone){
        const parts = parsePath(path);
        let current = pathStructure;
        for(let i = 0; i < parts.length; i++){
            const part = parts[i];
            if (!current.has(part)) {
                current.set(part, new Map());
            }
            current = current.get(part);
        }
    }
    return pathStructure;
}
function selectiveClone(obj, pathStructure) {
    if (!pathStructure) {
        return obj // No paths to redact, return original
        ;
    }
    function cloneSelectively(source, pathMap, depth = 0) {
        if (!pathMap || pathMap.size === 0) {
            return source // No more paths to clone, return reference
            ;
        }
        if (source === null || typeof source !== 'object') {
            return source;
        }
        if (source instanceof Date) {
            return new Date(source.getTime());
        }
        if (Array.isArray(source)) {
            const cloned = [];
            for(let i = 0; i < source.length; i++){
                const indexStr = i.toString();
                if (pathMap.has(indexStr) || pathMap.has('*')) {
                    cloned[i] = cloneSelectively(source[i], pathMap.get(indexStr) || pathMap.get('*'));
                } else {
                    cloned[i] = source[i]; // Share reference for non-redacted items
                }
            }
            return cloned;
        }
        // Handle objects
        const cloned = Object.create(Object.getPrototypeOf(source));
        for(const key in source){
            if (Object.prototype.hasOwnProperty.call(source, key)) {
                if (pathMap.has(key) || pathMap.has('*')) {
                    cloned[key] = cloneSelectively(source[key], pathMap.get(key) || pathMap.get('*'));
                } else {
                    cloned[key] = source[key]; // Share reference for non-redacted properties
                }
            }
        }
        return cloned;
    }
    return cloneSelectively(obj, pathStructure);
}
function validatePath(path) {
    if (typeof path !== 'string') {
        throw new Error('Paths must be (non-empty) strings');
    }
    if (path === '') {
        throw new Error('Invalid redaction path ()');
    }
    // Check for double dots
    if (path.includes('..')) {
        throw new Error(`Invalid redaction path (${path})`);
    }
    // Check for comma-separated paths (invalid syntax)
    if (path.includes(',')) {
        throw new Error(`Invalid redaction path (${path})`);
    }
    // Check for unmatched brackets
    let bracketCount = 0;
    let inQuotes = false;
    let quoteChar = '';
    for(let i = 0; i < path.length; i++){
        const char = path[i];
        if ((char === '"' || char === "'") && bracketCount > 0) {
            if (!inQuotes) {
                inQuotes = true;
                quoteChar = char;
            } else if (char === quoteChar) {
                inQuotes = false;
                quoteChar = '';
            }
        } else if (char === '[' && !inQuotes) {
            bracketCount++;
        } else if (char === ']' && !inQuotes) {
            bracketCount--;
            if (bracketCount < 0) {
                throw new Error(`Invalid redaction path (${path})`);
            }
        }
    }
    if (bracketCount !== 0) {
        throw new Error(`Invalid redaction path (${path})`);
    }
}
function validatePaths(paths) {
    if (!Array.isArray(paths)) {
        throw new TypeError('paths must be an array');
    }
    for (const path of paths){
        validatePath(path);
    }
}
function slowRedact(options = {}) {
    const { paths = [], censor = '[REDACTED]', serialize = JSON.stringify, strict = true, remove = false } = options;
    // Validate paths upfront to match fast-redact behavior
    validatePaths(paths);
    // Build path structure once during setup, not on every call
    const pathStructure = buildPathStructure(paths);
    return function redact(obj) {
        if (strict && (obj === null || typeof obj !== 'object')) {
            if (obj === null || obj === undefined) {
                return serialize ? serialize(obj) : obj;
            }
            if (typeof obj !== 'object') {
                return serialize ? serialize(obj) : obj;
            }
        }
        // Only clone paths that need redaction
        const cloned = selectiveClone(obj, pathStructure);
        const original = obj // Keep reference to original for restore
        ;
        let actualCensor = censor;
        if (typeof censor === 'function') {
            actualCensor = censor;
        }
        redactPaths(cloned, paths, actualCensor, remove);
        if (serialize === false) {
            cloned.restore = function() {
                return deepClone(original) // Full clone only when restore is called
                ;
            };
            return cloned;
        }
        if (typeof serialize === 'function') {
            return serialize(cloned);
        }
        return JSON.stringify(cloned);
    };
}
module.exports = slowRedact;
}),
"[project]/node_modules/.pnpm/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function tryStringify(o) {
    try {
        return JSON.stringify(o);
    } catch (e) {
        return '"[Circular]"';
    }
}
module.exports = format;
function format(f, args, opts) {
    var ss = opts && opts.stringify || tryStringify;
    var offset = 1;
    if (typeof f === 'object' && f !== null) {
        var len = args.length + offset;
        if (len === 1) return f;
        var objects = new Array(len);
        objects[0] = ss(f);
        for(var index = 1; index < len; index++){
            objects[index] = ss(args[index]);
        }
        return objects.join(' ');
    }
    if (typeof f !== 'string') {
        return f;
    }
    var argLen = args.length;
    if (argLen === 0) return f;
    var str = '';
    var a = 1 - offset;
    var lastPos = -1;
    var flen = f && f.length || 0;
    for(var i = 0; i < flen;){
        if (f.charCodeAt(i) === 37 && i + 1 < flen) {
            lastPos = lastPos > -1 ? lastPos : 0;
            switch(f.charCodeAt(i + 1)){
                case 100:
                case 102:
                    if (a >= argLen) break;
                    if (args[a] == null) break;
                    if (lastPos < i) str += f.slice(lastPos, i);
                    str += Number(args[a]);
                    lastPos = i + 2;
                    i++;
                    break;
                case 105:
                    if (a >= argLen) break;
                    if (args[a] == null) break;
                    if (lastPos < i) str += f.slice(lastPos, i);
                    str += Math.floor(Number(args[a]));
                    lastPos = i + 2;
                    i++;
                    break;
                case 79:
                case 111:
                case 106:
                    if (a >= argLen) break;
                    if (args[a] === undefined) break;
                    if (lastPos < i) str += f.slice(lastPos, i);
                    var type = typeof args[a];
                    if (type === 'string') {
                        str += '\'' + args[a] + '\'';
                        lastPos = i + 2;
                        i++;
                        break;
                    }
                    if (type === 'function') {
                        str += args[a].name || '<anonymous>';
                        lastPos = i + 2;
                        i++;
                        break;
                    }
                    str += ss(args[a]);
                    lastPos = i + 2;
                    i++;
                    break;
                case 115:
                    if (a >= argLen) break;
                    if (lastPos < i) str += f.slice(lastPos, i);
                    str += String(args[a]);
                    lastPos = i + 2;
                    i++;
                    break;
                case 37:
                    if (lastPos < i) str += f.slice(lastPos, i);
                    str += '%';
                    lastPos = i + 2;
                    i++;
                    a--;
                    break;
            }
            ++a;
        }
        ++i;
    }
    if (lastPos === -1) return f;
    else if (lastPos < flen) {
        str += f.slice(lastPos);
    }
    return str;
}
}),
"[project]/node_modules/.pnpm/sonic-boom@4.2.0/node_modules/sonic-boom/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const EventEmitter = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const inherits = __turbopack_context__.r("[externals]/util [external] (util, cjs)").inherits;
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const sleep = __turbopack_context__.r("[project]/node_modules/.pnpm/atomic-sleep@1.0.0/node_modules/atomic-sleep/index.js [app-rsc] (ecmascript)");
const assert = __turbopack_context__.r("[externals]/assert [external] (assert, cjs)");
const BUSY_WRITE_TIMEOUT = 100;
const kEmptyBuffer = Buffer.allocUnsafe(0);
// 16 KB. Don't write more than docker buffer size.
// https://github.com/moby/moby/blob/513ec73831269947d38a644c278ce3cac36783b2/daemon/logger/copier.go#L13
const MAX_WRITE = 16 * 1024;
const kContentModeBuffer = 'buffer';
const kContentModeUtf8 = 'utf8';
const [major, minor] = (process.versions.node || '0.0').split('.').map(Number);
const kCopyBuffer = major >= 22 && minor >= 7;
function openFile(file, sonic) {
    sonic._opening = true;
    sonic._writing = true;
    sonic._asyncDrainScheduled = false;
    // NOTE: 'error' and 'ready' events emitted below only relevant when sonic.sync===false
    // for sync mode, there is no way to add a listener that will receive these
    function fileOpened(err, fd) {
        if (err) {
            sonic._reopening = false;
            sonic._writing = false;
            sonic._opening = false;
            if (sonic.sync) {
                process.nextTick(()=>{
                    if (sonic.listenerCount('error') > 0) {
                        sonic.emit('error', err);
                    }
                });
            } else {
                sonic.emit('error', err);
            }
            return;
        }
        const reopening = sonic._reopening;
        sonic.fd = fd;
        sonic.file = file;
        sonic._reopening = false;
        sonic._opening = false;
        sonic._writing = false;
        if (sonic.sync) {
            process.nextTick(()=>sonic.emit('ready'));
        } else {
            sonic.emit('ready');
        }
        if (sonic.destroyed) {
            return;
        }
        // start
        if (!sonic._writing && sonic._len > sonic.minLength || sonic._flushPending) {
            sonic._actualWrite();
        } else if (reopening) {
            process.nextTick(()=>sonic.emit('drain'));
        }
    }
    const flags = sonic.append ? 'a' : 'w';
    const mode = sonic.mode;
    if (sonic.sync) {
        try {
            if (sonic.mkdir) fs.mkdirSync(path.dirname(file), {
                recursive: true
            });
            const fd = fs.openSync(file, flags, mode);
            fileOpened(null, fd);
        } catch (err) {
            fileOpened(err);
            throw err;
        }
    } else if (sonic.mkdir) {
        fs.mkdir(path.dirname(file), {
            recursive: true
        }, (err)=>{
            if (err) return fileOpened(err);
            fs.open(file, flags, mode, fileOpened);
        });
    } else {
        fs.open(file, flags, mode, fileOpened);
    }
}
function SonicBoom(opts) {
    if (!(this instanceof SonicBoom)) {
        return new SonicBoom(opts);
    }
    let { fd, dest, minLength, maxLength, maxWrite, periodicFlush, sync, append = true, mkdir, retryEAGAIN, fsync, contentMode, mode } = opts || {};
    fd = fd || dest;
    this._len = 0;
    this.fd = -1;
    this._bufs = [];
    this._lens = [];
    this._writing = false;
    this._ending = false;
    this._reopening = false;
    this._asyncDrainScheduled = false;
    this._flushPending = false;
    this._hwm = Math.max(minLength || 0, 16387);
    this.file = null;
    this.destroyed = false;
    this.minLength = minLength || 0;
    this.maxLength = maxLength || 0;
    this.maxWrite = maxWrite || MAX_WRITE;
    this._periodicFlush = periodicFlush || 0;
    this._periodicFlushTimer = undefined;
    this.sync = sync || false;
    this.writable = true;
    this._fsync = fsync || false;
    this.append = append || false;
    this.mode = mode;
    this.retryEAGAIN = retryEAGAIN || (()=>true);
    this.mkdir = mkdir || false;
    let fsWriteSync;
    let fsWrite;
    if (contentMode === kContentModeBuffer) {
        this._writingBuf = kEmptyBuffer;
        this.write = writeBuffer;
        this.flush = flushBuffer;
        this.flushSync = flushBufferSync;
        this._actualWrite = actualWriteBuffer;
        fsWriteSync = ()=>fs.writeSync(this.fd, this._writingBuf);
        fsWrite = ()=>fs.write(this.fd, this._writingBuf, this.release);
    } else if (contentMode === undefined || contentMode === kContentModeUtf8) {
        this._writingBuf = '';
        this.write = write;
        this.flush = flush;
        this.flushSync = flushSync;
        this._actualWrite = actualWrite;
        fsWriteSync = ()=>fs.writeSync(this.fd, this._writingBuf, 'utf8');
        fsWrite = ()=>fs.write(this.fd, this._writingBuf, 'utf8', this.release);
    } else {
        throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`);
    }
    if (typeof fd === 'number') {
        this.fd = fd;
        process.nextTick(()=>this.emit('ready'));
    } else if (typeof fd === 'string') {
        openFile(fd, this);
    } else {
        throw new Error('SonicBoom supports only file descriptors and files');
    }
    if (this.minLength >= this.maxWrite) {
        throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
    }
    this.release = (err, n)=>{
        if (err) {
            if ((err.code === 'EAGAIN' || err.code === 'EBUSY') && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
                if (this.sync) {
                    // This error code should not happen in sync mode, because it is
                    // not using the underlining operating system asynchronous functions.
                    // However it happens, and so we handle it.
                    // Ref: https://github.com/pinojs/pino/issues/783
                    try {
                        sleep(BUSY_WRITE_TIMEOUT);
                        this.release(undefined, 0);
                    } catch (err) {
                        this.release(err);
                    }
                } else {
                    // Let's give the destination some time to process the chunk.
                    setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
                }
            } else {
                this._writing = false;
                this.emit('error', err);
            }
            return;
        }
        this.emit('write', n);
        const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
        this._len = releasedBufObj.len;
        this._writingBuf = releasedBufObj.writingBuf;
        if (this._writingBuf.length) {
            if (!this.sync) {
                fsWrite();
                return;
            }
            try {
                do {
                    const n = fsWriteSync();
                    const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
                    this._len = releasedBufObj.len;
                    this._writingBuf = releasedBufObj.writingBuf;
                }while (this._writingBuf.length)
            } catch (err) {
                this.release(err);
                return;
            }
        }
        if (this._fsync) {
            fs.fsyncSync(this.fd);
        }
        const len = this._len;
        if (this._reopening) {
            this._writing = false;
            this._reopening = false;
            this.reopen();
        } else if (len > this.minLength) {
            this._actualWrite();
        } else if (this._ending) {
            if (len > 0) {
                this._actualWrite();
            } else {
                this._writing = false;
                actualClose(this);
            }
        } else {
            this._writing = false;
            if (this.sync) {
                if (!this._asyncDrainScheduled) {
                    this._asyncDrainScheduled = true;
                    process.nextTick(emitDrain, this);
                }
            } else {
                this.emit('drain');
            }
        }
    };
    this.on('newListener', function(name) {
        if (name === 'drain') {
            this._asyncDrainScheduled = false;
        }
    });
    if (this._periodicFlush !== 0) {
        this._periodicFlushTimer = setInterval(()=>this.flush(null), this._periodicFlush);
        this._periodicFlushTimer.unref();
    }
}
/**
 * Release the writingBuf after fs.write n bytes data
 * @param {string | Buffer} writingBuf - currently writing buffer, usually be instance._writingBuf.
 * @param {number} len - currently buffer length, usually be instance._len.
 * @param {number} n - number of bytes fs already written
 * @returns {{writingBuf: string | Buffer, len: number}} released writingBuf and length
 */ function releaseWritingBuf(writingBuf, len, n) {
    // if Buffer.byteLength is equal to n, that means writingBuf contains no multi-byte character
    if (typeof writingBuf === 'string' && Buffer.byteLength(writingBuf) !== n) {
        // Since the fs.write callback parameter `n` means how many bytes the passed of string
        // We calculate the original string length for avoiding the multi-byte character issue
        n = Buffer.from(writingBuf).subarray(0, n).toString().length;
    }
    len = Math.max(len - n, 0);
    writingBuf = writingBuf.slice(n);
    return {
        writingBuf,
        len
    };
}
function emitDrain(sonic) {
    const hasListeners = sonic.listenerCount('drain') > 0;
    if (!hasListeners) return;
    sonic._asyncDrainScheduled = false;
    sonic.emit('drain');
}
inherits(SonicBoom, EventEmitter);
function mergeBuf(bufs, len) {
    if (bufs.length === 0) {
        return kEmptyBuffer;
    }
    if (bufs.length === 1) {
        return bufs[0];
    }
    return Buffer.concat(bufs, len);
}
function write(data) {
    if (this.destroyed) {
        throw new Error('SonicBoom destroyed');
    }
    const len = this._len + data.length;
    const bufs = this._bufs;
    if (this.maxLength && len > this.maxLength) {
        this.emit('drop', data);
        return this._len < this._hwm;
    }
    if (bufs.length === 0 || bufs[bufs.length - 1].length + data.length > this.maxWrite) {
        bufs.push('' + data);
    } else {
        bufs[bufs.length - 1] += data;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
    }
    return this._len < this._hwm;
}
function writeBuffer(data) {
    if (this.destroyed) {
        throw new Error('SonicBoom destroyed');
    }
    const len = this._len + data.length;
    const bufs = this._bufs;
    const lens = this._lens;
    if (this.maxLength && len > this.maxLength) {
        this.emit('drop', data);
        return this._len < this._hwm;
    }
    if (bufs.length === 0 || lens[lens.length - 1] + data.length > this.maxWrite) {
        bufs.push([
            data
        ]);
        lens.push(data.length);
    } else {
        bufs[bufs.length - 1].push(data);
        lens[lens.length - 1] += data.length;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
    }
    return this._len < this._hwm;
}
function callFlushCallbackOnDrain(cb) {
    this._flushPending = true;
    const onDrain = ()=>{
        // only if _fsync is false to avoid double fsync
        if (!this._fsync) {
            try {
                fs.fsync(this.fd, (err)=>{
                    this._flushPending = false;
                    cb(err);
                });
            } catch (err) {
                cb(err);
            }
        } else {
            this._flushPending = false;
            cb();
        }
        this.off('error', onError);
    };
    const onError = (err)=>{
        this._flushPending = false;
        cb(err);
        this.off('drain', onDrain);
    };
    this.once('drain', onDrain);
    this.once('error', onError);
}
function flush(cb) {
    if (cb != null && typeof cb !== 'function') {
        throw new Error('flush cb must be a function');
    }
    if (this.destroyed) {
        const error = new Error('SonicBoom destroyed');
        if (cb) {
            cb(error);
            return;
        }
        throw error;
    }
    if (this.minLength <= 0) {
        cb?.();
        return;
    }
    if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
    }
    if (this._writing) {
        return;
    }
    if (this._bufs.length === 0) {
        this._bufs.push('');
    }
    this._actualWrite();
}
function flushBuffer(cb) {
    if (cb != null && typeof cb !== 'function') {
        throw new Error('flush cb must be a function');
    }
    if (this.destroyed) {
        const error = new Error('SonicBoom destroyed');
        if (cb) {
            cb(error);
            return;
        }
        throw error;
    }
    if (this.minLength <= 0) {
        cb?.();
        return;
    }
    if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
    }
    if (this._writing) {
        return;
    }
    if (this._bufs.length === 0) {
        this._bufs.push([]);
        this._lens.push(0);
    }
    this._actualWrite();
}
SonicBoom.prototype.reopen = function(file) {
    if (this.destroyed) {
        throw new Error('SonicBoom destroyed');
    }
    if (this._opening) {
        this.once('ready', ()=>{
            this.reopen(file);
        });
        return;
    }
    if (this._ending) {
        return;
    }
    if (!this.file) {
        throw new Error('Unable to reopen a file descriptor, you must pass a file to SonicBoom');
    }
    if (file) {
        this.file = file;
    }
    this._reopening = true;
    if (this._writing) {
        return;
    }
    const fd = this.fd;
    this.once('ready', ()=>{
        if (fd !== this.fd) {
            fs.close(fd, (err)=>{
                if (err) {
                    return this.emit('error', err);
                }
            });
        }
    });
    openFile(this.file, this);
};
SonicBoom.prototype.end = function() {
    if (this.destroyed) {
        throw new Error('SonicBoom destroyed');
    }
    if (this._opening) {
        this.once('ready', ()=>{
            this.end();
        });
        return;
    }
    if (this._ending) {
        return;
    }
    this._ending = true;
    if (this._writing) {
        return;
    }
    if (this._len > 0 && this.fd >= 0) {
        this._actualWrite();
    } else {
        actualClose(this);
    }
};
function flushSync() {
    if (this.destroyed) {
        throw new Error('SonicBoom destroyed');
    }
    if (this.fd < 0) {
        throw new Error('sonic boom is not ready yet');
    }
    if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift(this._writingBuf);
        this._writingBuf = '';
    }
    let buf = '';
    while(this._bufs.length || buf){
        if (buf.length <= 0) {
            buf = this._bufs[0];
        }
        try {
            const n = fs.writeSync(this.fd, buf, 'utf8');
            const releasedBufObj = releaseWritingBuf(buf, this._len, n);
            buf = releasedBufObj.writingBuf;
            this._len = releasedBufObj.len;
            if (buf.length <= 0) {
                this._bufs.shift();
            }
        } catch (err) {
            const shouldRetry = err.code === 'EAGAIN' || err.code === 'EBUSY';
            if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
                throw err;
            }
            sleep(BUSY_WRITE_TIMEOUT);
        }
    }
    try {
        fs.fsyncSync(this.fd);
    } catch  {
    // Skip the error. The fd might not support fsync.
    }
}
function flushBufferSync() {
    if (this.destroyed) {
        throw new Error('SonicBoom destroyed');
    }
    if (this.fd < 0) {
        throw new Error('sonic boom is not ready yet');
    }
    if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift([
            this._writingBuf
        ]);
        this._writingBuf = kEmptyBuffer;
    }
    let buf = kEmptyBuffer;
    while(this._bufs.length || buf.length){
        if (buf.length <= 0) {
            buf = mergeBuf(this._bufs[0], this._lens[0]);
        }
        try {
            const n = fs.writeSync(this.fd, buf);
            buf = buf.subarray(n);
            this._len = Math.max(this._len - n, 0);
            if (buf.length <= 0) {
                this._bufs.shift();
                this._lens.shift();
            }
        } catch (err) {
            const shouldRetry = err.code === 'EAGAIN' || err.code === 'EBUSY';
            if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
                throw err;
            }
            sleep(BUSY_WRITE_TIMEOUT);
        }
    }
}
SonicBoom.prototype.destroy = function() {
    if (this.destroyed) {
        return;
    }
    actualClose(this);
};
function actualWrite() {
    const release = this.release;
    this._writing = true;
    this._writingBuf = this._writingBuf || this._bufs.shift() || '';
    if (this.sync) {
        try {
            const written = fs.writeSync(this.fd, this._writingBuf, 'utf8');
            release(null, written);
        } catch (err) {
            release(err);
        }
    } else {
        fs.write(this.fd, this._writingBuf, 'utf8', release);
    }
}
function actualWriteBuffer() {
    const release = this.release;
    this._writing = true;
    this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());
    if (this.sync) {
        try {
            const written = fs.writeSync(this.fd, this._writingBuf);
            release(null, written);
        } catch (err) {
            release(err);
        }
    } else {
        // fs.write will need to copy string to buffer anyway so
        // we do it here to avoid the overhead of calculating the buffer size
        // in releaseWritingBuf.
        if (kCopyBuffer) {
            this._writingBuf = Buffer.from(this._writingBuf);
        }
        fs.write(this.fd, this._writingBuf, release);
    }
}
function actualClose(sonic) {
    if (sonic.fd === -1) {
        sonic.once('ready', actualClose.bind(null, sonic));
        return;
    }
    if (sonic._periodicFlushTimer !== undefined) {
        clearInterval(sonic._periodicFlushTimer);
    }
    sonic.destroyed = true;
    sonic._bufs = [];
    sonic._lens = [];
    assert(typeof sonic.fd === 'number', `sonic.fd must be a number, got ${typeof sonic.fd}`);
    try {
        fs.fsync(sonic.fd, closeWrapped);
    } catch  {}
    function closeWrapped() {
        // We skip errors in fsync
        if (sonic.fd !== 1 && sonic.fd !== 2) {
            fs.close(sonic.fd, done);
        } else {
            done();
        }
    }
    function done(err) {
        if (err) {
            sonic.emit('error', err);
            return;
        }
        if (sonic._ending && !sonic._writing) {
            sonic.emit('finish');
        }
        sonic.emit('close');
    }
}
/**
 * These export configurations enable JS and TS developers
 * to consumer SonicBoom in whatever way best suits their needs.
 * Some examples of supported import syntax includes:
 * - `const SonicBoom = require('SonicBoom')`
 * - `const { SonicBoom } = require('SonicBoom')`
 * - `import * as SonicBoom from 'SonicBoom'`
 * - `import { SonicBoom } from 'SonicBoom'`
 * - `import SonicBoom from 'SonicBoom'`
 */ SonicBoom.SonicBoom = SonicBoom;
SonicBoom.default = SonicBoom;
module.exports = SonicBoom;
}),
"[project]/node_modules/.pnpm/safe-stable-stringify@2.5.0/node_modules/safe-stable-stringify/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { hasOwnProperty } = Object.prototype;
const stringify = configure();
// @ts-expect-error
stringify.configure = configure;
// @ts-expect-error
stringify.stringify = stringify;
// @ts-expect-error
stringify.default = stringify;
// @ts-expect-error used for named export
exports.stringify = stringify;
// @ts-expect-error used for named export
exports.configure = configure;
module.exports = stringify;
// eslint-disable-next-line no-control-regex
const strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
// Escape C0 control characters, double quotes, the backslash and every code
// unit with a numeric value in the inclusive range 0xD800 to 0xDFFF.
function strEscape(str) {
    // Some magic numbers that worked out fine while benchmarking with v8 8.0
    if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
    }
    return JSON.stringify(str);
}
function sort(array, comparator) {
    // Insertion sort is very efficient for small input sizes, but it has a bad
    // worst case complexity. Thus, use native array sort for bigger values.
    if (array.length > 2e2 || comparator) {
        return array.sort(comparator);
    }
    for(let i = 1; i < array.length; i++){
        const currentValue = array[i];
        let position = i;
        while(position !== 0 && array[position - 1] > currentValue){
            array[position] = array[position - 1];
            position--;
        }
        array[position] = currentValue;
    }
    return array;
}
const typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array())), Symbol.toStringTag).get;
function isTypedArrayWithEntries(value) {
    return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0;
}
function stringifyTypedArray(array, separator, maximumBreadth) {
    if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
    }
    const whitespace = separator === ',' ? '' : ' ';
    let res = `"0":${whitespace}${array[0]}`;
    for(let i = 1; i < maximumBreadth; i++){
        res += `${separator}"${i}":${whitespace}${array[i]}`;
    }
    return res;
}
function getCircularValueOption(options) {
    if (hasOwnProperty.call(options, 'circularValue')) {
        const circularValue = options.circularValue;
        if (typeof circularValue === 'string') {
            return `"${circularValue}"`;
        }
        if (circularValue == null) {
            return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
            return {
                toString () {
                    throw new TypeError('Converting circular structure to JSON');
                }
            };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
    }
    return '"[Circular]"';
}
function getDeterministicOption(options) {
    let value;
    if (hasOwnProperty.call(options, 'deterministic')) {
        value = options.deterministic;
        if (typeof value !== 'boolean' && typeof value !== 'function') {
            throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
    }
    return value === undefined ? true : value;
}
function getBooleanOption(options, key) {
    let value;
    if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== 'boolean') {
            throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
    }
    return value === undefined ? true : value;
}
function getPositiveIntegerOption(options, key) {
    let value;
    if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== 'number') {
            throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
            throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
            throw new RangeError(`The "${key}" argument must be >= 1`);
        }
    }
    return value === undefined ? Infinity : value;
}
function getItemCount(number) {
    if (number === 1) {
        return '1 item';
    }
    return `${number} items`;
}
function getUniqueReplacerSet(replacerArray) {
    const replacerSet = new Set();
    for (const value of replacerArray){
        if (typeof value === 'string' || typeof value === 'number') {
            replacerSet.add(String(value));
        }
    }
    return replacerSet;
}
function getStrictOption(options) {
    if (hasOwnProperty.call(options, 'strict')) {
        const value = options.strict;
        if (typeof value !== 'boolean') {
            throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
            return (value)=>{
                let message = `Object can not safely be stringified. Received type ${typeof value}`;
                if (typeof value !== 'function') message += ` (${value.toString()})`;
                throw new Error(message);
            };
        }
    }
}
function configure(options) {
    options = {
        ...options
    };
    const fail = getStrictOption(options);
    if (fail) {
        if (options.bigint === undefined) {
            options.bigint = false;
        }
        if (!('circularValue' in options)) {
            options.circularValue = Error;
        }
    }
    const circularValue = getCircularValueOption(options);
    const bigint = getBooleanOption(options, 'bigint');
    const deterministic = getDeterministicOption(options);
    const comparator = typeof deterministic === 'function' ? deterministic : undefined;
    const maximumDepth = getPositiveIntegerOption(options, 'maximumDepth');
    const maximumBreadth = getPositiveIntegerOption(options, 'maximumBreadth');
    function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch(typeof value){
            case 'string':
                return strEscape(value);
            case 'object':
                {
                    if (value === null) {
                        return 'null';
                    }
                    if (stack.indexOf(value) !== -1) {
                        return circularValue;
                    }
                    let res = '';
                    let join = ',';
                    const originalIndentation = indentation;
                    if (Array.isArray(value)) {
                        if (value.length === 0) {
                            return '[]';
                        }
                        if (maximumDepth < stack.length + 1) {
                            return '"[Array]"';
                        }
                        stack.push(value);
                        if (spacer !== '') {
                            indentation += spacer;
                            res += `\n${indentation}`;
                            join = `,\n${indentation}`;
                        }
                        const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                        let i = 0;
                        for(; i < maximumValuesToStringify - 1; i++){
                            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                            res += tmp !== undefined ? tmp : 'null';
                            res += join;
                        }
                        const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                        res += tmp !== undefined ? tmp : 'null';
                        if (value.length - 1 > maximumBreadth) {
                            const removedKeys = value.length - maximumBreadth - 1;
                            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
                        }
                        if (spacer !== '') {
                            res += `\n${originalIndentation}`;
                        }
                        stack.pop();
                        return `[${res}]`;
                    }
                    let keys = Object.keys(value);
                    const keyLength = keys.length;
                    if (keyLength === 0) {
                        return '{}';
                    }
                    if (maximumDepth < stack.length + 1) {
                        return '"[Object]"';
                    }
                    let whitespace = '';
                    let separator = '';
                    if (spacer !== '') {
                        indentation += spacer;
                        join = `,\n${indentation}`;
                        whitespace = ' ';
                    }
                    const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                    if (deterministic && !isTypedArrayWithEntries(value)) {
                        keys = sort(keys, comparator);
                    }
                    stack.push(value);
                    for(let i = 0; i < maximumPropertiesToStringify; i++){
                        const key = keys[i];
                        const tmp = stringifyFnReplacer(key, value, stack, replacer, spacer, indentation);
                        if (tmp !== undefined) {
                            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`;
                            separator = join;
                        }
                    }
                    if (keyLength > maximumBreadth) {
                        const removedKeys = keyLength - maximumBreadth;
                        res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
                        separator = join;
                    }
                    if (spacer !== '' && separator.length > 1) {
                        res = `\n${indentation}${res}\n${originalIndentation}`;
                    }
                    stack.pop();
                    return `{${res}}`;
                }
            case 'number':
                return isFinite(value) ? String(value) : fail ? fail(value) : 'null';
            case 'boolean':
                return value === true ? 'true' : 'false';
            case 'undefined':
                return undefined;
            case 'bigint':
                if (bigint) {
                    return String(value);
                }
            // fallthrough
            default:
                return fail ? fail(value) : undefined;
        }
    }
    function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }
        switch(typeof value){
            case 'string':
                return strEscape(value);
            case 'object':
                {
                    if (value === null) {
                        return 'null';
                    }
                    if (stack.indexOf(value) !== -1) {
                        return circularValue;
                    }
                    const originalIndentation = indentation;
                    let res = '';
                    let join = ',';
                    if (Array.isArray(value)) {
                        if (value.length === 0) {
                            return '[]';
                        }
                        if (maximumDepth < stack.length + 1) {
                            return '"[Array]"';
                        }
                        stack.push(value);
                        if (spacer !== '') {
                            indentation += spacer;
                            res += `\n${indentation}`;
                            join = `,\n${indentation}`;
                        }
                        const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                        let i = 0;
                        for(; i < maximumValuesToStringify - 1; i++){
                            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                            res += tmp !== undefined ? tmp : 'null';
                            res += join;
                        }
                        const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                        res += tmp !== undefined ? tmp : 'null';
                        if (value.length - 1 > maximumBreadth) {
                            const removedKeys = value.length - maximumBreadth - 1;
                            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
                        }
                        if (spacer !== '') {
                            res += `\n${originalIndentation}`;
                        }
                        stack.pop();
                        return `[${res}]`;
                    }
                    stack.push(value);
                    let whitespace = '';
                    if (spacer !== '') {
                        indentation += spacer;
                        join = `,\n${indentation}`;
                        whitespace = ' ';
                    }
                    let separator = '';
                    for (const key of replacer){
                        const tmp = stringifyArrayReplacer(key, value[key], stack, replacer, spacer, indentation);
                        if (tmp !== undefined) {
                            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`;
                            separator = join;
                        }
                    }
                    if (spacer !== '' && separator.length > 1) {
                        res = `\n${indentation}${res}\n${originalIndentation}`;
                    }
                    stack.pop();
                    return `{${res}}`;
                }
            case 'number':
                return isFinite(value) ? String(value) : fail ? fail(value) : 'null';
            case 'boolean':
                return value === true ? 'true' : 'false';
            case 'undefined':
                return undefined;
            case 'bigint':
                if (bigint) {
                    return String(value);
                }
            // fallthrough
            default:
                return fail ? fail(value) : undefined;
        }
    }
    function stringifyIndent(key, value, stack, spacer, indentation) {
        switch(typeof value){
            case 'string':
                return strEscape(value);
            case 'object':
                {
                    if (value === null) {
                        return 'null';
                    }
                    if (typeof value.toJSON === 'function') {
                        value = value.toJSON(key);
                        // Prevent calling `toJSON` again.
                        if (typeof value !== 'object') {
                            return stringifyIndent(key, value, stack, spacer, indentation);
                        }
                        if (value === null) {
                            return 'null';
                        }
                    }
                    if (stack.indexOf(value) !== -1) {
                        return circularValue;
                    }
                    const originalIndentation = indentation;
                    if (Array.isArray(value)) {
                        if (value.length === 0) {
                            return '[]';
                        }
                        if (maximumDepth < stack.length + 1) {
                            return '"[Array]"';
                        }
                        stack.push(value);
                        indentation += spacer;
                        let res = `\n${indentation}`;
                        const join = `,\n${indentation}`;
                        const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                        let i = 0;
                        for(; i < maximumValuesToStringify - 1; i++){
                            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                            res += tmp !== undefined ? tmp : 'null';
                            res += join;
                        }
                        const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                        res += tmp !== undefined ? tmp : 'null';
                        if (value.length - 1 > maximumBreadth) {
                            const removedKeys = value.length - maximumBreadth - 1;
                            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
                        }
                        res += `\n${originalIndentation}`;
                        stack.pop();
                        return `[${res}]`;
                    }
                    let keys = Object.keys(value);
                    const keyLength = keys.length;
                    if (keyLength === 0) {
                        return '{}';
                    }
                    if (maximumDepth < stack.length + 1) {
                        return '"[Object]"';
                    }
                    indentation += spacer;
                    const join = `,\n${indentation}`;
                    let res = '';
                    let separator = '';
                    let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                    if (isTypedArrayWithEntries(value)) {
                        res += stringifyTypedArray(value, join, maximumBreadth);
                        keys = keys.slice(value.length);
                        maximumPropertiesToStringify -= value.length;
                        separator = join;
                    }
                    if (deterministic) {
                        keys = sort(keys, comparator);
                    }
                    stack.push(value);
                    for(let i = 0; i < maximumPropertiesToStringify; i++){
                        const key = keys[i];
                        const tmp = stringifyIndent(key, value[key], stack, spacer, indentation);
                        if (tmp !== undefined) {
                            res += `${separator}${strEscape(key)}: ${tmp}`;
                            separator = join;
                        }
                    }
                    if (keyLength > maximumBreadth) {
                        const removedKeys = keyLength - maximumBreadth;
                        res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
                        separator = join;
                    }
                    if (separator !== '') {
                        res = `\n${indentation}${res}\n${originalIndentation}`;
                    }
                    stack.pop();
                    return `{${res}}`;
                }
            case 'number':
                return isFinite(value) ? String(value) : fail ? fail(value) : 'null';
            case 'boolean':
                return value === true ? 'true' : 'false';
            case 'undefined':
                return undefined;
            case 'bigint':
                if (bigint) {
                    return String(value);
                }
            // fallthrough
            default:
                return fail ? fail(value) : undefined;
        }
    }
    function stringifySimple(key, value, stack) {
        switch(typeof value){
            case 'string':
                return strEscape(value);
            case 'object':
                {
                    if (value === null) {
                        return 'null';
                    }
                    if (typeof value.toJSON === 'function') {
                        value = value.toJSON(key);
                        // Prevent calling `toJSON` again
                        if (typeof value !== 'object') {
                            return stringifySimple(key, value, stack);
                        }
                        if (value === null) {
                            return 'null';
                        }
                    }
                    if (stack.indexOf(value) !== -1) {
                        return circularValue;
                    }
                    let res = '';
                    const hasLength = value.length !== undefined;
                    if (hasLength && Array.isArray(value)) {
                        if (value.length === 0) {
                            return '[]';
                        }
                        if (maximumDepth < stack.length + 1) {
                            return '"[Array]"';
                        }
                        stack.push(value);
                        const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                        let i = 0;
                        for(; i < maximumValuesToStringify - 1; i++){
                            const tmp = stringifySimple(String(i), value[i], stack);
                            res += tmp !== undefined ? tmp : 'null';
                            res += ',';
                        }
                        const tmp = stringifySimple(String(i), value[i], stack);
                        res += tmp !== undefined ? tmp : 'null';
                        if (value.length - 1 > maximumBreadth) {
                            const removedKeys = value.length - maximumBreadth - 1;
                            res += `,"... ${getItemCount(removedKeys)} not stringified"`;
                        }
                        stack.pop();
                        return `[${res}]`;
                    }
                    let keys = Object.keys(value);
                    const keyLength = keys.length;
                    if (keyLength === 0) {
                        return '{}';
                    }
                    if (maximumDepth < stack.length + 1) {
                        return '"[Object]"';
                    }
                    let separator = '';
                    let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                    if (hasLength && isTypedArrayWithEntries(value)) {
                        res += stringifyTypedArray(value, ',', maximumBreadth);
                        keys = keys.slice(value.length);
                        maximumPropertiesToStringify -= value.length;
                        separator = ',';
                    }
                    if (deterministic) {
                        keys = sort(keys, comparator);
                    }
                    stack.push(value);
                    for(let i = 0; i < maximumPropertiesToStringify; i++){
                        const key = keys[i];
                        const tmp = stringifySimple(key, value[key], stack);
                        if (tmp !== undefined) {
                            res += `${separator}${strEscape(key)}:${tmp}`;
                            separator = ',';
                        }
                    }
                    if (keyLength > maximumBreadth) {
                        const removedKeys = keyLength - maximumBreadth;
                        res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
                    }
                    stack.pop();
                    return `{${res}}`;
                }
            case 'number':
                return isFinite(value) ? String(value) : fail ? fail(value) : 'null';
            case 'boolean':
                return value === true ? 'true' : 'false';
            case 'undefined':
                return undefined;
            case 'bigint':
                if (bigint) {
                    return String(value);
                }
            // fallthrough
            default:
                return fail ? fail(value) : undefined;
        }
    }
    function stringify(value, replacer, space) {
        if (arguments.length > 1) {
            let spacer = '';
            if (typeof space === 'number') {
                spacer = ' '.repeat(Math.min(space, 10));
            } else if (typeof space === 'string') {
                spacer = space.slice(0, 10);
            }
            if (replacer != null) {
                if (typeof replacer === 'function') {
                    return stringifyFnReplacer('', {
                        '': value
                    }, [], replacer, spacer, '');
                }
                if (Array.isArray(replacer)) {
                    return stringifyArrayReplacer('', value, [], getUniqueReplacerSet(replacer), spacer, '');
                }
            }
            if (spacer.length !== 0) {
                return stringifyIndent('', value, [], spacer, '');
            }
        }
        return stringifySimple('', value, []);
    }
    return stringify;
}
}),
"[project]/node_modules/.pnpm/colorette@2.0.20/node_modules/colorette/index.cjs [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
var tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function(k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function() {
                        return e[k];
                    }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}
var tty__namespace = /*#__PURE__*/ _interopNamespace(tty);
const { env = {}, argv = [], platform = "" } = typeof process === "undefined" ? {} : process;
const isDisabled = "NO_COLOR" in env || argv.includes("--no-color");
const isForced = "FORCE_COLOR" in env || argv.includes("--color");
const isWindows = platform === "win32";
const isDumbTerminal = env.TERM === "dumb";
const isCompatibleTerminal = tty__namespace && tty__namespace.isatty && tty__namespace.isatty(1) && env.TERM && !isDumbTerminal;
const isCI = "CI" in env && ("GITHUB_ACTIONS" in env || "GITLAB_CI" in env || "CIRCLECI" in env);
const isColorSupported = !isDisabled && (isForced || isWindows && !isDumbTerminal || isCompatibleTerminal || isCI);
const replaceClose = (index, string, close, replace, head = string.substring(0, index) + replace, tail = string.substring(index + close.length), next = tail.indexOf(close))=>head + (next < 0 ? tail : replaceClose(next, tail, close, replace));
const clearBleed = (index, string, open, close, replace)=>index < 0 ? open + string + close : open + replaceClose(index, string, close, replace) + close;
const filterEmpty = (open, close, replace = open, at = open.length + 1)=>(string)=>string || !(string === "" || string === undefined) ? clearBleed(("" + string).indexOf(close, at), string, open, close, replace) : "";
const init = (open, close, replace)=>filterEmpty(`\x1b[${open}m`, `\x1b[${close}m`, replace);
const colors = {
    reset: init(0, 0),
    bold: init(1, 22, "\x1b[22m\x1b[1m"),
    dim: init(2, 22, "\x1b[22m\x1b[2m"),
    italic: init(3, 23),
    underline: init(4, 24),
    inverse: init(7, 27),
    hidden: init(8, 28),
    strikethrough: init(9, 29),
    black: init(30, 39),
    red: init(31, 39),
    green: init(32, 39),
    yellow: init(33, 39),
    blue: init(34, 39),
    magenta: init(35, 39),
    cyan: init(36, 39),
    white: init(37, 39),
    gray: init(90, 39),
    bgBlack: init(40, 49),
    bgRed: init(41, 49),
    bgGreen: init(42, 49),
    bgYellow: init(43, 49),
    bgBlue: init(44, 49),
    bgMagenta: init(45, 49),
    bgCyan: init(46, 49),
    bgWhite: init(47, 49),
    blackBright: init(90, 39),
    redBright: init(91, 39),
    greenBright: init(92, 39),
    yellowBright: init(93, 39),
    blueBright: init(94, 39),
    magentaBright: init(95, 39),
    cyanBright: init(96, 39),
    whiteBright: init(97, 39),
    bgBlackBright: init(100, 49),
    bgRedBright: init(101, 49),
    bgGreenBright: init(102, 49),
    bgYellowBright: init(103, 49),
    bgBlueBright: init(104, 49),
    bgMagentaBright: init(105, 49),
    bgCyanBright: init(106, 49),
    bgWhiteBright: init(107, 49)
};
const createColors = ({ useColor = isColorSupported } = {})=>useColor ? colors : Object.keys(colors).reduce((colors, key)=>({
            ...colors,
            [key]: String
        }), {});
const { reset, bold, dim, italic, underline, inverse, hidden, strikethrough, black, red, green, yellow, blue, magenta, cyan, white, gray, bgBlack, bgRed, bgGreen, bgYellow, bgBlue, bgMagenta, bgCyan, bgWhite, blackBright, redBright, greenBright, yellowBright, blueBright, magentaBright, cyanBright, whiteBright, bgBlackBright, bgRedBright, bgGreenBright, bgYellowBright, bgBlueBright, bgMagentaBright, bgCyanBright, bgWhiteBright } = createColors();
exports.bgBlack = bgBlack;
exports.bgBlackBright = bgBlackBright;
exports.bgBlue = bgBlue;
exports.bgBlueBright = bgBlueBright;
exports.bgCyan = bgCyan;
exports.bgCyanBright = bgCyanBright;
exports.bgGreen = bgGreen;
exports.bgGreenBright = bgGreenBright;
exports.bgMagenta = bgMagenta;
exports.bgMagentaBright = bgMagentaBright;
exports.bgRed = bgRed;
exports.bgRedBright = bgRedBright;
exports.bgWhite = bgWhite;
exports.bgWhiteBright = bgWhiteBright;
exports.bgYellow = bgYellow;
exports.bgYellowBright = bgYellowBright;
exports.black = black;
exports.blackBright = blackBright;
exports.blue = blue;
exports.blueBright = blueBright;
exports.bold = bold;
exports.createColors = createColors;
exports.cyan = cyan;
exports.cyanBright = cyanBright;
exports.dim = dim;
exports.gray = gray;
exports.green = green;
exports.greenBright = greenBright;
exports.hidden = hidden;
exports.inverse = inverse;
exports.isColorSupported = isColorSupported;
exports.italic = italic;
exports.magenta = magenta;
exports.magentaBright = magentaBright;
exports.red = red;
exports.redBright = redBright;
exports.reset = reset;
exports.strikethrough = strikethrough;
exports.underline = underline;
exports.white = white;
exports.whiteBright = whiteBright;
exports.yellow = yellow;
exports.yellowBright = yellowBright;
}),
"[project]/node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy;
function wrappy(fn, cb) {
    if (fn && cb) return wrappy(fn)(cb);
    if (typeof fn !== 'function') throw new TypeError('need wrapper function');
    Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
    });
    return wrapper;
    //TURBOPACK unreachable
    ;
    function wrapper() {
        var args = new Array(arguments.length);
        for(var i = 0; i < args.length; i++){
            args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb = args[args.length - 1];
        if (typeof ret === 'function' && ret !== cb) {
            Object.keys(cb).forEach(function(k) {
                ret[k] = cb[k];
            });
        }
        return ret;
    }
}
}),
"[project]/node_modules/.pnpm/once@1.4.0/node_modules/once/once.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var wrappy = __turbopack_context__.r("[project]/node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js [app-rsc] (ecmascript)");
module.exports = wrappy(once);
module.exports.strict = wrappy(onceStrict);
once.proto = once(function() {
    Object.defineProperty(Function.prototype, 'once', {
        value: function() {
            return once(this);
        },
        configurable: true
    });
    Object.defineProperty(Function.prototype, 'onceStrict', {
        value: function() {
            return onceStrict(this);
        },
        configurable: true
    });
});
function once(fn) {
    var f = function() {
        if (f.called) return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
}
function onceStrict(fn) {
    var f = function() {
        if (f.called) throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || 'Function wrapped with `once`';
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
}
}),
"[project]/node_modules/.pnpm/end-of-stream@1.4.5/node_modules/end-of-stream/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var once = __turbopack_context__.r("[project]/node_modules/.pnpm/once@1.4.0/node_modules/once/once.js [app-rsc] (ecmascript)");
var noop = function() {};
var qnt = /*TURBOPACK member replacement*/ __turbopack_context__.g.Bare ? queueMicrotask : process.nextTick.bind(process);
var isRequest = function(stream) {
    return stream.setHeader && typeof stream.abort === 'function';
};
var isChildProcess = function(stream) {
    return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
};
var eos = function(stream, opts, callback) {
    if (typeof opts === 'function') return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once(callback || noop);
    var ws = stream._writableState;
    var rs = stream._readableState;
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var cancelled = false;
    var onlegacyfinish = function() {
        if (!stream.writable) onfinish();
    };
    var onfinish = function() {
        writable = false;
        if (!readable) callback.call(stream);
    };
    var onend = function() {
        readable = false;
        if (!writable) callback.call(stream);
    };
    var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
    };
    var onerror = function(err) {
        callback.call(stream, err);
    };
    var onclose = function() {
        qnt(onclosenexttick);
    };
    var onclosenexttick = function() {
        if (cancelled) return;
        if (readable && !(rs && rs.ended && !rs.destroyed)) return callback.call(stream, new Error('premature close'));
        if (writable && !(ws && ws.ended && !ws.destroyed)) return callback.call(stream, new Error('premature close'));
    };
    var onrequest = function() {
        stream.req.on('finish', onfinish);
    };
    if (isRequest(stream)) {
        stream.on('complete', onfinish);
        stream.on('abort', onclose);
        if (stream.req) onrequest();
        else stream.on('request', onrequest);
    } else if (writable && !ws) {
        stream.on('end', onlegacyfinish);
        stream.on('close', onlegacyfinish);
    }
    if (isChildProcess(stream)) stream.on('exit', onexit);
    stream.on('end', onend);
    stream.on('finish', onfinish);
    if (opts.error !== false) stream.on('error', onerror);
    stream.on('close', onclose);
    return function() {
        cancelled = true;
        stream.removeListener('complete', onfinish);
        stream.removeListener('abort', onclose);
        stream.removeListener('request', onrequest);
        if (stream.req) stream.req.removeListener('finish', onfinish);
        stream.removeListener('end', onlegacyfinish);
        stream.removeListener('close', onlegacyfinish);
        stream.removeListener('finish', onfinish);
        stream.removeListener('exit', onexit);
        stream.removeListener('end', onend);
        stream.removeListener('error', onerror);
        stream.removeListener('close', onclose);
    };
};
module.exports = eos;
}),
"[project]/node_modules/.pnpm/pump@3.0.3/node_modules/pump/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var once = __turbopack_context__.r("[project]/node_modules/.pnpm/once@1.4.0/node_modules/once/once.js [app-rsc] (ecmascript)");
var eos = __turbopack_context__.r("[project]/node_modules/.pnpm/end-of-stream@1.4.5/node_modules/end-of-stream/index.js [app-rsc] (ecmascript)");
var fs;
try {
    fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)"); // we only need fs to get the ReadStream and WriteStream prototypes
} catch (e) {}
var noop = function() {};
var ancient = typeof process === 'undefined' ? false : /^v?\.0/.test(process.version);
var isFn = function(fn) {
    return typeof fn === 'function';
};
var isFS = function(stream) {
    if (!ancient) return false // newer node version do not need to care about fs is a special way
    ;
    if (!fs) return false // browser
    ;
    return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close);
};
var isRequest = function(stream) {
    return stream.setHeader && isFn(stream.abort);
};
var destroyer = function(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on('close', function() {
        closed = true;
    });
    eos(stream, {
        readable: reading,
        writable: writing
    }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
    });
    var destroyed = false;
    return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
        ;
        if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want
        ;
        if (isFn(stream.destroy)) return stream.destroy();
        callback(err || new Error('stream was destroyed'));
    };
};
var call = function(fn) {
    fn();
};
var pipe = function(from, to) {
    return from.pipe(to);
};
var pump = function() {
    var streams = Array.prototype.slice.call(arguments);
    var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) throw new Error('pump requires two streams per minimum');
    var error;
    var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
            if (!error) error = err;
            if (err) destroys.forEach(call);
            if (reading) return;
            destroys.forEach(call);
            callback(error);
        });
    });
    return streams.reduce(pipe);
};
module.exports = pump;
}),
"[project]/node_modules/.pnpm/split2@4.2.0/node_modules/split2/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
Copyright (c) 2014-2021, Matteo Collina <hello@matteocollina.com>

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/ const { Transform } = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const { StringDecoder } = __turbopack_context__.r("[externals]/string_decoder [external] (string_decoder, cjs)");
const kLast = Symbol('last');
const kDecoder = Symbol('decoder');
function transform(chunk, enc, cb) {
    let list;
    if (this.overflow) {
        const buf = this[kDecoder].write(chunk);
        list = buf.split(this.matcher);
        if (list.length === 1) return cb() // Line ending not found. Discard entire chunk.
        ;
        // Line ending found. Discard trailing fragment of previous line and reset overflow state.
        list.shift();
        this.overflow = false;
    } else {
        this[kLast] += this[kDecoder].write(chunk);
        list = this[kLast].split(this.matcher);
    }
    this[kLast] = list.pop();
    for(let i = 0; i < list.length; i++){
        try {
            push(this, this.mapper(list[i]));
        } catch (error) {
            return cb(error);
        }
    }
    this.overflow = this[kLast].length > this.maxLength;
    if (this.overflow && !this.skipOverflow) {
        cb(new Error('maximum buffer reached'));
        return;
    }
    cb();
}
function flush(cb) {
    // forward any gibberish left in there
    this[kLast] += this[kDecoder].end();
    if (this[kLast]) {
        try {
            push(this, this.mapper(this[kLast]));
        } catch (error) {
            return cb(error);
        }
    }
    cb();
}
function push(self, val) {
    if (val !== undefined) {
        self.push(val);
    }
}
function noop(incoming) {
    return incoming;
}
function split(matcher, mapper, options) {
    // Set defaults for any arguments not supplied.
    matcher = matcher || /\r?\n/;
    mapper = mapper || noop;
    options = options || {};
    // Test arguments explicitly.
    switch(arguments.length){
        case 1:
            // If mapper is only argument.
            if (typeof matcher === 'function') {
                mapper = matcher;
                matcher = /\r?\n/;
            // If options is only argument.
            } else if (typeof matcher === 'object' && !(matcher instanceof RegExp) && !matcher[Symbol.split]) {
                options = matcher;
                matcher = /\r?\n/;
            }
            break;
        case 2:
            // If mapper and options are arguments.
            if (typeof matcher === 'function') {
                options = mapper;
                mapper = matcher;
                matcher = /\r?\n/;
            // If matcher and options are arguments.
            } else if (typeof mapper === 'object') {
                options = mapper;
                mapper = noop;
            }
    }
    options = Object.assign({}, options);
    options.autoDestroy = true;
    options.transform = transform;
    options.flush = flush;
    options.readableObjectMode = true;
    const stream = new Transform(options);
    stream[kLast] = '';
    stream[kDecoder] = new StringDecoder('utf8');
    stream.matcher = matcher;
    stream.mapper = mapper;
    stream.maxLength = options.maxLength;
    stream.skipOverflow = options.skipOverflow || false;
    stream.overflow = false;
    stream._destroy = function(err, cb) {
        // Weird Node v12 bug that we need to work around
        this._writableState.errorEmitted = false;
        cb(err);
    };
    return stream;
}
module.exports = split;
}),
"[project]/node_modules/.pnpm/pino-abstract-transport@2.0.0/node_modules/pino-abstract-transport/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const metadata = Symbol.for('pino.metadata');
const split = __turbopack_context__.r("[project]/node_modules/.pnpm/split2@4.2.0/node_modules/split2/index.js [app-rsc] (ecmascript)");
const { Duplex } = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const { parentPort, workerData } = __turbopack_context__.r("[externals]/worker_threads [external] (worker_threads, cjs)");
function createDeferred() {
    let resolve;
    let reject;
    const promise = new Promise((_resolve, _reject)=>{
        resolve = _resolve;
        reject = _reject;
    });
    promise.resolve = resolve;
    promise.reject = reject;
    return promise;
}
module.exports = function build(fn, opts = {}) {
    const waitForConfig = opts.expectPinoConfig === true && workerData?.workerData?.pinoWillSendConfig === true;
    const parseLines = opts.parse === 'lines';
    const parseLine = typeof opts.parseLine === 'function' ? opts.parseLine : JSON.parse;
    const close = opts.close || defaultClose;
    const stream = split(function(line) {
        let value;
        try {
            value = parseLine(line);
        } catch (error) {
            this.emit('unknown', line, error);
            return;
        }
        if (value === null) {
            this.emit('unknown', line, 'Null value ignored');
            return;
        }
        if (typeof value !== 'object') {
            value = {
                data: value,
                time: Date.now()
            };
        }
        if (stream[metadata]) {
            stream.lastTime = value.time;
            stream.lastLevel = value.level;
            stream.lastObj = value;
        }
        if (parseLines) {
            return line;
        }
        return value;
    }, {
        autoDestroy: true
    });
    stream._destroy = function(err, cb) {
        const promise = close(err, cb);
        if (promise && typeof promise.then === 'function') {
            promise.then(cb, cb);
        }
    };
    if (opts.expectPinoConfig === true && workerData?.workerData?.pinoWillSendConfig !== true) {
        setImmediate(()=>{
            stream.emit('error', new Error('This transport is not compatible with the current version of pino. Please upgrade pino to the latest version.'));
        });
    }
    if (opts.metadata !== false) {
        stream[metadata] = true;
        stream.lastTime = 0;
        stream.lastLevel = 0;
        stream.lastObj = null;
    }
    if (waitForConfig) {
        let pinoConfig = {};
        const configReceived = createDeferred();
        parentPort.on('message', function handleMessage(message) {
            if (message.code === 'PINO_CONFIG') {
                pinoConfig = message.config;
                configReceived.resolve();
                parentPort.off('message', handleMessage);
            }
        });
        Object.defineProperties(stream, {
            levels: {
                get () {
                    return pinoConfig.levels;
                }
            },
            messageKey: {
                get () {
                    return pinoConfig.messageKey;
                }
            },
            errorKey: {
                get () {
                    return pinoConfig.errorKey;
                }
            }
        });
        return configReceived.then(finish);
    }
    return finish();
    //TURBOPACK unreachable
    ;
    function finish() {
        let res = fn(stream);
        if (res && typeof res.catch === 'function') {
            res.catch((err)=>{
                stream.destroy(err);
            });
            // set it to null to not retain a reference to the promise
            res = null;
        } else if (opts.enablePipelining && res) {
            return Duplex.from({
                writable: stream,
                readable: res
            });
        }
        return stream;
    }
};
function defaultClose(err, cb) {
    process.nextTick(cb, err);
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/constants.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * A set of property names that indicate the value represents an error object.
 *
 * @typedef {string[]} K_ERROR_LIKE_KEYS
 */ module.exports = {
    DATE_FORMAT: 'yyyy-mm-dd HH:MM:ss.l o',
    DATE_FORMAT_SIMPLE: 'HH:MM:ss.l',
    /**
   * @type {K_ERROR_LIKE_KEYS}
   */ ERROR_LIKE_KEYS: [
        'err',
        'error'
    ],
    MESSAGE_KEY: 'msg',
    LEVEL_KEY: 'level',
    LEVEL_LABEL: 'levelLabel',
    TIMESTAMP_KEY: 'time',
    LEVELS: {
        default: 'USERLVL',
        60: 'FATAL',
        50: 'ERROR',
        40: 'WARN',
        30: 'INFO',
        20: 'DEBUG',
        10: 'TRACE'
    },
    LEVEL_NAMES: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
    },
    // Object keys that probably came from a logger like Pino or Bunyan.
    LOGGER_KEYS: [
        'pid',
        'hostname',
        'name',
        'level',
        'time',
        'timestamp',
        'caller'
    ]
};
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/get-level-label-data.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = getLevelLabelData;
const { LEVELS, LEVEL_NAMES } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/constants.js [app-rsc] (ecmascript)");
/**
 * Given initial settings for custom levels/names and use of only custom props
 * get the level label that corresponds with a given level number
 *
 * @param {boolean} useOnlyCustomProps
 * @param {object} customLevels
 * @param {object} customLevelNames
 *
 * @returns {function} A function that takes a number level and returns the level's label string
 */ function getLevelLabelData(useOnlyCustomProps, customLevels, customLevelNames) {
    const levels = useOnlyCustomProps ? customLevels || LEVELS : Object.assign({}, LEVELS, customLevels);
    const levelNames = useOnlyCustomProps ? customLevelNames || LEVEL_NAMES : Object.assign({}, LEVEL_NAMES, customLevelNames);
    return function(level) {
        let levelNum = 'default';
        if (Number.isInteger(+level)) {
            levelNum = Object.prototype.hasOwnProperty.call(levels, level) ? level : levelNum;
        } else {
            levelNum = Object.prototype.hasOwnProperty.call(levelNames, level.toLowerCase()) ? levelNames[level.toLowerCase()] : levelNum;
        }
        return [
            levels[levelNum],
            levelNum
        ];
    };
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/colors.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const nocolor = (input)=>input;
const plain = {
    default: nocolor,
    60: nocolor,
    50: nocolor,
    40: nocolor,
    30: nocolor,
    20: nocolor,
    10: nocolor,
    message: nocolor,
    greyMessage: nocolor,
    property: nocolor
};
const { createColors } = __turbopack_context__.r("[project]/node_modules/.pnpm/colorette@2.0.20/node_modules/colorette/index.cjs [app-rsc] (ecmascript)");
const getLevelLabelData = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/get-level-label-data.js [app-rsc] (ecmascript)");
const availableColors = createColors({
    useColor: true
});
const { white, bgRed, red, yellow, green, blue, gray, cyan, magenta } = availableColors;
const colored = {
    default: white,
    60: bgRed,
    50: red,
    40: yellow,
    30: green,
    20: blue,
    10: gray,
    message: cyan,
    greyMessage: gray,
    property: magenta
};
function resolveCustomColoredColorizer(customColors) {
    return customColors.reduce(function(agg, [level, color]) {
        agg[level] = typeof availableColors[color] === 'function' ? availableColors[color] : white;
        return agg;
    }, {
        default: white,
        message: cyan,
        greyMessage: gray,
        property: magenta
    });
}
function colorizeLevel(useOnlyCustomProps) {
    return function(level, colorizer, { customLevels, customLevelNames } = {}) {
        const [levelStr, levelNum] = getLevelLabelData(useOnlyCustomProps, customLevels, customLevelNames)(level);
        return Object.prototype.hasOwnProperty.call(colorizer, levelNum) ? colorizer[levelNum](levelStr) : colorizer.default(levelStr);
    };
}
function plainColorizer(useOnlyCustomProps) {
    const newPlainColorizer = colorizeLevel(useOnlyCustomProps);
    const customColoredColorizer = function(level, opts) {
        return newPlainColorizer(level, plain, opts);
    };
    customColoredColorizer.message = plain.message;
    customColoredColorizer.greyMessage = plain.greyMessage;
    customColoredColorizer.property = plain.property;
    customColoredColorizer.colors = createColors({
        useColor: false
    });
    return customColoredColorizer;
}
function coloredColorizer(useOnlyCustomProps) {
    const newColoredColorizer = colorizeLevel(useOnlyCustomProps);
    const customColoredColorizer = function(level, opts) {
        return newColoredColorizer(level, colored, opts);
    };
    customColoredColorizer.message = colored.message;
    customColoredColorizer.property = colored.property;
    customColoredColorizer.greyMessage = colored.greyMessage;
    customColoredColorizer.colors = availableColors;
    return customColoredColorizer;
}
function customColoredColorizerFactory(customColors, useOnlyCustomProps) {
    const onlyCustomColored = resolveCustomColoredColorizer(customColors);
    const customColored = useOnlyCustomProps ? onlyCustomColored : Object.assign({}, colored, onlyCustomColored);
    const colorizeLevelCustom = colorizeLevel(useOnlyCustomProps);
    const customColoredColorizer = function(level, opts) {
        return colorizeLevelCustom(level, customColored, opts);
    };
    customColoredColorizer.colors = availableColors;
    customColoredColorizer.message = customColoredColorizer.message || customColored.message;
    customColoredColorizer.property = customColoredColorizer.property || customColored.property;
    customColoredColorizer.greyMessage = customColoredColorizer.greyMessage || customColored.greyMessage;
    return customColoredColorizer;
}
/**
 * Applies colorization, if possible, to a string representing the passed in
 * `level`. For example, the default colorizer will return a "green" colored
 * string for the "info" level.
 *
 * @typedef {function} ColorizerFunc
 * @param {string|number} level In either case, the input will map to a color
 * for the specified level or to the color for `USERLVL` if the level is not
 * recognized.
 * @property {function} message Accepts one string parameter that will be
 * colorized to a predefined color.
 * @property {Colorette.Colorette} colors Available color functions based on `useColor` (or `colorize`) context
 */ /**
 * Factory function get a function to colorized levels. The returned function
 * also includes a `.message(str)` method to colorize strings.
 *
 * @param {boolean} [useColors=false] When `true` a function that applies standard
 * terminal colors is returned.
 * @param {array[]} [customColors] Tuple where first item of each array is the
 * level index and the second item is the color
 * @param {boolean} [useOnlyCustomProps] When `true`, only use the provided
 * custom colors provided and not fallback to default
 *
 * @returns {ColorizerFunc} `function (level) {}` has a `.message(str)` method to
 * apply colorization to a string. The core function accepts either an integer
 * `level` or a `string` level. The integer level will map to a known level
 * string or to `USERLVL` if not known.  The string `level` will map to the same
 * colors as the integer `level` and will also default to `USERLVL` if the given
 * string is not a recognized level name.
 */ module.exports = function getColorizer(useColors = false, customColors, useOnlyCustomProps) {
    if (useColors && customColors !== undefined) {
        return customColoredColorizerFactory(customColors, useOnlyCustomProps);
    } else if (useColors) {
        return coloredColorizer(useOnlyCustomProps);
    }
    return plainColorizer(useOnlyCustomProps);
};
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/noop.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function noop() {};
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/build-safe-sonic-boom.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = buildSafeSonicBoom;
const { isMainThread } = __turbopack_context__.r("[externals]/node:worker_threads [external] (node:worker_threads, cjs)");
const SonicBoom = __turbopack_context__.r("[project]/node_modules/.pnpm/sonic-boom@4.2.0/node_modules/sonic-boom/index.js [app-rsc] (ecmascript)");
const noop = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/noop.js [app-rsc] (ecmascript)");
/**
 * Creates a safe SonicBoom instance
 *
 * @param {object} opts Options for SonicBoom
 *
 * @returns {object} A new SonicBoom stream
 */ function buildSafeSonicBoom(opts) {
    const stream = new SonicBoom(opts);
    stream.on('error', filterBrokenPipe);
    // if we are sync: false, we must flush on exit
    if (!opts.sync && isMainThread) {
        setupOnExit(stream);
    }
    return stream;
    //TURBOPACK unreachable
    ;
    function filterBrokenPipe(err) {
        if (err.code === 'EPIPE') {
            stream.write = noop;
            stream.end = noop;
            stream.flushSync = noop;
            stream.destroy = noop;
            return;
        }
        stream.removeListener('error', filterBrokenPipe);
    }
}
function setupOnExit(stream) {
    /* istanbul ignore next */ if (/*TURBOPACK member replacement*/ __turbopack_context__.g.WeakRef && /*TURBOPACK member replacement*/ __turbopack_context__.g.WeakMap && /*TURBOPACK member replacement*/ __turbopack_context__.g.FinalizationRegistry) {
        // This is leak free, it does not leave event handlers
        const onExit = __turbopack_context__.r("[project]/node_modules/.pnpm/on-exit-leak-free@2.1.2/node_modules/on-exit-leak-free/index.js [app-rsc] (ecmascript)");
        onExit.register(stream, autoEnd);
        stream.on('close', function() {
            onExit.unregister(stream);
        });
    }
}
/* istanbul ignore next */ function autoEnd(stream, eventName) {
    // This check is needed only on some platforms
    if (stream.destroyed) {
        return;
    }
    if (eventName === 'beforeExit') {
        // We still have an event loop, let's use it
        stream.flush();
        stream.on('drain', function() {
            stream.end();
        });
    } else {
        // We do not have an event loop, so flush synchronously
        stream.flushSync();
    }
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/is-valid-date.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = isValidDate;
/**
 * Checks if the argument is a JS Date and not 'Invalid Date'.
 *
 * @param {Date} date The date to check.
 *
 * @returns {boolean} true if the argument is a JS Date and not 'Invalid Date'.
 */ function isValidDate(date) {
    return date instanceof Date && !Number.isNaN(date.getTime());
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/create-date.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = createDate;
const isValidDate = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/is-valid-date.js [app-rsc] (ecmascript)");
/**
 * Constructs a JS Date from a number or string. Accepts any single number
 * or single string argument that is valid for the Date() constructor,
 * or an epoch as a string.
 *
 * @param {string|number} epoch The representation of the Date.
 *
 * @returns {Date} The constructed Date.
 */ function createDate(epoch) {
    // If epoch is already a valid argument, return the valid Date
    let date = new Date(epoch);
    if (isValidDate(date)) {
        return date;
    }
    // Convert to a number to permit epoch as a string
    date = new Date(+epoch);
    return date;
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/split-property-key.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = splitPropertyKey;
/**
 * Splits the property key delimited by a dot character but not when it is preceded
 * by a backslash.
 *
 * @param {string} key A string identifying the property.
 *
 * @returns {string[]} Returns a list of string containing each delimited property.
 * e.g. `'prop2\.domain\.corp.prop2'` should return [ 'prop2.domain.com', 'prop2' ]
 */ function splitPropertyKey(key) {
    const result = [];
    let backslash = false;
    let segment = '';
    for(let i = 0; i < key.length; i++){
        const c = key.charAt(i);
        if (c === '\\') {
            backslash = true;
            continue;
        }
        if (backslash) {
            backslash = false;
            segment += c;
            continue;
        }
        /* Non-escaped dot, push to result */ if (c === '.') {
            result.push(segment);
            segment = '';
            continue;
        }
        segment += c;
    }
    /* Push last entry to result */ if (segment.length) {
        result.push(segment);
    }
    return result;
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/get-property-value.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = getPropertyValue;
const splitPropertyKey = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/split-property-key.js [app-rsc] (ecmascript)");
/**
 * Gets a specified property from an object if it exists.
 *
 * @param {object} obj The object to be searched.
 * @param {string|string[]} property A string, or an array of strings, identifying
 * the property to be retrieved from the object.
 * Accepts nested properties delimited by a `.`.
 * Delimiter can be escaped to preserve property names that contain the delimiter.
 * e.g. `'prop1.prop2'` or `'prop2\.domain\.corp.prop2'`.
 *
 * @returns {*}
 */ function getPropertyValue(obj, property) {
    const props = Array.isArray(property) ? property : splitPropertyKey(property);
    for (const prop of props){
        if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
            return;
        }
        obj = obj[prop];
    }
    return obj;
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/delete-log-property.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = deleteLogProperty;
const getPropertyValue = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/get-property-value.js [app-rsc] (ecmascript)");
const splitPropertyKey = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/split-property-key.js [app-rsc] (ecmascript)");
/**
 * Deletes a specified property from a log object if it exists.
 * This function mutates the passed in `log` object.
 *
 * @param {object} log The log object to be modified.
 * @param {string} property A string identifying the property to be deleted from
 * the log object. Accepts nested properties delimited by a `.`
 * Delimiter can be escaped to preserve property names that contain the delimiter.
 * e.g. `'prop1.prop2'` or `'prop2\.domain\.corp.prop2'`
 */ function deleteLogProperty(log, property) {
    const props = splitPropertyKey(property);
    const propToDelete = props.pop();
    log = getPropertyValue(log, props);
    /* istanbul ignore else */ if (log !== null && typeof log === 'object' && Object.prototype.hasOwnProperty.call(log, propToDelete)) {
        delete log[propToDelete];
    }
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/filter-log.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = filterLog;
const { createCopier } = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-copy@3.0.2/node_modules/fast-copy/dist/cjs/index.cjs [app-rsc] (ecmascript)");
const fastCopy = createCopier({});
const deleteLogProperty = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/delete-log-property.js [app-rsc] (ecmascript)");
/**
 * @typedef {object} FilterLogParams
 * @property {object} log The log object to be modified.
 * @property {PrettyContext} context The context object built from parsing
 * the options.
 */ /**
 * Filter a log object by removing or including keys accordingly.
 * When `includeKeys` is passed, `ignoredKeys` will be ignored.
 * One of ignoreKeys or includeKeys must be pass in.
 *
 * @param {FilterLogParams} input
 *
 * @returns {object} A new `log` object instance that
 *  either only includes the keys in ignoreKeys
 *  or does not include those in ignoredKeys.
 */ function filterLog({ log, context }) {
    const { ignoreKeys, includeKeys } = context;
    const logCopy = fastCopy(log);
    if (includeKeys) {
        const logIncluded = {};
        includeKeys.forEach((key)=>{
            logIncluded[key] = logCopy[key];
        });
        return logIncluded;
    }
    ignoreKeys.forEach((ignoreKey)=>{
        deleteLogProperty(logCopy, ignoreKey);
    });
    return logCopy;
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/format-time.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = formatTime;
const { DATE_FORMAT, DATE_FORMAT_SIMPLE } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/constants.js [app-rsc] (ecmascript)");
const dateformat = __turbopack_context__.r("[project]/node_modules/.pnpm/dateformat@4.6.3/node_modules/dateformat/lib/dateformat.js [app-rsc] (ecmascript)");
const createDate = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/create-date.js [app-rsc] (ecmascript)");
const isValidDate = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/is-valid-date.js [app-rsc] (ecmascript)");
/**
 * Converts a given `epoch` to a desired display format.
 *
 * @param {number|string} epoch The time to convert. May be any value that is
 * valid for `new Date()`.
 * @param {boolean|string} [translateTime=false] When `false`, the given `epoch`
 * will simply be returned. When `true`, the given `epoch` will be converted
 * to a string at UTC using the `DATE_FORMAT` constant. If `translateTime` is
 * a string, the following rules are available:
 *
 * - `<format string>`: The string is a literal format string. This format
 * string will be used to interpret the `epoch` and return a display string
 * at UTC.
 * - `SYS:STANDARD`: The returned display string will follow the `DATE_FORMAT`
 * constant at the system's local timezone.
 * - `SYS:<format string>`: The returned display string will follow the given
 * `<format string>` at the system's local timezone.
 * - `UTC:<format string>`: The returned display string will follow the given
 * `<format string>` at UTC.
 *
 * @returns {number|string} The formatted time.
 */ function formatTime(epoch, translateTime = false) {
    if (translateTime === false) {
        return epoch;
    }
    const instant = createDate(epoch);
    // If the Date is invalid, do not attempt to format
    if (!isValidDate(instant)) {
        return epoch;
    }
    if (translateTime === true) {
        return dateformat(instant, DATE_FORMAT_SIMPLE);
    }
    const upperFormat = translateTime.toUpperCase();
    if (upperFormat === 'SYS:STANDARD') {
        return dateformat(instant, DATE_FORMAT);
    }
    const prefix = upperFormat.substr(0, 4);
    if (prefix === 'SYS:' || prefix === 'UTC:') {
        if (prefix === 'UTC:') {
            return dateformat(instant, translateTime);
        }
        return dateformat(instant, translateTime.slice(4));
    }
    return dateformat(instant, `UTC:${translateTime}`);
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/handle-custom-levels-names-opts.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = handleCustomLevelsNamesOpts;
/**
 * Parse a CSV string or options object that maps level
 * labels to level values.
 *
 * @param {string|object} cLevels An object mapping level
 * names to level values, e.g. `{ info: 30, debug: 65 }`, or a
 * CSV string in the format `level_name:level_value`, e.g.
 * `info:30,debug:65`.
 *
 * @returns {object} An object mapping levels names to level values
 * e.g. `{ info: 30, debug: 65 }`.
 */ function handleCustomLevelsNamesOpts(cLevels) {
    if (!cLevels) return {};
    if (typeof cLevels === 'string') {
        return cLevels.split(',').reduce((agg, value, idx)=>{
            const [levelName, levelNum = idx] = value.split(':');
            agg[levelName.toLowerCase()] = levelNum;
            return agg;
        }, {});
    } else if (Object.prototype.toString.call(cLevels) === '[object Object]') {
        return Object.keys(cLevels).reduce((agg, levelName)=>{
            agg[levelName.toLowerCase()] = cLevels[levelName];
            return agg;
        }, {});
    } else {
        return {};
    }
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/handle-custom-levels-opts.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = handleCustomLevelsOpts;
/**
 * Parse a CSV string or options object that specifies
 * configuration for custom levels.
 *
 * @param {string|object} cLevels An object mapping level
 * names to values, e.g. `{ info: 30, debug: 65 }`, or a
 * CSV string in the format `level_name:level_value`, e.g.
 * `info:30,debug:65`.
 *
 * @returns {object} An object mapping levels to labels that
 * appear in logs, e.g. `{ '30': 'INFO', '65': 'DEBUG' }`.
 */ function handleCustomLevelsOpts(cLevels) {
    if (!cLevels) return {};
    if (typeof cLevels === 'string') {
        return cLevels.split(',').reduce((agg, value, idx)=>{
            const [levelName, levelNum = idx] = value.split(':');
            agg[levelNum] = levelName.toUpperCase();
            return agg;
        }, {
            default: 'USERLVL'
        });
    } else if (Object.prototype.toString.call(cLevels) === '[object Object]') {
        return Object.keys(cLevels).reduce((agg, levelName)=>{
            agg[cLevels[levelName]] = levelName.toUpperCase();
            return agg;
        }, {
            default: 'USERLVL'
        });
    } else {
        return {};
    }
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/interpret-conditionals.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = interpretConditionals;
const getPropertyValue = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/get-property-value.js [app-rsc] (ecmascript)");
/**
 * Translates all conditional blocks from within the messageFormat. Translates
 * any matching {if key}{key}{end} statements and returns everything between
 * if and else blocks if the key provided was found in log.
 *
 * @param {MessageFormatString|MessageFormatFunction} messageFormat A format
 * string or function that defines how the logged message should be
 * conditionally formatted.
 * @param {object} log The log object to be modified.
 *
 * @returns {string} The parsed messageFormat.
 */ function interpretConditionals(messageFormat, log) {
    messageFormat = messageFormat.replace(/{if (.*?)}(.*?){end}/g, replacer);
    // Remove non-terminated if blocks
    messageFormat = messageFormat.replace(/{if (.*?)}/g, '');
    // Remove floating end blocks
    messageFormat = messageFormat.replace(/{end}/g, '');
    return messageFormat.replace(/\s+/g, ' ').trim();
    //TURBOPACK unreachable
    ;
    function replacer(_, key, value) {
        const propertyValue = getPropertyValue(log, key);
        if (propertyValue && value.includes(key)) {
            return value.replace(new RegExp('{' + key + '}', 'g'), propertyValue);
        } else {
            return '';
        }
    }
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/is-object.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = isObject;
function isObject(input) {
    return Object.prototype.toString.apply(input) === '[object Object]';
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/join-lines-with-indentation.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = joinLinesWithIndentation;
/**
 * @typedef {object} JoinLinesWithIndentationParams
 * @property {string} input The string to split and reformat.
 * @property {string} [ident] The indentation string. Default: `    ` (4 spaces).
 * @property {string} [eol] The end of line sequence to use when rejoining
 * the lines. Default: `'\n'`.
 */ /**
 * Given a string with line separators, either `\r\n` or `\n`, add indentation
 * to all lines subsequent to the first line and rejoin the lines using an
 * end of line sequence.
 *
 * @param {JoinLinesWithIndentationParams} input
 *
 * @returns {string} A string with lines subsequent to the first indented
 * with the given indentation sequence.
 */ function joinLinesWithIndentation({ input, ident = '    ', eol = '\n' }) {
    const lines = input.split(/\r?\n/);
    for(let i = 1; i < lines.length; i += 1){
        lines[i] = ident + lines[i];
    }
    return lines.join(eol);
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/parse-factory-options.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = parseFactoryOptions;
const { LEVEL_NAMES } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/constants.js [app-rsc] (ecmascript)");
const colors = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/colors.js [app-rsc] (ecmascript)");
const handleCustomLevelsOpts = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/handle-custom-levels-opts.js [app-rsc] (ecmascript)");
const handleCustomLevelsNamesOpts = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/handle-custom-levels-names-opts.js [app-rsc] (ecmascript)");
const handleLevelLabelData = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/get-level-label-data.js [app-rsc] (ecmascript)");
/**
 * A `PrettyContext` is an object to be used by the various functions that
 * process log data. It is derived from the provided {@link PinoPrettyOptions}.
 * It may be used as a `this` context.
 *
 * @typedef {object} PrettyContext
 * @property {string} EOL The escape sequence chosen as the line terminator.
 * @property {string} IDENT The string to use as the indentation sequence.
 * @property {ColorizerFunc} colorizer A configured colorizer function.
 * @property {Array[Array<number, string>]} customColors A set of custom color
 * names associated with level numbers.
 * @property {object} customLevelNames A hash of level numbers to level names,
 * e.g. `{ 30: "info" }`.
 * @property {object} customLevels A hash of level names to level numbers,
 * e.g. `{ info: 30 }`.
 * @property {CustomPrettifiers} customPrettifiers A hash of custom prettifier
 * functions.
 * @property {object} customProperties Comprised of `customLevels` and
 * `customLevelNames` if such options are provided.
 * @property {string[]} errorLikeObjectKeys The key names in the log data that
 * should be considered as holding error objects.
 * @property {string[]} errorProps A list of error object keys that should be
 * included in the output.
 * @property {function} getLevelLabelData Pass a numeric level to return [levelLabelString,levelNum]
 * @property {boolean} hideObject Indicates the prettifier should omit objects
 * in the output.
 * @property {string[]} ignoreKeys Set of log data keys to omit.
 * @property {string[]} includeKeys Opposite of `ignoreKeys`.
 * @property {boolean} levelFirst Indicates the level should be printed first.
 * @property {string} levelKey Name of the key in the log data that contains
 * the message.
 * @property {string} levelLabel Format token to represent the position of the
 * level name in the output string.
 * @property {MessageFormatString|MessageFormatFunction} messageFormat
 * @property {string} messageKey Name of the key in the log data that contains
 * the message.
 * @property {string|number} minimumLevel The minimum log level to process
 * and output.
 * @property {ColorizerFunc} objectColorizer
 * @property {boolean} singleLine Indicates objects should be printed on a
 * single output line.
 * @property {string} timestampKey The name of the key in the log data that
 * contains the log timestamp.
 * @property {boolean} translateTime Indicates if timestamps should be
 * translated to a human-readable string.
 * @property {boolean} useOnlyCustomProps
 */ /**
 * @param {PinoPrettyOptions} options The user supplied object of options.
 *
 * @returns {PrettyContext}
 */ function parseFactoryOptions(options) {
    const EOL = options.crlf ? '\r\n' : '\n';
    const IDENT = '    ';
    const { customPrettifiers, errorLikeObjectKeys, hideObject, levelFirst, levelKey, levelLabel, messageFormat, messageKey, minimumLevel, singleLine, timestampKey, translateTime } = options;
    const errorProps = options.errorProps.split(',');
    const useOnlyCustomProps = typeof options.useOnlyCustomProps === 'boolean' ? options.useOnlyCustomProps : options.useOnlyCustomProps === 'true';
    const customLevels = handleCustomLevelsOpts(options.customLevels);
    const customLevelNames = handleCustomLevelsNamesOpts(options.customLevels);
    const getLevelLabelData = handleLevelLabelData(useOnlyCustomProps, customLevels, customLevelNames);
    let customColors;
    if (options.customColors) {
        if (typeof options.customColors === 'string') {
            customColors = options.customColors.split(',').reduce((agg, value)=>{
                const [level, color] = value.split(':');
                const condition = useOnlyCustomProps ? options.customLevels : customLevelNames[level] !== undefined;
                const levelNum = condition ? customLevelNames[level] : LEVEL_NAMES[level];
                const colorIdx = levelNum !== undefined ? levelNum : level;
                agg.push([
                    colorIdx,
                    color
                ]);
                return agg;
            }, []);
        } else if (typeof options.customColors === 'object') {
            customColors = Object.keys(options.customColors).reduce((agg, value)=>{
                const [level, color] = [
                    value,
                    options.customColors[value]
                ];
                const condition = useOnlyCustomProps ? options.customLevels : customLevelNames[level] !== undefined;
                const levelNum = condition ? customLevelNames[level] : LEVEL_NAMES[level];
                const colorIdx = levelNum !== undefined ? levelNum : level;
                agg.push([
                    colorIdx,
                    color
                ]);
                return agg;
            }, []);
        } else {
            throw new Error('options.customColors must be of type string or object.');
        }
    }
    const customProperties = {
        customLevels,
        customLevelNames
    };
    if (useOnlyCustomProps === true && !options.customLevels) {
        customProperties.customLevels = undefined;
        customProperties.customLevelNames = undefined;
    }
    const includeKeys = options.include !== undefined ? new Set(options.include.split(',')) : undefined;
    const ignoreKeys = !includeKeys && options.ignore ? new Set(options.ignore.split(',')) : undefined;
    const colorizer = colors(options.colorize, customColors, useOnlyCustomProps);
    const objectColorizer = options.colorizeObjects ? colorizer : colors(false, [], false);
    return {
        EOL,
        IDENT,
        colorizer,
        customColors,
        customLevelNames,
        customLevels,
        customPrettifiers,
        customProperties,
        errorLikeObjectKeys,
        errorProps,
        getLevelLabelData,
        hideObject,
        ignoreKeys,
        includeKeys,
        levelFirst,
        levelKey,
        levelLabel,
        messageFormat,
        messageKey,
        minimumLevel,
        objectColorizer,
        singleLine,
        timestampKey,
        translateTime,
        useOnlyCustomProps
    };
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-error.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = prettifyError;
const joinLinesWithIndentation = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/join-lines-with-indentation.js [app-rsc] (ecmascript)");
/**
 * @typedef {object} PrettifyErrorParams
 * @property {string} keyName The key assigned to this error in the log object.
 * @property {string} lines The STRINGIFIED error. If the error field has a
 *  custom prettifier, that should be pre-applied as well.
 * @property {string} ident The indentation sequence to use.
 * @property {string} eol The EOL sequence to use.
 */ /**
 * Prettifies an error string into a multi-line format.
 *
 * @param {PrettifyErrorParams} input
 *
 * @returns {string}
 */ function prettifyError({ keyName, lines, eol, ident }) {
    let result = '';
    const joinedLines = joinLinesWithIndentation({
        input: lines,
        ident,
        eol
    });
    const splitLines = `${ident}${keyName}: ${joinedLines}${eol}`.split(eol);
    for(let j = 0; j < splitLines.length; j += 1){
        if (j !== 0) result += eol;
        const line = splitLines[j];
        if (/^\s*"stack"/.test(line)) {
            const matches = /^(\s*"stack":)\s*(".*"),?$/.exec(line);
            /* istanbul ignore else */ if (matches && matches.length === 3) {
                const indentSize = /^\s*/.exec(line)[0].length + 4;
                const indentation = ' '.repeat(indentSize);
                const stackMessage = matches[2];
                result += matches[1] + eol + indentation + JSON.parse(stackMessage).replace(/\n/g, eol + indentation);
            } else {
                result += line;
            }
        } else {
            result += line;
        }
    }
    return result;
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-object.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = prettifyObject;
const { LOGGER_KEYS } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/constants.js [app-rsc] (ecmascript)");
const stringifySafe = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-safe-stringify@2.1.1/node_modules/fast-safe-stringify/index.js [app-rsc] (ecmascript)");
const joinLinesWithIndentation = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/join-lines-with-indentation.js [app-rsc] (ecmascript)");
const prettifyError = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-error.js [app-rsc] (ecmascript)");
/**
 * @typedef {object} PrettifyObjectParams
 * @property {object} log The object to prettify.
 * @property {boolean} [excludeLoggerKeys] Indicates if known logger specific
 * keys should be excluded from prettification. Default: `true`.
 * @property {string[]} [skipKeys] A set of object keys to exclude from the
 *  * prettified result. Default: `[]`.
 * @property {PrettyContext} context The context object built from parsing
 * the options.
 */ /**
 * Prettifies a standard object. Special care is taken when processing the object
 * to handle child objects that are attached to keys known to contain error
 * objects.
 *
 * @param {PrettifyObjectParams} input
 *
 * @returns {string} The prettified string. This can be as little as `''` if
 * there was nothing to prettify.
 */ function prettifyObject({ log, excludeLoggerKeys = true, skipKeys = [], context }) {
    const { EOL: eol, IDENT: ident, customPrettifiers, errorLikeObjectKeys: errorLikeKeys, objectColorizer, singleLine, colorizer } = context;
    const keysToIgnore = [].concat(skipKeys);
    /* istanbul ignore else */ if (excludeLoggerKeys === true) Array.prototype.push.apply(keysToIgnore, LOGGER_KEYS);
    let result = '';
    // Split object keys into two categories: error and non-error
    const { plain, errors } = Object.entries(log).reduce(({ plain, errors }, [k, v])=>{
        if (keysToIgnore.includes(k) === false) {
            // Pre-apply custom prettifiers, because all 3 cases below will need this
            const pretty = typeof customPrettifiers[k] === 'function' ? customPrettifiers[k](v, k, log, {
                colors: colorizer.colors
            }) : v;
            if (errorLikeKeys.includes(k)) {
                errors[k] = pretty;
            } else {
                plain[k] = pretty;
            }
        }
        return {
            plain,
            errors
        };
    }, {
        plain: {},
        errors: {}
    });
    if (singleLine) {
        // Stringify the entire object as a single JSON line
        /* istanbul ignore else */ if (Object.keys(plain).length > 0) {
            result += objectColorizer.greyMessage(stringifySafe(plain));
        }
        result += eol;
        // Avoid printing the escape character on escaped backslashes.
        result = result.replace(/\\\\/gi, '\\');
    } else {
        // Put each object entry on its own line
        Object.entries(plain).forEach(([keyName, keyValue])=>{
            // custom prettifiers are already applied above, so we can skip it now
            let lines = typeof customPrettifiers[keyName] === 'function' ? keyValue : stringifySafe(keyValue, null, 2);
            if (lines === undefined) return;
            // Avoid printing the escape character on escaped backslashes.
            lines = lines.replace(/\\\\/gi, '\\');
            const joinedLines = joinLinesWithIndentation({
                input: lines,
                ident,
                eol
            });
            result += `${ident}${objectColorizer.property(keyName)}:${joinedLines.startsWith(eol) ? '' : ' '}${joinedLines}${eol}`;
        });
    }
    // Errors
    Object.entries(errors).forEach(([keyName, keyValue])=>{
        // custom prettifiers are already applied above, so we can skip it now
        const lines = typeof customPrettifiers[keyName] === 'function' ? keyValue : stringifySafe(keyValue, null, 2);
        if (lines === undefined) return;
        result += prettifyError({
            keyName,
            lines,
            eol,
            ident
        });
    });
    return result;
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-error-log.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = prettifyErrorLog;
const { LOGGER_KEYS } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/constants.js [app-rsc] (ecmascript)");
const isObject = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/is-object.js [app-rsc] (ecmascript)");
const joinLinesWithIndentation = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/join-lines-with-indentation.js [app-rsc] (ecmascript)");
const prettifyObject = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-object.js [app-rsc] (ecmascript)");
/**
 * @typedef {object} PrettifyErrorLogParams
 * @property {object} log The error log to prettify.
 * @property {PrettyContext} context The context object built from parsing
 * the options.
 */ /**
 * Given a log object that has a `type: 'Error'` key, prettify the object and
 * return the result. In other
 *
 * @param {PrettifyErrorLogParams} input
 *
 * @returns {string} A string that represents the prettified error log.
 */ function prettifyErrorLog({ log, context }) {
    const { EOL: eol, IDENT: ident, errorProps: errorProperties, messageKey } = context;
    const stack = log.stack;
    const joinedLines = joinLinesWithIndentation({
        input: stack,
        ident,
        eol
    });
    let result = `${ident}${joinedLines}${eol}`;
    if (errorProperties.length > 0) {
        const excludeProperties = LOGGER_KEYS.concat(messageKey, 'type', 'stack');
        let propertiesToPrint;
        if (errorProperties[0] === '*') {
            // Print all sibling properties except for the standard exclusions.
            propertiesToPrint = Object.keys(log).filter((k)=>excludeProperties.includes(k) === false);
        } else {
            // Print only specified properties unless the property is a standard exclusion.
            propertiesToPrint = errorProperties.filter((k)=>excludeProperties.includes(k) === false);
        }
        for(let i = 0; i < propertiesToPrint.length; i += 1){
            const key = propertiesToPrint[i];
            if (key in log === false) continue;
            if (isObject(log[key])) {
                // The nested object may have "logger" type keys but since they are not
                // at the root level of the object being processed, we want to print them.
                // Thus, we invoke with `excludeLoggerKeys: false`.
                const prettifiedObject = prettifyObject({
                    log: log[key],
                    excludeLoggerKeys: false,
                    context: {
                        ...context,
                        IDENT: ident + ident
                    }
                });
                result = `${result}${ident}${key}: {${eol}${prettifiedObject}${ident}}${eol}`;
                continue;
            }
            result = `${result}${ident}${key}: ${log[key]}${eol}`;
        }
    }
    return result;
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-level.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = prettifyLevel;
const getPropertyValue = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/get-property-value.js [app-rsc] (ecmascript)");
/**
 * @typedef {object} PrettifyLevelParams
 * @property {object} log The log object.
 * @property {PrettyContext} context The context object built from parsing
 * the options.
 */ /**
 * Checks if the passed in log has a `level` value and returns a prettified
 * string for that level if so.
 *
 * @param {PrettifyLevelParams} input
 *
 * @returns {undefined|string} If `log` does not have a `level` property then
 * `undefined` will be returned. Otherwise, a string from the specified
 * `colorizer` is returned.
 */ function prettifyLevel({ log, context }) {
    const { colorizer, customLevels, customLevelNames, levelKey, getLevelLabelData } = context;
    const prettifier = context.customPrettifiers?.level;
    const output = getPropertyValue(log, levelKey);
    if (output === undefined) return undefined;
    const labelColorized = colorizer(output, {
        customLevels,
        customLevelNames
    });
    if (prettifier) {
        const [label] = getLevelLabelData(output);
        return prettifier(output, levelKey, log, {
            label,
            labelColorized,
            colors: colorizer.colors
        });
    }
    return labelColorized;
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-message.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = prettifyMessage;
const { LEVELS } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/constants.js [app-rsc] (ecmascript)");
const getPropertyValue = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/get-property-value.js [app-rsc] (ecmascript)");
const interpretConditionals = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/interpret-conditionals.js [app-rsc] (ecmascript)");
/**
 * @typedef {object} PrettifyMessageParams
 * @property {object} log The log object with the message to colorize.
 * @property {PrettyContext} context The context object built from parsing
 * the options.
 */ /**
 * Prettifies a message string if the given `log` has a message property.
 *
 * @param {PrettifyMessageParams} input
 *
 * @returns {undefined|string} If the message key is not found, or the message
 * key is not a string, then `undefined` will be returned. Otherwise, a string
 * that is the prettified message.
 */ function prettifyMessage({ log, context }) {
    const { colorizer, customLevels, levelKey, levelLabel, messageFormat, messageKey, useOnlyCustomProps } = context;
    if (messageFormat && typeof messageFormat === 'string') {
        const parsedMessageFormat = interpretConditionals(messageFormat, log);
        const message = String(parsedMessageFormat).replace(/{([^{}]+)}/g, function(match, p1) {
            // return log level as string instead of int
            let level;
            if (p1 === levelLabel && (level = getPropertyValue(log, levelKey)) !== undefined) {
                const condition = useOnlyCustomProps ? customLevels === undefined : customLevels[level] === undefined;
                return condition ? LEVELS[level] : customLevels[level];
            }
            // Parse nested key access, e.g. `{keyA.subKeyB}`.
            return getPropertyValue(log, p1) || '';
        });
        return colorizer.message(message);
    }
    if (messageFormat && typeof messageFormat === 'function') {
        const msg = messageFormat(log, messageKey, levelLabel, {
            colors: colorizer.colors
        });
        return colorizer.message(msg);
    }
    if (messageKey in log === false) return undefined;
    if (typeof log[messageKey] !== 'string' && typeof log[messageKey] !== 'number' && typeof log[messageKey] !== 'boolean') return undefined;
    return colorizer.message(log[messageKey]);
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-metadata.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = prettifyMetadata;
/**
 * @typedef {object} PrettifyMetadataParams
 * @property {object} log The log that may or may not contain metadata to
 * be prettified.
 * @property {PrettyContext} context The context object built from parsing
 * the options.
 */ /**
 * Prettifies metadata that is usually present in a Pino log line. It looks for
 * fields `name`, `pid`, `hostname`, and `caller` and returns a formatted string using
 * the fields it finds.
 *
 * @param {PrettifyMetadataParams} input
 *
 * @returns {undefined|string} If no metadata is found then `undefined` is
 * returned. Otherwise, a string of prettified metadata is returned.
 */ function prettifyMetadata({ log, context }) {
    const { customPrettifiers: prettifiers, colorizer } = context;
    let line = '';
    if (log.name || log.pid || log.hostname) {
        line += '(';
        if (log.name) {
            line += prettifiers.name ? prettifiers.name(log.name, 'name', log, {
                colors: colorizer.colors
            }) : log.name;
        }
        if (log.pid) {
            const prettyPid = prettifiers.pid ? prettifiers.pid(log.pid, 'pid', log, {
                colors: colorizer.colors
            }) : log.pid;
            if (log.name && log.pid) {
                line += '/' + prettyPid;
            } else {
                line += prettyPid;
            }
        }
        if (log.hostname) {
            // If `pid` and `name` were in the ignore keys list then we don't need
            // the leading space.
            const prettyHostname = prettifiers.hostname ? prettifiers.hostname(log.hostname, 'hostname', log, {
                colors: colorizer.colors
            }) : log.hostname;
            line += `${line === '(' ? 'on' : ' on'} ${prettyHostname}`;
        }
        line += ')';
    }
    if (log.caller) {
        const prettyCaller = prettifiers.caller ? prettifiers.caller(log.caller, 'caller', log, {
            colors: colorizer.colors
        }) : log.caller;
        line += `${line === '' ? '' : ' '}<${prettyCaller}>`;
    }
    if (line === '') {
        return undefined;
    } else {
        return line;
    }
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-time.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = prettifyTime;
const formatTime = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/format-time.js [app-rsc] (ecmascript)");
/**
 * @typedef {object} PrettifyTimeParams
 * @property {object} log The log object with the timestamp to be prettified.
 * @property {PrettyContext} context The context object built from parsing
 * the options.
 */ /**
 * Prettifies a timestamp if the given `log` has either `time`, `timestamp` or custom specified timestamp
 * property.
 *
 * @param {PrettifyTimeParams} input
 *
 * @returns {undefined|string} If a timestamp property cannot be found then
 * `undefined` is returned. Otherwise, the prettified time is returned as a
 * string.
 */ function prettifyTime({ log, context }) {
    const { timestampKey, translateTime: translateFormat } = context;
    const prettifier = context.customPrettifiers?.time;
    let time = null;
    if (timestampKey in log) {
        time = log[timestampKey];
    } else if ('timestamp' in log) {
        time = log.timestamp;
    }
    if (time === null) return undefined;
    const output = translateFormat ? formatTime(time, translateFormat) : time;
    return prettifier ? prettifier(output) : `[${output}]`;
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {
    buildSafeSonicBoom: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/build-safe-sonic-boom.js [app-rsc] (ecmascript)"),
    createDate: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/create-date.js [app-rsc] (ecmascript)"),
    deleteLogProperty: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/delete-log-property.js [app-rsc] (ecmascript)"),
    filterLog: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/filter-log.js [app-rsc] (ecmascript)"),
    formatTime: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/format-time.js [app-rsc] (ecmascript)"),
    getPropertyValue: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/get-property-value.js [app-rsc] (ecmascript)"),
    handleCustomLevelsNamesOpts: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/handle-custom-levels-names-opts.js [app-rsc] (ecmascript)"),
    handleCustomLevelsOpts: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/handle-custom-levels-opts.js [app-rsc] (ecmascript)"),
    interpretConditionals: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/interpret-conditionals.js [app-rsc] (ecmascript)"),
    isObject: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/is-object.js [app-rsc] (ecmascript)"),
    isValidDate: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/is-valid-date.js [app-rsc] (ecmascript)"),
    joinLinesWithIndentation: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/join-lines-with-indentation.js [app-rsc] (ecmascript)"),
    noop: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/noop.js [app-rsc] (ecmascript)"),
    parseFactoryOptions: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/parse-factory-options.js [app-rsc] (ecmascript)"),
    prettifyErrorLog: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-error-log.js [app-rsc] (ecmascript)"),
    prettifyError: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-error.js [app-rsc] (ecmascript)"),
    prettifyLevel: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-level.js [app-rsc] (ecmascript)"),
    prettifyMessage: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-message.js [app-rsc] (ecmascript)"),
    prettifyMetadata: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-metadata.js [app-rsc] (ecmascript)"),
    prettifyObject: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-object.js [app-rsc] (ecmascript)"),
    prettifyTime: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-time.js [app-rsc] (ecmascript)"),
    splitPropertyKey: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/split-property-key.js [app-rsc] (ecmascript)"),
    getLevelLabelData: __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/get-level-label-data.js [app-rsc] (ecmascript)")
}; // The remainder of this file consists of jsdoc blocks that are difficult to
 // determine a more appropriate "home" for. As an example, the blocks associated
 // with custom prettifiers could live in either the `prettify-level`,
 // `prettify-metadata`, or `prettify-time` files since they are the primary
 // files where such code is used. But we want a central place to define common
 // doc blocks, so we are picking this file as the answer.
 /**
 * A hash of log property names mapped to prettifier functions. When the
 * incoming log data is being processed for prettification, any key on the log
 * that matches a key in a custom prettifiers hash will be prettified using
 * that matching custom prettifier. The value passed to the custom prettifier
 * will the value associated with the corresponding log key.
 *
 * The hash may contain any arbitrary keys for arbitrary log properties, but it
 * may also contain a set of predefined key names that map to well-known log
 * properties. These keys are:
 *
 * + `time` (for the timestamp field)
 * + `level` (for the level label field; value may be a level number instead
 * of a level label)
 * + `hostname`
 * + `pid`
 * + `name`
 * + `caller`
 *
 * @typedef {Object.<string, CustomPrettifierFunc>} CustomPrettifiers
 */  /**
 * A synchronous function to be used for prettifying a log property. It must
 * return a string.
 *
 * @typedef {function} CustomPrettifierFunc
 * @param {any} value The value to be prettified for the key associated with
 * the prettifier.
 * @returns {string}
 */  /**
 * A tokenized string that indicates how the prettified log line should be
 * formatted. Tokens are either log properties enclosed in curly braces, e.g.
 * `{levelLabel}`, `{pid}`, or `{req.url}`, or conditional directives in curly
 * braces. The only conditional directives supported are `if` and `end`, e.g.
 * `{if pid}{pid}{end}`; every `if` must have a matching `end`. Nested
 * conditions are not supported.
 *
 * @typedef {string} MessageFormatString
 *
 * @example
 * `{levelLabel} - {if pid}{pid} - {end}url:{req.url}`
 */  /**
 * @typedef {object} PrettifyMessageExtras
 * @property {object} colors Available color functions based on `useColor` (or `colorize`) context
 * the options.
 */  /**
 * A function that accepts a log object, name of the message key, and name of
 * the level label key and returns a formatted log line.
 *
 * Note: this function must be synchronous.
 *
 * @typedef {function} MessageFormatFunction
 * @param {object} log The log object to be processed.
 * @param {string} messageKey The name of the key in the `log` object that
 * contains the log message.
 * @param {string} levelLabel The name of the key in the `log` object that
 * contains the log level name.
 * @param {PrettifyMessageExtras} extras Additional data available for message context
 * @returns {string}
 *
 * @example
 * function (log, messageKey, levelLabel) {
 *   return `${log[levelLabel]} - ${log[messageKey]}`
 * }
 */ 
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/pretty.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = pretty;
const sjs = __turbopack_context__.r("[project]/node_modules/.pnpm/secure-json-parse@4.1.0/node_modules/secure-json-parse/index.js [app-rsc] (ecmascript)");
const isObject = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/is-object.js [app-rsc] (ecmascript)");
const prettifyErrorLog = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-error-log.js [app-rsc] (ecmascript)");
const prettifyLevel = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-level.js [app-rsc] (ecmascript)");
const prettifyMessage = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-message.js [app-rsc] (ecmascript)");
const prettifyMetadata = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-metadata.js [app-rsc] (ecmascript)");
const prettifyObject = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-object.js [app-rsc] (ecmascript)");
const prettifyTime = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/prettify-time.js [app-rsc] (ecmascript)");
const filterLog = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/filter-log.js [app-rsc] (ecmascript)");
const { LEVELS, LEVEL_KEY, LEVEL_NAMES } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/constants.js [app-rsc] (ecmascript)");
const jsonParser = (input)=>{
    try {
        return {
            value: sjs.parse(input, {
                protoAction: 'remove'
            })
        };
    } catch (err) {
        return {
            err
        };
    }
};
/**
 * Orchestrates processing the received log data according to the provided
 * configuration and returns a prettified log string.
 *
 * @typedef {function} LogPrettifierFunc
 * @param {string|object} inputData A log string or a log-like object.
 * @returns {string} A string that represents the prettified log data.
 */ function pretty(inputData) {
    let log;
    if (!isObject(inputData)) {
        const parsed = jsonParser(inputData);
        if (parsed.err || !isObject(parsed.value)) {
            // pass through
            return inputData + this.EOL;
        }
        log = parsed.value;
    } else {
        log = inputData;
    }
    if (this.minimumLevel) {
        // We need to figure out if the custom levels has the desired minimum
        // level & use that one if found. If not, determine if the level exists
        // in the standard levels. In both cases, make sure we have the level
        // number instead of the level name.
        let condition;
        if (this.useOnlyCustomProps) {
            condition = this.customLevels;
        } else {
            condition = this.customLevelNames[this.minimumLevel] !== undefined;
        }
        let minimum;
        if (condition) {
            minimum = this.customLevelNames[this.minimumLevel];
        } else {
            minimum = LEVEL_NAMES[this.minimumLevel];
        }
        if (!minimum) {
            minimum = typeof this.minimumLevel === 'string' ? LEVEL_NAMES[this.minimumLevel] : LEVEL_NAMES[LEVELS[this.minimumLevel].toLowerCase()];
        }
        const level = log[this.levelKey === undefined ? LEVEL_KEY : this.levelKey];
        if (level < minimum) return;
    }
    const prettifiedMessage = prettifyMessage({
        log,
        context: this.context
    });
    if (this.ignoreKeys || this.includeKeys) {
        log = filterLog({
            log,
            context: this.context
        });
    }
    const prettifiedLevel = prettifyLevel({
        log,
        context: {
            ...this.context,
            // This is odd. The colorizer ends up relying on the value of
            // `customProperties` instead of the original `customLevels` and
            // `customLevelNames`.
            ...this.context.customProperties
        }
    });
    const prettifiedMetadata = prettifyMetadata({
        log,
        context: this.context
    });
    const prettifiedTime = prettifyTime({
        log,
        context: this.context
    });
    let line = '';
    if (this.levelFirst && prettifiedLevel) {
        line = `${prettifiedLevel}`;
    }
    if (prettifiedTime && line === '') {
        line = `${prettifiedTime}`;
    } else if (prettifiedTime) {
        line = `${line} ${prettifiedTime}`;
    }
    if (!this.levelFirst && prettifiedLevel) {
        if (line.length > 0) {
            line = `${line} ${prettifiedLevel}`;
        } else {
            line = prettifiedLevel;
        }
    }
    if (prettifiedMetadata) {
        if (line.length > 0) {
            line = `${line} ${prettifiedMetadata}:`;
        } else {
            line = prettifiedMetadata;
        }
    }
    if (line.endsWith(':') === false && line !== '') {
        line += ':';
    }
    if (prettifiedMessage !== undefined) {
        if (line.length > 0) {
            line = `${line} ${prettifiedMessage}`;
        } else {
            line = prettifiedMessage;
        }
    }
    if (line.length > 0 && !this.singleLine) {
        line += this.EOL;
    }
    // pino@7+ does not log this anymore
    if (log.type === 'Error' && typeof log.stack === 'string') {
        const prettifiedErrorLog = prettifyErrorLog({
            log,
            context: this.context
        });
        if (this.singleLine) line += this.EOL;
        line += prettifiedErrorLog;
    } else if (this.hideObject === false) {
        const skipKeys = [
            this.messageKey,
            this.levelKey,
            this.timestampKey
        ].map((key)=>key.replaceAll(/\\/g, '')).filter((key)=>{
            return typeof log[key] === 'string' || typeof log[key] === 'number' || typeof log[key] === 'boolean';
        });
        const prettifiedObject = prettifyObject({
            log,
            skipKeys,
            context: this.context
        });
        // In single line mode, include a space only if prettified version isn't empty
        if (this.singleLine && !/^\s$/.test(prettifiedObject)) {
            line += ' ';
        }
        line += prettifiedObject;
    }
    return line;
}
}),
"[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { isColorSupported } = __turbopack_context__.r("[project]/node_modules/.pnpm/colorette@2.0.20/node_modules/colorette/index.cjs [app-rsc] (ecmascript)");
const pump = __turbopack_context__.r("[project]/node_modules/.pnpm/pump@3.0.3/node_modules/pump/index.js [app-rsc] (ecmascript)");
const { Transform } = __turbopack_context__.r("[externals]/node:stream [external] (node:stream, cjs)");
const abstractTransport = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-abstract-transport@2.0.0/node_modules/pino-abstract-transport/index.js [app-rsc] (ecmascript)");
const colors = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/colors.js [app-rsc] (ecmascript)");
const { ERROR_LIKE_KEYS, LEVEL_KEY, LEVEL_LABEL, MESSAGE_KEY, TIMESTAMP_KEY } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/constants.js [app-rsc] (ecmascript)");
const { buildSafeSonicBoom, parseFactoryOptions } = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/utils/index.js [app-rsc] (ecmascript)");
const pretty = __turbopack_context__.r("[project]/node_modules/.pnpm/pino-pretty@13.1.2/node_modules/pino-pretty/lib/pretty.js [app-rsc] (ecmascript)");
/**
 * @typedef {object} PinoPrettyOptions
 * @property {boolean} [colorize] Indicates if colors should be used when
 * prettifying. The default will be determined by the terminal capabilities at
 * run time.
 * @property {boolean} [colorizeObjects=true] Apply coloring to rendered objects
 * when coloring is enabled.
 * @property {boolean} [crlf=false] End lines with `\r\n` instead of `\n`.
 * @property {string|null} [customColors=null] A comma separated list of colors
 * to use for specific level labels, e.g. `err:red,info:blue`.
 * @property {string|null} [customLevels=null] A comma separated list of user
 * defined level names and numbers, e.g. `err:99,info:1`.
 * @property {CustomPrettifiers} [customPrettifiers={}] A set of prettifier
 * functions to apply to keys defined in this object.
 * @property {K_ERROR_LIKE_KEYS} [errorLikeObjectKeys] A list of string property
 * names to consider as error objects.
 * @property {string} [errorProps=''] A comma separated list of properties on
 * error objects to include in the output.
 * @property {boolean} [hideObject=false] When `true`, data objects will be
 * omitted from the output (except for error objects).
 * @property {string} [ignore='hostname'] A comma separated list of log keys
 * to omit when outputting the prettified log information.
 * @property {undefined|string} [include=undefined] A comma separated list of
 * log keys to include in the prettified log information. Only the keys in this
 * list will be included in the output.
 * @property {boolean} [levelFirst=false] When true, the log level will be the
 * first field in the prettified output.
 * @property {string} [levelKey='level'] The key name in the log data that
 * contains the level value for the log.
 * @property {string} [levelLabel='levelLabel'] Token name to use in
 * `messageFormat` to represent the name of the logged level.
 * @property {null|MessageFormatString|MessageFormatFunction} [messageFormat=null]
 * When a string, defines how the prettified line should be formatted according
 * to defined tokens. When a function, a synchronous function that returns a
 * formatted string.
 * @property {string} [messageKey='msg'] Defines the key in incoming logs that
 * contains the message of the log, if present.
 * @property {undefined|string|number} [minimumLevel=undefined] The minimum
 * level for logs that should be processed. Any logs below this level will
 * be omitted.
 * @property {object} [outputStream=process.stdout] The stream to write
 * prettified log lines to.
 * @property {boolean} [singleLine=false] When `true` any objects, except error
 * objects, in the log data will be printed as a single line instead as multiple
 * lines.
 * @property {string} [timestampKey='time'] Defines the key in incoming logs
 * that contains the timestamp of the log, if present.
 * @property {boolean|string} [translateTime=true] When true, will translate a
 * JavaScript date integer into a human-readable string. If set to a string,
 * it must be a format string.
 * @property {boolean} [useOnlyCustomProps=true] When true, only custom levels
 * and colors will be used if they have been provided.
 */ /**
 * The default options that will be used when prettifying log lines.
 *
 * @type {PinoPrettyOptions}
 */ const defaultOptions = {
    colorize: isColorSupported,
    colorizeObjects: true,
    crlf: false,
    customColors: null,
    customLevels: null,
    customPrettifiers: {},
    errorLikeObjectKeys: ERROR_LIKE_KEYS,
    errorProps: '',
    hideObject: false,
    ignore: 'hostname',
    include: undefined,
    levelFirst: false,
    levelKey: LEVEL_KEY,
    levelLabel: LEVEL_LABEL,
    messageFormat: null,
    messageKey: MESSAGE_KEY,
    minimumLevel: undefined,
    outputStream: process.stdout,
    singleLine: false,
    timestampKey: TIMESTAMP_KEY,
    translateTime: true,
    useOnlyCustomProps: true
};
/**
 * Processes the supplied options and returns a function that accepts log data
 * and produces a prettified log string.
 *
 * @param {PinoPrettyOptions} options Configuration for the prettifier.
 * @returns {LogPrettifierFunc}
 */ function prettyFactory(options) {
    const context = parseFactoryOptions(Object.assign({}, defaultOptions, options));
    return pretty.bind({
        ...context,
        context
    });
}
/**
 * @typedef {PinoPrettyOptions} BuildStreamOpts
 * @property {object|number|string} [destination] A destination stream, file
 * descriptor, or target path to a file.
 * @property {boolean} [append]
 * @property {boolean} [mkdir]
 * @property {boolean} [sync=false]
 */ /**
 * Constructs a {@link LogPrettifierFunc} and a stream to which the produced
 * prettified log data will be written.
 *
 * @param {BuildStreamOpts} opts
 * @returns {Transform | (Transform & OnUnknown)}
 */ function build(opts = {}) {
    let pretty = prettyFactory(opts);
    let destination;
    return abstractTransport(function(source) {
        source.on('message', function pinoConfigListener(message) {
            if (!message || message.code !== 'PINO_CONFIG') return;
            Object.assign(opts, {
                messageKey: message.config.messageKey,
                errorLikeObjectKeys: Array.from(new Set([
                    ...opts.errorLikeObjectKeys || ERROR_LIKE_KEYS,
                    message.config.errorKey
                ])),
                customLevels: message.config.levels.values
            });
            pretty = prettyFactory(opts);
            source.off('message', pinoConfigListener);
        });
        const stream = new Transform({
            objectMode: true,
            autoDestroy: true,
            transform (chunk, enc, cb) {
                const line = pretty(chunk);
                cb(null, line);
            }
        });
        if (typeof opts.destination === 'object' && typeof opts.destination.write === 'function') {
            destination = opts.destination;
        } else {
            destination = buildSafeSonicBoom({
                dest: opts.destination || 1,
                append: opts.append,
                mkdir: opts.mkdir,
                sync: opts.sync // by default sonic will be async
            });
        }
        source.on('unknown', function(line) {
            destination.write(line + '\n');
        });
        pump(source, stream, destination);
        return stream;
    }, {
        parse: 'lines',
        close (err, cb) {
            destination.on('close', ()=>{
                cb(err);
            });
        }
    });
}
module.exports = build;
module.exports.build = build;
module.exports.PinoPretty = build;
module.exports.prettyFactory = prettyFactory;
module.exports.colorizerFactory = colors;
module.exports.isColorSupported = isColorSupported;
module.exports.default = build;
}),
"[project]/node_modules/.pnpm/fast-copy@3.0.2/node_modules/fast-copy/dist/cjs/index.cjs [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, '__esModule', {
    value: true
});
var toStringFunction = Function.prototype.toString;
var create = Object.create;
var toStringObject = Object.prototype.toString;
/**
 * @classdesc Fallback cache for when WeakMap is not natively supported
 */ var LegacyCache = function() {
    function LegacyCache() {
        this._keys = [];
        this._values = [];
    }
    LegacyCache.prototype.has = function(key) {
        return !!~this._keys.indexOf(key);
    };
    LegacyCache.prototype.get = function(key) {
        return this._values[this._keys.indexOf(key)];
    };
    LegacyCache.prototype.set = function(key, value) {
        this._keys.push(key);
        this._values.push(value);
    };
    return LegacyCache;
}();
function createCacheLegacy() {
    return new LegacyCache();
}
function createCacheModern() {
    return new WeakMap();
}
/**
 * Get a new cache object to prevent circular references.
 */ var createCache = typeof WeakMap !== 'undefined' ? createCacheModern : createCacheLegacy;
/**
 * Get an empty version of the object with the same prototype it has.
 */ function getCleanClone(prototype) {
    if (!prototype) {
        return create(null);
    }
    var Constructor = prototype.constructor;
    if (Constructor === Object) {
        return prototype === Object.prototype ? {} : create(prototype);
    }
    if (Constructor && ~toStringFunction.call(Constructor).indexOf('[native code]')) {
        try {
            return new Constructor();
        } catch (_a) {}
    }
    return create(prototype);
}
function getRegExpFlagsLegacy(regExp) {
    var flags = '';
    if (regExp.global) {
        flags += 'g';
    }
    if (regExp.ignoreCase) {
        flags += 'i';
    }
    if (regExp.multiline) {
        flags += 'm';
    }
    if (regExp.unicode) {
        flags += 'u';
    }
    if (regExp.sticky) {
        flags += 'y';
    }
    return flags;
}
function getRegExpFlagsModern(regExp) {
    return regExp.flags;
}
/**
 * Get the flags to apply to the copied regexp.
 */ var getRegExpFlags = /test/g.flags === 'g' ? getRegExpFlagsModern : getRegExpFlagsLegacy;
function getTagLegacy(value) {
    var type = toStringObject.call(value);
    return type.substring(8, type.length - 1);
}
function getTagModern(value) {
    return value[Symbol.toStringTag] || getTagLegacy(value);
}
/**
 * Get the tag of the value passed, so that the correct copier can be used.
 */ var getTag = typeof Symbol !== 'undefined' ? getTagModern : getTagLegacy;
var defineProperty = Object.defineProperty, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols;
var _a = Object.prototype, hasOwnProperty = _a.hasOwnProperty, propertyIsEnumerable = _a.propertyIsEnumerable;
var SUPPORTS_SYMBOL = typeof getOwnPropertySymbols === 'function';
function getStrictPropertiesModern(object) {
    return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
}
/**
 * Get the properites used when copying objects strictly. This includes both keys and symbols.
 */ var getStrictProperties = SUPPORTS_SYMBOL ? getStrictPropertiesModern : getOwnPropertyNames;
/**
 * Striclty copy all properties contained on the object.
 */ function copyOwnPropertiesStrict(value, clone, state) {
    var properties = getStrictProperties(value);
    for(var index = 0, length_1 = properties.length, property = void 0, descriptor = void 0; index < length_1; ++index){
        property = properties[index];
        if (property === 'callee' || property === 'caller') {
            continue;
        }
        descriptor = getOwnPropertyDescriptor(value, property);
        if (!descriptor) {
            // In extra edge cases where the property descriptor cannot be retrived, fall back to
            // the loose assignment.
            clone[property] = state.copier(value[property], state);
            continue;
        }
        // Only clone the value if actually a value, not a getter / setter.
        if (!descriptor.get && !descriptor.set) {
            descriptor.value = state.copier(descriptor.value, state);
        }
        try {
            defineProperty(clone, property, descriptor);
        } catch (error) {
            // Tee above can fail on node in edge cases, so fall back to the loose assignment.
            clone[property] = descriptor.value;
        }
    }
    return clone;
}
/**
 * Deeply copy the indexed values in the array.
 */ function copyArrayLoose(array, state) {
    var clone = new state.Constructor();
    // set in the cache immediately to be able to reuse the object recursively
    state.cache.set(array, clone);
    for(var index = 0, length_2 = array.length; index < length_2; ++index){
        clone[index] = state.copier(array[index], state);
    }
    return clone;
}
/**
 * Deeply copy the indexed values in the array, as well as any custom properties.
 */ function copyArrayStrict(array, state) {
    var clone = new state.Constructor();
    // set in the cache immediately to be able to reuse the object recursively
    state.cache.set(array, clone);
    return copyOwnPropertiesStrict(array, clone, state);
}
/**
 * Copy the contents of the ArrayBuffer.
 */ function copyArrayBuffer(arrayBuffer, _state) {
    return arrayBuffer.slice(0);
}
/**
 * Create a new Blob with the contents of the original.
 */ function copyBlob(blob, _state) {
    return blob.slice(0, blob.size, blob.type);
}
/**
 * Create a new DataView with the contents of the original.
 */ function copyDataView(dataView, state) {
    return new state.Constructor(copyArrayBuffer(dataView.buffer));
}
/**
 * Create a new Date based on the time of the original.
 */ function copyDate(date, state) {
    return new state.Constructor(date.getTime());
}
/**
 * Deeply copy the keys and values of the original.
 */ function copyMapLoose(map, state) {
    var clone = new state.Constructor();
    // set in the cache immediately to be able to reuse the object recursively
    state.cache.set(map, clone);
    map.forEach(function(value, key) {
        clone.set(key, state.copier(value, state));
    });
    return clone;
}
/**
 * Deeply copy the keys and values of the original, as well as any custom properties.
 */ function copyMapStrict(map, state) {
    return copyOwnPropertiesStrict(map, copyMapLoose(map, state), state);
}
function copyObjectLooseLegacy(object, state) {
    var clone = getCleanClone(state.prototype);
    // set in the cache immediately to be able to reuse the object recursively
    state.cache.set(object, clone);
    for(var key in object){
        if (hasOwnProperty.call(object, key)) {
            clone[key] = state.copier(object[key], state);
        }
    }
    return clone;
}
function copyObjectLooseModern(object, state) {
    var clone = getCleanClone(state.prototype);
    // set in the cache immediately to be able to reuse the object recursively
    state.cache.set(object, clone);
    for(var key in object){
        if (hasOwnProperty.call(object, key)) {
            clone[key] = state.copier(object[key], state);
        }
    }
    var symbols = getOwnPropertySymbols(object);
    for(var index = 0, length_3 = symbols.length, symbol = void 0; index < length_3; ++index){
        symbol = symbols[index];
        if (propertyIsEnumerable.call(object, symbol)) {
            clone[symbol] = state.copier(object[symbol], state);
        }
    }
    return clone;
}
/**
 * Deeply copy the properties (keys and symbols) and values of the original.
 */ var copyObjectLoose = SUPPORTS_SYMBOL ? copyObjectLooseModern : copyObjectLooseLegacy;
/**
 * Deeply copy the properties (keys and symbols) and values of the original, as well
 * as any hidden or non-enumerable properties.
 */ function copyObjectStrict(object, state) {
    var clone = getCleanClone(state.prototype);
    // set in the cache immediately to be able to reuse the object recursively
    state.cache.set(object, clone);
    return copyOwnPropertiesStrict(object, clone, state);
}
/**
 * Create a new primitive wrapper from the value of the original.
 */ function copyPrimitiveWrapper(primitiveObject, state) {
    return new state.Constructor(primitiveObject.valueOf());
}
/**
 * Create a new RegExp based on the value and flags of the original.
 */ function copyRegExp(regExp, state) {
    var clone = new state.Constructor(regExp.source, getRegExpFlags(regExp));
    clone.lastIndex = regExp.lastIndex;
    return clone;
}
/**
 * Return the original value (an identity function).
 *
 * @note
 * THis is used for objects that cannot be copied, such as WeakMap.
 */ function copySelf(value, _state) {
    return value;
}
/**
 * Deeply copy the values of the original.
 */ function copySetLoose(set, state) {
    var clone = new state.Constructor();
    // set in the cache immediately to be able to reuse the object recursively
    state.cache.set(set, clone);
    set.forEach(function(value) {
        clone.add(state.copier(value, state));
    });
    return clone;
}
/**
 * Deeply copy the values of the original, as well as any custom properties.
 */ function copySetStrict(set, state) {
    return copyOwnPropertiesStrict(set, copySetLoose(set, state), state);
}
var isArray = Array.isArray;
var assign = Object.assign;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
};
var DEFAULT_LOOSE_OPTIONS = {
    array: copyArrayLoose,
    arrayBuffer: copyArrayBuffer,
    blob: copyBlob,
    dataView: copyDataView,
    date: copyDate,
    error: copySelf,
    map: copyMapLoose,
    object: copyObjectLoose,
    regExp: copyRegExp,
    set: copySetLoose
};
var DEFAULT_STRICT_OPTIONS = assign({}, DEFAULT_LOOSE_OPTIONS, {
    array: copyArrayStrict,
    map: copyMapStrict,
    object: copyObjectStrict,
    set: copySetStrict
});
/**
 * Get the copiers used for each specific object tag.
 */ function getTagSpecificCopiers(options) {
    return {
        Arguments: options.object,
        Array: options.array,
        ArrayBuffer: options.arrayBuffer,
        Blob: options.blob,
        Boolean: copyPrimitiveWrapper,
        DataView: options.dataView,
        Date: options.date,
        Error: options.error,
        Float32Array: options.arrayBuffer,
        Float64Array: options.arrayBuffer,
        Int8Array: options.arrayBuffer,
        Int16Array: options.arrayBuffer,
        Int32Array: options.arrayBuffer,
        Map: options.map,
        Number: copyPrimitiveWrapper,
        Object: options.object,
        Promise: copySelf,
        RegExp: options.regExp,
        Set: options.set,
        String: copyPrimitiveWrapper,
        WeakMap: copySelf,
        WeakSet: copySelf,
        Uint8Array: options.arrayBuffer,
        Uint8ClampedArray: options.arrayBuffer,
        Uint16Array: options.arrayBuffer,
        Uint32Array: options.arrayBuffer,
        Uint64Array: options.arrayBuffer
    };
}
/**
 * Create a custom copier based on the object-specific copy methods passed.
 */ function createCopier(options) {
    var normalizedOptions = assign({}, DEFAULT_LOOSE_OPTIONS, options);
    var tagSpecificCopiers = getTagSpecificCopiers(normalizedOptions);
    var array = tagSpecificCopiers.Array, object = tagSpecificCopiers.Object;
    function copier(value, state) {
        state.prototype = state.Constructor = undefined;
        if (!value || typeof value !== 'object') {
            return value;
        }
        if (state.cache.has(value)) {
            return state.cache.get(value);
        }
        state.prototype = getPrototypeOf(value);
        state.Constructor = state.prototype && state.prototype.constructor;
        // plain objects
        if (!state.Constructor || state.Constructor === Object) {
            return object(value, state);
        }
        // arrays
        if (isArray(value)) {
            return array(value, state);
        }
        var tagSpecificCopier = tagSpecificCopiers[getTag(value)];
        if (tagSpecificCopier) {
            return tagSpecificCopier(value, state);
        }
        return typeof value.then === 'function' ? value : object(value, state);
    }
    return function copy(value) {
        return copier(value, {
            Constructor: undefined,
            cache: createCache(),
            copier: copier,
            prototype: undefined
        });
    };
}
/**
 * Create a custom copier based on the object-specific copy methods passed, defaulting to the
 * same internals as `copyStrict`.
 */ function createStrictCopier(options) {
    return createCopier(assign({}, DEFAULT_STRICT_OPTIONS, options));
}
/**
 * Copy an value deeply as much as possible, where strict recreation of object properties
 * are maintained. All properties (including non-enumerable ones) are copied with their
 * original property descriptors on both objects and arrays.
 */ var copyStrict = createStrictCopier({});
/**
 * Copy an value deeply as much as possible.
 */ var index = createCopier({});
exports.copyStrict = copyStrict;
exports.createCopier = createCopier;
exports.createStrictCopier = createStrictCopier;
exports.default = index; //# sourceMappingURL=index.cjs.map
}),
"[project]/node_modules/.pnpm/dateformat@4.6.3/node_modules/dateformat/lib/dateformat.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof(obj);
}
(function(global) {
    var _arguments = arguments;
    var dateFormat = function() {
        var token = /d{1,4}|D{3,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|W{1,2}|[LlopSZN]|"[^"]*"|'[^']*'/g;
        var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
        var timezoneClip = /[^-+\dA-Z]/g;
        return function(date, mask, utc, gmt) {
            if (_arguments.length === 1 && kindOf(date) === "string" && !/\d/.test(date)) {
                mask = date;
                date = undefined;
            }
            date = date || date === 0 ? date : new Date;
            if (!(date instanceof Date)) {
                date = new Date(date);
            }
            if (isNaN(date)) {
                throw TypeError("Invalid date");
            }
            mask = String(dateFormat.masks[mask] || mask || dateFormat.masks["default"]);
            var maskSlice = mask.slice(0, 4);
            if (maskSlice === "UTC:" || maskSlice === "GMT:") {
                mask = mask.slice(4);
                utc = true;
                if (maskSlice === "GMT:") {
                    gmt = true;
                }
            }
            var _ = function _() {
                return utc ? "getUTC" : "get";
            };
            var _d = function d() {
                return date[_() + "Date"]();
            };
            var D = function D() {
                return date[_() + "Day"]();
            };
            var _m = function m() {
                return date[_() + "Month"]();
            };
            var y = function y() {
                return date[_() + "FullYear"]();
            };
            var _H = function H() {
                return date[_() + "Hours"]();
            };
            var _M = function M() {
                return date[_() + "Minutes"]();
            };
            var _s = function s() {
                return date[_() + "Seconds"]();
            };
            var _L = function L() {
                return date[_() + "Milliseconds"]();
            };
            var _o = function o() {
                return utc ? 0 : date.getTimezoneOffset();
            };
            var _W = function W() {
                return getWeek(date);
            };
            var _N = function N() {
                return getDayOfWeek(date);
            };
            var flags = {
                d: function d() {
                    return _d();
                },
                dd: function dd() {
                    return pad(_d());
                },
                ddd: function ddd() {
                    return dateFormat.i18n.dayNames[D()];
                },
                DDD: function DDD() {
                    return getDayName({
                        y: y(),
                        m: _m(),
                        d: _d(),
                        _: _(),
                        dayName: dateFormat.i18n.dayNames[D()],
                        short: true
                    });
                },
                dddd: function dddd() {
                    return dateFormat.i18n.dayNames[D() + 7];
                },
                DDDD: function DDDD() {
                    return getDayName({
                        y: y(),
                        m: _m(),
                        d: _d(),
                        _: _(),
                        dayName: dateFormat.i18n.dayNames[D() + 7]
                    });
                },
                m: function m() {
                    return _m() + 1;
                },
                mm: function mm() {
                    return pad(_m() + 1);
                },
                mmm: function mmm() {
                    return dateFormat.i18n.monthNames[_m()];
                },
                mmmm: function mmmm() {
                    return dateFormat.i18n.monthNames[_m() + 12];
                },
                yy: function yy() {
                    return String(y()).slice(2);
                },
                yyyy: function yyyy() {
                    return pad(y(), 4);
                },
                h: function h() {
                    return _H() % 12 || 12;
                },
                hh: function hh() {
                    return pad(_H() % 12 || 12);
                },
                H: function H() {
                    return _H();
                },
                HH: function HH() {
                    return pad(_H());
                },
                M: function M() {
                    return _M();
                },
                MM: function MM() {
                    return pad(_M());
                },
                s: function s() {
                    return _s();
                },
                ss: function ss() {
                    return pad(_s());
                },
                l: function l() {
                    return pad(_L(), 3);
                },
                L: function L() {
                    return pad(Math.floor(_L() / 10));
                },
                t: function t() {
                    return _H() < 12 ? dateFormat.i18n.timeNames[0] : dateFormat.i18n.timeNames[1];
                },
                tt: function tt() {
                    return _H() < 12 ? dateFormat.i18n.timeNames[2] : dateFormat.i18n.timeNames[3];
                },
                T: function T() {
                    return _H() < 12 ? dateFormat.i18n.timeNames[4] : dateFormat.i18n.timeNames[5];
                },
                TT: function TT() {
                    return _H() < 12 ? dateFormat.i18n.timeNames[6] : dateFormat.i18n.timeNames[7];
                },
                Z: function Z() {
                    return gmt ? "GMT" : utc ? "UTC" : (String(date).match(timezone) || [
                        ""
                    ]).pop().replace(timezoneClip, "").replace(/GMT\+0000/g, "UTC");
                },
                o: function o() {
                    return (_o() > 0 ? "-" : "+") + pad(Math.floor(Math.abs(_o()) / 60) * 100 + Math.abs(_o()) % 60, 4);
                },
                p: function p() {
                    return (_o() > 0 ? "-" : "+") + pad(Math.floor(Math.abs(_o()) / 60), 2) + ":" + pad(Math.floor(Math.abs(_o()) % 60), 2);
                },
                S: function S() {
                    return [
                        "th",
                        "st",
                        "nd",
                        "rd"
                    ][_d() % 10 > 3 ? 0 : (_d() % 100 - _d() % 10 != 10) * _d() % 10];
                },
                W: function W() {
                    return _W();
                },
                WW: function WW() {
                    return pad(_W());
                },
                N: function N() {
                    return _N();
                }
            };
            return mask.replace(token, function(match) {
                if (match in flags) {
                    return flags[match]();
                }
                return match.slice(1, match.length - 1);
            });
        };
    }();
    dateFormat.masks = {
        default: "ddd mmm dd yyyy HH:MM:ss",
        shortDate: "m/d/yy",
        paddedShortDate: "mm/dd/yyyy",
        mediumDate: "mmm d, yyyy",
        longDate: "mmmm d, yyyy",
        fullDate: "dddd, mmmm d, yyyy",
        shortTime: "h:MM TT",
        mediumTime: "h:MM:ss TT",
        longTime: "h:MM:ss TT Z",
        isoDate: "yyyy-mm-dd",
        isoTime: "HH:MM:ss",
        isoDateTime: "yyyy-mm-dd'T'HH:MM:sso",
        isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'",
        expiresHeaderFormat: "ddd, dd mmm yyyy HH:MM:ss Z"
    };
    dateFormat.i18n = {
        dayNames: [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat",
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
        ],
        monthNames: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec",
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
        ],
        timeNames: [
            "a",
            "p",
            "am",
            "pm",
            "A",
            "P",
            "AM",
            "PM"
        ]
    };
    var pad = function pad(val, len) {
        val = String(val);
        len = len || 2;
        while(val.length < len){
            val = "0" + val;
        }
        return val;
    };
    var getDayName = function getDayName(_ref) {
        var y = _ref.y, m = _ref.m, d = _ref.d, _ = _ref._, dayName = _ref.dayName, _ref$short = _ref["short"], _short = _ref$short === void 0 ? false : _ref$short;
        var today = new Date;
        var yesterday = new Date;
        yesterday.setDate(yesterday[_ + "Date"]() - 1);
        var tomorrow = new Date;
        tomorrow.setDate(tomorrow[_ + "Date"]() + 1);
        var today_d = function today_d() {
            return today[_ + "Date"]();
        };
        var today_m = function today_m() {
            return today[_ + "Month"]();
        };
        var today_y = function today_y() {
            return today[_ + "FullYear"]();
        };
        var yesterday_d = function yesterday_d() {
            return yesterday[_ + "Date"]();
        };
        var yesterday_m = function yesterday_m() {
            return yesterday[_ + "Month"]();
        };
        var yesterday_y = function yesterday_y() {
            return yesterday[_ + "FullYear"]();
        };
        var tomorrow_d = function tomorrow_d() {
            return tomorrow[_ + "Date"]();
        };
        var tomorrow_m = function tomorrow_m() {
            return tomorrow[_ + "Month"]();
        };
        var tomorrow_y = function tomorrow_y() {
            return tomorrow[_ + "FullYear"]();
        };
        if (today_y() === y && today_m() === m && today_d() === d) {
            return _short ? "Tdy" : "Today";
        } else if (yesterday_y() === y && yesterday_m() === m && yesterday_d() === d) {
            return _short ? "Ysd" : "Yesterday";
        } else if (tomorrow_y() === y && tomorrow_m() === m && tomorrow_d() === d) {
            return _short ? "Tmw" : "Tomorrow";
        }
        return dayName;
    };
    var getWeek = function getWeek(date) {
        var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());
        targetThursday.setDate(targetThursday.getDate() - (targetThursday.getDay() + 6) % 7 + 3);
        var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);
        firstThursday.setDate(firstThursday.getDate() - (firstThursday.getDay() + 6) % 7 + 3);
        var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
        targetThursday.setHours(targetThursday.getHours() - ds);
        var weekDiff = (targetThursday - firstThursday) / (864e5 * 7);
        return 1 + Math.floor(weekDiff);
    };
    var getDayOfWeek = function getDayOfWeek(date) {
        var dow = date.getDay();
        if (dow === 0) {
            dow = 7;
        }
        return dow;
    };
    var kindOf = function kindOf(val) {
        if (val === null) {
            return "null";
        }
        if (val === undefined) {
            return "undefined";
        }
        if (_typeof(val) !== "object") {
            return _typeof(val);
        }
        if (Array.isArray(val)) {
            return "array";
        }
        return ({}).toString.call(val).slice(8, -1).toLowerCase();
    };
    if (typeof define === "function" && define.amd) {
        ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            return dateFormat;
        }(__turbopack_context__.r, exports, module));
    } else if ((("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : _typeof(exports)) === "object") {
        module.exports = dateFormat;
    } else {
        global.dateFormat = dateFormat;
    }
})(void 0);
}),
"[project]/node_modules/.pnpm/fast-safe-stringify@2.1.1/node_modules/fast-safe-stringify/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = stringify;
stringify.default = stringify;
stringify.stable = deterministicStringify;
stringify.stableStringify = deterministicStringify;
var LIMIT_REPLACE_NODE = '[...]';
var CIRCULAR_REPLACE_NODE = '[Circular]';
var arr = [];
var replacerStack = [];
function defaultOptions() {
    return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
    };
}
// Regular stringify
function stringify(obj, replacer, spacer, options) {
    if (typeof options === 'undefined') {
        options = defaultOptions();
    }
    decirc(obj, '', 0, [], undefined, 0, options);
    var res;
    try {
        if (replacerStack.length === 0) {
            res = JSON.stringify(obj, replacer, spacer);
        } else {
            res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
    } catch (_) {
        return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]');
    } finally{
        while(arr.length !== 0){
            var part = arr.pop();
            if (part.length === 4) {
                Object.defineProperty(part[0], part[1], part[3]);
            } else {
                part[0][part[1]] = part[2];
            }
        }
    }
    return res;
}
function setReplace(replace, val, k, parent) {
    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
    if (propertyDescriptor.get !== undefined) {
        if (propertyDescriptor.configurable) {
            Object.defineProperty(parent, k, {
                value: replace
            });
            arr.push([
                parent,
                k,
                val,
                propertyDescriptor
            ]);
        } else {
            replacerStack.push([
                val,
                k,
                replace
            ]);
        }
    } else {
        parent[k] = replace;
        arr.push([
            parent,
            k,
            val
        ]);
    }
}
function decirc(val, k, edgeIndex, stack, parent, depth, options) {
    depth += 1;
    var i;
    if (typeof val === 'object' && val !== null) {
        for(i = 0; i < stack.length; i++){
            if (stack[i] === val) {
                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
                return;
            }
        }
        if (typeof options.depthLimit !== 'undefined' && depth > options.depthLimit) {
            setReplace(LIMIT_REPLACE_NODE, val, k, parent);
            return;
        }
        if (typeof options.edgesLimit !== 'undefined' && edgeIndex + 1 > options.edgesLimit) {
            setReplace(LIMIT_REPLACE_NODE, val, k, parent);
            return;
        }
        stack.push(val);
        // Optimize for Arrays. Big arrays could kill the performance otherwise!
        if (Array.isArray(val)) {
            for(i = 0; i < val.length; i++){
                decirc(val[i], i, i, stack, val, depth, options);
            }
        } else {
            var keys = Object.keys(val);
            for(i = 0; i < keys.length; i++){
                var key = keys[i];
                decirc(val[key], key, i, stack, val, depth, options);
            }
        }
        stack.pop();
    }
}
// Stable-stringify
function compareFunction(a, b) {
    if (a < b) {
        return -1;
    }
    if (a > b) {
        return 1;
    }
    return 0;
}
function deterministicStringify(obj, replacer, spacer, options) {
    if (typeof options === 'undefined') {
        options = defaultOptions();
    }
    var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj;
    var res;
    try {
        if (replacerStack.length === 0) {
            res = JSON.stringify(tmp, replacer, spacer);
        } else {
            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
    } catch (_) {
        return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]');
    } finally{
        // Ensure that we restore the object as it was.
        while(arr.length !== 0){
            var part = arr.pop();
            if (part.length === 4) {
                Object.defineProperty(part[0], part[1], part[3]);
            } else {
                part[0][part[1]] = part[2];
            }
        }
    }
    return res;
}
function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
    depth += 1;
    var i;
    if (typeof val === 'object' && val !== null) {
        for(i = 0; i < stack.length; i++){
            if (stack[i] === val) {
                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
                return;
            }
        }
        try {
            if (typeof val.toJSON === 'function') {
                return;
            }
        } catch (_) {
            return;
        }
        if (typeof options.depthLimit !== 'undefined' && depth > options.depthLimit) {
            setReplace(LIMIT_REPLACE_NODE, val, k, parent);
            return;
        }
        if (typeof options.edgesLimit !== 'undefined' && edgeIndex + 1 > options.edgesLimit) {
            setReplace(LIMIT_REPLACE_NODE, val, k, parent);
            return;
        }
        stack.push(val);
        // Optimize for Arrays. Big arrays could kill the performance otherwise!
        if (Array.isArray(val)) {
            for(i = 0; i < val.length; i++){
                deterministicDecirc(val[i], i, i, stack, val, depth, options);
            }
        } else {
            // Create a temporary object in the required way
            var tmp = {};
            var keys = Object.keys(val).sort(compareFunction);
            for(i = 0; i < keys.length; i++){
                var key = keys[i];
                deterministicDecirc(val[key], key, i, stack, val, depth, options);
                tmp[key] = val[key];
            }
            if (typeof parent !== 'undefined') {
                arr.push([
                    parent,
                    k,
                    val
                ]);
                parent[k] = tmp;
            } else {
                return tmp;
            }
        }
        stack.pop();
    }
}
// wraps replacer function to handle values we couldn't replace
// and mark them as replaced value
function replaceGetterValues(replacer) {
    replacer = typeof replacer !== 'undefined' ? replacer : function(k, v) {
        return v;
    };
    return function(key, val) {
        if (replacerStack.length > 0) {
            for(var i = 0; i < replacerStack.length; i++){
                var part = replacerStack[i];
                if (part[1] === key && part[0] === val) {
                    val = part[2];
                    replacerStack.splice(i, 1);
                    break;
                }
            }
        }
        return replacer.call(this, key, val);
    };
}
}),
"[project]/node_modules/.pnpm/secure-json-parse@4.1.0/node_modules/secure-json-parse/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const hasBuffer = typeof Buffer !== 'undefined';
const suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
/**
 * @description Internal parse function that parses JSON text with security checks.
 * @private
 * @param {string|Buffer} text - The JSON text string or Buffer to parse.
 * @param {Function} [reviver] - The JSON.parse() optional reviver argument.
 * @param {import('./types').ParseOptions} [options] - Optional configuration object.
 * @returns {*} The parsed object.
 * @throws {SyntaxError} If a forbidden prototype property is found and `options.protoAction` or
 * `options.constructorAction` is `'error'`.
 */ function _parse(text, reviver, options) {
    // Normalize arguments
    if (options == null) {
        if (reviver !== null && typeof reviver === 'object') {
            options = reviver;
            reviver = undefined;
        }
    }
    if (hasBuffer && Buffer.isBuffer(text)) {
        text = text.toString();
    }
    // BOM checker
    if (text && text.charCodeAt(0) === 0xFEFF) {
        text = text.slice(1);
    }
    // Parse normally, allowing exceptions
    const obj = JSON.parse(text, reviver);
    // Ignore null and non-objects
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    const protoAction = options && options.protoAction || 'error';
    const constructorAction = options && options.constructorAction || 'error';
    // options: 'error' (default) / 'remove' / 'ignore'
    if (protoAction === 'ignore' && constructorAction === 'ignore') {
        return obj;
    }
    if (protoAction !== 'ignore' && constructorAction !== 'ignore') {
        if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
            return obj;
        }
    } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {
        if (suspectProtoRx.test(text) === false) {
            return obj;
        }
    } else {
        if (suspectConstructorRx.test(text) === false) {
            return obj;
        }
    }
    // Scan result for proto keys
    return filter(obj, {
        protoAction,
        constructorAction,
        safe: options && options.safe
    });
}
/**
 * @description Scans and filters an object for forbidden prototype properties.
 * @param {Object} obj - The object being scanned.
 * @param {import('./types').ParseOptions} [options] - Optional configuration object.
 * @returns {Object|null} The filtered object, or `null` if safe mode is enabled and issues are found.
 * @throws {SyntaxError} If a forbidden prototype property is found and `options.protoAction` or
 * `options.constructorAction` is `'error'`.
 */ function filter(obj, { protoAction = 'error', constructorAction = 'error', safe } = {}) {
    let next = [
        obj
    ];
    while(next.length){
        const nodes = next;
        next = [];
        for (const node of nodes){
            if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) {
                if (safe === true) {
                    return null;
                } else if (protoAction === 'error') {
                    throw new SyntaxError('Object contains forbidden prototype property');
                }
                delete node.__proto__; // eslint-disable-line no-proto
            }
            if (constructorAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, 'constructor') && node.constructor !== null && typeof node.constructor === 'object' && Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) {
                if (safe === true) {
                    return null;
                } else if (constructorAction === 'error') {
                    throw new SyntaxError('Object contains forbidden prototype property');
                }
                delete node.constructor;
            }
            for(const key in node){
                const value = node[key];
                if (value && typeof value === 'object') {
                    next.push(value);
                }
            }
        }
    }
    return obj;
}
/**
 * @description Parses a given JSON-formatted text into an object.
 * @param {string|Buffer} text - The JSON text string or Buffer to parse.
 * @param {Function} [reviver] - The `JSON.parse()` optional reviver argument, or options object.
 * @param {import('./types').ParseOptions} [options] - Optional configuration object.
 * @returns {*} The parsed object.
 * @throws {SyntaxError} If the JSON text is malformed or contains forbidden prototype properties
 * when `options.protoAction` or `options.constructorAction` is `'error'`.
 */ function parse(text, reviver, options) {
    const { stackTraceLimit } = Error;
    Error.stackTraceLimit = 0;
    try {
        return _parse(text, reviver, options);
    } finally{
        Error.stackTraceLimit = stackTraceLimit;
    }
}
/**
 * @description Safely parses a given JSON-formatted text into an object.
 * @param {string|Buffer} text - The JSON text string or Buffer to parse.
 * @param {Function} [reviver] - The `JSON.parse()` optional reviver argument.
 * @returns {*|null|undefined} The parsed object, `null` if security issues found, or `undefined` on parse error.
 */ function safeParse(text, reviver) {
    const { stackTraceLimit } = Error;
    Error.stackTraceLimit = 0;
    try {
        return _parse(text, reviver, {
            safe: true
        });
    } catch  {
        return undefined;
    } finally{
        Error.stackTraceLimit = stackTraceLimit;
    }
}
module.exports = parse;
module.exports.default = parse;
module.exports.parse = parse;
module.exports.safeParse = safeParse;
module.exports.scan = filter;
}),
"[project]/node_modules/.pnpm/@payloadcms+next@3.64.0_@types+react@19.0.1_graphql@16.12.0_monaco-editor@0.55.1_next@1_e7a6815e9254f7c7cc1d038994d043b1/node_modules/@payloadcms/next/dist/exports/utilities.js [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// NOTICE: Server-only utilities, do not import anything client-side here.
__turbopack_context__.s([
    "addDataAndFileToRequest",
    ()=>addDataAndFileToRequest,
    "addLocalesToRequestFromData",
    ()=>addLocalesToRequestFromData,
    "createPayloadRequest",
    ()=>createPayloadRequest,
    "headersWithCors",
    ()=>headersWithCors,
    "mergeHeaders",
    ()=>mergeHeaders,
    "sanitizeLocales",
    ()=>sanitizeLocales
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$addDataAndFileToRequest$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/payload@3.64.0_graphql@16.12.0_typescript@5.5.2/node_modules/payload/dist/utilities/addDataAndFileToRequest.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$addLocalesToRequest$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/payload@3.64.0_graphql@16.12.0_typescript@5.5.2/node_modules/payload/dist/utilities/addLocalesToRequest.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$createPayloadRequest$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/payload@3.64.0_graphql@16.12.0_typescript@5.5.2/node_modules/payload/dist/utilities/createPayloadRequest.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$headersWithCors$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/payload@3.64.0_graphql@16.12.0_typescript@5.5.2/node_modules/payload/dist/utilities/headersWithCors.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$mergeHeaders$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/payload@3.64.0_graphql@16.12.0_typescript@5.5.2/node_modules/payload/dist/utilities/mergeHeaders.js [app-rsc] (ecmascript)");
;
;
;
const mergeHeaders = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$mergeHeaders$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["mergeHeaders"];
const headersWithCors = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$headersWithCors$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["headersWithCors"];
const createPayloadRequest = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$createPayloadRequest$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createPayloadRequest"];
const addDataAndFileToRequest = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$addDataAndFileToRequest$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addDataAndFileToRequest"];
const sanitizeLocales = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$addLocalesToRequest$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["sanitizeLocales"];
const addLocalesToRequestFromData = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$payload$40$3$2e$64$2e$0_graphql$40$16$2e$12$2e$0_typescript$40$5$2e$5$2e$2$2f$node_modules$2f$payload$2f$dist$2f$utilities$2f$addLocalesToRequest$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addLocalesToRequestFromData"]; //# sourceMappingURL=utilities.js.map
}),
"[project]/node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) return obj;
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") return {
        default: obj
    };
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);
            else newObj[key] = obj[key];
        }
    }
    newObj.default = obj;
    if (cache) cache.set(obj, newObj);
    return newObj;
}
exports._ = _interop_require_wildcard;
}),
"[project]/node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "clsx",
    ()=>clsx,
    "default",
    ()=>__TURBOPACK__default__export__
]);
function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
        var o = e.length;
        for(t = 0; t < o; t++)e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else for(f in e)e[f] && (n && (n += " "), n += f);
    return n;
}
function clsx() {
    for(var e, t, f = 0, n = "", o = arguments.length; f < o; f++)(e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
}
const __TURBOPACK__default__export__ = clsx;
}),
"[project]/node_modules/.pnpm/@radix-ui+react-compose-refs@1.1.2_@types+react@19.0.1_react@19.0.0/node_modules/@radix-ui/react-compose-refs/dist/index.mjs [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "composeRefs",
    ()=>composeRefs,
    "useComposedRefs",
    ()=>useComposedRefs
]);
// packages/react/compose-refs/src/compose-refs.tsx
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.1.0-canary.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.77.4/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
;
function setRef(ref, value) {
    if (typeof ref === "function") {
        return ref(value);
    } else if (ref !== null && ref !== void 0) {
        ref.current = value;
    }
}
function composeRefs(...refs) {
    return (node)=>{
        let hasCleanup = false;
        const cleanups = refs.map((ref)=>{
            const cleanup = setRef(ref, node);
            if (!hasCleanup && typeof cleanup == "function") {
                hasCleanup = true;
            }
            return cleanup;
        });
        if (hasCleanup) {
            return ()=>{
                for(let i = 0; i < cleanups.length; i++){
                    const cleanup = cleanups[i];
                    if (typeof cleanup == "function") {
                        cleanup();
                    } else {
                        setRef(refs[i], null);
                    }
                }
            };
        }
    };
}
function useComposedRefs(...refs) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["useCallback"](composeRefs(...refs), refs);
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/.pnpm/@radix-ui+react-slot@1.2.4_@types+react@19.0.1_react@19.0.0/node_modules/@radix-ui/react-slot/dist/index.mjs [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Root",
    ()=>Slot,
    "Slot",
    ()=>Slot,
    "Slottable",
    ()=>Slottable,
    "createSlot",
    ()=>createSlot,
    "createSlottable",
    ()=>createSlottable
]);
// src/slot.tsx
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.1.0-canary.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.77.4/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$radix$2d$ui$2b$react$2d$compose$2d$refs$40$1$2e$1$2e$2_$40$types$2b$react$40$19$2e$0$2e$1_react$40$19$2e$0$2e$0$2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@radix-ui+react-compose-refs@1.1.2_@types+react@19.0.1_react@19.0.0/node_modules/@radix-ui/react-compose-refs/dist/index.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.1.0-canary.0_react-dom@19.0.0_react@19.0.0__react@19.0.0_sass@1.77.4/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.js [app-rsc] (ecmascript)");
;
;
;
var REACT_LAZY_TYPE = Symbol.for("react.lazy");
var use = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__[" use ".trim().toString()];
function isPromiseLike(value) {
    return typeof value === "object" && value !== null && "then" in value;
}
function isLazyComponent(element) {
    return element != null && typeof element === "object" && "$$typeof" in element && element.$$typeof === REACT_LAZY_TYPE && "_payload" in element && isPromiseLike(element._payload);
}
// @__NO_SIDE_EFFECTS__
function createSlot(ownerName) {
    const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
    const Slot2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__.forwardRef((props, forwardedRef)=>{
        let { children, ...slotProps } = props;
        if (isLazyComponent(children) && typeof use === "function") {
            children = use(children._payload);
        }
        const childrenArray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__.Children.toArray(children);
        const slottable = childrenArray.find(isSlottable);
        if (slottable) {
            const newElement = slottable.props.children;
            const newChildren = childrenArray.map((child)=>{
                if (child === slottable) {
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__.Children.count(newElement) > 1) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__.Children.only(null);
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__.isValidElement(newElement) ? newElement.props.children : null;
                } else {
                    return child;
                }
            });
            return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])(SlotClone, {
                ...slotProps,
                ref: forwardedRef,
                children: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__.isValidElement(newElement) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__.cloneElement(newElement, void 0, newChildren) : null
            });
        }
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])(SlotClone, {
            ...slotProps,
            ref: forwardedRef,
            children
        });
    });
    Slot2.displayName = `${ownerName}.Slot`;
    return Slot2;
}
var Slot = /* @__PURE__ */ createSlot("Slot");
// @__NO_SIDE_EFFECTS__
function createSlotClone(ownerName) {
    const SlotClone = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__.forwardRef((props, forwardedRef)=>{
        let { children, ...slotProps } = props;
        if (isLazyComponent(children) && typeof use === "function") {
            children = use(children._payload);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__.isValidElement(children)) {
            const childrenRef = getElementRef(children);
            const props2 = mergeProps(slotProps, children.props);
            if (children.type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__.Fragment) {
                props2.ref = forwardedRef ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$radix$2d$ui$2b$react$2d$compose$2d$refs$40$1$2e$1$2e$2_$40$types$2b$react$40$19$2e$0$2e$1_react$40$19$2e$0$2e$0$2f$node_modules$2f40$radix$2d$ui$2f$react$2d$compose$2d$refs$2f$dist$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["composeRefs"])(forwardedRef, childrenRef) : childrenRef;
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__.cloneElement(children, props2);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__.Children.count(children) > 1 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__.Children.only(null) : null;
    });
    SlotClone.displayName = `${ownerName}.SlotClone`;
    return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function createSlottable(ownerName) {
    const Slottable2 = ({ children })=>{
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Fragment"], {
            children
        });
    };
    Slottable2.displayName = `${ownerName}.Slottable`;
    Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
    return Slottable2;
}
var Slottable = /* @__PURE__ */ createSlottable("Slottable");
function isSlottable(child) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$1$2e$0$2d$canary$2e$0_react$2d$dom$40$19$2e$0$2e$0_react$40$19$2e$0$2e$0_$5f$react$40$19$2e$0$2e$0_sass$40$1$2e$77$2e$4$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
    const overrideProps = {
        ...childProps
    };
    for(const propName in childProps){
        const slotPropValue = slotProps[propName];
        const childPropValue = childProps[propName];
        const isHandler = /^on[A-Z]/.test(propName);
        if (isHandler) {
            if (slotPropValue && childPropValue) {
                overrideProps[propName] = (...args)=>{
                    const result = childPropValue(...args);
                    slotPropValue(...args);
                    return result;
                };
            } else if (slotPropValue) {
                overrideProps[propName] = slotPropValue;
            }
        } else if (propName === "style") {
            overrideProps[propName] = {
                ...slotPropValue,
                ...childPropValue
            };
        } else if (propName === "className") {
            overrideProps[propName] = [
                slotPropValue,
                childPropValue
            ].filter(Boolean).join(" ");
        }
    }
    return {
        ...slotProps,
        ...overrideProps
    };
}
function getElementRef(element) {
    let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
        return element.ref;
    }
    getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
        return element.props.ref;
    }
    return element.props.ref || element.ref;
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/.pnpm/class-variance-authority@0.7.1/node_modules/class-variance-authority/dist/index.mjs [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "cva",
    ()=>cva,
    "cx",
    ()=>cx
]);
/**
 * Copyright 2022 Joe Bell. All rights reserved.
 *
 * This file is licensed to you under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR REPRESENTATIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$clsx$40$2$2e$1$2e$1$2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs [app-rsc] (ecmascript)");
;
const falsyToString = (value)=>typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
const cx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$clsx$40$2$2e$1$2e$1$2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clsx"];
const cva = (base, config)=>(props)=>{
        var _config_compoundVariants;
        if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
        const { variants, defaultVariants } = config;
        const getVariantClassNames = Object.keys(variants).map((variant)=>{
            const variantProp = props === null || props === void 0 ? void 0 : props[variant];
            const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
            if (variantProp === null) return null;
            const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
            return variants[variant][variantKey];
        });
        const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param)=>{
            let [key, value] = param;
            if (value === undefined) {
                return acc;
            }
            acc[key] = value;
            return acc;
        }, {});
        const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param)=>{
            let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
            return Object.entries(compoundVariantOptions).every((param)=>{
                let [key, value] = param;
                return Array.isArray(value) ? value.includes({
                    ...defaultVariants,
                    ...propsWithoutUndefined
                }[key]) : ({
                    ...defaultVariants,
                    ...propsWithoutUndefined
                })[key] === value;
            }) ? [
                ...acc,
                cvClass,
                cvClassName
            ] : acc;
        }, []);
        return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
    };
}),
];

//# sourceMappingURL=node_modules__pnpm_b098a3ad._.js.map