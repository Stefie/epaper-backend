{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/react-error-boundary%404.1.2_react%4019.0.0/node_modules/react-error-boundary/dist/react-error-boundary.development.esm.js"],"sourcesContent":["'use client';\nimport { createContext, Component, createElement, useContext, useState, useMemo, forwardRef } from 'react';\n\nconst ErrorBoundaryContext = createContext(null);\n\nconst initialState = {\n  didCatch: false,\n  error: null\n};\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);\n    this.state = initialState;\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      didCatch: true,\n      error\n    };\n  }\n  resetErrorBoundary() {\n    const {\n      error\n    } = this.state;\n    if (error !== null) {\n      var _this$props$onReset, _this$props;\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {\n        args,\n        reason: \"imperative-api\"\n      });\n      this.setState(initialState);\n    }\n  }\n  componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  }\n  componentDidUpdate(prevProps, prevState) {\n    const {\n      didCatch\n    } = this.state;\n    const {\n      resetKeys\n    } = this.props;\n\n    // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,\n    // we'd end up resetting the error boundary immediately.\n    // This would likely trigger a second error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set.\n\n    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onReset2, _this$props3;\n      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {\n        next: resetKeys,\n        prev: prevProps.resetKeys,\n        reason: \"keys\"\n      });\n      this.setState(initialState);\n    }\n  }\n  render() {\n    const {\n      children,\n      fallbackRender,\n      FallbackComponent,\n      fallback\n    } = this.props;\n    const {\n      didCatch,\n      error\n    } = this.state;\n    let childToRender = children;\n    if (didCatch) {\n      const props = {\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n      if (typeof fallbackRender === \"function\") {\n        childToRender = fallbackRender(props);\n      } else if (FallbackComponent) {\n        childToRender = createElement(FallbackComponent, props);\n      } else if (fallback !== undefined) {\n        childToRender = fallback;\n      } else {\n        {\n          console.error(\"react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop\");\n        }\n        throw error;\n      }\n    }\n    return createElement(ErrorBoundaryContext.Provider, {\n      value: {\n        didCatch,\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      }\n    }, childToRender);\n  }\n}\nfunction hasArrayChanged() {\n  let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]));\n}\n\nfunction assertErrorBoundaryContext(value) {\n  if (value == null || typeof value.didCatch !== \"boolean\" || typeof value.resetErrorBoundary !== \"function\") {\n    throw new Error(\"ErrorBoundaryContext not found\");\n  }\n}\n\nfunction useErrorBoundary() {\n  const context = useContext(ErrorBoundaryContext);\n  assertErrorBoundaryContext(context);\n  const [state, setState] = useState({\n    error: null,\n    hasError: false\n  });\n  const memoized = useMemo(() => ({\n    resetBoundary: () => {\n      context.resetErrorBoundary();\n      setState({\n        error: null,\n        hasError: false\n      });\n    },\n    showBoundary: error => setState({\n      error,\n      hasError: true\n    })\n  }), [context.resetErrorBoundary]);\n  if (state.hasError) {\n    throw state.error;\n  }\n  return memoized;\n}\n\nfunction withErrorBoundary(component, errorBoundaryProps) {\n  const Wrapped = forwardRef((props, ref) => createElement(ErrorBoundary, errorBoundaryProps, createElement(component, {\n    ...props,\n    ref\n  })));\n\n  // Format for display in DevTools\n  const name = component.displayName || component.name || \"Unknown\";\n  Wrapped.displayName = \"withErrorBoundary(\".concat(name, \")\");\n  return Wrapped;\n}\n\nexport { ErrorBoundary, ErrorBoundaryContext, useErrorBoundary, withErrorBoundary };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 152, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40lexical%2Breact%400.35.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_yjs%4013.6.27/node_modules/%40lexical/react/LexicalComposer.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { createLexicalComposerContext, LexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { createEditor, $getRoot, $createParagraphNode, $getSelection, HISTORY_MERGE_TAG } from 'lexical';\nimport { useLayoutEffect, useEffect, useMemo } from 'react';\nimport { jsx } from 'react/jsx-runtime';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? useLayoutEffect : useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE_OPTIONS = {\n  tag: HISTORY_MERGE_TAG\n};\nfunction LexicalComposer({\n  initialConfig,\n  children\n}) {\n  const composerContext = useMemo(() => {\n    const {\n      theme,\n      namespace,\n      nodes,\n      onError,\n      editorState: initialEditorState,\n      html\n    } = initialConfig;\n    const context = createLexicalComposerContext(null, theme);\n    const editor = createEditor({\n      editable: initialConfig.editable,\n      html,\n      namespace,\n      nodes,\n      onError: error => onError(error, editor),\n      theme\n    });\n    initializeEditor(editor, initialEditorState);\n    return [editor, context];\n  },\n  // We only do this for init\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useLayoutEffectImpl(() => {\n    const isEditable = initialConfig.editable;\n    const [editor] = composerContext;\n    editor.setEditable(isEditable !== undefined ? isEditable : true);\n\n    // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/jsx(LexicalComposerContext.Provider, {\n    value: composerContext,\n    children: children\n  });\n}\nfunction initializeEditor(editor, initialEditorState) {\n  if (initialEditorState === null) {\n    return;\n  } else if (initialEditorState === undefined) {\n    editor.update(() => {\n      const root = $getRoot();\n      if (root.isEmpty()) {\n        const paragraph = $createParagraphNode();\n        root.append(paragraph);\n        const activeElement = CAN_USE_DOM ? document.activeElement : null;\n        if ($getSelection() !== null || activeElement !== null && activeElement === editor.getRootElement()) {\n          paragraph.select();\n        }\n      }\n    }, HISTORY_MERGE_OPTIONS);\n  } else if (initialEditorState !== null) {\n    switch (typeof initialEditorState) {\n      case 'string':\n        {\n          const parsedEditorState = editor.parseEditorState(initialEditorState);\n          editor.setEditorState(parsedEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'object':\n        {\n          editor.setEditorState(initialEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'function':\n        {\n          editor.update(() => {\n            const root = $getRoot();\n            if (root.isEmpty()) {\n              initialEditorState(editor);\n            }\n          }, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n    }\n  }\n}\n\nexport { LexicalComposer };\n"],"names":[],"mappings":";;;;AAAA;;;;;;CAMC,GAED;AACA;AACA;AACA;;;;;AAEA;;;;;;CAMC,GAED,MAAM,cAAc,kDAAkB,eAAe,OAAO,OAAO,QAAQ,KAAK,eAAe,OAAO,OAAO,QAAQ,CAAC,aAAa,KAAK;AAExI;;;;;;CAMC,GAGD,sDAAsD;AACtD,wCAAwC;AACxC,+CAA+C;AAC/C,MAAM,sBAAsB,sCAAc,0BAAkB,qXAAS;AAErE;;;;;;CAMC,GAED,MAAM,wBAAwB;IAC5B,KAAK,oNAAiB;AACxB;AACA,SAAS,gBAAgB,EACvB,aAAa,EACb,QAAQ,EACT;IACC,MAAM,kBAAkB,IAAA,mXAAO,EAAC;QAC9B,MAAM,EACJ,KAAK,EACL,SAAS,EACT,KAAK,EACL,OAAO,EACP,aAAa,kBAAkB,EAC/B,IAAI,EACL,GAAG;QACJ,MAAM,UAAU,IAAA,sWAA4B,EAAC,MAAM;QACnD,MAAM,SAAS,IAAA,+MAAY,EAAC;YAC1B,UAAU,cAAc,QAAQ;YAChC;YACA;YACA;YACA,SAAS,CAAA,QAAS,QAAQ,OAAO;YACjC;QACF;QACA,iBAAiB,QAAQ;QACzB,OAAO;YAAC;YAAQ;SAAQ;IAC1B,GACA,2BAA2B;IAC3B,uDAAuD;IACvD,EAAE;IACF,oBAAoB;QAClB,MAAM,aAAa,cAAc,QAAQ;QACzC,MAAM,CAAC,OAAO,GAAG;QACjB,OAAO,WAAW,CAAC,eAAe,YAAY,aAAa;IAE3D,2BAA2B;IAC3B,uDAAuD;IACzD,GAAG,EAAE;IACL,OAAO,WAAW,GAAE,IAAA,iYAAG,EAAC,gWAAsB,CAAC,QAAQ,EAAE;QACvD,OAAO;QACP,UAAU;IACZ;AACF;AACA,SAAS,iBAAiB,MAAM,EAAE,kBAAkB;IAClD,IAAI,uBAAuB,MAAM;QAC/B;IACF,OAAO,IAAI,uBAAuB,WAAW;QAC3C,OAAO,MAAM,CAAC;YACZ,MAAM,OAAO,IAAA,2MAAQ;YACrB,IAAI,KAAK,OAAO,IAAI;gBAClB,MAAM,YAAY,IAAA,uNAAoB;gBACtC,KAAK,MAAM,CAAC;gBACZ,MAAM,gBAAgB,sCAAc,0BAAyB;gBAC7D,IAAI,IAAA,gNAAa,QAAO,QAAQ,kBAAkB,QAAQ,kBAAkB,OAAO,cAAc,IAAI;oBACnG,UAAU,MAAM;gBAClB;YACF;QACF,GAAG;IACL,OAAO,IAAI,uBAAuB,MAAM;QACtC,OAAQ,OAAO;YACb,KAAK;gBACH;oBACE,MAAM,oBAAoB,OAAO,gBAAgB,CAAC;oBAClD,OAAO,cAAc,CAAC,mBAAmB;oBACzC;gBACF;YACF,KAAK;gBACH;oBACE,OAAO,cAAc,CAAC,oBAAoB;oBAC1C;gBACF;YACF,KAAK;gBACH;oBACE,OAAO,MAAM,CAAC;wBACZ,MAAM,OAAO,IAAA,2MAAQ;wBACrB,IAAI,KAAK,OAAO,IAAI;4BAClB,mBAAmB;wBACrB;oBACF,GAAG;oBACH;gBACF;QACJ;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 274, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40lexical%2Breact%400.35.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_yjs%4013.6.27/node_modules/%40lexical/react/LexicalErrorBoundary.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as React from 'react';\nimport { jsx } from 'react/jsx-runtime';\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\n\nvar changedArray = function changedArray(a, b) {\n  if (a === void 0) {\n    a = [];\n  }\n\n  if (b === void 0) {\n    b = [];\n  }\n\n  return a.length !== b.length || a.some(function (item, index) {\n    return !Object.is(item, b[index]);\n  });\n};\n\nvar initialState = {\n  error: null\n};\n\nvar ErrorBoundary = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(ErrorBoundary, _React$Component);\n\n  function ErrorBoundary() {\n    var _this;\n\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;\n    _this.state = initialState;\n\n    _this.resetErrorBoundary = function () {\n      var _this$props;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);\n\n      _this.reset();\n    };\n\n    return _this;\n  }\n\n  ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {\n    return {\n      error: error\n    };\n  };\n\n  var _proto = ErrorBoundary.prototype;\n\n  _proto.reset = function reset() {\n    this.setState(initialState);\n  };\n\n  _proto.componentDidCatch = function componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n\n    (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    var error = this.state.error;\n    var resetKeys = this.props.resetKeys; // There's an edge case where if the thing that triggered the error\n    // happens to *also* be in the resetKeys array, we'd end up resetting\n    // the error boundary immediately. This would likely trigger a second\n    // error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call\n    // of cDU after the error is set\n\n    if (error !== null && prevState.error !== null && changedArray(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onResetKe, _this$props3;\n\n      (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);\n      this.reset();\n    }\n  };\n\n  _proto.render = function render() {\n    var error = this.state.error;\n    var _this$props4 = this.props,\n        fallbackRender = _this$props4.fallbackRender,\n        FallbackComponent = _this$props4.FallbackComponent,\n        fallback = _this$props4.fallback;\n\n    if (error !== null) {\n      var _props = {\n        error: error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n\n      if ( /*#__PURE__*/React.isValidElement(fallback)) {\n        return fallback;\n      } else if (typeof fallbackRender === 'function') {\n        return fallbackRender(_props);\n      } else if (FallbackComponent) {\n        return /*#__PURE__*/React.createElement(FallbackComponent, _props);\n      } else {\n        throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');\n      }\n    }\n\n    return this.props.children;\n  };\n\n  return ErrorBoundary;\n}(React.Component);\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction LexicalErrorBoundary({\n  children,\n  onError\n}) {\n  return /*#__PURE__*/jsx(ErrorBoundary, {\n    fallback: /*#__PURE__*/jsx(\"div\", {\n      style: {\n        border: '1px solid #f00',\n        color: '#f00',\n        padding: '8px'\n      },\n      children: \"An error was thrown.\"\n    }),\n    onError: onError,\n    children: children\n  });\n}\n\nexport { LexicalErrorBoundary };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 409, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40lexical%2Bhistory%400.35.0/node_modules/%40lexical/history/LexicalHistory.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { mergeRegister } from '@lexical/utils';\nimport { UNDO_COMMAND, COMMAND_PRIORITY_EDITOR, REDO_COMMAND, CLEAR_EDITOR_COMMAND, CLEAR_HISTORY_COMMAND, CAN_REDO_COMMAND, CAN_UNDO_COMMAND, HISTORIC_TAG, HISTORY_PUSH_TAG, HISTORY_MERGE_TAG, $isRangeSelection, $isTextNode, $isRootNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE = 0;\nconst HISTORY_PUSH = 1;\nconst DISCARD_HISTORY_CANDIDATE = 2;\nconst OTHER = 0;\nconst COMPOSING_CHARACTER = 1;\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\n  const nodeMap = editorState._nodeMap;\n  const nodes = [];\n  for (const dirtyLeafKey of dirtyLeaves) {\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\n    if (dirtyLeaf !== undefined) {\n      nodes.push(dirtyLeaf);\n    }\n  }\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\n    if (!intentionallyMarkedAsDirty) {\n      continue;\n    }\n    const dirtyElement = nodeMap.get(dirtyElementKey);\n    if (dirtyElement !== undefined && !$isRootNode(dirtyElement)) {\n      nodes.push(dirtyElement);\n    }\n  }\n  return nodes;\n}\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {\n    return OTHER;\n  }\n  const nextSelection = nextEditorState._selection;\n  const prevSelection = prevEditorState._selection;\n  if (isComposing) {\n    return COMPOSING_CHARACTER;\n  }\n  if (!$isRangeSelection(nextSelection) || !$isRangeSelection(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\n    return OTHER;\n  }\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\n  if (dirtyNodes.length === 0) {\n    return OTHER;\n  }\n\n  // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\n  // or after existing node.\n  if (dirtyNodes.length > 1) {\n    const nextNodeMap = nextEditorState._nodeMap;\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && $isTextNode(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\n      return INSERT_CHARACTER_AFTER_SELECTION;\n    }\n    return OTHER;\n  }\n  const nextDirtyNode = dirtyNodes[0];\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\n  if (!$isTextNode(prevDirtyNode) || !$isTextNode(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\n    return OTHER;\n  }\n  const prevText = prevDirtyNode.__text;\n  const nextText = nextDirtyNode.__text;\n  if (prevText === nextText) {\n    return OTHER;\n  }\n  const nextAnchor = nextSelection.anchor;\n  const prevAnchor = prevSelection.anchor;\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\n    return OTHER;\n  }\n  const nextAnchorOffset = nextAnchor.offset;\n  const prevAnchorOffset = prevAnchor.offset;\n  const textDiff = nextText.length - prevText.length;\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\n    return INSERT_CHARACTER_AFTER_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\n    return DELETE_CHARACTER_BEFORE_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\n    return DELETE_CHARACTER_AFTER_SELECTION;\n  }\n  return OTHER;\n}\nfunction isTextNodeUnchanged(key, prevEditorState, nextEditorState) {\n  const prevNode = prevEditorState._nodeMap.get(key);\n  const nextNode = nextEditorState._nodeMap.get(key);\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  const isDeletingLine = $isRangeSelection(prevSelection) && $isRangeSelection(nextSelection) && prevSelection.anchor.type === 'element' && prevSelection.focus.type === 'element' && nextSelection.anchor.type === 'text' && nextSelection.focus.type === 'text';\n  if (!isDeletingLine && $isTextNode(prevNode) && $isTextNode(nextNode) && prevNode.__parent === nextNode.__parent) {\n    // This has the assumption that object key order won't change if the\n    // content did not change, which should normally be safe given\n    // the manner in which nodes and exportJSON are typically implemented.\n    return JSON.stringify(prevEditorState.read(() => prevNode.exportJSON())) === JSON.stringify(nextEditorState.read(() => nextNode.exportJSON()));\n  }\n  return false;\n}\nfunction createMergeActionGetter(editor, delay) {\n  let prevChangeTime = Date.now();\n  let prevChangeType = OTHER;\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\n    const changeTime = Date.now();\n\n    // If applying changes from history stack there's no need\n    // to run history logic again, as history entries already calculated\n    if (tags.has(HISTORIC_TAG)) {\n      prevChangeType = OTHER;\n      prevChangeTime = changeTime;\n      return DISCARD_HISTORY_CANDIDATE;\n    }\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\n    const mergeAction = (() => {\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\n      const shouldPushHistory = tags.has(HISTORY_PUSH_TAG);\n      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has(HISTORY_MERGE_TAG);\n      if (shouldMergeHistory) {\n        return HISTORY_MERGE;\n      }\n      if (prevEditorState === null) {\n        return HISTORY_PUSH;\n      }\n      const selection = nextEditorState._selection;\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n      if (!hasDirtyNodes) {\n        if (selection !== null) {\n          return HISTORY_MERGE;\n        }\n        return DISCARD_HISTORY_CANDIDATE;\n      }\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\n        return HISTORY_MERGE;\n      }\n\n      // A single node might have been marked as dirty, but not have changed\n      // due to some node transform reverting the change.\n      if (dirtyLeaves.size === 1) {\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\n        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {\n          return HISTORY_MERGE;\n        }\n      }\n      return HISTORY_PUSH;\n    })();\n    prevChangeTime = changeTime;\n    prevChangeType = changeType;\n    return mergeAction;\n  };\n}\nfunction redo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  if (redoStack.length !== 0) {\n    const current = historyState.current;\n    if (current !== null) {\n      undoStack.push(current);\n      editor.dispatchCommand(CAN_UNDO_COMMAND, true);\n    }\n    const historyStateEntry = redoStack.pop();\n    if (redoStack.length === 0) {\n      editor.dispatchCommand(CAN_REDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: HISTORIC_TAG\n      });\n    }\n  }\n}\nfunction undo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  const undoStackLength = undoStack.length;\n  if (undoStackLength !== 0) {\n    const current = historyState.current;\n    const historyStateEntry = undoStack.pop();\n    if (current !== null) {\n      redoStack.push(current);\n      editor.dispatchCommand(CAN_REDO_COMMAND, true);\n    }\n    if (undoStack.length === 0) {\n      editor.dispatchCommand(CAN_UNDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: HISTORIC_TAG\n      });\n    }\n  }\n}\nfunction clearHistory(historyState) {\n  historyState.undoStack = [];\n  historyState.redoStack = [];\n  historyState.current = null;\n}\n\n/**\n * Registers necessary listeners to manage undo/redo history stack and related editor commands.\n * It returns `unregister` callback that cleans up all listeners and should be called on editor unmount.\n * @param editor - The lexical editor.\n * @param historyState - The history state, containing the current state and the undo/redo stack.\n * @param delay - The time (in milliseconds) the editor should delay generating a new history stack,\n * instead of merging the current changes with the current stack.\n * @returns The listeners cleanup callback function.\n */\nfunction registerHistory(editor, historyState, delay) {\n  const getMergeAction = createMergeActionGetter(editor, delay);\n  const applyChange = ({\n    editorState,\n    prevEditorState,\n    dirtyLeaves,\n    dirtyElements,\n    tags\n  }) => {\n    const current = historyState.current;\n    const redoStack = historyState.redoStack;\n    const undoStack = historyState.undoStack;\n    const currentEditorState = current === null ? null : current.editorState;\n    if (current !== null && editorState === currentEditorState) {\n      return;\n    }\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\n    if (mergeAction === HISTORY_PUSH) {\n      if (redoStack.length !== 0) {\n        historyState.redoStack = [];\n        editor.dispatchCommand(CAN_REDO_COMMAND, false);\n      }\n      if (current !== null) {\n        undoStack.push({\n          ...current\n        });\n        editor.dispatchCommand(CAN_UNDO_COMMAND, true);\n      }\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\n      return;\n    }\n\n    // Else we merge\n    historyState.current = {\n      editor,\n      editorState\n    };\n  };\n  const unregister = mergeRegister(editor.registerCommand(UNDO_COMMAND, () => {\n    undo(editor, historyState);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(REDO_COMMAND, () => {\n    redo(editor, historyState);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CLEAR_EDITOR_COMMAND, () => {\n    clearHistory(historyState);\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CLEAR_HISTORY_COMMAND, () => {\n    clearHistory(historyState);\n    editor.dispatchCommand(CAN_REDO_COMMAND, false);\n    editor.dispatchCommand(CAN_UNDO_COMMAND, false);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\n  return unregister;\n}\n\n/**\n * Creates an empty history state.\n * @returns - The empty history state, as an object.\n */\nfunction createEmptyHistoryState() {\n  return {\n    current: null,\n    redoStack: [],\n    undoStack: []\n  };\n}\n\nexport { createEmptyHistoryState, registerHistory };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 697, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40lexical%2Breact%400.35.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_yjs%4013.6.27/node_modules/%40lexical/react/LexicalHistoryPlugin.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { createEmptyHistoryState, registerHistory } from '@lexical/history';\nexport { createEmptyHistoryState } from '@lexical/history';\nimport { useMemo, useEffect } from 'react';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useHistory(editor, externalHistoryState, delay = 1000) {\n  const historyState = useMemo(() => externalHistoryState || createEmptyHistoryState(), [externalHistoryState]);\n  useEffect(() => {\n    return registerHistory(editor, historyState, delay);\n  }, [delay, editor, historyState]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction HistoryPlugin({\n  delay,\n  externalHistoryState\n}) {\n  const [editor] = useLexicalComposerContext();\n  useHistory(editor, externalHistoryState, delay);\n  return null;\n}\n\nexport { HistoryPlugin };\n"],"names":[],"mappings":";;;;AAAA;;;;;;CAMC,GAED;AACA;AAEA;;;;;AAEA;;;;;;CAMC,GAED,SAAS,WAAW,MAAM,EAAE,oBAAoB,EAAE,QAAQ,IAAI;IAC5D,MAAM,eAAe,IAAA,mXAAO,EAAC,IAAM,wBAAwB,IAAA,2PAAuB,KAAI;QAAC;KAAqB;IAC5G,IAAA,qXAAS,EAAC;QACR,OAAO,IAAA,mPAAe,EAAC,QAAQ,cAAc;IAC/C,GAAG;QAAC;QAAO;QAAQ;KAAa;AAClC;AAEA;;;;;;CAMC,GAED,SAAS,cAAc,EACrB,KAAK,EACL,oBAAoB,EACrB;IACC,MAAM,CAAC,OAAO,GAAG,IAAA,mWAAyB;IAC1C,WAAW,QAAQ,sBAAsB;IACzC,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 748, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40lexical%2Breact%400.35.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_yjs%4013.6.27/node_modules/%40lexical/react/LexicalOnChangePlugin.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { HISTORY_MERGE_TAG } from 'lexical';\nimport { useLayoutEffect, useEffect } from 'react';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? useLayoutEffect : useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction OnChangePlugin({\n  ignoreHistoryMergeTagChange = true,\n  ignoreSelectionChange = false,\n  onChange\n}) {\n  const [editor] = useLexicalComposerContext();\n  useLayoutEffectImpl(() => {\n    if (onChange) {\n      return editor.registerUpdateListener(({\n        editorState,\n        dirtyElements,\n        dirtyLeaves,\n        prevEditorState,\n        tags\n      }) => {\n        if (ignoreSelectionChange && dirtyElements.size === 0 && dirtyLeaves.size === 0 || ignoreHistoryMergeTagChange && tags.has(HISTORY_MERGE_TAG) || prevEditorState.isEmpty()) {\n          return;\n        }\n        onChange(editorState, editor, tags);\n      });\n    }\n  }, [editor, ignoreHistoryMergeTagChange, ignoreSelectionChange, onChange]);\n  return null;\n}\n\nexport { OnChangePlugin };\n"],"names":[],"mappings":";;;;AAAA;;;;;;CAMC,GAED;AACA;AACA;;;;AAEA;;;;;;CAMC,GAED,MAAM,cAAc,kDAAkB,eAAe,OAAO,OAAO,QAAQ,KAAK,eAAe,OAAO,OAAO,QAAQ,CAAC,aAAa,KAAK;AAExI;;;;;;CAMC,GAGD,sDAAsD;AACtD,wCAAwC;AACxC,+CAA+C;AAC/C,MAAM,sBAAsB,sCAAc,0BAAkB,qXAAS;AAErE;;;;;;CAMC,GAED,SAAS,eAAe,EACtB,8BAA8B,IAAI,EAClC,wBAAwB,KAAK,EAC7B,QAAQ,EACT;IACC,MAAM,CAAC,OAAO,GAAG,IAAA,mWAAyB;IAC1C,oBAAoB;QAClB,IAAI,UAAU;YACZ,OAAO,OAAO,sBAAsB,CAAC,CAAC,EACpC,WAAW,EACX,aAAa,EACb,WAAW,EACX,eAAe,EACf,IAAI,EACL;gBACC,IAAI,yBAAyB,cAAc,IAAI,KAAK,KAAK,YAAY,IAAI,KAAK,KAAK,+BAA+B,KAAK,GAAG,CAAC,oNAAiB,KAAK,gBAAgB,OAAO,IAAI;oBAC1K;gBACF;gBACA,SAAS,aAAa,QAAQ;YAChC;QACF;IACF,GAAG;QAAC;QAAQ;QAA6B;QAAuB;KAAS;IACzE,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 811, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40lexical%2Btext%400.35.0/node_modules/%40lexical/text/LexicalText.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getRoot, $isDecoratorNode, $isElementNode, $isParagraphNode, $isTextNode, TextNode, $createTextNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns the root's text content.\n * @returns The root's text content.\n */\nfunction $rootTextContent() {\n  const root = $getRoot();\n  return root.getTextContent();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the root has any text content and can trim any whitespace if it does.\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\n */\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n  let text = $rootTextContent();\n  if (trim) {\n    text = text.trim();\n  }\n  return text === '';\n}\n\n/**\n * Returns a function that executes {@link $isRootTextContentEmpty}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\n */\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the input should show the placeholder. If anything is in\n * in the root the placeholder should not be shown.\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns true if the input should show the placeholder, false otherwise.\n */\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n  const root = $getRoot();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n  if (childrenLength > 1) {\n    return false;\n  }\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n    if ($isDecoratorNode(topBlock)) {\n      return false;\n    }\n    if ($isElementNode(topBlock)) {\n      if (!$isParagraphNode(topBlock)) {\n        return false;\n      }\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n        if (!$isTextNode(child)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Returns a function that executes {@link $canShowPlaceholder}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns A function that executes $canShowPlaceholder with arguments.\n */\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Finds a TextNode with a size larger than targetCharacters and returns\n * the node along with the remaining length of the text.\n * @param root - The RootNode.\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n  mainLoop: while (node !== null) {\n    if ($isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if ($isTextNode(node)) {\n      const characters = node.getTextContentSize();\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n      currentCharacters += characters;\n    }\n    const sibling = node.getNextSibling();\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n    let parent = node.getParent();\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n      parent = parent.getParent();\n    }\n    break;\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Returns a tuple that can be rested (...) into mergeRegister to clean up\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\n * @example\n * ```ts\n *   useEffect(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    );\n  }, [createNode, editor, getMatch, targetNode]);\n * ```\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\n * @param editor - The lexical editor.\n * @param getMatch - Finds a matching string that satisfies a regex expression.\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\n * @returns An array containing the plain text and reverse node transform listeners.\n */\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $replaceWithSimpleText = node => {\n    const textNode = $createTextNode(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n  const $textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n    let prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n    if ($isTextNode(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          $replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    }\n    let prevMatchLengthToSkip = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n        if ($isTextNode(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              $replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      }\n      if (match === null) {\n        return;\n      }\n      if (match.start === 0 && $isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n        prevMatchLengthToSkip += match.end;\n        continue;\n      }\n      let nodeToReplace;\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start + prevMatchLengthToSkip, match.end + prevMatchLengthToSkip);\n      }\n      if (!(nodeToReplace !== undefined)) {\n        formatDevErrorMessage(`${'nodeToReplace'} should not be undefined. You may want to check splitOffsets passed to the splitText.`);\n      }\n      const replacementNode = createNode(nodeToReplace);\n      replacementNode.setFormat(nodeToReplace.getFormat());\n      nodeToReplace.replace(replacementNode);\n      if (currentNode == null) {\n        return;\n      }\n      prevMatchLengthToSkip = 0;\n      prevSibling = replacementNode;\n    }\n  };\n  const $reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n    if (match === null || match.start !== 0) {\n      $replaceWithSimpleText(node);\n      return;\n    }\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    if ($isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n      $replaceWithSimpleText(prevSibling);\n      $replaceWithSimpleText(node);\n    }\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling) && nextSibling.isTextEntity()) {\n      $replaceWithSimpleText(nextSibling);\n\n      // This may have already been converted in the previous block\n      if (isTargetNode(node)) {\n        $replaceWithSimpleText(node);\n      }\n    }\n  };\n  const removePlainTextTransform = editor.registerNodeTransform(TextNode, $textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, $reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\nexport { $canShowPlaceholder, $canShowPlaceholderCurry, $findTextIntersectionFromCharacters, $isRootTextContentEmpty, $isRootTextContentEmptyCurry, $rootTextContent, registerLexicalTextEntity };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1142, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40lexical%2Bdragon%400.35.0/node_modules/%40lexical/dragon/LexicalDragon.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getSelection, $isRangeSelection, $isTextNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction registerDragonSupport(editor) {\n  const origin = window.location.origin;\n  const handler = event => {\n    if (event.origin !== origin) {\n      return;\n    }\n    const rootElement = editor.getRootElement();\n    if (document.activeElement !== rootElement) {\n      return;\n    }\n    const data = event.data;\n    if (typeof data === 'string') {\n      let parsedData;\n      try {\n        parsedData = JSON.parse(data);\n      } catch (e) {\n        return;\n      }\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\n        const payload = parsedData.payload;\n        if (payload && payload.functionId === 'makeChanges') {\n          const args = payload.args;\n          if (args) {\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args;\n            editor.update(() => {\n              const selection = $getSelection();\n              if ($isRangeSelection(selection)) {\n                const anchor = selection.anchor;\n                let anchorNode = anchor.getNode();\n                let setSelStart = 0;\n                let setSelEnd = 0;\n                if ($isTextNode(anchorNode)) {\n                  // set initial selection\n                  if (elementStart >= 0 && elementLength >= 0) {\n                    setSelStart = elementStart;\n                    setSelEnd = elementStart + elementLength;\n                    // If the offset is more than the end, make it the end\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                  }\n                }\n                if (setSelStart !== setSelEnd || text !== '') {\n                  selection.insertRawText(text);\n                  anchorNode = anchor.getNode();\n                }\n                if ($isTextNode(anchorNode)) {\n                  // set final selection\n                  setSelStart = selStart;\n                  setSelEnd = selStart + selLength;\n                  const anchorNodeTextLength = anchorNode.getTextContentSize();\n                  // If the offset is more than the end, make it the end\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                }\n\n                // block the chrome extension from handling this event\n                event.stopImmediatePropagation();\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n  window.addEventListener('message', handler, true);\n  return () => {\n    window.removeEventListener('message', handler, true);\n  };\n}\n\nexport { registerDragonSupport };\n"],"names":[],"mappings":";;;;AAAA;;;;;;CAMC,GAED;;AAEA;;;;;;CAMC,GAED,SAAS,sBAAsB,MAAM;IACnC,MAAM,SAAS,OAAO,QAAQ,CAAC,MAAM;IACrC,MAAM,UAAU,CAAA;QACd,IAAI,MAAM,MAAM,KAAK,QAAQ;YAC3B;QACF;QACA,MAAM,cAAc,OAAO,cAAc;QACzC,IAAI,SAAS,aAAa,KAAK,aAAa;YAC1C;QACF;QACA,MAAM,OAAO,MAAM,IAAI;QACvB,IAAI,OAAO,SAAS,UAAU;YAC5B,IAAI;YACJ,IAAI;gBACF,aAAa,KAAK,KAAK,CAAC;YAC1B,EAAE,OAAO,GAAG;gBACV;YACF;YACA,IAAI,cAAc,WAAW,QAAQ,KAAK,uBAAuB,WAAW,IAAI,KAAK,WAAW;gBAC9F,MAAM,UAAU,WAAW,OAAO;gBAClC,IAAI,WAAW,QAAQ,UAAU,KAAK,eAAe;oBACnD,MAAM,OAAO,QAAQ,IAAI;oBACzB,IAAI,MAAM;wBACR,MAAM,CAAC,cAAc,eAAe,MAAM,UAAU,WAAW,cAAc,GAAG;wBAChF,OAAO,MAAM,CAAC;4BACZ,MAAM,YAAY,IAAA,gNAAa;4BAC/B,IAAI,IAAA,oNAAiB,EAAC,YAAY;gCAChC,MAAM,SAAS,UAAU,MAAM;gCAC/B,IAAI,aAAa,OAAO,OAAO;gCAC/B,IAAI,cAAc;gCAClB,IAAI,YAAY;gCAChB,IAAI,IAAA,8MAAW,EAAC,aAAa;oCAC3B,wBAAwB;oCACxB,IAAI,gBAAgB,KAAK,iBAAiB,GAAG;wCAC3C,cAAc;wCACd,YAAY,eAAe;wCAC3B,sDAAsD;wCACtD,UAAU,gBAAgB,CAAC,YAAY,aAAa,YAAY;oCAClE;gCACF;gCACA,IAAI,gBAAgB,aAAa,SAAS,IAAI;oCAC5C,UAAU,aAAa,CAAC;oCACxB,aAAa,OAAO,OAAO;gCAC7B;gCACA,IAAI,IAAA,8MAAW,EAAC,aAAa;oCAC3B,sBAAsB;oCACtB,cAAc;oCACd,YAAY,WAAW;oCACvB,MAAM,uBAAuB,WAAW,kBAAkB;oCAC1D,sDAAsD;oCACtD,cAAc,cAAc,uBAAuB,uBAAuB;oCAC1E,YAAY,YAAY,uBAAuB,uBAAuB;oCACtE,UAAU,gBAAgB,CAAC,YAAY,aAAa,YAAY;gCAClE;gCAEA,sDAAsD;gCACtD,MAAM,wBAAwB;4BAChC;wBACF;oBACF;gBACF;YACF;QACF;IACF;IACA,OAAO,gBAAgB,CAAC,WAAW,SAAS;IAC5C,OAAO;QACL,OAAO,mBAAmB,CAAC,WAAW,SAAS;IACjD;AACF","ignoreList":[0]}},
    {"offset": {"line": 1233, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40lexical%2Breact%400.35.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_yjs%4013.6.27/node_modules/%40lexical/react/LexicalRichTextPlugin.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { useLexicalEditable } from '@lexical/react/useLexicalEditable';\nimport { $canShowPlaceholderCurry } from '@lexical/text';\nimport { mergeRegister } from '@lexical/utils';\nimport { useLayoutEffect, useEffect, useState, useMemo, Suspense } from 'react';\nimport { flushSync, createPortal } from 'react-dom';\nimport { jsx, jsxs, Fragment } from 'react/jsx-runtime';\nimport { registerDragonSupport } from '@lexical/dragon';\nimport { registerRichText } from '@lexical/rich-text';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? useLayoutEffect : useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction canShowPlaceholderFromCurrentEditorState(editor) {\n  const currentCanShowPlaceholder = editor.getEditorState().read($canShowPlaceholderCurry(editor.isComposing()));\n  return currentCanShowPlaceholder;\n}\nfunction useCanShowPlaceholder(editor) {\n  const [canShowPlaceholder, setCanShowPlaceholder] = useState(() => canShowPlaceholderFromCurrentEditorState(editor));\n  useLayoutEffectImpl(() => {\n    function resetCanShowPlaceholder() {\n      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);\n      setCanShowPlaceholder(currentCanShowPlaceholder);\n    }\n    resetCanShowPlaceholder();\n    return mergeRegister(editor.registerUpdateListener(() => {\n      resetCanShowPlaceholder();\n    }), editor.registerEditableListener(() => {\n      resetCanShowPlaceholder();\n    }));\n  }, [editor]);\n  return canShowPlaceholder;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useDecorators(editor, ErrorBoundary) {\n  const [decorators, setDecorators] = useState(() => editor.getDecorators());\n\n  // Subscribe to changes\n  useLayoutEffectImpl(() => {\n    return editor.registerDecoratorListener(nextDecorators => {\n      flushSync(() => {\n        setDecorators(nextDecorators);\n      });\n    });\n  }, [editor]);\n  useEffect(() => {\n    // If the content editable mounts before the subscription is added, then\n    // nothing will be rendered on initial pass. We can get around that by\n    // ensuring that we set the value.\n    setDecorators(editor.getDecorators());\n  }, [editor]);\n\n  // Return decorators defined as React Portals\n  return useMemo(() => {\n    const decoratedPortals = [];\n    const decoratorKeys = Object.keys(decorators);\n    for (let i = 0; i < decoratorKeys.length; i++) {\n      const nodeKey = decoratorKeys[i];\n      const reactDecorator = /*#__PURE__*/jsx(ErrorBoundary, {\n        onError: e => editor._onError(e),\n        children: /*#__PURE__*/jsx(Suspense, {\n          fallback: null,\n          children: decorators[nodeKey]\n        })\n      });\n      const element = editor.getElementByKey(nodeKey);\n      if (element !== null) {\n        decoratedPortals.push(/*#__PURE__*/createPortal(reactDecorator, element, nodeKey));\n      }\n    }\n    return decoratedPortals;\n  }, [ErrorBoundary, decorators, editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useRichTextSetup(editor) {\n  useLayoutEffectImpl(() => {\n    return mergeRegister(registerRichText(editor), registerDragonSupport(editor));\n\n    // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction RichTextPlugin({\n  contentEditable,\n  // TODO Remove. This property is now part of ContentEditable\n  placeholder = null,\n  ErrorBoundary\n}) {\n  const [editor] = useLexicalComposerContext();\n  const decorators = useDecorators(editor, ErrorBoundary);\n  useRichTextSetup(editor);\n  return /*#__PURE__*/jsxs(Fragment, {\n    children: [contentEditable, /*#__PURE__*/jsx(Placeholder, {\n      content: placeholder\n    }), decorators]\n  });\n}\n\n// TODO remove\nfunction Placeholder({\n  content\n}) {\n  const [editor] = useLexicalComposerContext();\n  const showPlaceholder = useCanShowPlaceholder(editor);\n  const editable = useLexicalEditable();\n  if (!showPlaceholder) {\n    return null;\n  }\n  if (typeof content === 'function') {\n    return content(editable);\n  } else {\n    return content;\n  }\n}\n\nexport { RichTextPlugin };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1412, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40lexical%2Breact%400.35.0_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0_yjs%4013.6.27/node_modules/%40lexical/react/LexicalContentEditable.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { useLayoutEffect, useEffect, forwardRef, useState, useCallback, useMemo } from 'react';\nimport { jsx, jsxs, Fragment } from 'react/jsx-runtime';\nimport { $canShowPlaceholderCurry } from '@lexical/text';\nimport { mergeRegister } from '@lexical/utils';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? useLayoutEffect : useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// Source: https://github.com/gregberge/react-merge-refs/blob/main/src/index.tsx\n\nfunction mergeRefs(...refs) {\n  return value => {\n    refs.forEach(ref => {\n      if (typeof ref === 'function') {\n        ref(value);\n      } else if (ref != null) {\n        ref.current = value;\n      }\n    });\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction ContentEditableElementImpl({\n  editor,\n  ariaActiveDescendant,\n  ariaAutoComplete,\n  ariaControls,\n  ariaDescribedBy,\n  ariaErrorMessage,\n  ariaExpanded,\n  ariaInvalid,\n  ariaLabel,\n  ariaLabelledBy,\n  ariaMultiline,\n  ariaOwns,\n  ariaRequired,\n  autoCapitalize,\n  className,\n  id,\n  role = 'textbox',\n  spellCheck = true,\n  style,\n  tabIndex,\n  'data-testid': testid,\n  ...rest\n}, ref) {\n  const [isEditable, setEditable] = useState(editor.isEditable());\n  const handleRef = useCallback(rootElement => {\n    // defaultView is required for a root element.\n    // In multi-window setups, the defaultView may not exist at certain points.\n    if (rootElement && rootElement.ownerDocument && rootElement.ownerDocument.defaultView) {\n      editor.setRootElement(rootElement);\n    } else {\n      editor.setRootElement(null);\n    }\n  }, [editor]);\n  const mergedRefs = useMemo(() => mergeRefs(ref, handleRef), [handleRef, ref]);\n  useLayoutEffectImpl(() => {\n    setEditable(editor.isEditable());\n    return editor.registerEditableListener(currentIsEditable => {\n      setEditable(currentIsEditable);\n    });\n  }, [editor]);\n  return /*#__PURE__*/jsx(\"div\", {\n    \"aria-activedescendant\": isEditable ? ariaActiveDescendant : undefined,\n    \"aria-autocomplete\": isEditable ? ariaAutoComplete : 'none',\n    \"aria-controls\": isEditable ? ariaControls : undefined,\n    \"aria-describedby\": ariaDescribedBy\n    // for compat, only override aria-errormessage if ariaErrorMessage is defined\n    ,\n    ...(ariaErrorMessage != null ? {\n      'aria-errormessage': ariaErrorMessage\n    } : {}),\n    \"aria-expanded\": isEditable && role === 'combobox' ? !!ariaExpanded : undefined\n    // for compat, only override aria-invalid if ariaInvalid is defined\n    ,\n    ...(ariaInvalid != null ? {\n      'aria-invalid': ariaInvalid\n    } : {}),\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    \"aria-multiline\": ariaMultiline,\n    \"aria-owns\": isEditable ? ariaOwns : undefined,\n    \"aria-readonly\": isEditable ? undefined : true,\n    \"aria-required\": ariaRequired,\n    autoCapitalize: autoCapitalize,\n    className: className,\n    contentEditable: isEditable,\n    \"data-testid\": testid,\n    id: id,\n    ref: mergedRefs,\n    role: role,\n    spellCheck: spellCheck,\n    style: style,\n    tabIndex: tabIndex,\n    ...rest\n  });\n}\nconst ContentEditableElement = /*#__PURE__*/forwardRef(ContentEditableElementImpl);\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction canShowPlaceholderFromCurrentEditorState(editor) {\n  const currentCanShowPlaceholder = editor.getEditorState().read($canShowPlaceholderCurry(editor.isComposing()));\n  return currentCanShowPlaceholder;\n}\nfunction useCanShowPlaceholder(editor) {\n  const [canShowPlaceholder, setCanShowPlaceholder] = useState(() => canShowPlaceholderFromCurrentEditorState(editor));\n  useLayoutEffectImpl(() => {\n    function resetCanShowPlaceholder() {\n      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);\n      setCanShowPlaceholder(currentCanShowPlaceholder);\n    }\n    resetCanShowPlaceholder();\n    return mergeRegister(editor.registerUpdateListener(() => {\n      resetCanShowPlaceholder();\n    }), editor.registerEditableListener(() => {\n      resetCanShowPlaceholder();\n    }));\n  }, [editor]);\n  return canShowPlaceholder;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * @deprecated This type has been renamed to `ContentEditableProps` to provide a clearer and more descriptive name.\n * For backward compatibility, this type is still exported as `Props`, but it is recommended to migrate to using `ContentEditableProps` instead.\n *\n * @note This alias is maintained for compatibility purposes but may be removed in future versions.\n * Please update your codebase to use `ContentEditableProps` to ensure long-term maintainability.\n */\n\nconst ContentEditable = /*#__PURE__*/forwardRef(ContentEditableImpl);\nfunction ContentEditableImpl(props, ref) {\n  const {\n    placeholder,\n    ...rest\n  } = props;\n  const [editor] = useLexicalComposerContext();\n  return /*#__PURE__*/jsxs(Fragment, {\n    children: [/*#__PURE__*/jsx(ContentEditableElement, {\n      editor: editor,\n      ...rest,\n      ref: ref\n    }), placeholder != null && /*#__PURE__*/jsx(Placeholder, {\n      editor: editor,\n      content: placeholder\n    })]\n  });\n}\nfunction Placeholder({\n  content,\n  editor\n}) {\n  const showPlaceholder = useCanShowPlaceholder(editor);\n  const [isEditable, setEditable] = useState(editor.isEditable());\n  useLayoutEffect(() => {\n    setEditable(editor.isEditable());\n    return editor.registerEditableListener(currentIsEditable => {\n      setEditable(currentIsEditable);\n    });\n  }, [editor]);\n  if (!showPlaceholder) {\n    return null;\n  }\n  let placeholder = null;\n  if (typeof content === 'function') {\n    placeholder = content(isEditable);\n  } else if (content !== null) {\n    placeholder = content;\n  }\n  if (placeholder === null) {\n    return null;\n  }\n  return /*#__PURE__*/jsx(\"div\", {\n    \"aria-hidden\": true,\n    children: placeholder\n  });\n}\n\nexport { ContentEditable, ContentEditableElement };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1623, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/field/Field.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/LexicalProvider.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/LexicalEditor.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/EditorPlugin.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/plugins/ClipboardPlugin/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/plugins/DecoratorPlugin/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/plugins/handles/AddBlockHandlePlugin/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/plugins/handles/utils/calculateDistanceFromScrollerElem.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/plugins/handles/utils/getNodeCloseToPoint.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/plugins/handles/DraggableBlockPlugin/getBoundingRectWithoutTransform.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/plugins/handles/utils/getCollapsedMargins.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/plugins/handles/utils/getTopLevelNodeKeys.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/plugins/handles/utils/isOnHandleElement.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/plugins/handles/utils/doesLineHeightAffectElement.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/plugins/handles/utils/setHandlePosition.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/plugins/handles/DraggableBlockPlugin/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/plugins/handles/DraggableBlockPlugin/setTargetLine.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/plugins/InsertParagraphAtEnd/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/plugins/MarkdownShortcut/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/plugins/NormalizeSelection/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/plugins/SelectAllPlugin/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/plugins/SlashMenu/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/plugins/SlashMenu/useMenuTriggerMatch.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/plugins/TextPlugin/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/ContentEditable.tsx"],"sourcesContent":["'use client'\nimport type { EditorState, SerializedEditorState } from 'lexical'\n\nimport {\n  BulkUploadProvider,\n  FieldDescription,\n  FieldError,\n  FieldLabel,\n  RenderCustomComponent,\n  useEditDepth,\n  useEffectEvent,\n  useField,\n} from '@payloadcms/ui'\nimport { mergeFieldStyles } from '@payloadcms/ui/shared'\nimport { dequal } from 'dequal/lite'\nimport { type Validate } from 'payload'\nimport React, { useCallback, useEffect, useMemo, useState } from 'react'\nimport { ErrorBoundary } from 'react-error-boundary'\n\nimport type { SanitizedClientEditorConfig } from '../lexical/config/types.js'\n\nimport '../lexical/theme/EditorTheme.scss'\nimport './bundled.css'\nimport './index.scss'\n\nimport type { LexicalRichTextFieldProps } from '../types.js'\n\nimport { LexicalProvider } from '../lexical/LexicalProvider.js'\nimport { useRunDeprioritized } from '../utilities/useRunDeprioritized.js'\n\nconst baseClass = 'rich-text-lexical'\n\nconst RichTextComponent: React.FC<\n  {\n    readonly editorConfig: SanitizedClientEditorConfig // With rendered features n stuff\n  } & LexicalRichTextFieldProps\n> = (props) => {\n  const {\n    editorConfig,\n    field,\n    field: {\n      admin: { className, description, readOnly: readOnlyFromAdmin } = {},\n      label,\n      localized,\n      required,\n    },\n    path: pathFromProps,\n    readOnly: readOnlyFromTopLevelProps,\n    validate, // Users can pass in client side validation if they WANT to, but it's not required anymore\n  } = props\n\n  const readOnlyFromProps = readOnlyFromTopLevelProps || readOnlyFromAdmin\n\n  const editDepth = useEditDepth()\n\n  const memoizedValidate = useCallback<Validate>(\n    (value, validationOptions) => {\n      if (typeof validate === 'function') {\n        // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n        return validate(value, { ...validationOptions, required })\n      }\n      return true\n    },\n    // Important: do not add props to the dependencies array.\n    // This would cause an infinite loop and endless re-rendering.\n    // Removing props from the dependencies array fixed this issue: https://github.com/payloadcms/payload/issues/3709\n    [validate, required],\n  )\n\n  const {\n    customComponents: { AfterInput, BeforeInput, Description, Error, Label } = {},\n    disabled: disabledFromField,\n    initialValue,\n    path,\n    setValue,\n    showError,\n    value,\n  } = useField<SerializedEditorState>({\n    potentiallyStalePath: pathFromProps,\n    validate: memoizedValidate,\n  })\n\n  const disabled = readOnlyFromProps || disabledFromField\n\n  const [isSmallWidthViewport, setIsSmallWidthViewport] = useState<boolean>(false)\n  const [rerenderProviderKey, setRerenderProviderKey] = useState<Date>()\n\n  const prevInitialValueRef = React.useRef<SerializedEditorState | undefined>(initialValue)\n  const prevValueRef = React.useRef<SerializedEditorState | undefined>(value)\n\n  useEffect(() => {\n    const updateViewPortWidth = () => {\n      const isNextSmallWidthViewport = window.matchMedia('(max-width: 768px)').matches\n\n      if (isNextSmallWidthViewport !== isSmallWidthViewport) {\n        setIsSmallWidthViewport(isNextSmallWidthViewport)\n      }\n    }\n    updateViewPortWidth()\n    window.addEventListener('resize', updateViewPortWidth)\n\n    return () => {\n      window.removeEventListener('resize', updateViewPortWidth)\n    }\n  }, [isSmallWidthViewport])\n\n  const classes = [\n    baseClass,\n    'field-type',\n    className,\n    showError && 'error',\n    disabled && `${baseClass}--read-only`,\n    editorConfig?.admin?.hideGutter !== true && !isSmallWidthViewport\n      ? `${baseClass}--show-gutter`\n      : null,\n  ]\n    .filter(Boolean)\n    .join(' ')\n\n  const pathWithEditDepth = `${path}.${editDepth}`\n\n  const runDeprioritized = useRunDeprioritized() // defaults to 500 ms timeout\n\n  const handleChange = useCallback(\n    (editorState: EditorState) => {\n      // Capture `editorState` in the closure so we can safely run later.\n      const updateFieldValue = () => {\n        const newState = editorState.toJSON()\n        prevValueRef.current = newState\n        setValue(newState)\n      }\n\n      // Queue the update for the browsers idle time (or Safari shim)\n      // and let the hook handle debouncing/cancellation.\n      void runDeprioritized(updateFieldValue)\n    },\n    [setValue, runDeprioritized], // `runDeprioritized` is stable (useCallback inside hook)\n  )\n\n  const styles = useMemo(() => mergeFieldStyles(field), [field])\n\n  const handleInitialValueChange = useEffectEvent(\n    (initialValue: SerializedEditorState | undefined) => {\n      // Object deep equality check here, as re-mounting the editor if\n      // the new value is the same as the old one is not necessary.\n      // In postgres, the order of keys in JSON objects is not guaranteed to be preserved,\n      // so we need to do a deep equality check here that does not care about key order => we use dequal.\n      // If we used JSON.stringify, the editor would re-mount every time you save the document, as the order of keys changes => change detected => re-mount.\n      if (\n        prevValueRef.current !== value &&\n        !dequal(\n          prevValueRef.current != null\n            ? JSON.parse(JSON.stringify(prevValueRef.current))\n            : prevValueRef.current,\n          value,\n        )\n      ) {\n        prevInitialValueRef.current = initialValue\n        prevValueRef.current = value\n        setRerenderProviderKey(new Date())\n      }\n    },\n  )\n\n  useEffect(() => {\n    // Needs to trigger for object reference changes - otherwise,\n    // reacting to the same initial value change twice will cause\n    // the second change to be ignored, even though the value has changed.\n    // That's because initialValue is not kept up-to-date\n    if (!Object.is(initialValue, prevInitialValueRef.current)) {\n      handleInitialValueChange(initialValue)\n    }\n  }, [initialValue])\n\n  return (\n    <div className={classes} key={pathWithEditDepth} style={styles}>\n      <RenderCustomComponent\n        CustomComponent={Error}\n        Fallback={<FieldError path={path} showError={showError} />}\n      />\n      {Label || <FieldLabel label={label} localized={localized} path={path} required={required} />}\n      <div className={`${baseClass}__wrap`}>\n        <ErrorBoundary fallbackRender={fallbackRender} onReset={() => {}}>\n          {BeforeInput}\n          {/* Lexical may be in a drawer. We need to define another BulkUploadProvider to ensure that the bulk upload drawer\n          is rendered in the correct depth (not displayed *behind* the current drawer)*/}\n          <BulkUploadProvider drawerSlugPrefix={path}>\n            <LexicalProvider\n              composerKey={pathWithEditDepth}\n              editorConfig={editorConfig}\n              fieldProps={props}\n              isSmallWidthViewport={isSmallWidthViewport}\n              key={JSON.stringify({ path, rerenderProviderKey })} // makes sure lexical is completely re-rendered when initialValue changes, bypassing the lexical-internal value memoization. That way, external changes to the form will update the editor. More infos in PR description (https://github.com/payloadcms/payload/pull/5010)\n              onChange={handleChange}\n              readOnly={disabled}\n              value={value}\n            />\n          </BulkUploadProvider>\n          {AfterInput}\n        </ErrorBoundary>\n        <RenderCustomComponent\n          CustomComponent={Description}\n          Fallback={<FieldDescription description={description} path={path} />}\n        />\n      </div>\n    </div>\n  )\n}\n\nfunction fallbackRender({ error }: { error: Error }) {\n  // Call resetErrorBoundary() to reset the error boundary and retry the render.\n\n  return (\n    <div className=\"errorBoundary\" role=\"alert\">\n      <p>Something went wrong:</p>\n      <pre style={{ color: 'red' }}>{error.message}</pre>\n    </div>\n  )\n}\n\nexport const RichText: typeof RichTextComponent = RichTextComponent\n","'use client'\nimport type { InitialConfigType } from '@lexical/react/LexicalComposer.js'\nimport type { EditorState, LexicalEditor, SerializedEditorState } from 'lexical'\n\nimport { LexicalComposer } from '@lexical/react/LexicalComposer.js'\nimport { useEditDepth } from '@payloadcms/ui'\nimport * as React from 'react'\nimport { useMemo } from 'react'\n\nimport type { LexicalRichTextFieldProps } from '../types.js'\nimport type { SanitizedClientEditorConfig } from './config/types.js'\n\nimport {\n  EditorConfigProvider,\n  useEditorConfigContext,\n} from './config/client/EditorConfigProvider.js'\nimport { LexicalEditor as LexicalEditorComponent } from './LexicalEditor.js'\nimport { getEnabledNodes } from './nodes/index.js'\n\nexport type LexicalProviderProps = {\n  composerKey: string\n  editorConfig: SanitizedClientEditorConfig\n  fieldProps: LexicalRichTextFieldProps\n  isSmallWidthViewport: boolean\n  onChange: (editorState: EditorState, editor: LexicalEditor, tags: Set<string>) => void\n  readOnly: boolean\n  value: SerializedEditorState\n}\n\nconst NestProviders = ({\n  children,\n  providers,\n}: {\n  children: React.ReactNode\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  providers: any[]\n}) => {\n  if (!providers?.length) {\n    return children\n  }\n  const Component = providers[0]\n  if (providers.length > 1) {\n    return (\n      <Component>\n        <NestProviders providers={providers.slice(1)}>{children}</NestProviders>\n      </Component>\n    )\n  }\n  return <Component>{children}</Component>\n}\n\nexport const LexicalProvider: React.FC<LexicalProviderProps> = (props) => {\n  const { composerKey, editorConfig, fieldProps, isSmallWidthViewport, onChange, readOnly, value } =\n    props\n\n  const parentContext = useEditorConfigContext()\n\n  const editDepth = useEditDepth()\n\n  const editorContainerRef = React.useRef<HTMLDivElement>(null)\n\n  // useMemo for the initialConfig that depends on readOnly and value\n  const initialConfig = useMemo<InitialConfigType>(() => {\n    if (value && typeof value !== 'object') {\n      throw new Error(\n        'The value passed to the Lexical editor is not an object. This is not supported. Please remove the data from the field and start again. This is the value that was passed in: ' +\n          JSON.stringify(value),\n      )\n    }\n\n    if (value && Array.isArray(value) && !('root' in value)) {\n      throw new Error(\n        'You have tried to pass in data from the old Slate editor to the new Lexical editor. The data structure is different, thus you will have to migrate your data. We offer a one-line migration script which migrates all your rich text fields: https://payloadcms.com/docs/lexical/migration#migration-via-migration-script-recommended',\n      )\n    }\n\n    if (value && 'jsonContent' in value) {\n      throw new Error(\n        'You have tried to pass in data from payload-plugin-lexical. The data structure is different, thus you will have to migrate your data. Migration guide: https://payloadcms.com/docs/lexical/migration#migrating-from-payload-plugin-lexical',\n      )\n    }\n\n    return {\n      editable: readOnly !== true,\n      editorState: value != null ? JSON.stringify(value) : undefined,\n      namespace: editorConfig.lexical.namespace,\n      nodes: getEnabledNodes({ editorConfig }),\n      onError: (error: Error) => {\n        throw error\n      },\n      theme: editorConfig.lexical.theme,\n    }\n    // Important: do not add readOnly and value to the dependencies array. This will cause the entire lexical editor to re-render if the document is saved, which will\n    // cause the editor to lose focus.\n  }, [editorConfig])\n\n  if (!initialConfig) {\n    return <p>Loading...</p>\n  }\n\n  // We need to add initialConfig.editable to the key to force a re-render when the readOnly prop changes.\n  // Without it, there were cases where lexical editors inside drawers turn readOnly initially - a few miliseconds later they turn editable, but the editor does not re-render and stays readOnly.\n  return (\n    <LexicalComposer initialConfig={initialConfig} key={composerKey + initialConfig.editable}>\n      <EditorConfigProvider\n        editorConfig={editorConfig}\n        editorContainerRef={editorContainerRef}\n        fieldProps={fieldProps}\n        /**\n         * Parent editor is not truly the parent editor, if the current editor is part of a drawer and the parent editor is the main editor.\n         */\n        parentContext={parentContext?.editDepth === editDepth ? parentContext : undefined}\n      >\n        <NestProviders providers={editorConfig.features.providers}>\n          <LexicalEditorComponent\n            editorConfig={editorConfig}\n            editorContainerRef={editorContainerRef}\n            isSmallWidthViewport={isSmallWidthViewport}\n            onChange={onChange}\n          />\n        </NestProviders>\n      </EditorConfigProvider>\n    </LexicalComposer>\n  )\n}\n","'use client'\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { LexicalErrorBoundary } from '@lexical/react/LexicalErrorBoundary.js'\nimport { HistoryPlugin } from '@lexical/react/LexicalHistoryPlugin.js'\nimport { OnChangePlugin } from '@lexical/react/LexicalOnChangePlugin.js'\nimport { RichTextPlugin } from '@lexical/react/LexicalRichTextPlugin.js'\nimport { useLexicalEditable } from '@lexical/react/useLexicalEditable'\nimport { BLUR_COMMAND, COMMAND_PRIORITY_LOW, FOCUS_COMMAND } from 'lexical'\nimport * as React from 'react'\nimport { useEffect, useState } from 'react'\n\nimport type { LexicalProviderProps } from './LexicalProvider.js'\n\nimport { useEditorConfigContext } from './config/client/EditorConfigProvider.js'\nimport './LexicalEditor.scss'\nimport { EditorPlugin } from './EditorPlugin.js'\nimport { ClipboardPlugin } from './plugins/ClipboardPlugin/index.js'\nimport { DecoratorPlugin } from './plugins/DecoratorPlugin/index.js'\nimport { AddBlockHandlePlugin } from './plugins/handles/AddBlockHandlePlugin/index.js'\nimport { DraggableBlockPlugin } from './plugins/handles/DraggableBlockPlugin/index.js'\nimport { InsertParagraphAtEndPlugin } from './plugins/InsertParagraphAtEnd/index.js'\nimport { MarkdownShortcutPlugin } from './plugins/MarkdownShortcut/index.js'\nimport { NormalizeSelectionPlugin } from './plugins/NormalizeSelection/index.js'\nimport { SelectAllPlugin } from './plugins/SelectAllPlugin/index.js'\nimport { SlashMenuPlugin } from './plugins/SlashMenu/index.js'\nimport { TextPlugin } from './plugins/TextPlugin/index.js'\nimport { LexicalContentEditable } from './ui/ContentEditable.js'\n\nexport const LexicalEditor: React.FC<\n  {\n    editorContainerRef: React.RefObject<HTMLDivElement | null>\n    isSmallWidthViewport: boolean\n  } & Pick<LexicalProviderProps, 'editorConfig' | 'onChange'>\n> = (props) => {\n  const { editorConfig, editorContainerRef, isSmallWidthViewport, onChange } = props\n  const editorConfigContext = useEditorConfigContext()\n  const [editor] = useLexicalComposerContext()\n  const isEditable = useLexicalEditable()\n\n  const [floatingAnchorElem, setFloatingAnchorElem] = useState<HTMLDivElement | null>(null)\n  const onRef = (_floatingAnchorElem: HTMLDivElement) => {\n    if (_floatingAnchorElem !== null) {\n      setFloatingAnchorElem(_floatingAnchorElem)\n    }\n  }\n\n  useEffect(() => {\n    if (!editorConfigContext?.uuid) {\n      console.error('Lexical Editor must be used within an EditorConfigProvider')\n      return\n    }\n    if (editorConfigContext?.parentEditor?.uuid) {\n      editorConfigContext.parentEditor?.registerChild(editorConfigContext.uuid, editorConfigContext)\n    }\n\n    const handleFocus = () => {\n      editorConfigContext.focusEditor(editorConfigContext)\n    }\n\n    const handleBlur = () => {\n      editorConfigContext.blurEditor(editorConfigContext)\n    }\n\n    const unregisterFocus = editor.registerCommand<MouseEvent>(\n      FOCUS_COMMAND,\n      () => {\n        handleFocus()\n        return true\n      },\n      COMMAND_PRIORITY_LOW,\n    )\n\n    const unregisterBlur = editor.registerCommand<MouseEvent>(\n      BLUR_COMMAND,\n      () => {\n        handleBlur()\n        return true\n      },\n      COMMAND_PRIORITY_LOW,\n    )\n\n    return () => {\n      unregisterFocus()\n      unregisterBlur()\n      editorConfigContext.parentEditor?.unregisterChild?.(editorConfigContext.uuid)\n    }\n  }, [editor, editorConfigContext])\n\n  return (\n    <React.Fragment>\n      {editorConfig.features.plugins?.map((plugin) => {\n        if (plugin.position === 'aboveContainer') {\n          return <EditorPlugin clientProps={plugin.clientProps} key={plugin.key} plugin={plugin} />\n        }\n      })}\n      <div className=\"editor-container\" ref={editorContainerRef}>\n        {editorConfig.features.plugins?.map((plugin) => {\n          if (plugin.position === 'top') {\n            return (\n              <EditorPlugin clientProps={plugin.clientProps} key={plugin.key} plugin={plugin} />\n            )\n          }\n        })}\n        <RichTextPlugin\n          contentEditable={\n            <div className=\"editor-scroller\">\n              <div className=\"editor\" ref={onRef}>\n                <LexicalContentEditable editorConfig={editorConfig} />\n              </div>\n            </div>\n          }\n          ErrorBoundary={LexicalErrorBoundary}\n        />\n        <NormalizeSelectionPlugin />\n        {isEditable && <InsertParagraphAtEndPlugin />}\n        <DecoratorPlugin />\n        <ClipboardPlugin />\n        <TextPlugin features={editorConfig.features} />\n        <SelectAllPlugin />\n        {isEditable && (\n          <OnChangePlugin\n            // Selection changes can be ignored here, reducing the\n            // frequency that the FieldComponent and Payload receive updates.\n            // Selection changes are only needed if you are saving selection state\n            ignoreSelectionChange\n            onChange={(editorState, editor, tags) => {\n              // Ignore any onChange event triggered by focus only\n              if (!tags.has('focus') || tags.size > 1) {\n                if (onChange != null) {\n                  onChange(editorState, editor, tags)\n                }\n              }\n            }}\n          />\n        )}\n        {floatingAnchorElem && (\n          <React.Fragment>\n            {!isSmallWidthViewport && isEditable && (\n              <React.Fragment>\n                {editorConfig.admin?.hideDraggableBlockElement ? null : (\n                  <DraggableBlockPlugin anchorElem={floatingAnchorElem} />\n                )}\n                {editorConfig.admin?.hideAddBlockButton ? null : (\n                  <AddBlockHandlePlugin anchorElem={floatingAnchorElem} />\n                )}\n              </React.Fragment>\n            )}\n            {editorConfig.features.plugins?.map((plugin) => {\n              if (\n                plugin.position === 'floatingAnchorElem' &&\n                !(plugin.desktopOnly === true && isSmallWidthViewport)\n              ) {\n                return (\n                  <EditorPlugin\n                    anchorElem={floatingAnchorElem}\n                    clientProps={plugin.clientProps}\n                    key={plugin.key}\n                    plugin={plugin}\n                  />\n                )\n              }\n            })}\n            {isEditable && (\n              <React.Fragment>\n                <SlashMenuPlugin anchorElem={floatingAnchorElem} />\n              </React.Fragment>\n            )}\n          </React.Fragment>\n        )}\n        {isEditable && (\n          <React.Fragment>\n            <HistoryPlugin />\n            {editorConfig?.features?.markdownTransformers?.length > 0 && <MarkdownShortcutPlugin />}\n          </React.Fragment>\n        )}\n        {editorConfig.features.plugins?.map((plugin) => {\n          if (plugin.position === 'normal') {\n            return (\n              <EditorPlugin clientProps={plugin.clientProps} key={plugin.key} plugin={plugin} />\n            )\n          }\n        })}\n        {editorConfig.features.plugins?.map((plugin) => {\n          if (plugin.position === 'bottom') {\n            return (\n              <EditorPlugin clientProps={plugin.clientProps} key={plugin.key} plugin={plugin} />\n            )\n          }\n        })}\n      </div>\n      {editorConfig.features.plugins?.map((plugin) => {\n        if (plugin.position === 'belowContainer') {\n          return <EditorPlugin clientProps={plugin.clientProps} key={plugin.key} plugin={plugin} />\n        }\n      })}\n    </React.Fragment>\n  )\n}\n","'use client'\nimport React from 'react'\n\nimport type { SanitizedPlugin } from '../features/typesClient.js'\n\nexport const EditorPlugin: React.FC<{\n  anchorElem?: HTMLDivElement\n  clientProps: unknown\n  plugin: SanitizedPlugin\n}> = ({ anchorElem, clientProps, plugin }) => {\n  if (plugin.position === 'floatingAnchorElem' && anchorElem) {\n    return (\n      plugin.Component && <plugin.Component anchorElem={anchorElem} clientProps={clientProps} />\n    )\n  }\n\n  // @ts-expect-error - ts is not able to infer that plugin.Component is of type PluginComponent\n  return plugin.Component && <plugin.Component clientProps={clientProps} />\n}\n","'use client'\n\nimport { copyToClipboard } from '@lexical/clipboard'\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { objectKlassEquals } from '@lexical/utils'\nimport ObjectID from 'bson-objectid'\nimport { COMMAND_PRIORITY_LOW, COPY_COMMAND } from 'lexical'\nimport { useEffect } from 'react'\n\ntype SerializedUnknownLexicalNode = {\n  children?: SerializedUnknownLexicalNode[]\n  type: string\n}\n\nexport function ClipboardPlugin() {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    // Remove duplicated ids from clipboard. We do it here because:\n    // 1. Browsers do not allow setting the clipboardData in paste event for security reasons.\n    // 2. If you cut instead of paste, the id will be kept, which is a good thing.\n    return editor.registerCommand(\n      COPY_COMMAND,\n      (event) => {\n        copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null)\n          .then(() => {\n            if (!(event instanceof ClipboardEvent) || !event.clipboardData) {\n              throw new Error('No clipboard event')\n            }\n            const lexicalStringified = event.clipboardData.getData('application/x-lexical-editor')\n            if (!lexicalStringified) {\n              return true\n            }\n\n            const lexical = JSON.parse(lexicalStringified) as {\n              nodes: SerializedUnknownLexicalNode[]\n            }\n            const changeIds = (node: SerializedUnknownLexicalNode) => {\n              if (\n                'fields' in node &&\n                typeof node.fields === 'object' &&\n                node.fields !== null &&\n                'id' in node.fields\n              ) {\n                node.fields.id = new ObjectID.default().toHexString()\n              } else if ('id' in node) {\n                node.id = new ObjectID.default().toHexString()\n              }\n\n              if (node.children) {\n                for (const child of node.children) {\n                  changeIds(child)\n                }\n              }\n            }\n            for (const node of lexical.nodes) {\n              changeIds(node)\n            }\n            const stringified = JSON.stringify(lexical)\n            event.clipboardData.setData('application/x-lexical-editor', stringified)\n          })\n          .catch((error) => {\n            if (event instanceof ClipboardEvent) {\n              event.clipboardData?.setData('application/x-lexical-editor', '')\n            }\n            throw error\n          })\n        return true\n      },\n      COMMAND_PRIORITY_LOW,\n    )\n  }, [editor])\n\n  return null\n}\n","'use client'\n\nimport type { DecoratorNode, ElementNode, LexicalNode } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { $findMatchingParent, mergeRegister } from '@lexical/utils'\nimport {\n  $createNodeSelection,\n  $getEditor,\n  $getNearestNodeFromDOMNode,\n  $getSelection,\n  $isDecoratorNode,\n  $isElementNode,\n  $isLineBreakNode,\n  $isNodeSelection,\n  $isRangeSelection,\n  $isRootOrShadowRoot,\n  $isTextNode,\n  $setSelection,\n  CLICK_COMMAND,\n  COMMAND_PRIORITY_LOW,\n  KEY_ARROW_DOWN_COMMAND,\n  KEY_ARROW_UP_COMMAND,\n  KEY_BACKSPACE_COMMAND,\n  KEY_DELETE_COMMAND,\n  SELECTION_CHANGE_COMMAND,\n} from 'lexical'\nimport { useEffect } from 'react'\n\nimport './index.scss'\n\n// TODO: This should ideally be fixed in Lexical. See\n// https://github.com/facebook/lexical/pull/7072\nexport function DecoratorPlugin() {\n  const [editor] = useLexicalComposerContext()\n\n  const $onDelete = (event: KeyboardEvent) => {\n    const selection = $getSelection()\n    if (!$isNodeSelection(selection)) {\n      return false\n    }\n    event.preventDefault()\n    selection.getNodes().forEach((node) => {\n      node.remove()\n    })\n    return true\n  }\n\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerCommand(\n        CLICK_COMMAND,\n        (event) => {\n          document.querySelector('.decorator-selected')?.classList.remove('decorator-selected')\n          const decorator = $getDecoratorByMouseEvent(event)\n          if (!decorator) {\n            return true\n          }\n          const { target } = event\n          const isInteractive =\n            !(target instanceof HTMLElement) ||\n            target.isContentEditable ||\n            target.closest(\n              'button, textarea, input, .react-select, .code-editor, .no-select-decorator, [role=\"button\"]',\n            )\n          if (isInteractive) {\n            $setSelection(null)\n          } else {\n            $selectDecorator(decorator)\n          }\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand(KEY_DELETE_COMMAND, $onDelete, COMMAND_PRIORITY_LOW),\n      editor.registerCommand(KEY_BACKSPACE_COMMAND, $onDelete, COMMAND_PRIORITY_LOW),\n      editor.registerCommand(\n        SELECTION_CHANGE_COMMAND,\n        () => {\n          const decorator = $getSelectedDecorator()\n          document.querySelector('.decorator-selected')?.classList.remove('decorator-selected')\n          if (decorator) {\n            decorator.element?.classList.add('decorator-selected')\n            return true\n          }\n          return false\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand(\n        KEY_ARROW_UP_COMMAND,\n        (event) => {\n          // CASE 1: Node selection\n          const selection = $getSelection()\n          if ($isNodeSelection(selection)) {\n            const prevSibling = selection.getNodes()[0]?.getPreviousSibling()\n            if ($isDecoratorNode(prevSibling)) {\n              const element = $getEditor().getElementByKey(prevSibling.getKey())\n              if (element) {\n                $selectDecorator({ element, node: prevSibling })\n                event.preventDefault()\n                return true\n              }\n              return false\n            }\n            if (!$isElementNode(prevSibling)) {\n              return false\n            }\n            const lastDescendant = prevSibling.getLastDescendant() ?? prevSibling\n            if (!lastDescendant) {\n              return false\n            }\n            const block = $findMatchingParent(lastDescendant, INTERNAL_$isBlock)\n            block?.selectStart()\n            event.preventDefault()\n            return true\n          }\n          if (!$isRangeSelection(selection)) {\n            return false\n          }\n\n          // CASE 2: Range selection\n          // Get first selected block\n          const firstPoint = selection.isBackward() ? selection.anchor : selection.focus\n          const firstNode = firstPoint.getNode()\n          const firstSelectedBlock = $findMatchingParent(firstNode, (node) => {\n            return findFirstSiblingBlock(node) !== null\n          })\n          const prevBlock = firstSelectedBlock?.getPreviousSibling()\n          if (!firstSelectedBlock || prevBlock !== findFirstSiblingBlock(firstSelectedBlock)) {\n            return false\n          }\n\n          if ($isDecoratorNode(prevBlock)) {\n            const prevBlockElement = $getEditor().getElementByKey(prevBlock.getKey())\n            if (prevBlockElement) {\n              $selectDecorator({ element: prevBlockElement, node: prevBlock })\n              event.preventDefault()\n              return true\n            }\n          }\n\n          return false\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand(\n        KEY_ARROW_DOWN_COMMAND,\n        (event) => {\n          // CASE 1: Node selection\n          const selection = $getSelection()\n          if ($isNodeSelection(selection)) {\n            event.preventDefault()\n            const nextSibling = selection.getNodes()[0]?.getNextSibling()\n            if ($isDecoratorNode(nextSibling)) {\n              const element = $getEditor().getElementByKey(nextSibling.getKey())\n              if (element) {\n                $selectDecorator({ element, node: nextSibling })\n              }\n              return true\n            }\n            if (!$isElementNode(nextSibling)) {\n              return true\n            }\n            const firstDescendant = nextSibling.getFirstDescendant() ?? nextSibling\n            if (!firstDescendant) {\n              return true\n            }\n            const block = $findMatchingParent(firstDescendant, INTERNAL_$isBlock)\n            block?.selectEnd()\n            event.preventDefault()\n            return true\n          }\n          if (!$isRangeSelection(selection)) {\n            return false\n          }\n\n          // CASE 2: Range selection\n          // Get last selected block\n          const lastPoint = selection.isBackward() ? selection.anchor : selection.focus\n          const lastNode = lastPoint.getNode()\n          const lastSelectedBlock = $findMatchingParent(lastNode, (node) => {\n            return findLaterSiblingBlock(node) !== null\n          })\n          const nextBlock = lastSelectedBlock?.getNextSibling()\n          if (!lastSelectedBlock || nextBlock !== findLaterSiblingBlock(lastSelectedBlock)) {\n            return false\n          }\n\n          if ($isDecoratorNode(nextBlock)) {\n            const nextBlockElement = $getEditor().getElementByKey(nextBlock.getKey())\n            if (nextBlockElement) {\n              $selectDecorator({ element: nextBlockElement, node: nextBlock })\n              event.preventDefault()\n              return true\n            }\n          }\n\n          return false\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n    )\n  }, [editor])\n\n  return null\n}\n\nfunction $getDecoratorByMouseEvent(\n  event: MouseEvent,\n): { element: HTMLElement; node: DecoratorNode<unknown> } | undefined {\n  if (!(event.target instanceof HTMLElement)) {\n    return undefined\n  }\n  const element = event.target.closest('[data-lexical-decorator=\"true\"]')\n  if (!(element instanceof HTMLElement)) {\n    return undefined\n  }\n  const node = $getNearestNodeFromDOMNode(element)\n  return $isDecoratorNode(node) ? { element, node } : undefined\n}\n\nfunction $getSelectedDecorator() {\n  const selection = $getSelection()\n  if (!$isNodeSelection(selection)) {\n    return undefined\n  }\n  const nodes = selection.getNodes()\n  if (nodes.length !== 1) {\n    return undefined\n  }\n  const node = nodes[0]\n  return $isDecoratorNode(node)\n    ? {\n        decorator: node,\n        element: $getEditor().getElementByKey(node.getKey()),\n      }\n    : undefined\n}\n\nfunction $selectDecorator({\n  element,\n  node,\n}: {\n  element: HTMLElement\n  node: DecoratorNode<unknown>\n}) {\n  document.querySelector('.decorator-selected')?.classList.remove('decorator-selected')\n  const selection = $createNodeSelection()\n  selection.add(node.getKey())\n  $setSelection(selection)\n  element.scrollIntoView({ behavior: 'smooth', block: 'nearest' })\n  element.classList.add('decorator-selected')\n}\n\n/**\n * Copied from https://github.com/facebook/lexical/blob/main/packages/lexical/src/LexicalUtils.ts\n *\n * This function returns true for a DecoratorNode that is not inline OR\n * an ElementNode that is:\n * - not a root or shadow root\n * - not inline\n * - can't be empty\n * - has no children or an inline first child\n */\nexport function INTERNAL_$isBlock(node: LexicalNode): node is DecoratorNode<unknown> | ElementNode {\n  if ($isDecoratorNode(node) && !node.isInline()) {\n    return true\n  }\n  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {\n    return false\n  }\n\n  const firstChild = node.getFirstChild()\n  const isLeafElement =\n    firstChild === null ||\n    $isLineBreakNode(firstChild) ||\n    $isTextNode(firstChild) ||\n    firstChild.isInline()\n\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement\n}\n\nfunction findLaterSiblingBlock(node: LexicalNode): LexicalNode | null {\n  let current = node.getNextSibling()\n  while (current !== null) {\n    if (INTERNAL_$isBlock(current)) {\n      return current\n    }\n    current = current.getNextSibling()\n  }\n  return null\n}\n\nfunction findFirstSiblingBlock(node: LexicalNode): LexicalNode | null {\n  let current = node.getPreviousSibling()\n  while (current !== null) {\n    if (INTERNAL_$isBlock(current)) {\n      return current\n    }\n    current = current.getPreviousSibling()\n  }\n  return null\n}\n","'use client'\nimport type { LexicalEditor, LexicalNode, ParagraphNode } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { $createParagraphNode, isHTMLElement } from 'lexical'\nimport * as React from 'react'\nimport { useCallback, useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\n\nimport { useEditorConfigContext } from '../../../config/client/EditorConfigProvider.js'\nimport { Point } from '../../../utils/point.js'\nimport { ENABLE_SLASH_MENU_COMMAND } from '../../SlashMenu/LexicalTypeaheadMenuPlugin/index.js'\nimport { calculateDistanceFromScrollerElem } from '../utils/calculateDistanceFromScrollerElem.js'\nimport { getNodeCloseToPoint } from '../utils/getNodeCloseToPoint.js'\nimport { getTopLevelNodeKeys } from '../utils/getTopLevelNodeKeys.js'\nimport { isOnHandleElement } from '../utils/isOnHandleElement.js'\nimport { setHandlePosition } from '../utils/setHandlePosition.js'\nimport './index.scss'\n\nconst ADD_BLOCK_MENU_CLASSNAME = 'add-block-menu'\n\nlet prevIndex = Infinity\n\nfunction getCurrentIndex(keysLength: number): number {\n  if (keysLength === 0) {\n    return Infinity\n  }\n  if (prevIndex >= 0 && prevIndex < keysLength) {\n    return prevIndex\n  }\n\n  return Math.floor(keysLength / 2)\n}\n\nfunction useAddBlockHandle(\n  editor: LexicalEditor,\n  anchorElem: HTMLElement,\n  isEditable: boolean,\n): React.ReactElement {\n  const scrollerElem = anchorElem.parentElement\n\n  const { editorConfig } = useEditorConfigContext()\n  const blockHandleHorizontalOffset = editorConfig?.admin?.hideGutter ? -24 : 12\n\n  const menuRef = useRef<HTMLButtonElement>(null)\n  const [hoveredElement, setHoveredElement] = useState<{\n    elem: HTMLElement\n    node: LexicalNode\n  } | null>(null)\n\n  useEffect(() => {\n    function onDocumentMouseMove(event: MouseEvent) {\n      const target = event.target\n      if (!isHTMLElement(target)) {\n        return\n      }\n\n      const distanceFromScrollerElem = calculateDistanceFromScrollerElem(\n        scrollerElem,\n        event.pageX,\n        event.pageY,\n        target,\n      )\n\n      if (distanceFromScrollerElem === -1) {\n        setHoveredElement(null)\n        return\n      }\n\n      if (isOnHandleElement(target, ADD_BLOCK_MENU_CLASSNAME)) {\n        return\n      }\n      const topLevelNodeKeys = getTopLevelNodeKeys(editor)\n\n      const {\n        blockElem: _emptyBlockElem,\n        blockNode,\n        foundAtIndex,\n      } = getNodeCloseToPoint({\n        anchorElem,\n        cache_threshold: 0,\n        editor,\n        horizontalOffset: -distanceFromScrollerElem,\n        point: new Point(event.x, event.y),\n        returnEmptyParagraphs: true,\n        startIndex: getCurrentIndex(topLevelNodeKeys.length),\n        useEdgeAsDefault: false,\n      })\n\n      prevIndex = foundAtIndex\n\n      if (!_emptyBlockElem) {\n        return\n      }\n      if (\n        blockNode &&\n        (hoveredElement?.node !== blockNode || hoveredElement?.elem !== _emptyBlockElem)\n      ) {\n        setHoveredElement({\n          elem: _emptyBlockElem,\n          node: blockNode,\n        })\n      }\n    }\n\n    // Since the draggableBlockElem is outside the actual editor, we need to listen to the document\n    // to be able to detect when the mouse is outside the editor and respect a buffer around\n    // the scrollerElem to avoid the draggableBlockElem disappearing too early.\n    document?.addEventListener('mousemove', onDocumentMouseMove)\n\n    return () => {\n      document?.removeEventListener('mousemove', onDocumentMouseMove)\n    }\n  }, [scrollerElem, anchorElem, editor, hoveredElement])\n\n  useEffect(() => {\n    if (menuRef.current && hoveredElement?.node) {\n      setHandlePosition(\n        hoveredElement?.elem,\n        menuRef.current,\n        anchorElem,\n        blockHandleHorizontalOffset,\n      )\n    }\n  }, [anchorElem, hoveredElement, blockHandleHorizontalOffset])\n\n  const handleAddClick = useCallback(\n    (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n      let hoveredElementToUse = hoveredElement\n      if (!hoveredElementToUse?.node) {\n        return\n      }\n\n      // 1. Update hoveredElement.node to a new paragraph node if the hoveredElement.node is not a paragraph node\n      editor.update(() => {\n        // Check if blockNode is an empty text node\n        let isEmptyParagraph = true\n        if (\n          hoveredElementToUse?.node.getType() !== 'paragraph' ||\n          hoveredElementToUse.node.getTextContent() !== ''\n        ) {\n          isEmptyParagraph = false\n        }\n\n        if (!isEmptyParagraph) {\n          const newParagraph = $createParagraphNode()\n          hoveredElementToUse?.node.insertAfter(newParagraph)\n\n          setTimeout(() => {\n            hoveredElementToUse = {\n              elem: editor.getElementByKey(newParagraph.getKey())!,\n              node: newParagraph,\n            }\n            setHoveredElement(hoveredElementToUse)\n          }, 0)\n        }\n      })\n\n      // 2. Focus on the new paragraph node\n      setTimeout(() => {\n        editor.update(() => {\n          editor.focus()\n\n          if (\n            hoveredElementToUse?.node &&\n            'select' in hoveredElementToUse.node &&\n            typeof hoveredElementToUse.node.select === 'function'\n          ) {\n            hoveredElementToUse.node.select()\n          }\n        })\n      }, 1)\n\n      // Make sure this is called AFTER the focusing has been processed by the browser\n      // Otherwise, this won't work\n      setTimeout(() => {\n        editor.dispatchCommand(ENABLE_SLASH_MENU_COMMAND, {\n          node: hoveredElementToUse?.node as ParagraphNode,\n        })\n      }, 2)\n\n      event.stopPropagation()\n      event.preventDefault()\n    },\n    [editor, hoveredElement],\n  )\n\n  return createPortal(\n    <React.Fragment>\n      <button\n        aria-label=\"Add block\"\n        className=\"icon add-block-menu\"\n        onClick={(event) => {\n          handleAddClick(event)\n        }}\n        ref={menuRef}\n        type=\"button\"\n      >\n        <div className={isEditable ? 'icon' : ''} />\n      </button>\n    </React.Fragment>,\n    anchorElem,\n  )\n}\n\nexport function AddBlockHandlePlugin({\n  anchorElem = document.body,\n}: {\n  anchorElem?: HTMLElement\n}): React.ReactElement {\n  const [editor] = useLexicalComposerContext()\n  return useAddBlockHandle(editor, anchorElem, editor._editable)\n}\n","'use client'\n/**\n * Calculate distance between scrollerElem and target if target is not in scrollerElem\n */\nexport const calculateDistanceFromScrollerElem = (\n  scrollerElem: HTMLElement | null,\n  pageX: number,\n  pageY: number,\n  target: HTMLElement,\n  horizontalBuffer: number = 50,\n  verticalBuffer: number = 25,\n): number => {\n  let distanceFromScrollerElem = 0\n  if (scrollerElem && !scrollerElem.contains(target)) {\n    const { bottom, left, right, top } = scrollerElem.getBoundingClientRect()\n\n    const adjustedTop = top + window.scrollY\n    const adjustedBottom = bottom + window.scrollY\n\n    if (\n      pageY < adjustedTop - verticalBuffer ||\n      pageY > adjustedBottom + verticalBuffer ||\n      pageX < left - horizontalBuffer ||\n      pageX > right + horizontalBuffer\n    ) {\n      return -1\n    }\n\n    // This is used to allow the _draggableBlockElem to be found when the mouse is in the\n    // buffer zone around the scrollerElem.\n    if (pageX < left || pageX > right) {\n      distanceFromScrollerElem = pageX < left ? pageX - left : pageX - right\n    }\n  }\n  return distanceFromScrollerElem\n}\n","'use client'\nimport type { LexicalEditor, LexicalNode } from 'lexical'\n\nimport { $getNodeByKey } from 'lexical'\n\nimport { Point } from '../../../utils/point.js'\nimport { Rect } from '../../../utils/rect.js'\nimport { getBoundingClientRectWithoutTransform } from '../DraggableBlockPlugin/getBoundingRectWithoutTransform.js'\nimport { getCollapsedMargins } from '../utils/getCollapsedMargins.js'\nimport { getTopLevelNodeKeys } from '../utils/getTopLevelNodeKeys.js'\n\n// Directions\nconst Downward = 1\nconst Upward = -1\nconst Indeterminate = 0\n\ntype Props = {\n  anchorElem: HTMLElement\n  cache_threshold?: number\n  editor: LexicalEditor\n  /** fuzzy makes the search not exact. If no exact match found, find the closes node instead of returning null */\n  fuzzy?: boolean\n  horizontalOffset?: number\n  point: Point\n  /**\n   * By default, empty paragraphs are not returned. Set this to true to return empty paragraphs. @default false\n   */\n  returnEmptyParagraphs?: boolean\n  /**\n   * The index to start searching from. It can be a considerable performance optimization to start searching from the index of the\n   * previously found node, as the node is likely to be close to the next node.\n   */\n  startIndex?: number\n  useEdgeAsDefault?: boolean\n  verbose?: boolean\n}\n\ntype Output = {\n  blockElem: HTMLElement | null\n  blockNode: LexicalNode | null\n  foundAtIndex: number\n  isFoundNodeEmptyParagraph: boolean\n}\n\nconst cache = {\n  props: null as null | Props,\n  result: null as null | Output,\n}\n\nfunction isPointClose(previous: Point, current: Point, threshold: number = 20): boolean {\n  const dx = previous.x - current.x\n  const dy = previous.y - current.y\n  return dx * dx + dy * dy <= threshold * threshold\n}\n\nexport function getNodeCloseToPoint(props: Props): Output {\n  const {\n    anchorElem,\n    cache_threshold = 20,\n    editor,\n    fuzzy = false,\n    horizontalOffset = 0,\n    point: { x, y },\n    startIndex = 0,\n    useEdgeAsDefault = false,\n  } = props\n\n  // Use cache\n  if (\n    cache_threshold > 0 &&\n    cache.props &&\n    cache.result &&\n    cache.props.fuzzy === props.fuzzy &&\n    cache.props.horizontalOffset === props.horizontalOffset &&\n    cache.props.useEdgeAsDefault === props.useEdgeAsDefault &&\n    isPointClose(cache.props.point, props.point, cache_threshold)\n  ) {\n    return cache.result\n  }\n\n  const anchorElementRect = anchorElem.getBoundingClientRect()\n  const topLevelNodeKeys = getTopLevelNodeKeys(editor)\n\n  const closestBlockElem: {\n    blockElem: HTMLElement | null\n    blockNode: LexicalNode | null\n    distance: number\n    foundAtIndex: number\n    isFoundNodeEmptyParagraph: boolean\n  } = {\n    blockElem: null,\n    blockNode: null,\n    distance: Infinity,\n    foundAtIndex: -1,\n    isFoundNodeEmptyParagraph: false,\n  }\n\n  // Return null if matching block element is the first or last node\n  editor.getEditorState().read(() => {\n    if (useEdgeAsDefault) {\n      const firstNode = editor.getElementByKey(topLevelNodeKeys[0]!)\n      const lastNode = editor.getElementByKey(topLevelNodeKeys[topLevelNodeKeys.length - 1]!)\n\n      if (firstNode && lastNode) {\n        const [firstNodeRect, lastNodeRect] = [\n          getBoundingClientRectWithoutTransform(firstNode),\n          getBoundingClientRectWithoutTransform(lastNode),\n        ]\n\n        if (y < firstNodeRect.top) {\n          closestBlockElem.blockElem = firstNode\n          closestBlockElem.distance = firstNodeRect.top - y\n          closestBlockElem.blockNode = $getNodeByKey(topLevelNodeKeys[0]!)\n          closestBlockElem.foundAtIndex = 0\n        } else if (y > lastNodeRect.bottom) {\n          closestBlockElem.distance = y - lastNodeRect.bottom\n          closestBlockElem.blockNode = $getNodeByKey(topLevelNodeKeys[topLevelNodeKeys.length - 1]!)\n          closestBlockElem.blockElem = lastNode\n          closestBlockElem.foundAtIndex = topLevelNodeKeys.length - 1\n        }\n\n        if (closestBlockElem?.blockElem) {\n          return {\n            blockElem: null,\n            isFoundNodeEmptyParagraph: false,\n          } as Output\n        }\n      }\n    }\n\n    // Find matching block element\n    let index = startIndex\n    let direction = Indeterminate\n\n    while (index >= 0 && index < topLevelNodeKeys.length) {\n      const key = topLevelNodeKeys[index]!\n      const elem = editor.getElementByKey(key)\n      if (elem === null) {\n        break\n      }\n      const point = new Point(x + horizontalOffset, y)\n      //const domRect = Rect.fromDOM(elem)\n      // Do not consider transform of blocks when calculating distance\n      const domRect = Rect.fromDOMRect(getBoundingClientRectWithoutTransform(elem))\n\n      const { marginBottom, marginTop } = getCollapsedMargins(elem)\n\n      const rect = domRect.generateNewRect({\n        bottom: domRect.bottom + marginBottom,\n        left: anchorElementRect.left,\n        right: anchorElementRect.right,\n        top: domRect.top - marginTop,\n      })\n\n      const { distance, isOnBottomSide, isOnTopSide } = rect.distanceFromPoint(point)\n\n      if (distance === 0) {\n        closestBlockElem.blockElem = elem\n        closestBlockElem.blockNode = $getNodeByKey(key)\n        closestBlockElem.foundAtIndex = index\n        closestBlockElem.distance = distance\n\n        // Check if blockNode is an empty text node\n        if (\n          closestBlockElem.blockNode &&\n          closestBlockElem.blockNode.getType() === 'paragraph' &&\n          closestBlockElem.blockNode.getTextContent() === ''\n        ) {\n          if (!fuzzy && !props.returnEmptyParagraphs) {\n            closestBlockElem.blockElem = null\n            closestBlockElem.blockNode = null\n          }\n\n          closestBlockElem.isFoundNodeEmptyParagraph = true\n        }\n        break\n      } else if (fuzzy) {\n        if (distance < closestBlockElem.distance) {\n          closestBlockElem.blockElem = elem\n          closestBlockElem.blockNode = $getNodeByKey(key)\n          closestBlockElem.distance = distance\n          closestBlockElem.foundAtIndex = index\n        }\n      }\n\n      if (direction === Indeterminate) {\n        if (isOnTopSide) {\n          direction = Upward\n        } else if (isOnBottomSide) {\n          direction = Downward\n        } else {\n          // stop search block element\n          direction = Infinity\n        }\n      }\n\n      index += direction\n    }\n  })\n\n  // Store in cache before returning\n  cache.props = props\n  cache.result = {\n    blockElem: closestBlockElem.blockElem,\n    blockNode: closestBlockElem.blockNode,\n    foundAtIndex: closestBlockElem.foundAtIndex,\n    isFoundNodeEmptyParagraph: closestBlockElem.isFoundNodeEmptyParagraph,\n  }\n\n  return {\n    blockElem: closestBlockElem.blockElem,\n    blockNode: closestBlockElem.blockNode,\n    foundAtIndex: closestBlockElem.foundAtIndex,\n    isFoundNodeEmptyParagraph: closestBlockElem.isFoundNodeEmptyParagraph,\n  }\n}\n","'use client'\nexport function getBoundingClientRectWithoutTransform(elem: HTMLElement): DOMRect {\n  const rect = elem.getBoundingClientRect()\n\n  // Extract the translation value from the transform style\n  const transformValue = getComputedStyle(elem).getPropertyValue('transform')\n  if (!transformValue || transformValue === 'none') {\n    return rect\n  }\n\n  const lastNumberOfTransformValue = transformValue.split(',').pop()\n  rect.y = rect.y - Number(lastNumberOfTransformValue?.replace(')', ''))\n\n  // Return the original bounding rect if no translation is applied\n  return rect\n}\n","'use client'\nexport function getCollapsedMargins(elem: HTMLElement): {\n  marginBottom: number\n  marginTop: number\n} {\n  const getMargin = (element: Element | null, margin: 'marginBottom' | 'marginTop'): number =>\n    element ? parseFloat(window.getComputedStyle(element)[margin]) : 0\n\n  const { marginBottom, marginTop } = window.getComputedStyle(elem)\n  const prevElemSiblingMarginBottom = getMargin(elem.previousElementSibling, 'marginBottom')\n  const nextElemSiblingMarginTop = getMargin(elem.nextElementSibling, 'marginTop')\n  const collapsedTopMargin = Math.max(parseFloat(marginTop), prevElemSiblingMarginBottom)\n  const collapsedBottomMargin = Math.max(parseFloat(marginBottom), nextElemSiblingMarginTop)\n\n  return { marginBottom: collapsedBottomMargin, marginTop: collapsedTopMargin }\n}\n","'use client'\nimport type { LexicalEditor } from 'lexical'\n\nimport { $getRoot } from 'lexical'\n\nexport function getTopLevelNodeKeys(editor: LexicalEditor): string[] {\n  return editor.getEditorState().read(() => $getRoot().getChildrenKeys())\n}\n","'use client'\nexport function isOnHandleElement(element: HTMLElement, handleElementClassName: string): boolean {\n  return !!element.closest(`.${handleElementClassName}`)\n}\n","'use client'\nconst replacedElements = [\n  'IMG',\n  'INPUT',\n  'TEXTAREA',\n  'SELECT',\n  'BUTTON',\n  'VIDEO',\n  'OBJECT',\n  'EMBED',\n  'IFRAME',\n  'HR',\n]\n\n/**\n * From ChatGPT, only that verified it works for HR elements.\n *\n * HTML Elements can have CSS lineHeight applied to them, but it doesn't always affect the visual layout.\n * This function checks if the line-height property has an effect on the element's layout.\n * @param htmlElem\n */\nexport function doesLineHeightAffectElement(htmlElem: HTMLElement) {\n  if (!htmlElem) {\n    return false\n  }\n\n  // Check for replaced elements, elements that typically don't support line-height adjustments,\n  // and elements without visible content\n\n  if (\n    replacedElements.includes(htmlElem.tagName) ||\n    htmlElem.offsetHeight === 0 ||\n    htmlElem.offsetWidth === 0\n  ) {\n    return false\n  }\n\n  // Check for specific CSS properties that negate line-height's visual effects\n  const style = window.getComputedStyle(htmlElem)\n  if (\n    style.display === 'table-cell' ||\n    style.position === 'absolute' ||\n    style.visibility === 'hidden' ||\n    style.opacity === '0'\n  ) {\n    return false\n  }\n\n  // This is a basic check, and there can be more complex scenarios where line-height doesn't have an effect.\n  return true\n}\n","'use client'\nimport { doesLineHeightAffectElement } from './doesLineHeightAffectElement.js'\n\nexport function setHandlePosition(\n  targetElem: HTMLElement | null,\n  handleElem: HTMLElement,\n  anchorElem: HTMLElement,\n  leftOffset: number = 0, // SPACE\n) {\n  if (!targetElem) {\n    handleElem.style.opacity = '0'\n    handleElem.style.transform = 'translate(-10000px, -10000px)'\n    return\n  }\n\n  const targetRect = targetElem.getBoundingClientRect()\n  const targetStyle = window.getComputedStyle(targetElem)\n  const floatingElemRect = handleElem.getBoundingClientRect()\n  const anchorElementRect = anchorElem.getBoundingClientRect()\n\n  let top: number\n\n  const isBlockStyle = [\n    'LexicalEditorTheme__block',\n    'LexicalEditorTheme__upload',\n    'LexicalEditorTheme__relationship',\n  ].some(\n    (classes) =>\n      targetElem.classList.contains(classes) ||\n      targetElem.firstElementChild?.classList.contains(classes),\n  )\n\n  if (!isBlockStyle) {\n    // No need to let line height affect the re-positioning of the floating element if line height has no\n    // visual effect on the element. Otherwise, the floating element will be positioned incorrectly.\n    const actualLineHeight = doesLineHeightAffectElement(targetElem)\n      ? parseInt(targetStyle.lineHeight, 10)\n      : 0\n\n    top = targetRect.top + (actualLineHeight - floatingElemRect.height) / 2 - anchorElementRect.top\n  } else {\n    top = targetRect.top + 8 - anchorElementRect.top\n  }\n\n  const left = leftOffset\n\n  handleElem.style.opacity = '1'\n  handleElem.style.transform = `translate(${left}px, ${top}px)`\n}\n","'use client'\nimport type { LexicalEditor } from 'lexical'\nimport type { DragEvent as ReactDragEvent } from 'react'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { eventFiles } from '@lexical/rich-text'\nimport { $getNearestNodeFromDOMNode, $getNodeByKey, isHTMLElement } from 'lexical'\nimport * as React from 'react'\nimport { useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\n\nimport { useEditorConfigContext } from '../../../config/client/EditorConfigProvider.js'\nimport { Point } from '../../../utils/point.js'\nimport { calculateDistanceFromScrollerElem } from '../utils/calculateDistanceFromScrollerElem.js'\nimport { getNodeCloseToPoint } from '../utils/getNodeCloseToPoint.js'\nimport { getTopLevelNodeKeys } from '../utils/getTopLevelNodeKeys.js'\nimport { isOnHandleElement } from '../utils/isOnHandleElement.js'\nimport { setHandlePosition } from '../utils/setHandlePosition.js'\nimport { getBoundingClientRectWithoutTransform } from './getBoundingRectWithoutTransform.js'\nimport './index.scss'\nimport { setTargetLine } from './setTargetLine.js'\n\nconst DRAGGABLE_BLOCK_MENU_CLASSNAME = 'draggable-block-menu'\nconst DRAG_DATA_FORMAT = 'application/x-lexical-drag-block'\n\nlet prevIndex = Infinity\n\nfunction getCurrentIndex(keysLength: number): number {\n  if (keysLength === 0) {\n    return Infinity\n  }\n  if (prevIndex >= 0 && prevIndex < keysLength) {\n    return prevIndex\n  }\n\n  return Math.floor(keysLength / 2)\n}\n\nfunction setDragImage(dataTransfer: DataTransfer, draggableBlockElem: HTMLElement) {\n  const { transform } = draggableBlockElem.style\n\n  // Remove dragImage borders\n  dataTransfer.setDragImage(draggableBlockElem, 0, 0)\n\n  setTimeout(() => {\n    draggableBlockElem.style.transform = transform\n  })\n}\n\nfunction hideTargetLine(\n  targetLineElem: HTMLElement | null,\n  lastTargetBlockElem: HTMLElement | null,\n) {\n  if (targetLineElem) {\n    targetLineElem.style.opacity = '0'\n  }\n  if (lastTargetBlockElem) {\n    lastTargetBlockElem.style.opacity = ''\n    // Delete marginBottom and marginTop values we set\n    lastTargetBlockElem.style.marginBottom = ''\n    lastTargetBlockElem.style.marginTop = ''\n    //lastTargetBlock.style.border = 'none'\n  }\n}\n\nfunction useDraggableBlockMenu(\n  editor: LexicalEditor,\n  anchorElem: HTMLElement,\n  isEditable: boolean,\n): React.ReactElement {\n  const scrollerElem = anchorElem.parentElement\n\n  const menuRef = useRef<HTMLButtonElement>(null)\n  const targetLineRef = useRef<HTMLDivElement>(null)\n  const debugHighlightRef = useRef<HTMLDivElement>(null)\n  const isDraggingBlockRef = useRef<boolean>(false)\n  const [draggableBlockElem, setDraggableBlockElem] = useState<HTMLElement | null>(null)\n  const [lastTargetBlock, setLastTargetBlock] = useState<{\n    boundingBox?: DOMRect\n    elem: HTMLElement | null\n    isBelow: boolean\n  } | null>(null)\n\n  const { editorConfig } = useEditorConfigContext()\n\n  const blockHandleHorizontalOffset = editorConfig?.admin?.hideGutter ? -44 : -8\n\n  useEffect(() => {\n    /**\n     * Handles positioning of the drag handle\n     */\n    function onDocumentMouseMove(event: MouseEvent) {\n      const target = event.target\n      if (!isHTMLElement(target)) {\n        return\n      }\n\n      const distanceFromScrollerElem = calculateDistanceFromScrollerElem(\n        scrollerElem,\n        event.pageX,\n        event.pageY,\n        target,\n      )\n      if (distanceFromScrollerElem === -1) {\n        setDraggableBlockElem(null)\n        return\n      }\n\n      if (isOnHandleElement(target, DRAGGABLE_BLOCK_MENU_CLASSNAME)) {\n        return\n      }\n\n      const topLevelNodeKeys = getTopLevelNodeKeys(editor)\n\n      const {\n        blockElem: _draggableBlockElem,\n        foundAtIndex,\n        isFoundNodeEmptyParagraph,\n      } = getNodeCloseToPoint({\n        anchorElem,\n        cache_threshold: 0,\n        editor,\n        horizontalOffset: -distanceFromScrollerElem,\n        point: new Point(event.x, event.y),\n        startIndex: getCurrentIndex(topLevelNodeKeys.length),\n        useEdgeAsDefault: false,\n        verbose: false,\n      })\n\n      prevIndex = foundAtIndex\n\n      //if (DEBUG && _draggableBlockElem) {\n      //targetBlockElem.style.border = '3px solid red'\n      // highlightElemOriginalPosition(debugHighlightRef, _draggableBlockElem, anchorElem)\n      //}\n\n      if (!_draggableBlockElem && !isFoundNodeEmptyParagraph) {\n        return\n      }\n\n      if (draggableBlockElem !== _draggableBlockElem) {\n        setDraggableBlockElem(_draggableBlockElem)\n      }\n    }\n\n    // Since the draggableBlockElem is outside the actual editor, we need to listen to the document\n    // to be able to detect when the mouse is outside the editor and respect a buffer around\n    // the scrollerElem to avoid the draggableBlockElem disappearing too early.\n    document?.addEventListener('mousemove', onDocumentMouseMove)\n\n    return () => {\n      document?.removeEventListener('mousemove', onDocumentMouseMove)\n    }\n  }, [scrollerElem, anchorElem, editor, draggableBlockElem])\n\n  useEffect(() => {\n    if (menuRef.current) {\n      setHandlePosition(\n        draggableBlockElem,\n        menuRef.current,\n        anchorElem,\n        blockHandleHorizontalOffset,\n      )\n    }\n  }, [anchorElem, draggableBlockElem, blockHandleHorizontalOffset])\n\n  useEffect(() => {\n    function onDragover(event: DragEvent): boolean {\n      if (!isDraggingBlockRef.current) {\n        return false\n      }\n      const [isFileTransfer] = eventFiles(event)\n      if (isFileTransfer) {\n        return false\n      }\n\n      const { pageY, target } = event\n      if (!isHTMLElement(target)) {\n        return false\n      }\n\n      const distanceFromScrollerElem = calculateDistanceFromScrollerElem(\n        scrollerElem,\n        event.pageX,\n        event.pageY,\n        target,\n        100,\n        50,\n      )\n\n      const topLevelNodeKeys = getTopLevelNodeKeys(editor)\n\n      const {\n        blockElem: targetBlockElem,\n        foundAtIndex,\n        isFoundNodeEmptyParagraph,\n      } = getNodeCloseToPoint({\n        anchorElem,\n        editor,\n        fuzzy: true,\n        horizontalOffset: -distanceFromScrollerElem,\n        point: new Point(event.x, event.y),\n        startIndex: getCurrentIndex(topLevelNodeKeys.length),\n        useEdgeAsDefault: true,\n        verbose: true,\n      })\n\n      prevIndex = foundAtIndex\n\n      const targetLineElem = targetLineRef.current\n      // targetBlockElem === null shouldn't happen\n      if (targetBlockElem === null || targetLineElem === null) {\n        return false\n      }\n\n      if (draggableBlockElem !== targetBlockElem) {\n        const { isBelow, willStayInSamePosition } = setTargetLine(\n          editorConfig?.admin?.hideGutter ? '0px' : '3rem',\n          blockHandleHorizontalOffset +\n            (editorConfig?.admin?.hideGutter\n              ? (menuRef?.current?.getBoundingClientRect()?.width ?? 0)\n              : -(menuRef?.current?.getBoundingClientRect()?.width ?? 0)),\n          targetLineElem,\n          targetBlockElem,\n          lastTargetBlock!,\n          pageY,\n          anchorElem,\n          event,\n          debugHighlightRef,\n          isFoundNodeEmptyParagraph,\n        )\n\n        // Prevent default event to be able to trigger onDrop events\n        // Calling preventDefault() adds the green plus icon to the cursor,\n        // indicating that the drop is allowed.\n        event.preventDefault()\n\n        if (!willStayInSamePosition) {\n          setLastTargetBlock({\n            boundingBox: targetBlockElem.getBoundingClientRect(),\n            elem: targetBlockElem,\n            isBelow,\n          })\n        }\n      } else if (lastTargetBlock?.elem) {\n        hideTargetLine(targetLineElem, lastTargetBlock.elem)\n        setLastTargetBlock({\n          boundingBox: targetBlockElem.getBoundingClientRect(),\n          elem: targetBlockElem,\n          isBelow: false,\n        })\n      }\n\n      return true\n    }\n\n    function onDrop(event: DragEvent): boolean {\n      if (!isDraggingBlockRef.current) {\n        return false\n      }\n      const [isFileTransfer] = eventFiles(event)\n      if (isFileTransfer) {\n        return false\n      }\n      const { dataTransfer, pageY, target } = event\n      const dragData = dataTransfer?.getData(DRAG_DATA_FORMAT) || ''\n\n      editor.update(() => {\n        const draggedNode = $getNodeByKey(dragData)\n        if (!draggedNode) {\n          return false\n        }\n        if (!isHTMLElement(target)) {\n          return false\n        }\n        const distanceFromScrollerElem = calculateDistanceFromScrollerElem(\n          scrollerElem,\n          event.pageX,\n          event.pageY,\n          target,\n          100,\n          50,\n        )\n\n        const { blockElem: targetBlockElem, isFoundNodeEmptyParagraph } = getNodeCloseToPoint({\n          anchorElem,\n          editor,\n          fuzzy: true,\n          horizontalOffset: -distanceFromScrollerElem,\n          point: new Point(event.x, event.y),\n          useEdgeAsDefault: true,\n        })\n\n        if (!targetBlockElem) {\n          return false\n        }\n        const targetNode = $getNearestNodeFromDOMNode(targetBlockElem)\n        if (!targetNode) {\n          return false\n        }\n        if (targetNode === draggedNode) {\n          return true\n        }\n\n        const { height: targetBlockElemHeight, top: targetBlockElemTop } =\n          getBoundingClientRectWithoutTransform(targetBlockElem)\n\n        const mouseY = pageY\n        const isBelow = mouseY >= targetBlockElemTop + targetBlockElemHeight / 2 + window.scrollY\n\n        if (!isFoundNodeEmptyParagraph) {\n          if (isBelow) {\n            // below targetBlockElem\n            targetNode.insertAfter(draggedNode)\n          } else {\n            // above targetBlockElem\n            targetNode.insertBefore(draggedNode)\n          }\n        } else {\n          //\n          targetNode.insertBefore(draggedNode)\n          targetNode.remove()\n        }\n\n        /*\n        if (pageY >= targetBlockElemTop + targetBlockElemHeight / 2) {\n          targetNode.insertAfter(draggedNode)\n        } else {\n          targetNode.insertBefore(draggedNode)\n        }*/\n        if (draggableBlockElem !== null) {\n          setDraggableBlockElem(null)\n        }\n\n        // find all previous elements with lexical-block-highlighter class and remove them\n        const allPrevHighlighters = document.querySelectorAll('.lexical-block-highlighter')\n        allPrevHighlighters.forEach((highlighter) => {\n          highlighter.remove()\n        })\n\n        const newInsertedElem = editor.getElementByKey(draggedNode.getKey())\n        setTimeout(() => {\n          // add new temp html element to newInsertedElem with the same height and width and the class block-selected\n          // to highlight the new inserted element\n          const newInsertedElemRect = newInsertedElem?.getBoundingClientRect()\n          if (!newInsertedElemRect) {\n            return\n          }\n          const highlightElem = document.createElement('div')\n          highlightElem.className = 'lexical-block-highlighter'\n\n          highlightElem.style.backgroundColor = 'var(--theme-elevation-1000'\n          highlightElem.style.transition = 'opacity 0.5s ease-in-out'\n          highlightElem.style.zIndex = '1'\n          highlightElem.style.pointerEvents = 'none'\n          highlightElem.style.boxSizing = 'border-box'\n          highlightElem.style.borderRadius = '4px'\n          highlightElem.style.position = 'absolute'\n          document.body.appendChild(highlightElem)\n\n          highlightElem.style.opacity = '0.1'\n\n          highlightElem.style.height = `${newInsertedElemRect.height + 8}px`\n          highlightElem.style.width = `${newInsertedElemRect.width + 8}px`\n          highlightElem.style.top = `${newInsertedElemRect.top + window.scrollY - 4}px`\n          highlightElem.style.left = `${newInsertedElemRect.left - 4}px`\n\n          setTimeout(() => {\n            highlightElem.style.opacity = '0'\n            setTimeout(() => {\n              highlightElem.remove()\n            }, 500)\n          }, 1000)\n        }, 120)\n      })\n\n      return true\n    }\n\n    // register onDragover event listeners:\n    document.addEventListener('dragover', onDragover)\n    // register onDrop event listeners:\n    document.addEventListener('drop', onDrop)\n\n    return () => {\n      document.removeEventListener('dragover', onDragover)\n      document.removeEventListener('drop', onDrop)\n    }\n  }, [\n    scrollerElem,\n    blockHandleHorizontalOffset,\n    anchorElem,\n    editor,\n    lastTargetBlock,\n    draggableBlockElem,\n    editorConfig?.admin?.hideGutter,\n  ])\n\n  function onDragStart(event: ReactDragEvent<HTMLButtonElement>): void {\n    const dataTransfer = event.dataTransfer\n    if (!dataTransfer || !draggableBlockElem) {\n      return\n    }\n    setDragImage(dataTransfer, draggableBlockElem)\n    let nodeKey = ''\n    editor.update(() => {\n      const node = $getNearestNodeFromDOMNode(draggableBlockElem)\n      if (node) {\n        nodeKey = node.getKey()\n      }\n    })\n    isDraggingBlockRef.current = true\n    dataTransfer.setData(DRAG_DATA_FORMAT, nodeKey)\n  }\n\n  function onDragEnd(): void {\n    isDraggingBlockRef.current = false\n    if (lastTargetBlock?.elem) {\n      hideTargetLine(targetLineRef.current, lastTargetBlock?.elem)\n    }\n  }\n\n  return createPortal(\n    <React.Fragment>\n      <button\n        aria-label=\"Drag to move\"\n        className=\"icon draggable-block-menu\"\n        draggable\n        onDragEnd={onDragEnd}\n        onDragStart={onDragStart}\n        ref={menuRef}\n        type=\"button\"\n      >\n        <div className={isEditable ? 'icon' : ''} />\n      </button>\n      <div className=\"draggable-block-target-line\" ref={targetLineRef} />\n      <div className=\"debug-highlight\" ref={debugHighlightRef} />\n    </React.Fragment>,\n    anchorElem,\n  )\n}\n\nexport function DraggableBlockPlugin({\n  anchorElem = document.body,\n}: {\n  anchorElem?: HTMLElement\n}): React.ReactElement {\n  const [editor] = useLexicalComposerContext()\n  return useDraggableBlockMenu(editor, anchorElem, editor._editable)\n}\n","'use client'\nimport { getCollapsedMargins } from '../utils/getCollapsedMargins.js'\nconst TARGET_LINE_HALF_HEIGHT = 0\nconst TEXT_BOX_HORIZONTAL_PADDING = -24\nconst DEBUG = false\n\nlet animationTimer = 0\n\nexport function setTargetLine(\n  offsetWidth: string,\n  offsetLeft: number,\n  targetLineElem: HTMLElement,\n  targetBlockElem: HTMLElement,\n  lastTargetBlock: {\n    boundingBox?: DOMRect\n    elem: HTMLElement | null\n    isBelow: boolean\n  },\n  mouseY: number,\n  anchorElem: HTMLElement,\n  event: DragEvent,\n  debugHighlightRef: React.RefObject<HTMLDivElement | null>,\n  isFoundNodeEmptyParagraph: boolean = false,\n) {\n  const { height: targetBlockElemHeight, top: targetBlockElemTop } =\n    targetBlockElem.getBoundingClientRect() // used to be getBoundingClientRectWithoutTransform. Not sure what's better, but the normal getBoundingClientRect seems to work fine\n  const { top: anchorTop, width: anchorWidth } = anchorElem.getBoundingClientRect()\n\n  const { marginBottom, marginTop } = getCollapsedMargins(targetBlockElem)\n  let lineTop = targetBlockElemTop\n\n  const isBelow = mouseY >= targetBlockElemTop + targetBlockElemHeight / 2 + window.scrollY\n\n  let willStayInSamePosition = false\n\n  /**\n   * Do not run any transform or changes if the actual new line position would be the same (even if it's now inserted BEFORE rather than AFTER - position would still be the same)\n   * This prevents unnecessary flickering.\n   *\n   * We still need to let it run even if the position (IGNORING the transform) would not change, as the transform animation is not finished yet. This is what animationTimer does. Otherwise, the positioning will be inaccurate\n   */\n  if (lastTargetBlock?.elem) {\n    if (targetBlockElem !== lastTargetBlock?.elem) {\n      if (\n        isBelow &&\n        lastTargetBlock?.elem &&\n        lastTargetBlock?.elem === targetBlockElem.nextElementSibling\n      ) {\n        animationTimer++\n\n        if (animationTimer < 200) {\n          willStayInSamePosition = true\n        }\n      } else if (\n        !isBelow &&\n        lastTargetBlock?.elem &&\n        lastTargetBlock?.elem === targetBlockElem.previousElementSibling\n      ) {\n        animationTimer++\n        if (animationTimer < 200) {\n          willStayInSamePosition = true\n        }\n      }\n    } else {\n      animationTimer++\n\n      const lastBoundingBoxPosition = lastTargetBlock?.boundingBox?.y\n      const currentBoundingBoxPosition = targetBlockElem.getBoundingClientRect().y\n\n      if (\n        (isBelow === lastTargetBlock?.isBelow &&\n          lastBoundingBoxPosition === currentBoundingBoxPosition) ||\n        animationTimer < 200\n      ) {\n        willStayInSamePosition = false\n      }\n    }\n  }\n  if (willStayInSamePosition) {\n    return {\n      isBelow,\n      willStayInSamePosition,\n    }\n  }\n\n  /**\n   * Paragraphs need no isBelow/above handling,\n   */\n  if (!isFoundNodeEmptyParagraph) {\n    //if (!isFoundNodeEmptyParagraph) {\n    if (isBelow) {\n      // below targetBlockElem\n      lineTop += targetBlockElemHeight + marginBottom / 2\n    } else {\n      // above targetBlockElem\n      lineTop -= marginTop / 2\n    }\n  } else {\n    lineTop += targetBlockElemHeight / 2\n  }\n\n  let targetElemTranslate2 = 0\n\n  if (!isFoundNodeEmptyParagraph) {\n    if (isBelow) {\n      targetElemTranslate2 = -TARGET_LINE_HALF_HEIGHT\n    } else {\n      targetElemTranslate2 = TARGET_LINE_HALF_HEIGHT\n    }\n  }\n\n  const top = lineTop - anchorTop + targetElemTranslate2\n\n  const left = TEXT_BOX_HORIZONTAL_PADDING - offsetLeft\n\n  targetLineElem.style.width = `calc(${anchorWidth}px - ${offsetWidth})`\n  targetLineElem.style.opacity = '.8'\n\n  // if (DEBUG) {\n  //   //targetBlockElem.style.border = '3px solid red'\n  //   highlightElemOriginalPosition(debugHighlightRef, targetBlockElem, anchorElem)\n  // }\n\n  targetLineElem.style.transform = `translate(${left}px, calc(${top}px - ${'2px'}))`\n\n  /**\n   * Properly reset previous targetBlockElem styles\n   */\n  if (lastTargetBlock?.elem) {\n    lastTargetBlock.elem.style.opacity = ''\n\n    if (lastTargetBlock?.elem === targetBlockElem) {\n      if (isBelow) {\n        lastTargetBlock.elem.style.marginTop = ''\n      } else {\n        lastTargetBlock.elem.style.marginBottom = ''\n      }\n    } else {\n      lastTargetBlock.elem.style.marginBottom = ''\n      lastTargetBlock.elem.style.marginTop = ''\n    }\n  }\n\n  animationTimer = 0\n  return {\n    isBelow,\n    willStayInSamePosition,\n  }\n}\n","/* eslint-disable jsx-a11y/click-events-have-key-events */\n'use client'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { $createParagraphNode, $getRoot } from 'lexical'\nimport React from 'react'\n\nimport './index.scss'\nimport { useEditorConfigContext } from '../../config/client/EditorConfigProvider.js'\nconst baseClass = 'insert-paragraph-at-end'\n\nexport const InsertParagraphAtEndPlugin: React.FC = () => {\n  const [editor] = useLexicalComposerContext()\n  const { editorConfig } = useEditorConfigContext()\n\n  if (editorConfig?.admin?.hideInsertParagraphAtEnd) {\n    return null\n  }\n\n  const onClick = () => {\n    editor.update(() => {\n      const paragraphNode = $createParagraphNode()\n      $getRoot().append(paragraphNode)\n      paragraphNode.select()\n    })\n  }\n\n  return (\n    // TODO: convert to button\n    <div\n      aria-label=\"Insert Paragraph\"\n      className={baseClass}\n      onClick={onClick}\n      role=\"button\"\n      tabIndex={0}\n    >\n      <div className={`${baseClass}-inside`}>\n        <span>+</span>\n      </div>\n    </div>\n  )\n}\n","'use client'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport * as React from 'react'\n\nimport { registerMarkdownShortcuts } from '../../../packages/@lexical/markdown/MarkdownShortcuts.js'\nimport { useEditorConfigContext } from '../../config/client/EditorConfigProvider.js'\n\nexport const MarkdownShortcutPlugin: React.FC = () => {\n  const { editorConfig } = useEditorConfigContext()\n  const [editor] = useLexicalComposerContext()\n\n  React.useEffect(() => {\n    return registerMarkdownShortcuts(editor, editorConfig.features.markdownTransformers ?? [])\n  }, [editor, editorConfig.features.markdownTransformers])\n\n  return null\n}\n","import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { $getSelection, $isRangeSelection, RootNode } from 'lexical'\nimport { useEffect } from 'react'\n\n/**\n * By default, Lexical throws an error if the selection ends in deleted nodes.\n * This is very aggressive considering there are reasons why this can happen\n * outside of Payload's control (custom features or conflicting features, for example).\n * In the case of selections on nonexistent nodes, this plugin moves the selection to\n * the end of the editor and displays a warning instead of an error.\n */\nexport function NormalizeSelectionPlugin() {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    return editor.registerNodeTransform(RootNode, (root) => {\n      const selection = $getSelection()\n      if ($isRangeSelection(selection)) {\n        const anchorNode = selection.anchor.getNode()\n        const focusNode = selection.focus.getNode()\n        if (!anchorNode.isAttached() || !focusNode.isAttached()) {\n          root.selectEnd()\n          // eslint-disable-next-line no-console\n          console.warn(\n            'updateEditor: selection has been moved to the end of the editor because the previously selected nodes have been removed and ' +\n              \"selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.\",\n          )\n        }\n      }\n      return false\n    })\n  }, [editor])\n\n  return null\n}\n","import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { $getSelection, COMMAND_PRIORITY_LOW, SELECT_ALL_COMMAND } from 'lexical'\nimport { useEffect } from 'react'\n\n/**\n * Allows to select inputs with `ctrl+a` or `cmd+a`.\n * Required because Lexical preventDefault the event.\n * see: https://github.com/payloadcms/payload/issues/6871\n */\nexport function SelectAllPlugin() {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    return editor.registerCommand(\n      SELECT_ALL_COMMAND,\n      () => {\n        const selection = $getSelection()\n        if (selection) {\n          return false\n        }\n        const activeElement = document.activeElement\n        if (activeElement instanceof HTMLInputElement) {\n          activeElement.select()\n        }\n        return true\n      },\n      COMMAND_PRIORITY_LOW,\n    )\n  }, [editor])\n\n  return null\n}\n","'use client'\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { useTranslation } from '@payloadcms/ui'\nimport { useCallback, useMemo, useState } from 'react'\nimport * as React from 'react'\nimport * as ReactDOM from 'react-dom'\n\nimport type {\n  SlashMenuGroup,\n  SlashMenuGroupInternal,\n  SlashMenuItemInternal,\n  SlashMenuItem as SlashMenuItemType,\n} from './LexicalTypeaheadMenuPlugin/types.js'\n\nimport { useEditorConfigContext } from '../../config/client/EditorConfigProvider.js'\nimport './index.scss'\nimport { LexicalTypeaheadMenuPlugin } from './LexicalTypeaheadMenuPlugin/index.js'\nimport { useMenuTriggerMatch } from './useMenuTriggerMatch.js'\n\nconst baseClass = 'slash-menu-popup'\n\nfunction SlashMenuItem({\n  isSelected,\n  item,\n  onClick,\n  onMouseEnter,\n  ref,\n}: {\n  index: number\n  isSelected: boolean\n  item: SlashMenuItemInternal\n  onClick: () => void\n  onMouseEnter: () => void\n  ref?: React.Ref<HTMLButtonElement>\n}) {\n  const {\n    fieldProps: { featureClientSchemaMap, schemaPath },\n  } = useEditorConfigContext()\n\n  const { i18n } = useTranslation<{}, string>()\n\n  let className = `${baseClass}__item ${baseClass}__item-${item.key}`\n  if (isSelected) {\n    className += ` ${baseClass}__item--selected`\n  }\n\n  let title = item.key\n  if (item.label) {\n    title =\n      typeof item.label === 'function'\n        ? item.label({ featureClientSchemaMap, i18n, schemaPath })\n        : item.label\n  }\n  // Crop title to max. 25 characters\n  if (title.length > 25) {\n    title = title.substring(0, 25) + '...'\n  }\n\n  return (\n    <button\n      aria-selected={isSelected}\n      className={className}\n      id={baseClass + '__item-' + item.key}\n      key={item.key}\n      onClick={onClick}\n      onMouseEnter={onMouseEnter}\n      ref={ref}\n      role=\"option\"\n      tabIndex={-1}\n      type=\"button\"\n    >\n      {item?.Icon && <item.Icon />}\n\n      <span className={`${baseClass}__item-text`}>{title}</span>\n    </button>\n  )\n}\n\nexport function SlashMenuPlugin({\n  anchorElem = document.body,\n}: {\n  anchorElem?: HTMLElement\n}): React.ReactElement {\n  const [editor] = useLexicalComposerContext()\n  const [queryString, setQueryString] = useState<null | string>(null)\n  const { editorConfig } = useEditorConfigContext()\n  const { i18n } = useTranslation<{}, string>()\n  const {\n    fieldProps: { featureClientSchemaMap, schemaPath },\n  } = useEditorConfigContext()\n\n  const checkForTriggerMatch = useMenuTriggerMatch('/', {\n    minLength: 0,\n  })\n\n  const getDynamicItems = useCallback(() => {\n    let groupWithItems: Array<SlashMenuGroup> = []\n\n    for (const dynamicItem of editorConfig.features.slashMenu.dynamicGroups) {\n      if (queryString) {\n        const dynamicGroupWithItems = dynamicItem({\n          editor,\n          queryString,\n        })\n        groupWithItems = groupWithItems.concat(dynamicGroupWithItems)\n      }\n    }\n\n    return groupWithItems\n  }, [editor, queryString, editorConfig?.features])\n\n  const groups: SlashMenuGroup[] = useMemo(() => {\n    let groupsWithItems: SlashMenuGroup[] = []\n    for (const groupWithItem of editorConfig?.features.slashMenu.groups ?? []) {\n      groupsWithItems.push(groupWithItem)\n    }\n\n    if (queryString) {\n      // Filter current groups first\n      // @ts-expect-error - TODO: fix this\n      groupsWithItems = groupsWithItems.map((group) => {\n        const filteredItems = group.items.filter((item) => {\n          let itemTitle = item.key\n          if (item.label) {\n            itemTitle =\n              typeof item.label === 'function'\n                ? item.label({ featureClientSchemaMap, i18n, schemaPath })\n                : item.label\n          }\n\n          if (new RegExp(queryString, 'gi').exec(itemTitle)) {\n            return true\n          }\n          if (item.keywords != null) {\n            return item.keywords.some((keyword) => new RegExp(queryString, 'gi').exec(keyword))\n          }\n          return false\n        })\n        if (filteredItems.length) {\n          return {\n            ...group,\n            items: filteredItems,\n          }\n        }\n        return null\n      })\n\n      groupsWithItems = groupsWithItems.filter((group) => group != null)\n\n      // Now add dynamic groups\n      const dynamicItemGroups = getDynamicItems()\n\n      // merge dynamic items into groups\n      for (const dynamicGroup of dynamicItemGroups) {\n        // 1. find the group with the same name or create new one\n        let group = groupsWithItems.find((group) => group.key === dynamicGroup.key)\n        if (!group) {\n          group = {\n            ...dynamicGroup,\n            items: [],\n          }\n        } else {\n          groupsWithItems = groupsWithItems.filter((group) => group.key !== dynamicGroup.key)\n        }\n\n        // 2. Add items to group items array and add to sanitized.slashMenu.groupsWithItems\n        if (group?.items?.length) {\n          group.items = group.items.concat(group.items)\n        }\n        groupsWithItems.push(group)\n      }\n    }\n\n    return groupsWithItems\n  }, [\n    queryString,\n    editorConfig?.features.slashMenu.groups,\n    getDynamicItems,\n    featureClientSchemaMap,\n    i18n,\n    schemaPath,\n  ])\n\n  return (\n    <LexicalTypeaheadMenuPlugin\n      anchorElem={anchorElem}\n      groups={groups as SlashMenuGroupInternal[]}\n      menuRenderFn={(\n        anchorElementRef,\n        { selectedItemKey, selectItemAndCleanUp, setSelectedItemKey },\n      ) =>\n        anchorElementRef.current && groups.length\n          ? ReactDOM.createPortal(\n              <div className={baseClass}>\n                {groups.map((group) => {\n                  let groupTitle = group.key\n                  if (group.label && featureClientSchemaMap) {\n                    groupTitle =\n                      typeof group.label === 'function'\n                        ? group.label({ featureClientSchemaMap, i18n, schemaPath })\n                        : group.label\n                  }\n\n                  return (\n                    <div\n                      className={`${baseClass}__group ${baseClass}__group-${group.key}`}\n                      key={group.key}\n                    >\n                      <div className={`${baseClass}__group-title`}>{groupTitle}</div>\n                      {group.items.map((item, oi: number) => (\n                        <SlashMenuItem\n                          index={oi}\n                          isSelected={selectedItemKey === item.key}\n                          item={item as SlashMenuItemInternal}\n                          key={item.key}\n                          onClick={() => {\n                            setSelectedItemKey(item.key)\n                            selectItemAndCleanUp(item)\n                          }}\n                          onMouseEnter={() => {\n                            setSelectedItemKey(item.key)\n                          }}\n                          ref={(el) => {\n                            ;(item as SlashMenuItemInternal).ref = { current: el }\n                          }}\n                        />\n                      ))}\n                    </div>\n                  )\n                })}\n              </div>,\n              anchorElementRef.current,\n            )\n          : null\n      }\n      onQueryChange={setQueryString}\n      triggerFn={checkForTriggerMatch}\n    />\n  )\n}\n","'use client'\nimport type { LexicalEditor } from 'lexical'\n\nimport { useCallback } from 'react'\n\nimport { PUNCTUATION } from './LexicalTypeaheadMenuPlugin/index.js'\n\nexport type TriggerFn = ({\n  editor,\n  query,\n}: {\n  editor: LexicalEditor\n  /** The query string is the POTENTIAL trigger AND the text after the trigger text. */\n  query: string\n}) => MenuTextMatch | null\n\nexport type MenuTextMatch = {\n  leadOffset: number\n  matchingString: string\n  replaceableString: string\n}\n\n/**\n * Returns a function which checks if the trigger (e.g. '/') is present in the query and, if so, returns the matching string (text after the trigger)\n */\nexport function useMenuTriggerMatch(\n  /**\n   * Text which triggers the menu. Everything after this text will be used as the query.\n   */\n  trigger: string,\n  { maxLength = 75, minLength = 1 }: { maxLength?: number; minLength?: number },\n): TriggerFn {\n  return useCallback(\n    ({ query }) => {\n      const validChars = '[^' + trigger + PUNCTUATION + '\\\\s]'\n      const TypeaheadTriggerRegex = new RegExp(\n        '(^|\\\\s|\\\\()(' +\n          '[' +\n          trigger +\n          ']' +\n          '((?:' +\n          validChars +\n          '){0,' +\n          maxLength +\n          '})' +\n          ')$',\n      )\n      const match = TypeaheadTriggerRegex.exec(query)\n      if (match !== null) {\n        const maybeLeadingWhitespace = match[1]!\n\n        /**\n         * matchingString is only the text AFTER the trigger text. (So everything after the /)\n         */\n        const matchingString = match[3]!\n\n        if (matchingString.length >= minLength) {\n          return {\n            leadOffset: match.index + maybeLeadingWhitespace.length,\n            matchingString,\n            replaceableString: match[2]!, // replaceableString is the trigger text + the matching string\n          }\n        }\n      }\n      return null\n    },\n    [maxLength, minLength, trigger],\n  )\n}\n","'use client'\nimport type { TextFormatType } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { TEXT_TYPE_TO_FORMAT, TextNode } from 'lexical'\nimport { useEffect } from 'react'\n\nimport type { SanitizedClientFeatures } from '../../../features/typesClient.js'\n\nexport function TextPlugin({ features }: { features: SanitizedClientFeatures }) {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    const disabledFormats = getDisabledFormats(features.enabledFormats)\n    if (disabledFormats.length === 0) {\n      return\n    }\n    // Ideally override the TextNode with our own TextNode (changing its setFormat or toggleFormat methods),\n    // would be more performant. If we find a noticeable perf regression we can switch to that option.\n    // Overriding the FORMAT_TEXT_COMMAND and PASTE_COMMAND commands is not an option I considered because\n    // there might be other forms of mutation that we might not be considering. For example:\n    // browser extensions or Payload/Lexical plugins that have their own commands.\n    return editor.registerNodeTransform(TextNode, (textNode) => {\n      disabledFormats.forEach((disabledFormat) => {\n        if (textNode.hasFormat(disabledFormat)) {\n          textNode.toggleFormat(disabledFormat)\n        }\n      })\n    })\n  }, [editor, features])\n\n  return null\n}\n\nfunction getDisabledFormats(enabledFormats: TextFormatType[]): TextFormatType[] {\n  const allFormats = Object.keys(TEXT_TYPE_TO_FORMAT) as TextFormatType[]\n  const enabledSet = new Set(enabledFormats)\n\n  return allFormats.filter((format) => !enabledSet.has(format))\n}\n","'use client'\nimport type { JSX } from 'react'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { ContentEditable } from '@lexical/react/LexicalContentEditable.js'\nimport { useTranslation } from '@payloadcms/ui'\n\nimport './ContentEditable.scss'\n\nimport * as React from 'react'\n\nimport type { SanitizedClientEditorConfig } from '../config/types.js'\n\nexport function LexicalContentEditable({\n  className,\n  editorConfig,\n}: {\n  className?: string\n  editorConfig: SanitizedClientEditorConfig\n}): JSX.Element {\n  const { t } = useTranslation<{}, string>()\n  const [_, { getTheme }] = useLexicalComposerContext()\n  const theme = getTheme()\n\n  return (\n    <ContentEditable\n      aria-placeholder={t('lexical:general:placeholder')}\n      className={className ?? 'ContentEditable__root'}\n      placeholder={\n        <p className={theme?.placeholder}>\n          {editorConfig?.admin?.placeholder ?? t('lexical:general:placeholder')}\n        </p>\n      }\n    />\n  )\n}\n"],"names":["BulkUploadProvider", "FieldDescription", "FieldError", "FieldLabel", "RenderCustomComponent", "useEditDepth", "useEffectEvent", "useField", "mergeFieldStyles", "dequal", "React", "useCallback", "useEffect", "useMemo", "useState", "ErrorBoundary", "LexicalComposer", "useEditDepth", "React", "useMemo", "c", "_c", "useLexicalComposerContext", "LexicalErrorBoundary", "HistoryPlugin", "OnChangePlugin", "RichTextPlugin", "useLexicalEditable", "BLUR_COMMAND", "COMMAND_PRIORITY_LOW", "FOCUS_COMMAND", "React", "useEffect", "useState", "EditorPlugin", "anchorElem", "clientProps", "plugin", "position", "Component", "_jsx", "c", "_c", "copyToClipboard", "useLexicalComposerContext", "objectKlassEquals", "ObjectID", "COMMAND_PRIORITY_LOW", "COPY_COMMAND", "useEffect", "ClipboardPlugin", "$", "editor", "t0", "t1", "registerCommand", "event", "ClipboardEvent", "then", "clipboardData", "Error", "lexicalStringified", "getData", "lexical", "JSON", "parse", "changeIds", "node", "fields", "id", "default", "toHexString", "children", "child", "node_0", "nodes", "stringified", "stringify", "setData", "catch", "error", "c", "_c", "useLexicalComposerContext", "$findMatchingParent", "mergeRegister", "$createNodeSelection", "$getEditor", "$getNearestNodeFromDOMNode", "$getSelection", "$isDecoratorNode", "$isElementNode", "$isLineBreakNode", "$isNodeSelection", "$isRangeSelection", "$isRootOrShadowRoot", "$isTextNode", "$setSelection", "CLICK_COMMAND", "COMMAND_PRIORITY_LOW", "KEY_ARROW_DOWN_COMMAND", "KEY_ARROW_UP_COMMAND", "KEY_BACKSPACE_COMMAND", "KEY_DELETE_COMMAND", "SELECTION_CHANGE_COMMAND", "useEffect", "DecoratorPlugin", "$", "editor", "$onDelete", "_temp2", "t0", "t1", "registerCommand", "_temp3", "_temp4", "_temp6", "_temp8", "event_2", "selection_1", "selection", "event", "preventDefault", "nextSibling", "getNodes", "getNextSibling", "element_0", "getElementByKey", "getKey", "element", "$selectDecorator", "node", "firstDescendant", "getFirstDescendant", "INTERNAL_$isBlock", "selectEnd", "lastNode", "isBackward", "anchor", "focus", "getNode", "lastSelectedBlock", "_temp7", "nextBlock", "findLaterSiblingBlock", "nextBlockElement", "node_1", "event_1", "selection_0", "prevSibling", "getPreviousSibling", "lastDescendant", "getLastDescendant", "selectStart", "firstNode", "firstSelectedBlock", "_temp5", "prevBlock", "findFirstSiblingBlock", "prevBlockElement", "node_0", "decorator_0", "$getSelectedDecorator", "document", "querySelector", "classList", "remove", "decorator", "add", "event_0", "$getDecoratorByMouseEvent", "target", "HTMLElement", "isContentEditable", "closest", "forEach", "_temp", "undefined", "nodes", "length", "scrollIntoView", "behavior", "block", "isInline", "firstChild", "getFirstChild", "isLeafElement", "canBeEmpty", "current", "useLexicalComposerContext", "$createParagraphNode", "isHTMLElement", "React", "useCallback", "useEffect", "useRef", "useState", "createPortal", "calculateDistanceFromScrollerElem", "scrollerElem", "pageX", "pageY", "target", "horizontalBuffer", "verticalBuffer", "distanceFromScrollerElem", "contains", "bottom", "left", "right", "top", "getBoundingClientRect", "adjustedTop", "window", "scrollY", "adjustedBottom", "$getNodeByKey", "getBoundingClientRectWithoutTransform", "elem", "rect", "getBoundingClientRect", "transformValue", "getComputedStyle", "getPropertyValue", "lastNumberOfTransformValue", "split", "pop", "y", "Number", "replace", "getCollapsedMargins", "elem", "getMargin", "element", "margin", "parseFloat", "window", "getComputedStyle", "marginBottom", "marginTop", "prevElemSiblingMarginBottom", "previousElementSibling", "nextElemSiblingMarginTop", "nextElementSibling", "collapsedTopMargin", "Math", "max", "$getRoot", "getTopLevelNodeKeys", "editor", "getEditorState", "read", "getChildrenKeys", "Downward", "Upward", "Indeterminate", "cache", "props", "result", "isPointClose", "previous", "current", "threshold", "dx", "x", "dy", "y", "getNodeCloseToPoint", "anchorElem", "cache_threshold", "editor", "fuzzy", "horizontalOffset", "point", "startIndex", "useEdgeAsDefault", "anchorElementRect", "getBoundingClientRect", "topLevelNodeKeys", "getTopLevelNodeKeys", "closestBlockElem", "blockElem", "blockNode", "distance", "Infinity", "foundAtIndex", "isFoundNodeEmptyParagraph", "getEditorState", "read", "firstNode", "getElementByKey", "lastNode", "length", "firstNodeRect", "lastNodeRect", "getBoundingClientRectWithoutTransform", "top", "$getNodeByKey", "bottom", "index", "direction", "key", "elem", "Point", "domRect", "Rect", "fromDOMRect", "marginBottom", "marginTop", "getCollapsedMargins", "rect", "generateNewRect", "left", "right", "isOnBottomSide", "isOnTopSide", "distanceFromPoint", "getType", "getTextContent", "returnEmptyParagraphs", "isOnHandleElement", "element", "handleElementClassName", "closest", "replacedElements", "doesLineHeightAffectElement", "htmlElem", "includes", "tagName", "offsetHeight", "offsetWidth", "style", "window", "getComputedStyle", "display", "position", "visibility", "opacity", "setHandlePosition", "targetElem", "handleElem", "anchorElem", "leftOffset", "style", "opacity", "transform", "targetRect", "getBoundingClientRect", "targetStyle", "window", "getComputedStyle", "floatingElemRect", "anchorElementRect", "top", "some", "classes", "classList", "contains", "firstElementChild", "actualLineHeight", "doesLineHeightAffectElement", "parseInt", "lineHeight", "height", "left", "ADD_BLOCK_MENU_CLASSNAME", "prevIndex", "Infinity", "getCurrentIndex", "keysLength", "Math", "floor", "useAddBlockHandle", "editor", "anchorElem", "isEditable", "scrollerElem", "parentElement", "editorConfig", "useEditorConfigContext", "blockHandleHorizontalOffset", "admin", "hideGutter", "menuRef", "useRef", "hoveredElement", "setHoveredElement", "useState", "useEffect", "onDocumentMouseMove", "event", "target", "isHTMLElement", "distanceFromScrollerElem", "calculateDistanceFromScrollerElem", "pageX", "pageY", "isOnHandleElement", "topLevelNodeKeys", "getTopLevelNodeKeys", "blockElem", "_emptyBlockElem", "blockNode", "foundAtIndex", "getNodeCloseToPoint", "cache_threshold", "horizontalOffset", "point", "Point", "x", "y", "returnEmptyParagraphs", "startIndex", "length", "useEdgeAsDefault", "node", "elem", "document", "addEventListener", "removeEventListener", "current", "setHandlePosition", "handleAddClick", "useCallback", "hoveredElementToUse", "update", "isEmptyParagraph", "getType", "getTextContent", "newParagraph", "$createParagraphNode", "insertAfter", "setTimeout", "getElementByKey", "getKey", "focus", "select", "dispatchCommand", "ENABLE_SLASH_MENU_COMMAND", "stopPropagation", "preventDefault", "createPortal", "_jsx", "Fragment", "className", "onClick", "ref", "type", "AddBlockHandlePlugin", "t0", "t1", "undefined", "body", "useLexicalComposerContext", "_editable", "useLexicalComposerContext", "eventFiles", "$getNearestNodeFromDOMNode", "$getNodeByKey", "isHTMLElement", "React", "useEffect", "useRef", "useState", "createPortal", "TARGET_LINE_HALF_HEIGHT", "TEXT_BOX_HORIZONTAL_PADDING", "animationTimer", "setTargetLine", "offsetWidth", "offsetLeft", "targetLineElem", "targetBlockElem", "lastTargetBlock", "mouseY", "anchorElem", "event", "debugHighlightRef", "isFoundNodeEmptyParagraph", "height", "targetBlockElemHeight", "top", "targetBlockElemTop", "getBoundingClientRect", "anchorTop", "width", "anchorWidth", "marginBottom", "marginTop", "getCollapsedMargins", "lineTop", "isBelow", "window", "scrollY", "willStayInSamePosition", "elem", "nextElementSibling", "previousElementSibling", "lastBoundingBoxPosition", "boundingBox", "y", "currentBoundingBoxPosition", "targetElemTranslate2", "TARGET_LINE_HALF_HEIGHT", "left", "TEXT_BOX_HORIZONTAL_PADDING", "style", "opacity", "transform", "DRAGGABLE_BLOCK_MENU_CLASSNAME", "DRAG_DATA_FORMAT", "prevIndex", "Infinity", "getCurrentIndex", "keysLength", "Math", "floor", "setDragImage", "dataTransfer", "draggableBlockElem", "transform", "style", "setTimeout", "hideTargetLine", "targetLineElem", "lastTargetBlockElem", "opacity", "marginBottom", "marginTop", "useDraggableBlockMenu", "editor", "anchorElem", "isEditable", "scrollerElem", "parentElement", "menuRef", "useRef", "targetLineRef", "debugHighlightRef", "isDraggingBlockRef", "setDraggableBlockElem", "useState", "lastTargetBlock", "setLastTargetBlock", "editorConfig", "useEditorConfigContext", "blockHandleHorizontalOffset", "admin", "hideGutter", "useEffect", "onDocumentMouseMove", "event", "target", "isHTMLElement", "distanceFromScrollerElem", "calculateDistanceFromScrollerElem", "pageX", "pageY", "isOnHandleElement", "topLevelNodeKeys", "getTopLevelNodeKeys", "blockElem", "_draggableBlockElem", "foundAtIndex", "isFoundNodeEmptyParagraph", "getNodeCloseToPoint", "cache_threshold", "horizontalOffset", "point", "Point", "x", "y", "startIndex", "length", "useEdgeAsDefault", "verbose", "document", "addEventListener", "removeEventListener", "current", "setHandlePosition", "onDragover", "isFileTransfer", "eventFiles", "targetBlockElem", "fuzzy", "isBelow", "willStayInSamePosition", "setTargetLine", "getBoundingClientRect", "width", "preventDefault", "boundingBox", "elem", "onDrop", "dragData", "getData", "update", "draggedNode", "$getNodeByKey", "targetNode", "$getNearestNodeFromDOMNode", "height", "targetBlockElemHeight", "top", "targetBlockElemTop", "getBoundingClientRectWithoutTransform", "window", "scrollY", "insertBefore", "remove", "insertAfter", "querySelectorAll", "forEach", "highlighter", "newInsertedElem", "getElementByKey", "getKey", "newInsertedElemRect", "highlightElem", "createElement", "className", "backgroundColor", "transition", "zIndex", "pointerEvents", "boxSizing", "borderRadius", "position", "body", "appendChild", "left", "onDragStart", "nodeKey", "node", "setData", "onDragEnd", "createPortal", "_jsxs", "Fragment", "_jsx", "draggable", "ref", "type", "DraggableBlockPlugin", "t0", "t1", "undefined", "useLexicalComposerContext", "_editable", "c", "_c", "useLexicalComposerContext", "$createParagraphNode", "$getRoot", "baseClass", "InsertParagraphAtEndPlugin", "$", "_c", "editor", "useLexicalComposerContext", "editorConfig", "useEditorConfigContext", "admin", "hideInsertParagraphAtEnd", "t0", "_jsx", "className", "onClick", "update", "_temp", "role", "tabIndex", "children", "paragraphNode", "$createParagraphNode", "$getRoot", "append", "select", "c", "_c", "useLexicalComposerContext", "React", "MarkdownShortcutPlugin", "$", "_c", "editorConfig", "useEditorConfigContext", "editor", "useLexicalComposerContext", "t0", "t1", "features", "markdownTransformers", "registerMarkdownShortcuts", "useEffect", "useLexicalComposerContext", "$getSelection", "$isRangeSelection", "RootNode", "useEffect", "NormalizeSelectionPlugin", "editor", "registerNodeTransform", "root", "selection", "anchorNode", "anchor", "getNode", "focusNode", "focus", "isAttached", "selectEnd", "console", "warn", "useLexicalComposerContext", "$getSelection", "COMMAND_PRIORITY_LOW", "SELECT_ALL_COMMAND", "useEffect", "SelectAllPlugin", "editor", "registerCommand", "activeElement", "document", "HTMLInputElement", "select", "useLexicalComposerContext", "useTranslation", "useCallback", "useMemo", "useState", "ReactDOM", "c", "_c", "useMenuTriggerMatch", "trigger", "t0", "$", "_c", "maxLength", "t1", "minLength", "t2", "undefined", "t3", "t4", "query", "validChars", "PUNCTUATION", "match", "RegExp", "exec", "maybeLeadingWhitespace", "matchingString", "length", "leadOffset", "index", "replaceableString", "baseClass", "SlashMenuItem", "isSelected", "item", "onClick", "onMouseEnter", "ref", "fieldProps", "featureClientSchemaMap", "schemaPath", "useEditorConfigContext", "i18n", "useTranslation", "className", "key", "title", "label", "length", "substring", "_jsxs", "id", "role", "tabIndex", "type", "Icon", "_jsx", "SlashMenuPlugin", "anchorElem", "document", "body", "editor", "useLexicalComposerContext", "queryString", "setQueryString", "useState", "editorConfig", "checkForTriggerMatch", "useMenuTriggerMatch", "minLength", "getDynamicItems", "useCallback", "groupWithItems", "dynamicItem", "features", "slashMenu", "dynamicGroups", "dynamicGroupWithItems", "concat", "groups", "useMemo", "groupsWithItems", "groupWithItem", "push", "map", "group", "filteredItems", "items", "filter", "itemTitle", "RegExp", "exec", "keywords", "some", "keyword", "dynamicItemGroups", "dynamicGroup", "find", "LexicalTypeaheadMenuPlugin", "menuRenderFn", "anchorElementRef", "selectedItemKey", "selectItemAndCleanUp", "setSelectedItemKey", "current", "createPortal", "groupTitle", "oi", "index", "el", "onQueryChange", "triggerFn", "c", "_c", "useLexicalComposerContext", "TEXT_TYPE_TO_FORMAT", "TextNode", "useEffect", "TextPlugin", "t0", "$", "features", "editor", "t1", "enabledFormats", "disabledFormats", "getDisabledFormats", "length", "registerNodeTransform", "textNode", "forEach", "disabledFormat", "hasFormat", "toggleFormat", "t2", "allFormats", "Object", "keys", "enabledSet", "Set", "filter", "format", "has", "c", "_c", "useLexicalComposerContext", "ContentEditable", "useTranslation", "LexicalContentEditable", "t0", "$", "className", "editorConfig", "t", "t1", "getTheme", "t2", "admin", "placeholder", "theme", "_jsx", "children", "LexicalEditor", "props", "$", "_c", "editorConfig", "editorContainerRef", "isSmallWidthViewport", "onChange", "editorConfigContext", "useEditorConfigContext", "editor", "useLexicalComposerContext", "isEditable", "useLexicalEditable", "floatingAnchorElem", "setFloatingAnchorElem", "useState", "t0", "Symbol", "for", "_floatingAnchorElem", "onRef", "t1", "t2", "uuid", "console", "error", "parentEditor", "registerChild", "handleFocus", "focusEditor", "handleBlur", "blurEditor", "unregisterFocus", "registerCommand", "FOCUS_COMMAND", "COMMAND_PRIORITY_LOW", "unregisterBlur", "BLUR_COMMAND", "unregisterChild", "useEffect", "t3", "_jsxs", "Fragment", "children", "features", "plugins", "map", "_temp", "className", "ref", "_temp2", "_jsx", "RichTextPlugin", "contentEditable", "LexicalContentEditable", "NormalizeSelectionPlugin", "InsertParagraphAtEndPlugin", "DecoratorPlugin", "ClipboardPlugin", "TextPlugin", "SelectAllPlugin", "OnChangePlugin", "ignoreSelectionChange", "editorState", "editor_0", "tags", "has", "size", "admin", "hideDraggableBlockElement", "DraggableBlockPlugin", "anchorElem", "hideAddBlockButton", "AddBlockHandlePlugin", "plugin_1", "plugin", "position", "desktopOnly", "EditorPlugin", "clientProps", "key", "SlashMenuPlugin", "HistoryPlugin", "markdownTransformers", "length", "MarkdownShortcutPlugin", "_temp3", "_temp4", "_temp5", "plugin_0", "plugin_2", "plugin_3", "plugin_4", "NestProviders", "children", "providers", "length", "Component", "_jsx", "slice", "LexicalProvider", "props", "composerKey", "editorConfig", "fieldProps", "isSmallWidthViewport", "onChange", "readOnly", "value", "parentContext", "useEditorConfigContext", "editDepth", "useEditDepth", "editorContainerRef", "useRef", "initialConfig", "useMemo", "Error", "JSON", "stringify", "Array", "isArray", "editable", "editorState", "undefined", "namespace", "lexical", "nodes", "getEnabledNodes", "onError", "error", "theme", "LexicalComposer", "EditorConfigProvider", "features", "LexicalEditorComponent", "baseClass", "RichTextComponent", "props", "editorConfig", "field", "admin", "className", "description", "readOnly", "readOnlyFromAdmin", "label", "localized", "required", "path", "pathFromProps", "readOnlyFromTopLevelProps", "validate", "readOnlyFromProps", "editDepth", "useEditDepth", "memoizedValidate", "useCallback", "value", "validationOptions", "customComponents", "AfterInput", "BeforeInput", "Description", "Error", "Label", "disabled", "disabledFromField", "initialValue", "setValue", "showError", "useField", "potentiallyStalePath", "isSmallWidthViewport", "setIsSmallWidthViewport", "useState", "rerenderProviderKey", "setRerenderProviderKey", "prevInitialValueRef", "React", "useRef", "prevValueRef", "useEffect", "updateViewPortWidth", "isNextSmallWidthViewport", "window", "matchMedia", "matches", "addEventListener", "removeEventListener", "classes", "hideGutter", "filter", "Boolean", "join", "pathWithEditDepth", "runDeprioritized", "useRunDeprioritized", "handleChange", "editorState", "updateFieldValue", "newState", "toJSON", "current", "styles", "useMemo", "mergeFieldStyles", "handleInitialValueChange", "useEffectEvent", "dequal", "JSON", "parse", "stringify", "Date", "Object", "is", "_jsxs", "style", "_jsx", "RenderCustomComponent", "CustomComponent", "Fallback", "FieldError", "FieldLabel", "ErrorBoundary", "fallbackRender", "onReset", "BulkUploadProvider", "drawerSlugPrefix", "LexicalProvider", "composerKey", "fieldProps", "onChange", "FieldDescription", "error", "role", "color", "message", "RichText"],"mappings":"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"}}]
}