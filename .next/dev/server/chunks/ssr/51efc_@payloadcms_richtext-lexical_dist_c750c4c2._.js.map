{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/i18n.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    placeholder: \"ابدأ بالكتابة، أو اضغط على '/' للأوامر ...\",\n    slashMenuBasicGroupLabel: 'أساسي',\n    slashMenuListGroupLabel: 'قوائم',\n    toolbarItemsActive: '{{count}} نشط',\n  },\n  az: {\n    placeholder: \"Yazmağa başlayın və ya əmrlər üçün '/' düyməsini basın...\",\n    slashMenuBasicGroupLabel: 'Əsas',\n    slashMenuListGroupLabel: 'Siyahılar',\n    toolbarItemsActive: '{{count}} aktiv',\n  },\n  bg: {\n    placeholder: \"Започнете да пишете или натиснете '/' за команди...\",\n    slashMenuBasicGroupLabel: 'Основен',\n    slashMenuListGroupLabel: 'Списъци',\n    toolbarItemsActive: '{{count}} активни',\n  },\n  cs: {\n    placeholder: \"Začněte psát nebo stiskněte '/' pro příkazy...\",\n    slashMenuBasicGroupLabel: 'Základní',\n    slashMenuListGroupLabel: 'Seznamy',\n    toolbarItemsActive: '{{count}} aktivní',\n  },\n  da: {\n    placeholder: \"Begynd at skrive, eller tryk på '/' for kommandoer...\",\n    slashMenuBasicGroupLabel: 'Grundlæggende',\n    slashMenuListGroupLabel: 'Lister',\n    toolbarItemsActive: '{{count}} aktive',\n  },\n  de: {\n    placeholder: \"Beginne zu tippen oder drücke '/' für Befehle...\",\n    slashMenuBasicGroupLabel: 'Basis',\n    slashMenuListGroupLabel: 'Listen',\n    toolbarItemsActive: '{{count}} aktiv',\n  },\n  en: {\n    placeholder: \"Start typing, or press '/' for commands...\",\n    slashMenuBasicGroupLabel: 'Basic',\n    slashMenuListGroupLabel: 'Lists',\n    toolbarItemsActive: '{{count}} active',\n  },\n  es: {\n    placeholder: \"Comience a escribir, o presione '/' para comandos...\",\n    slashMenuBasicGroupLabel: 'Básico',\n    slashMenuListGroupLabel: 'Listas',\n    toolbarItemsActive: '{{count}} activo',\n  },\n  et: {\n    placeholder: \"Alusta kirjutamist või vajuta '/' käskude jaoks...\",\n    slashMenuBasicGroupLabel: 'Põhiline',\n    slashMenuListGroupLabel: 'Loendid',\n    toolbarItemsActive: '{{count}} aktiivne',\n  },\n  fa: {\n    placeholder: \"شروع به تایپ کنید، یا برای دستورات '/' را فشار دهید ...\",\n    slashMenuBasicGroupLabel: 'پایه',\n    slashMenuListGroupLabel: 'لیست ها',\n    toolbarItemsActive: '{{count}} فعال',\n  },\n  fr: {\n    placeholder: \"Commencez à taper, ou appuyez sur '/' pour les commandes...\",\n    slashMenuBasicGroupLabel: 'De base',\n    slashMenuListGroupLabel: 'Listes',\n    toolbarItemsActive: '{{count}} actif',\n  },\n  he: {\n    placeholder: \"התחיל להקליד, או לחץ על '/' עבור פקודות ...\",\n    slashMenuBasicGroupLabel: 'בסיסי',\n    slashMenuListGroupLabel: 'רשימות',\n    toolbarItemsActive: '{{count}} פעיל',\n  },\n  hr: {\n    placeholder: \"Počnite tipkati, ili pritisnite '/' za naredbe...\",\n    slashMenuBasicGroupLabel: 'Osnovno',\n    slashMenuListGroupLabel: 'Popisi',\n    toolbarItemsActive: '{{count}} aktivno',\n  },\n  hu: {\n    placeholder: \"Kezdje el gépelni, vagy nyomja meg a '/' billentyűt a parancsokhoz...\",\n    slashMenuBasicGroupLabel: 'Alapvető',\n    slashMenuListGroupLabel: 'Listák',\n    toolbarItemsActive: '{{count}} aktív',\n  },\n  is: {\n    placeholder: \"Byrjaðu að skrifa eða sláðu inn '/' fyrir skipanir...\",\n    slashMenuBasicGroupLabel: 'Grunnur',\n    slashMenuListGroupLabel: 'Listar',\n    toolbarItemsActive: '{{count}} virk',\n  },\n  it: {\n    placeholder: \"Inizia a digitare, oppure premi '/' per i comandi...\",\n    slashMenuBasicGroupLabel: 'Base',\n    slashMenuListGroupLabel: 'Elenchi',\n    toolbarItemsActive: '{{count}} attivo',\n  },\n  ja: {\n    placeholder: \"入力を開始するか、コマンドのために'/'を押してください…\",\n    slashMenuBasicGroupLabel: '基本的な',\n    slashMenuListGroupLabel: 'リスト',\n    toolbarItemsActive: '{{count}} アクティブ',\n  },\n  ko: {\n    placeholder: \"타이핑을 시작하거나, 명령어를 입력하려면 '/'를 누르세요...\",\n    slashMenuBasicGroupLabel: '기본적인',\n    slashMenuListGroupLabel: '목록',\n    toolbarItemsActive: '{{count}} 활성화된',\n  },\n  my: {\n    placeholder: \"Mula menaip, atau tekan '/' untuk arahan...\",\n    slashMenuBasicGroupLabel: 'အခြေခံ',\n    slashMenuListGroupLabel: 'Senarai',\n    toolbarItemsActive: '{{count}} aktif',\n  },\n  nb: {\n    placeholder: \"Begynn å skrive, eller trykk '/' for kommandoer...\",\n    slashMenuBasicGroupLabel: 'Grunnleggende',\n    slashMenuListGroupLabel: 'Lister',\n    toolbarItemsActive: '{{count}} aktiv',\n  },\n  nl: {\n    placeholder: \"Begin met typen, of druk op '/' voor opdrachten...\",\n    slashMenuBasicGroupLabel: 'Basis',\n    slashMenuListGroupLabel: 'Lijsten',\n    toolbarItemsActive: '{{count}} actief',\n  },\n  pl: {\n    placeholder: \"Rozpocznij pisanie lub naciśnij '/' dla poleceń...\",\n    slashMenuBasicGroupLabel: 'Podstawowy',\n    slashMenuListGroupLabel: 'Listy',\n    toolbarItemsActive: '{{count}} aktywny',\n  },\n  pt: {\n    placeholder: \"Comece a digitar, ou pressione '/' para comandos...\",\n    slashMenuBasicGroupLabel: 'Básico',\n    slashMenuListGroupLabel: 'Listas',\n    toolbarItemsActive: '{{count}} ativo',\n  },\n  ro: {\n    placeholder: \"Începeți să tastați sau apăsați '/' pentru comenzi...\",\n    slashMenuBasicGroupLabel: 'De bază',\n    slashMenuListGroupLabel: 'Liste',\n    toolbarItemsActive: '{{count}} activ',\n  },\n  rs: {\n    placeholder: \"Почните да куцате, или притисните '/' за команде...\",\n    slashMenuBasicGroupLabel: 'Основно',\n    slashMenuListGroupLabel: 'Листе',\n    toolbarItemsActive: '{{count}} активно',\n  },\n  'rs-latin': {\n    placeholder: \"Počnite da kucate, ili pritisnite '/' za komande...\",\n    slashMenuBasicGroupLabel: 'Osnovno',\n    slashMenuListGroupLabel: 'Liste',\n    toolbarItemsActive: '{{count}} aktivan',\n  },\n  ru: {\n    placeholder: \"Начните печатать или нажмите '/' для команд...\",\n    slashMenuBasicGroupLabel: 'Базовый',\n    slashMenuListGroupLabel: 'Списки',\n    toolbarItemsActive: '{{count}} активных',\n  },\n  sk: {\n    placeholder: \"Začnite písať alebo stlačte '/' pre príkazy...\",\n    slashMenuBasicGroupLabel: 'Základný',\n    slashMenuListGroupLabel: 'Zoznamy',\n    toolbarItemsActive: '{{count}} aktívne',\n  },\n  sl: {\n    placeholder: 'Začnite tipkati ali pritisnite \"/\" za ukaze...',\n    slashMenuBasicGroupLabel: 'Osnovno',\n    slashMenuListGroupLabel: 'Seznami',\n    toolbarItemsActive: '{{count}} aktivno',\n  },\n  sv: {\n    placeholder: \"Börja skriva, eller tryck på '/' för kommandon...\",\n    slashMenuBasicGroupLabel: 'Grundläggande',\n    slashMenuListGroupLabel: 'Listor',\n    toolbarItemsActive: '{{count}} aktiv',\n  },\n  ta: {\n    placeholder: \"எழுதத் தொடங்கவும், அல்லது கட்டளைகளுக்கு '/' அழுத்தவும்...\",\n    slashMenuBasicGroupLabel: 'அடிப்படை',\n    slashMenuListGroupLabel: 'பட்டியல்கள்',\n    toolbarItemsActive: '{{count}} செயலில் உள்ளது',\n  },\n  th: {\n    placeholder: \"เริ่มพิมพ์หรือกด '/' สำหรับคำสั่ง...\",\n    slashMenuBasicGroupLabel: 'พื้นฐาน',\n    slashMenuListGroupLabel: 'รายการ',\n    toolbarItemsActive: '{{count}} ที่ใช้งานอยู่',\n  },\n  tr: {\n    placeholder: \"Yazmaya başlayın veya komutlar için '/' tuşuna basın...\",\n    slashMenuBasicGroupLabel: 'Temel',\n    slashMenuListGroupLabel: 'Listeler',\n    toolbarItemsActive: '{{count}} aktif',\n  },\n  uk: {\n    placeholder: \"Почніть друкувати, або натисніть '/' для команд...\",\n    slashMenuBasicGroupLabel: 'Базовий',\n    slashMenuListGroupLabel: 'Списки',\n    toolbarItemsActive: '{{count}} активний',\n  },\n  vi: {\n    placeholder: \"Bắt đầu gõ, hoặc nhấn '/' để gọi lệnh...\",\n    slashMenuBasicGroupLabel: 'Cơ bản',\n    slashMenuListGroupLabel: 'Danh sách',\n    toolbarItemsActive: '{{count}} đang hoạt động',\n  },\n  zh: {\n    placeholder: \"开始输入，或按'/'进行命令...\",\n    slashMenuBasicGroupLabel: '基础',\n    slashMenuListGroupLabel: '列表',\n    toolbarItemsActive: '{{count}} 活跃',\n  },\n  'zh-TW': {\n    placeholder: \"開始輸入，或按'/'以使用命令...\",\n    slashMenuBasicGroupLabel: '基本的',\n    slashMenuListGroupLabel: '清單',\n    toolbarItemsActive: '{{count}} 活躍中',\n  },\n}\n"],"names":["i18n","ar","placeholder","slashMenuBasicGroupLabel","slashMenuListGroupLabel","toolbarItemsActive","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","is","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","ta","th","tr","uk","vi","zh"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 236, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/utilities/createServerFeature.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/utilities/createServerFeature.ts"],"sourcesContent":["import type { SanitizedConfig } from 'payload'\n\nimport type {\n  FeatureProviderProviderServer,\n  FeatureProviderServer,\n  ResolvedServerFeatureMap,\n  ServerFeature,\n  ServerFeatureProviderMap,\n} from '../features/typesServer.js'\nimport type { ServerEditorConfig } from '../lexical/config/types.js'\n\nexport type CreateServerFeatureArgs<UnSanitizedProps, SanitizedProps, ClientProps> = {\n  feature:\n    | ((props: {\n        config: SanitizedConfig\n        /** unSanitizedEditorConfig.features, but mapped */\n        featureProviderMap: ServerFeatureProviderMap\n        isRoot?: boolean\n        parentIsLocalized: boolean\n        props: UnSanitizedProps\n        // other resolved features, which have been loaded before this one. All features declared in 'dependencies' should be available here\n        resolvedFeatures: ResolvedServerFeatureMap\n        // unSanitized EditorConfig,\n        unSanitizedEditorConfig: ServerEditorConfig\n      }) =>\n        | Promise<ServerFeature<SanitizedProps, ClientProps>>\n        | ServerFeature<SanitizedProps, ClientProps>)\n    | Omit<ServerFeature<SanitizedProps, ClientProps>, 'sanitizedServerFeatureProps'>\n} & Pick<\n  FeatureProviderServer<UnSanitizedProps, ClientProps>,\n  'dependencies' | 'dependenciesPriority' | 'dependenciesSoft' | 'key'\n>\n\nexport const createServerFeature: <\n  UnSanitizedProps = undefined,\n  SanitizedProps = UnSanitizedProps,\n  ClientProps = undefined,\n>(\n  args: CreateServerFeatureArgs<UnSanitizedProps, SanitizedProps, ClientProps>,\n) => FeatureProviderProviderServer<UnSanitizedProps, SanitizedProps, ClientProps> = ({\n  dependencies,\n  dependenciesPriority,\n  dependenciesSoft,\n  feature,\n  key,\n}) => {\n  const featureProviderProviderServer: FeatureProviderProviderServer<any, any, any> = (props) => {\n    const featureProviderServer: Partial<FeatureProviderServer<any, any, any>> = {\n      dependencies,\n      dependenciesPriority,\n      dependenciesSoft,\n      key,\n      serverFeatureProps: props,\n    }\n\n    if (typeof feature === 'function') {\n      featureProviderServer.feature = async ({\n        config,\n        featureProviderMap,\n        isRoot,\n        parentIsLocalized,\n        resolvedFeatures,\n        unSanitizedEditorConfig,\n      }) => {\n        const toReturn = await feature({\n          config,\n          featureProviderMap,\n          isRoot,\n          parentIsLocalized,\n          props,\n          resolvedFeatures,\n          unSanitizedEditorConfig,\n        })\n\n        if (toReturn.sanitizedServerFeatureProps === null) {\n          toReturn.sanitizedServerFeatureProps = props\n        }\n        return toReturn\n      }\n    } else {\n      // For explanation why we have to spread feature, see createClientFeature.ts\n      const newFeature: ServerFeature<any, any> = { ...feature }\n\n      newFeature.sanitizedServerFeatureProps = props\n      featureProviderServer.feature = newFeature\n    }\n    return featureProviderServer as FeatureProviderServer<any, any, any>\n  }\n\n  return featureProviderProviderServer\n}\n"],"names":["createServerFeature","dependencies","dependenciesPriority","dependenciesSoft","feature","key","featureProviderProviderServer","props","featureProviderServer","serverFeatureProps","config","featureProviderMap","isRoot","parentIsLocalized","resolvedFeatures","unSanitizedEditorConfig","toReturn","sanitizedServerFeatureProps","newFeature"],"mappings":";;;;AAiCO,MAAMA,mBAAA,GAMuEA,CAAC,EACnFC,YAAY,EACZC,oBAAoB,EACpBC,gBAAgB,EAChBC,OAAO,EACPC,GAAAA,EACD;IACC,MAAMC,6BAAA,IAA+EC,KAAA;QACnF,MAAMC,qBAAA,GAAuE;YAC3EP,YAAA;YACAC,oBAAA;YACAC,gBAAA;YACAE,GAAA;YACAI,kBAAA,EAAoBF;QACtB;QAEA,IAAI,OAAOH,OAAA,KAAY,YAAY;YACjCI,qBAAA,CAAsBJ,OAAO,GAAG,OAAO,EACrCM,MAAM,EACNC,kBAAkB,EAClBC,MAAM,EACNC,iBAAiB,EACjBC,gBAAgB,EAChBC,uBAAAA,EACD;gBACC,MAAMC,QAAA,GAAW,MAAMZ,OAAA,CAAQ;oBAC7BM,MAAA;oBACAC,kBAAA;oBACAC,MAAA;oBACAC,iBAAA;oBACAN,KAAA;oBACAO,gBAAA;oBACAC;gBACF;gBAEA,IAAIC,QAAA,CAASC,2BAA2B,KAAK,MAAM;oBACjDD,QAAA,CAASC,2BAA2B,GAAGV,KAAA;gBACzC;gBACA,OAAOS,QAAA;YACT;QACF,OAAO;YACL,4EAAA;YACA,MAAME,UAAA,GAAsC;gBAAE,GAAGd,OAAAA;YAAQ;YAEzDc,UAAA,CAAWD,2BAA2B,GAAGV,KAAA;YACzCC,qBAAA,CAAsBJ,OAAO,GAAGc,UAAA;QAClC;QACA,OAAOV,qBAAA;IACT;IAEA,OAAOF,6BAAA;AACT","ignoreList":[]}},
    {"offset": {"line": 281, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/align/server/i18n.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/align/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    alignCenterLabel: 'محاذاة في الوسط',\n    alignJustifyLabel: 'محاذاة التبرير',\n    alignLeftLabel: 'محاذاة إلى اليسار',\n    alignRightLabel: 'محاذاة إلى اليمين',\n  },\n  az: {\n    alignCenterLabel: 'Mərkəzə Düzəlt',\n    alignJustifyLabel: 'Düzəldin Səsləndirin',\n    alignLeftLabel: 'Sola Doğru Hizalama',\n    alignRightLabel: 'Sağa Doğru Hizalama',\n  },\n  bg: {\n    alignCenterLabel: 'Центрирай',\n    alignJustifyLabel: 'Подравняване по двата края',\n    alignLeftLabel: 'Подравняване отляво',\n    alignRightLabel: 'Подравняване вдясно',\n  },\n  cs: {\n    alignCenterLabel: 'Zarovnat na střed',\n    alignJustifyLabel: 'Zarovnat do bloku',\n    alignLeftLabel: 'Zarovnat vlevo',\n    alignRightLabel: 'Zarovnat vpravo',\n  },\n  da: {\n    alignCenterLabel: 'Centrer teksten',\n    alignJustifyLabel: 'Justér til begge sider',\n    alignLeftLabel: 'Justér til venstre',\n    alignRightLabel: 'Juster til højre',\n  },\n  de: {\n    alignCenterLabel: 'Zentrieren',\n    alignJustifyLabel: 'Blocksatz',\n    alignLeftLabel: 'Linksbündig',\n    alignRightLabel: 'Rechtsbündig',\n  },\n  en: {\n    alignCenterLabel: 'Align Center',\n    alignJustifyLabel: 'Align Justify',\n    alignLeftLabel: 'Align Left',\n    alignRightLabel: 'Align Right',\n  },\n  es: {\n    alignCenterLabel: 'Alinear al centro',\n    alignJustifyLabel: 'Alinear Justificar',\n    alignLeftLabel: 'Alinear a la izquierda',\n    alignRightLabel: 'Alinear a la derecha',\n  },\n  et: {\n    alignCenterLabel: 'Keskjoondus',\n    alignJustifyLabel: 'Rööpjoondus',\n    alignLeftLabel: 'Vasakjoondus',\n    alignRightLabel: 'Paremjoondus',\n  },\n  fa: {\n    alignCenterLabel: 'تراز در مرکز',\n    alignJustifyLabel: 'تراز کردن از دو طرف',\n    alignLeftLabel: 'چپ تراز',\n    alignRightLabel: 'راست چین',\n  },\n  fr: {\n    alignCenterLabel: 'Aligner au centre',\n    alignJustifyLabel: 'Aligner Justifier',\n    alignLeftLabel: 'Aligner à gauche',\n    alignRightLabel: 'Aligner à droite',\n  },\n  he: {\n    alignCenterLabel: 'ממורכז',\n    alignJustifyLabel: 'יישור דו-צדדי',\n    alignLeftLabel: 'הסב לשמאל',\n    alignRightLabel: 'יישור לימין',\n  },\n  hr: {\n    alignCenterLabel: 'Poravnaj središnje',\n    alignJustifyLabel: 'Poravnaj opravdaj',\n    alignLeftLabel: 'Poravnaj lijevo',\n    alignRightLabel: 'Poravnaj desno',\n  },\n  hu: {\n    alignCenterLabel: 'Középre igazítás',\n    alignJustifyLabel: 'Igazítás Sorkizárás',\n    alignLeftLabel: 'Igazítás balra',\n    alignRightLabel: 'Igazítás jobbra',\n  },\n  is: {\n    alignCenterLabel: 'Miðju jöfnun',\n    alignJustifyLabel: 'Samræmd jöfnun',\n    alignLeftLabel: 'Vinstri jöfnun',\n    alignRightLabel: 'Hægri jöfnun',\n  },\n  it: {\n    alignCenterLabel: 'Allinea al centro',\n    alignJustifyLabel: 'Allinea Giustifica',\n    alignLeftLabel: 'Allinea a sinistra',\n    alignRightLabel: 'Allinea a destra',\n  },\n  ja: {\n    alignCenterLabel: '中央揃え',\n    alignJustifyLabel: '両端揃え',\n    alignLeftLabel: '左揃え',\n    alignRightLabel: '右揃え',\n  },\n  ko: {\n    alignCenterLabel: '중앙 정렬',\n    alignJustifyLabel: '정렬 맞춤',\n    alignLeftLabel: '왼쪽 정렬',\n    alignRightLabel: '오른쪽 정렬',\n  },\n  my: {\n    alignCenterLabel: 'Pusat Selaras',\n    alignJustifyLabel: 'Penjajaran Justify',\n    alignLeftLabel: 'ဘယ်ဘက်ဦးတည်ခြင်း',\n    alignRightLabel: 'Penjajaran Kanan',\n  },\n  nb: {\n    alignCenterLabel: 'Sentrer tekst',\n    alignJustifyLabel: 'Juster linje',\n    alignLeftLabel: 'Juster til venstre',\n    alignRightLabel: 'Juster til høyre',\n  },\n  nl: {\n    alignCenterLabel: 'Centreer uitlijnen',\n    alignJustifyLabel: 'Uitlijnen Rechtvaardigen',\n    alignLeftLabel: 'Links uitlijnen',\n    alignRightLabel: 'Rechts uitlijnen',\n  },\n  pl: {\n    alignCenterLabel: 'Wyśrodkuj',\n    alignJustifyLabel: 'Wyjustuj wyrównanie',\n    alignLeftLabel: 'Wyrównaj do lewej',\n    alignRightLabel: 'Wyrównaj do prawej',\n  },\n  pt: {\n    alignCenterLabel: 'Alinhar ao Centro',\n    alignJustifyLabel: 'Alinhar Justificar',\n    alignLeftLabel: 'Alinhar à Esquerda',\n    alignRightLabel: 'Alinhar à Direita',\n  },\n  ro: {\n    alignCenterLabel: 'Aliniați Centrul',\n    alignJustifyLabel: 'Aliniaza Justifica',\n    alignLeftLabel: 'Aliniați la stânga',\n    alignRightLabel: 'Aliniați la dreapta',\n  },\n  rs: {\n    alignCenterLabel: 'Поравнај по средини',\n    alignJustifyLabel: 'Поравнај обострано',\n    alignLeftLabel: 'Поравнај лево',\n    alignRightLabel: 'Поравнај десно',\n  },\n  'rs-latin': {\n    alignCenterLabel: 'Poravnaj po sredini',\n    alignJustifyLabel: 'Poravnaj obostrano',\n    alignLeftLabel: 'Poravnaj levo',\n    alignRightLabel: 'Poravnaj desno',\n  },\n  ru: {\n    alignCenterLabel: 'Выровнять по центру',\n    alignJustifyLabel: 'Выровнять по ширине',\n    alignLeftLabel: 'Выровнять по левому краю',\n    alignRightLabel: 'Выровнять по правому краю',\n  },\n  sk: {\n    alignCenterLabel: 'Vycentrovať',\n    alignJustifyLabel: 'Zarovnať do bloku',\n    alignLeftLabel: 'Zarovnať doľava',\n    alignRightLabel: 'Zarovnať doprava',\n  },\n  sl: {\n    alignCenterLabel: 'Poravnaj na sredino',\n    alignJustifyLabel: 'Poravnaj Obojestransko',\n    alignLeftLabel: 'Poravnaj na levo',\n    alignRightLabel: 'Poravnaj na desno',\n  },\n  sv: {\n    alignCenterLabel: 'Centrera',\n    alignJustifyLabel: 'Justera Justify',\n    alignLeftLabel: 'Justera till vänster',\n    alignRightLabel: 'Justera till höger',\n  },\n  ta: {\n    alignCenterLabel: 'மையத்தில் ஒழுங்குபடுத்து',\n    alignJustifyLabel: 'இருபுறமும் ஒழுங்குபடுத்து',\n    alignLeftLabel: 'இடப்புறத்தில் ஒழுங்குபடுத்து',\n    alignRightLabel: 'வலப்புறத்தில் ஒழுங்குபடுத்து',\n  },\n  th: {\n    alignCenterLabel: 'จัดแนวกึ่งกลาง',\n    alignJustifyLabel: 'จัดแนวตรง',\n    alignLeftLabel: 'จัดชิดซ้าย',\n    alignRightLabel: 'จัดชิดขวา',\n  },\n  tr: {\n    alignCenterLabel: 'Ortaya Hizala',\n    alignJustifyLabel: 'Hizala Yasla',\n    alignLeftLabel: 'Sola Hizala',\n    alignRightLabel: 'Sağa Hizala',\n  },\n  uk: {\n    alignCenterLabel: 'Вирівняти по центру',\n    alignJustifyLabel: 'Вирівняти за шириною',\n    alignLeftLabel: 'Вирівняти по лівому краю',\n    alignRightLabel: 'Вирівняти по правому краю',\n  },\n  vi: {\n    alignCenterLabel: 'Căn giữa',\n    alignJustifyLabel: 'Căn đều',\n    alignLeftLabel: 'Căn lề trái',\n    alignRightLabel: 'Căn phải',\n  },\n  zh: {\n    alignCenterLabel: '居中对齐',\n    alignJustifyLabel: '对齐调整',\n    alignLeftLabel: '向左对齐',\n    alignRightLabel: '向右对齐',\n  },\n  'zh-TW': {\n    alignCenterLabel: '對齊中心',\n    alignJustifyLabel: '對齊並排列',\n    alignLeftLabel: '向左對齊',\n    alignRightLabel: '向右對齊',\n  },\n}\n"],"names":["i18n","ar","alignCenterLabel","alignJustifyLabel","alignLeftLabel","alignRightLabel","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","is","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","ta","th","tr","uk","vi","zh"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 513, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/align/server/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/align/server/index.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { i18n } from './i18n.js'\n\nexport const AlignFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#AlignFeatureClient',\n    i18n,\n  },\n  key: 'align',\n})\n"],"names":["createServerFeature","i18n","AlignFeature","feature","ClientFeature","key"],"mappings":";;;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,IAAI,QAAQ;;;AAEd,MAAMC,YAAA,OAAeF,gaAAA,EAAoB;IAC9CG,OAAA,EAAS;QACPC,aAAA,EAAe;cACfH,oZAAAA;IACF;IACAI,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 532, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/validate/hasText.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/validate/hasText.ts"],"sourcesContent":["import type {\n  SerializedEditorState,\n  SerializedLexicalNode,\n  SerializedParagraphNode,\n  SerializedTextNode,\n} from 'lexical'\n\nexport function hasText(\n  value: null | SerializedEditorState<SerializedLexicalNode> | undefined,\n): boolean {\n  const hasChildren = !!value?.root?.children?.length\n\n  let hasOnlyEmptyParagraph = false\n  if (value?.root?.children?.length === 1) {\n    if (value?.root?.children[0]?.type === 'paragraph') {\n      const paragraphNode = value?.root?.children[0] as SerializedParagraphNode\n\n      if (!paragraphNode?.children || paragraphNode?.children?.length === 0) {\n        hasOnlyEmptyParagraph = true\n      } else if (paragraphNode?.children?.length === 1) {\n        const paragraphNodeChild = paragraphNode?.children[0]\n        if (paragraphNodeChild?.type === 'text') {\n          if (!(paragraphNodeChild as SerializedTextNode | undefined)?.['text']?.length) {\n            hasOnlyEmptyParagraph = true\n          }\n        }\n      }\n    }\n  }\n\n  if (!hasChildren || hasOnlyEmptyParagraph) {\n    return false\n  } else {\n    return true\n  }\n}\n"],"names":["hasText","value","hasChildren","root","children","length","hasOnlyEmptyParagraph","type","paragraphNode","paragraphNodeChild"],"mappings":";;;;AAOO,SAASA,QACdC,KAAsE;IAEtE,MAAMC,WAAA,GAAc,CAAC,CAACD,KAAA,EAAOE,IAAA,EAAMC,QAAA,EAAUC,MAAA;IAE7C,IAAIC,qBAAA,GAAwB;IAC5B,IAAIL,KAAA,EAAOE,IAAA,EAAMC,QAAA,EAAUC,MAAA,KAAW,GAAG;QACvC,IAAIJ,KAAA,EAAOE,IAAA,EAAMC,QAAQ,CAAC,EAAE,EAAEG,IAAA,KAAS,aAAa;YAClD,MAAMC,aAAA,GAAgBP,KAAA,EAAOE,IAAA,EAAMC,QAAQ,CAAC,EAAE;YAE9C,IAAI,CAACI,aAAA,EAAeJ,QAAA,IAAYI,aAAA,EAAeJ,QAAA,EAAUC,MAAA,KAAW,GAAG;gBACrEC,qBAAA,GAAwB;YAC1B,OAAO,IAAIE,aAAA,EAAeJ,QAAA,EAAUC,MAAA,KAAW,GAAG;gBAChD,MAAMI,kBAAA,GAAqBD,aAAA,EAAeJ,QAAQ,CAAC,EAAE;gBACrD,IAAIK,kBAAA,EAAoBF,IAAA,KAAS,QAAQ;oBACvC,IAAI,CAAEE,kBAAA,EAAA,CAAwD,OAAO,EAAEJ,MAAA,EAAQ;wBAC7EC,qBAAA,GAAwB;oBAC1B;gBACF;YACF;QACF;IACF;IAEA,IAAI,CAACJ,WAAA,IAAeI,qBAAA,EAAuB;QACzC,OAAO;IACT,OAAO;QACL,OAAO;IACT;AACF","ignoreList":[]}},
    {"offset": {"line": 564, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/converters/lexicalToHtml_deprecated/converter/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToHtml_deprecated/converter/index.ts"],"sourcesContent":["import type { SerializedEditorState, SerializedLexicalNode } from 'lexical'\nimport type { Payload, PayloadRequest } from 'payload'\n\nimport { createLocalReq } from 'payload'\n\nimport type { HTMLConverter, SerializedLexicalNodeWithParent } from './types.js'\n\nimport { hasText } from '../../../../validate/hasText.js'\n\n/**\n * @deprecated - will be removed in 4.0\n */\nexport type ConvertLexicalToHTMLArgs = {\n  converters: HTMLConverter[]\n  currentDepth?: number\n  data: SerializedEditorState\n  depth?: number\n  draft?: boolean // default false\n  overrideAccess?: boolean // default false\n  showHiddenFields?: boolean // default false\n} & (\n  | {\n      /**\n       * This payload property will only be used if req is undefined.\n       */\n      payload?: never\n      /**\n       * When the converter is called, req CAN be passed in depending on where it's run.\n       * If this is undefined and config is passed through, lexical will create a new req object for you. If this is null or\n       * config is undefined, lexical will not create a new req object for you and local API / server-side-only\n       * functionality will be disabled.\n       */\n      req: PayloadRequest\n    }\n  | {\n      /**\n       * This payload property will only be used if req is undefined.\n       */\n      payload?: Payload\n      /**\n       * When the converter is called, req CAN be passed in depending on where it's run.\n       * If this is undefined and config is passed through, lexical will create a new req object for you. If this is null or\n       * config is undefined, lexical will not create a new req object for you and local API / server-side-only\n       * functionality will be disabled.\n       */\n      req?: null | undefined\n    }\n)\n\n/**\n * @deprecated - will be removed in 4.0. Use the function exported from `@payloadcms/richtext-lexical/html` instead.\n * @example\n * ```ts\n * // old (deprecated)\n * import { convertLexicalToHTML } from '@payloadcms/richtext-lexical'\n * // new (recommended)\n * import { convertLexicalToHTML } from '@payloadcms/richtext-lexical/html'\n * ```\n * For more details, you can refer to https://payloadcms.com/docs/rich-text/converting-html to see all the\n * ways to convert lexical to HTML.\n */\nexport async function convertLexicalToHTML({\n  converters,\n  currentDepth,\n  data,\n  depth,\n  draft,\n  overrideAccess,\n  payload,\n  req,\n  showHiddenFields,\n}: ConvertLexicalToHTMLArgs): Promise<string> {\n  if (hasText(data)) {\n    if (req === undefined && payload) {\n      req = await createLocalReq({}, payload)\n    }\n\n    if (!currentDepth) {\n      currentDepth = 0\n    }\n\n    if (!depth) {\n      depth = req?.payload?.config?.defaultDepth\n    }\n\n    return await convertLexicalNodesToHTML({\n      converters,\n      currentDepth,\n      depth: depth!,\n      draft: draft === undefined ? false : draft,\n      lexicalNodes: data?.root?.children,\n      overrideAccess: overrideAccess === undefined ? false : overrideAccess,\n      parent: data?.root,\n      req: req!,\n      showHiddenFields: showHiddenFields === undefined ? false : showHiddenFields,\n    })\n  }\n  return ''\n}\n\n/**\n * @deprecated - will be removed in 4.0\n */\nexport async function convertLexicalNodesToHTML({\n  converters,\n  currentDepth,\n  depth,\n  draft,\n  lexicalNodes,\n  overrideAccess,\n  parent,\n  req,\n  showHiddenFields,\n}: {\n  converters: HTMLConverter[]\n  currentDepth: number\n  depth: number\n  draft: boolean\n  lexicalNodes: SerializedLexicalNode[]\n  overrideAccess: boolean\n  parent: SerializedLexicalNodeWithParent\n  /**\n   * When the converter is called, req CAN be passed in depending on where it's run.\n   */\n  req: null | PayloadRequest\n  showHiddenFields: boolean\n}): Promise<string> {\n  const unknownConverter = converters.find((converter) => converter.nodeTypes.includes('unknown'))\n\n  const htmlArray = await Promise.all(\n    lexicalNodes.map(async (node, i) => {\n      const converterForNode = converters.find((converter) =>\n        converter.nodeTypes.includes(node.type),\n      )\n      try {\n        if (!converterForNode) {\n          if (unknownConverter) {\n            return await unknownConverter.converter({\n              childIndex: i,\n              converters,\n              currentDepth,\n              depth,\n              draft,\n              node,\n              overrideAccess,\n              parent,\n              req,\n              showHiddenFields,\n            })\n          }\n          return '<span>unknown node</span>'\n        }\n        return await converterForNode.converter({\n          childIndex: i,\n          converters,\n          currentDepth,\n          depth,\n          draft,\n          node,\n          overrideAccess,\n          parent,\n          req,\n          showHiddenFields,\n        })\n      } catch (error) {\n        console.error('Error converting lexical node to HTML:', error, 'node:', node)\n        return ''\n      }\n    }),\n  )\n\n  return htmlArray.join('') || ''\n}\n"],"names":["createLocalReq","hasText","convertLexicalToHTML","converters","currentDepth","data","depth","draft","overrideAccess","payload","req","showHiddenFields","undefined","config","defaultDepth","convertLexicalNodesToHTML","lexicalNodes","root","children","parent","unknownConverter","find","converter","nodeTypes","includes","htmlArray","Promise","all","map","node","i","converterForNode","type","childIndex","error","console","join"],"mappings":";;;;;;AAGA,SAASA,cAAc,QAAQ;AAI/B,SAASC,OAAO,QAAQ;;;AAsDjB,eAAeC,qBAAqB,EACzCC,UAAU,EACVC,YAAY,EACZC,IAAI,EACJC,KAAK,EACLC,KAAK,EACLC,cAAc,EACdC,OAAO,EACPC,GAAG,EACHC,gBAAAA,EACyB;IACzB,QAAIV,uYAAA,EAAQI,IAAA,GAAO;QACjB,IAAIK,GAAA,KAAQE,SAAA,IAAaH,OAAA,EAAS;YAChCC,GAAA,GAAM,UAAMV,wRAAA,EAAe,CAAC,GAAGS,OAAA;QACjC;QAEA,IAAI,CAACL,YAAA,EAAc;YACjBA,YAAA,GAAe;QACjB;QAEA,IAAI,CAACE,KAAA,EAAO;YACVA,KAAA,GAAQI,GAAA,EAAKD,OAAA,EAASI,MAAA,EAAQC,YAAA;QAChC;QAEA,OAAO,MAAMC,yBAAA,CAA0B;YACrCZ,UAAA;YACAC,YAAA;YACAE,KAAA,EAAOA,KAAA;YACPC,KAAA,EAAOA,KAAA,KAAUK,SAAA,GAAY,QAAQL,KAAA;YACrCS,YAAA,EAAcX,IAAA,EAAMY,IAAA,EAAMC,QAAA;YAC1BV,cAAA,EAAgBA,cAAA,KAAmBI,SAAA,GAAY,QAAQJ,cAAA;YACvDW,MAAA,EAAQd,IAAA,EAAMY,IAAA;YACdP,GAAA,EAAKA,GAAA;YACLC,gBAAA,EAAkBA,gBAAA,KAAqBC,SAAA,GAAY,QAAQD;QAC7D;IACF;IACA,OAAO;AACT;AAKO,eAAeI,0BAA0B,EAC9CZ,UAAU,EACVC,YAAY,EACZE,KAAK,EACLC,KAAK,EACLS,YAAY,EACZR,cAAc,EACdW,MAAM,EACNT,GAAG,EACHC,gBAAAA,EAcD;IACC,MAAMS,gBAAA,GAAmBjB,UAAA,CAAWkB,IAAI,EAAEC,SAAA,GAAcA,SAAA,CAAUC,SAAS,CAACC,QAAQ,CAAC;IAErF,MAAMC,SAAA,GAAY,MAAMC,OAAA,CAAQC,GAAG,CACjCX,YAAA,CAAaY,GAAG,CAAC,OAAOC,IAAA,EAAMC,CAAA;QAC5B,MAAMC,gBAAA,GAAmB5B,UAAA,CAAWkB,IAAI,EAAEC,SAAA,GACxCA,SAAA,CAAUC,SAAS,CAACC,QAAQ,CAACK,IAAA,CAAKG,IAAI;QAExC,IAAI;YACF,IAAI,CAACD,gBAAA,EAAkB;gBACrB,IAAIX,gBAAA,EAAkB;oBACpB,OAAO,MAAMA,gBAAA,CAAiBE,SAAS,CAAC;wBACtCW,UAAA,EAAYH,CAAA;wBACZ3B,UAAA;wBACAC,YAAA;wBACAE,KAAA;wBACAC,KAAA;wBACAsB,IAAA;wBACArB,cAAA;wBACAW,MAAA;wBACAT,GAAA;wBACAC;oBACF;gBACF;gBACA,OAAO;YACT;YACA,OAAO,MAAMoB,gBAAA,CAAiBT,SAAS,CAAC;gBACtCW,UAAA,EAAYH,CAAA;gBACZ3B,UAAA;gBACAC,YAAA;gBACAE,KAAA;gBACAC,KAAA;gBACAsB,IAAA;gBACArB,cAAA;gBACAW,MAAA;gBACAT,GAAA;gBACAC;YACF;QACF,EAAE,OAAOuB,KAAA,EAAO;YACdC,OAAA,CAAQD,KAAK,CAAC,0CAA0CA,KAAA,EAAO,SAASL,IAAA;YACxE,OAAO;QACT;IACF;IAGF,OAAOJ,SAAA,CAAUW,IAAI,CAAC,OAAO;AAC/B","ignoreList":[]}},
    {"offset": {"line": 644, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/typeUtilities.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/typeUtilities.ts"],"sourcesContent":["import type { LexicalNode } from 'lexical'\n\nimport type { NodeWithHooks } from './typesServer.js'\n\n/**\n * Utility function to create a node with hooks. You don't have to use this utility, but it improves type inference\n * @param node the node\n */\nexport function createNode<Node extends LexicalNode>(\n  node: NodeWithHooks<Node>,\n): NodeWithHooks<Node> {\n  return node\n}\n"],"names":["createNode","node"],"mappings":"AAIA;;;GAIA;;;;AAAO,SAASA,WACdC,IAAyB;IAEzB,OAAOA,IAAA;AACT","ignoreList":[]}},
    {"offset": {"line": 658, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/blockquote/markdownTransformer.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blockquote/markdownTransformer.ts"],"sourcesContent":["import { $createQuoteNode, $isQuoteNode, QuoteNode } from '@lexical/rich-text'\n\nimport type { ElementTransformer } from '../../packages/@lexical/markdown/index.js'\n\nexport const MarkdownTransformer: ElementTransformer = {\n  type: 'element',\n  dependencies: [QuoteNode],\n  export: (node, exportChildren) => {\n    if (!$isQuoteNode(node)) {\n      return null\n    }\n\n    const lines = exportChildren(node).split('\\n')\n    const output: string[] = []\n    for (const line of lines) {\n      output.push('> ' + line)\n    }\n    return output.join('\\n')\n  },\n  regExp: /^>\\s/,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling()\n      if ($isQuoteNode(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [...children])\n        previousNode.select(0, 0)\n        parentNode.remove()\n        return\n      }\n    }\n\n    const node = $createQuoteNode()\n    node.append(...children)\n    parentNode.replace(node)\n    node.select(0, 0)\n  },\n}\n"],"names":["$createQuoteNode","$isQuoteNode","QuoteNode","MarkdownTransformer","type","dependencies","export","node","exportChildren","lines","split","output","line","push","join","regExp","replace","parentNode","children","_match","isImport","previousNode","getPreviousSibling","splice","getChildrenSize","select","remove","append"],"mappings":";;;;AAAA,SAASA,gBAAgB,EAAEC,YAAY,EAAEC,SAAS,QAAQ;;AAInD,MAAMC,mBAAA,GAA0C;IACrDC,IAAA,EAAM;IACNC,YAAA,EAAc;QAACH,wPAAA;KAAU;IACzBI,MAAA,EAAQA,CAACC,IAAA,EAAMC,cAAA;QACb,IAAI,KAACP,2PAAA,EAAaM,IAAA,GAAO;YACvB,OAAO;QACT;QAEA,MAAME,KAAA,GAAQD,cAAA,CAAeD,IAAA,EAAMG,KAAK,CAAC;QACzC,MAAMC,MAAA,GAAmB,EAAE;QAC3B,KAAK,MAAMC,IAAA,IAAQH,KAAA,CAAO;YACxBE,MAAA,CAAOE,IAAI,CAAC,OAAOD,IAAA;QACrB;QACA,OAAOD,MAAA,CAAOG,IAAI,CAAC;IACrB;IACAC,MAAA,EAAQ;IACRC,OAAA,EAASA,CAACC,UAAA,EAAYC,QAAA,EAAUC,MAAA,EAAQC,QAAA;QACtC,IAAIA,QAAA,EAAU;YACZ,MAAMC,YAAA,GAAeJ,UAAA,CAAWK,kBAAkB;YAClD,QAAIrB,2PAAA,EAAaoB,YAAA,GAAe;gBAC9BA,YAAA,CAAaE,MAAM,CAACF,YAAA,CAAaG,eAAe,IAAI,GAAG,C;uBAAIN,QAAA;iBAAS;gBACpEG,YAAA,CAAaI,MAAM,CAAC,GAAG;gBACvBR,UAAA,CAAWS,MAAM;gBACjB;YACF;QACF;QAEA,MAAMnB,IAAA,OAAOP,+PAAA;QACbO,IAAA,CAAKoB,MAAM,IAAIT,QAAA;QACfD,UAAA,CAAWD,OAAO,CAACT,IAAA;QACnBA,IAAA,CAAKkB,MAAM,CAAC,GAAG;IACjB;AACF","ignoreList":[]}},
    {"offset": {"line": 703, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/blockquote/server/i18n.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blockquote/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'اقتباس',\n  },\n  az: {\n    label: 'Blokkvota',\n  },\n  bg: {\n    label: 'Цитат',\n  },\n  cs: {\n    label: 'Citace',\n  },\n  da: {\n    label: 'Blokering',\n  },\n  de: {\n    label: 'Blockzitat',\n  },\n  en: {\n    label: 'Blockquote',\n  },\n  es: {\n    label: 'Cita en bloque',\n  },\n  et: {\n    label: 'Tsitaat',\n  },\n  fa: {\n    label: 'نقل قول بلوکی',\n  },\n  fr: {\n    label: 'Citation',\n  },\n  he: {\n    label: 'בלוק ציטוט',\n  },\n  hr: {\n    label: 'Blok citat',\n  },\n  hu: {\n    label: 'Idézetblokk',\n  },\n  is: {\n    label: 'Tilvitnun',\n  },\n  it: {\n    label: 'Citazione',\n  },\n  ja: {\n    label: 'ブロッククォート',\n  },\n  ko: {\n    label: '인용구',\n  },\n  my: {\n    label: 'ဒေါင်းချီးခြင်း',\n  },\n  nb: {\n    label: 'Blokksitat',\n  },\n  nl: {\n    label: 'Citaat',\n  },\n  pl: {\n    label: 'Cytat blokowy',\n  },\n  pt: {\n    label: 'Citação em bloco',\n  },\n  ro: {\n    label: 'Citat',\n  },\n  rs: {\n    label: 'Блок цитата',\n  },\n  'rs-latin': {\n    label: 'Blok citata',\n  },\n  ru: {\n    label: 'Цитата',\n  },\n  sk: {\n    label: 'Citát',\n  },\n  sl: {\n    label: 'Citat',\n  },\n  sv: {\n    label: 'Blockcitat',\n  },\n  ta: {\n    label: 'கட்டமைப்பு மேற்கோள்',\n  },\n  th: {\n    label: 'ข้อความอ้างอิง',\n  },\n  tr: {\n    label: 'Alıntı',\n  },\n  uk: {\n    label: 'Блокцитата',\n  },\n  vi: {\n    label: 'Trích dẫn',\n  },\n  zh: {\n    label: '引用区块',\n  },\n  'zh-TW': {\n    label: '引用塊',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","is","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","ta","th","tr","uk","vi","zh"],"mappings":";;;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA8B,EAAA,EAAI;QACF9B,KAAA,EAAO;IACT;IACA+B,EAAA,EAAI;QACF/B,KAAA,EAAO;IACT;IACAgC,EAAA,EAAI;QACFhC,KAAA,EAAO;IACT;IACAiC,EAAA,EAAI;QACFjC,KAAA,EAAO;IACT;IACAkC,EAAA,EAAI;QACFlC,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF","ignoreList":[]}},
    {"offset": {"line": 824, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/blockquote/server/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blockquote/server/index.ts"],"sourcesContent":["import type { SerializedQuoteNode as _SerializedQuoteNode } from '@lexical/rich-text'\nimport type { SerializedLexicalNode } from 'lexical'\n\nimport { QuoteNode } from '@lexical/rich-text'\n\nimport type { StronglyTypedElementNode } from '../../../nodeTypes.js'\n\nimport { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { convertLexicalNodesToHTML } from '../../converters/lexicalToHtml_deprecated/converter/index.js'\nimport { createNode } from '../../typeUtilities.js'\nimport { MarkdownTransformer } from '../markdownTransformer.js'\nimport { i18n } from './i18n.js'\n\nexport type SerializedQuoteNode<T extends SerializedLexicalNode = SerializedLexicalNode> =\n  StronglyTypedElementNode<_SerializedQuoteNode, 'quote', T>\n\nexport const BlockquoteFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#BlockquoteFeatureClient',\n    clientFeatureProps: null,\n    i18n,\n    markdownTransformers: [MarkdownTransformer],\n    nodes: [\n      createNode({\n        converters: {\n          html: {\n            converter: async ({\n              converters,\n              currentDepth,\n              depth,\n              draft,\n              node,\n              overrideAccess,\n              parent,\n              req,\n              showHiddenFields,\n            }) => {\n              const childrenText = await convertLexicalNodesToHTML({\n                converters,\n                currentDepth,\n                depth,\n                draft,\n                lexicalNodes: node.children,\n                overrideAccess,\n                parent: {\n                  ...node,\n                  parent,\n                },\n                req,\n                showHiddenFields,\n              })\n              const style = [\n                node.format ? `text-align: ${node.format};` : '',\n                // the unit should be px. Do not change it to rem, em, or something else.\n                // The quantity should be 40px. Do not change it either.\n                // See rationale in\n                // https://github.com/payloadcms/payload/issues/13130#issuecomment-3058348085\n                node.indent > 0 ? `padding-inline-start: ${node.indent * 40}px;` : '',\n              ]\n                .filter(Boolean)\n                .join(' ')\n\n              return `<blockquote${style ? ` style='${style}'` : ''}>${childrenText}</blockquote>`\n            },\n            nodeTypes: [QuoteNode.getType()],\n          },\n        },\n        node: QuoteNode,\n      }),\n    ],\n  },\n  key: 'blockquote',\n})\n"],"names":["QuoteNode","createServerFeature","convertLexicalNodesToHTML","createNode","MarkdownTransformer","i18n","BlockquoteFeature","feature","ClientFeature","clientFeatureProps","markdownTransformers","nodes","converters","html","converter","currentDepth","depth","draft","node","overrideAccess","parent","req","showHiddenFields","childrenText","lexicalNodes","children","style","format","indent","filter","Boolean","join","nodeTypes","getType","key"],"mappings":";;;;AAGA,SAASA,SAAS,QAAQ;AAI1B,SAASC,mBAAmB,QAAQ;AACpC,SAASC,yBAAyB,QAAQ;AAC1C,SAASC,UAAU,QAAQ;AAC3B,SAASC,mBAAmB,QAAQ;AACpC,SAASC,IAAI,QAAQ;;;;;;;AAKd,MAAMC,iBAAA,OAAoBL,gaAAA,EAAoB;IACnDM,OAAA,EAAS;QACPC,aAAA,EAAe;QACfC,kBAAA,EAAoB;cACpBJ,yZAAA;QACAK,oBAAA,EAAsB;YAACN,6aAAA;SAAoB;QAC3CO,KAAA,EAAO;gBACLR,gZAAA,EAAW;gBACTS,UAAA,EAAY;oBACVC,IAAA,EAAM;wBACJC,SAAA,EAAW,MAAAA,CAAO,EAChBF,UAAU,EACVG,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdC,MAAM,EACNC,GAAG,EACHC,gBAAAA,EACD;4BACC,MAAMC,YAAA,GAAe,UAAMrB,8cAAA,EAA0B;gCACnDU,UAAA;gCACAG,YAAA;gCACAC,KAAA;gCACAC,KAAA;gCACAO,YAAA,EAAcN,IAAA,CAAKO,QAAQ;gCAC3BN,cAAA;gCACAC,MAAA,EAAQ;oCACN,GAAGF,IAAI;oCACPE;gCACF;gCACAC,GAAA;gCACAC;4BACF;4BACA,MAAMI,KAAA,GAAQ;gCACZR,IAAA,CAAKS,MAAM,GAAG,CAAA,YAAA,EAAeT,IAAA,CAAKS,MAAM,CAAA,CAAA,CAAG,GAAG;gCAC9C,yEAAA;gCACA,wDAAA;gCACA,mBAAA;gCACA,6EAAA;gCACAT,IAAA,CAAKU,MAAM,GAAG,IAAI,CAAA,sBAAA,EAAyBV,IAAA,CAAKU,MAAM,GAAG,GAAA,GAAA,CAAO,GAAG;6BACpE,CACEC,MAAM,CAACC,OAAA,EACPC,IAAI,CAAC;4BAER,OAAO,CAAA,WAAA,EAAcL,KAAA,GAAQ,CAAA,QAAA,EAAWA,KAAA,CAAA,CAAA,CAAQ,GAAG,GAAA,CAAA,EAAMH,YAAA,CAAA,aAAA,CAA2B;wBACtF;wBACAS,SAAA,EAAW;4BAAChC,wPAAA,CAAUiC,OAAO;yBAAA;oBAC/B;gBACF;gBACAf,IAAA,EAAMlB,wPAAAA;YACR;SAAA;IAEJ;IACAkC,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 892, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/format/bold/markdownTransformers.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/bold/markdownTransformers.ts"],"sourcesContent":["import type { TextFormatTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nexport const BOLD_ITALIC_STAR: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['bold', 'italic'],\n  tag: '***',\n}\n\nexport const BOLD_ITALIC_UNDERSCORE: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n}\n\nexport const BOLD_STAR: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['bold'],\n  tag: '**',\n}\n\nexport const BOLD_UNDERSCORE: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n}\n"],"names":["BOLD_ITALIC_STAR","type","format","tag","BOLD_ITALIC_UNDERSCORE","intraword","BOLD_STAR","BOLD_UNDERSCORE"],"mappings":";;;;;;;;;;AAEO,MAAMA,gBAAA,GAA0C;IACrDC,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;QAAQ;KAAS;IAC1BC,GAAA,EAAK;AACP;AAEO,MAAMC,sBAAA,GAAgD;IAC3DH,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;QAAQ;KAAS;IAC1BG,SAAA,EAAW;IACXF,GAAA,EAAK;AACP;AAEO,MAAMG,SAAA,GAAmC;IAC9CL,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;KAAO;IAChBC,GAAA,EAAK;AACP;AAEO,MAAMI,eAAA,GAAyC;IACpDN,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;KAAO;IAChBG,SAAA,EAAW;IACXF,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 938, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/format/bold/feature.server.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/bold/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport {\n  BOLD_ITALIC_STAR,\n  BOLD_ITALIC_UNDERSCORE,\n  BOLD_STAR,\n  BOLD_UNDERSCORE,\n} from './markdownTransformers.js'\n\nexport const BoldFeature = createServerFeature({\n  dependenciesSoft: ['italic'],\n  feature: ({ featureProviderMap }) => {\n    const markdownTransformers = [BOLD_STAR, BOLD_UNDERSCORE]\n    if (featureProviderMap.get('italic')) {\n      markdownTransformers.push(BOLD_ITALIC_UNDERSCORE, BOLD_ITALIC_STAR)\n    }\n\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#BoldFeatureClient',\n      markdownTransformers,\n    }\n  },\n  key: 'bold',\n})\n"],"names":["createServerFeature","BOLD_ITALIC_STAR","BOLD_ITALIC_UNDERSCORE","BOLD_STAR","BOLD_UNDERSCORE","BoldFeature","dependenciesSoft","feature","featureProviderMap","markdownTransformers","get","push","ClientFeature","key"],"mappings":";;;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SACEC,gBAAgB,EAChBC,sBAAsB,EACtBC,SAAS,EACTC,eAAe,QACV;;;AAEA,MAAMC,WAAA,OAAcL,gaAAA,EAAoB;IAC7CM,gBAAA,EAAkB;QAAC;KAAS;IAC5BC,OAAA,EAASA,CAAC,EAAEC,kBAAAA,EAAoB;QAC9B,MAAMC,oBAAA,GAAuB;YAACN,waAAA;YAAWC,8aAAA;SAAgB;QACzD,IAAII,kBAAA,CAAmBE,GAAG,CAAC,WAAW;YACpCD,oBAAA,CAAqBE,IAAI,CAACT,qbAAA,EAAwBD,+aAAA;QACpD;QAEA,OAAO;YACLW,aAAA,EAAe;YACfH;QACF;IACF;IACAI,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 969, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/format/inlineCode/markdownTransformers.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/inlineCode/markdownTransformers.ts"],"sourcesContent":["import type { TextFormatTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nexport const INLINE_CODE: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['code'],\n  tag: '`',\n}\n"],"names":["INLINE_CODE","type","format","tag"],"mappings":";;;;AAEO,MAAMA,WAAA,GAAqC;IAChDC,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;KAAO;IAChBC,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 984, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/format/inlineCode/feature.server.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/inlineCode/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { INLINE_CODE } from './markdownTransformers.js'\n\nexport const InlineCodeFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#InlineCodeFeatureClient',\n    markdownTransformers: [INLINE_CODE],\n  },\n  key: 'inlineCode',\n})\n"],"names":["createServerFeature","INLINE_CODE","InlineCodeFeature","feature","ClientFeature","markdownTransformers","key"],"mappings":";;;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,WAAW,QAAQ;;;AAErB,MAAMC,iBAAA,OAAoBF,gaAAA,EAAoB;IACnDG,OAAA,EAAS;QACPC,aAAA,EAAe;QACfC,oBAAA,EAAsB;YAACJ,gbAAA;SAAA;IACzB;IACAK,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 1005, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/format/italic/markdownTransformers.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/italic/markdownTransformers.ts"],"sourcesContent":["import type { TextFormatTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nexport const ITALIC_STAR: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['italic'],\n  tag: '*',\n}\n\nexport const ITALIC_UNDERSCORE: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n}\n"],"names":["ITALIC_STAR","type","format","tag","ITALIC_UNDERSCORE","intraword"],"mappings":";;;;;;AAEO,MAAMA,WAAA,GAAqC;IAChDC,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;KAAS;IAClBC,GAAA,EAAK;AACP;AAEO,MAAMC,iBAAA,GAA2C;IACtDH,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;KAAS;IAClBG,SAAA,EAAW;IACXF,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 1030, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/format/italic/feature.server.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/italic/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { ITALIC_STAR, ITALIC_UNDERSCORE } from './markdownTransformers.js'\n\nexport const ItalicFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#ItalicFeatureClient',\n    markdownTransformers: [ITALIC_STAR, ITALIC_UNDERSCORE],\n  },\n  key: 'italic',\n})\n"],"names":["createServerFeature","ITALIC_STAR","ITALIC_UNDERSCORE","ItalicFeature","feature","ClientFeature","markdownTransformers","key"],"mappings":";;;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,WAAW,EAAEC,iBAAiB,QAAQ;;;AAExC,MAAMC,aAAA,OAAgBH,gaAAA,EAAoB;IAC/CI,OAAA,EAAS;QACPC,aAAA,EAAe;QACfC,oBAAA,EAAsB;YAACL,4aAAA;YAAaC,kbAAA;SAAA;IACtC;IACAK,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 1052, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/format/strikethrough/markdownTransformers.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/strikethrough/markdownTransformers.ts"],"sourcesContent":["import type { TextFormatTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nexport const STRIKETHROUGH: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['strikethrough'],\n  tag: '~~',\n}\n"],"names":["STRIKETHROUGH","type","format","tag"],"mappings":";;;;AAEO,MAAMA,aAAA,GAAuC;IAClDC,IAAA,EAAM;IACNC,MAAA,EAAQ;QAAC;KAAgB;IACzBC,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 1067, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/format/strikethrough/feature.server.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/strikethrough/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { STRIKETHROUGH } from './markdownTransformers.js'\n\nexport const StrikethroughFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#StrikethroughFeatureClient',\n\n    markdownTransformers: [STRIKETHROUGH],\n  },\n  key: 'strikethrough',\n})\n"],"names":["createServerFeature","STRIKETHROUGH","StrikethroughFeature","feature","ClientFeature","markdownTransformers","key"],"mappings":";;;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,aAAa,QAAQ;;;AAEvB,MAAMC,oBAAA,OAAuBF,gaAAA,EAAoB;IACtDG,OAAA,EAAS;QACPC,aAAA,EAAe;QAEfC,oBAAA,EAAsB;YAACJ,qbAAA;SAAA;IACzB;IACAK,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 1088, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/format/subscript/feature.server.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/subscript/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\n\nexport const SubscriptFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#SubscriptFeatureClient',\n  },\n  key: 'subscript',\n})\n"],"names":["createServerFeature","SubscriptFeature","feature","ClientFeature","key"],"mappings":";;;;AAAA,SAASA,mBAAmB,QAAQ;;AAE7B,MAAMC,gBAAA,OAAmBD,gaAAA,EAAoB;IAClDE,OAAA,EAAS;QACPC,aAAA,EAAe;IACjB;IACAC,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 1104, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/format/superscript/feature.server.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/superscript/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\n\nexport const SuperscriptFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#SuperscriptFeatureClient',\n  },\n  key: 'superscript',\n})\n"],"names":["createServerFeature","SuperscriptFeature","feature","ClientFeature","key"],"mappings":";;;;AAAA,SAASA,mBAAmB,QAAQ;;AAE7B,MAAMC,kBAAA,OAAqBD,gaAAA,EAAoB;IACpDE,OAAA,EAAS;QACPC,aAAA,EAAe;IACjB;IACAC,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 1120, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/format/underline/feature.server.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/underline/feature.server.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\n\nexport const UnderlineFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#UnderlineFeatureClient',\n  },\n  key: 'underline',\n})\n"],"names":["createServerFeature","UnderlineFeature","feature","ClientFeature","key"],"mappings":";;;;AAAA,SAASA,mBAAmB,QAAQ;;AAE7B,MAAMC,gBAAA,OAAmBD,gaAAA,EAAoB;IAClDE,OAAA,EAAS;QACPC,aAAA,EAAe;IACjB;IACAC,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 1136, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/lexical/utils/markdown/createBlockNode.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/utils/markdown/createBlockNode.ts"],"sourcesContent":["import type { ElementNode } from 'lexical'\n\nimport type { ElementTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nexport const createBlockNode = (\n  createNode: (match: Array<string>) => ElementNode,\n): ElementTransformer['replace'] => {\n  return (parentNode, children, match) => {\n    const node = createNode(match)\n    if (node) {\n      node.append(...children)\n      parentNode.replace(node)\n      node.select(0, 0)\n    }\n  }\n}\n"],"names":["createBlockNode","createNode","parentNode","children","match","node","append","replace","select"],"mappings":";;;;AAIO,MAAMA,eAAA,IACXC,UAAA;IAEA,OAAO,CAACC,UAAA,EAAYC,QAAA,EAAUC,KAAA;QAC5B,MAAMC,IAAA,GAAOJ,UAAA,CAAWG,KAAA;QACxB,IAAIC,IAAA,EAAM;YACRA,IAAA,CAAKC,MAAM,IAAIH,QAAA;YACfD,UAAA,CAAWK,OAAO,CAACF,IAAA;YACnBA,IAAA,CAAKG,MAAM,CAAC,GAAG;QACjB;IACF;AACF","ignoreList":[]}},
    {"offset": {"line": 1154, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/heading/markdownTransformer.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/heading/markdownTransformer.ts"],"sourcesContent":["import type { HeadingTagType } from '@lexical/rich-text'\n\nimport { $createHeadingNode, $isHeadingNode, HeadingNode } from '@lexical/rich-text'\n\nimport type { ElementTransformer } from '../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport { createBlockNode } from '../../lexical/utils/markdown/createBlockNode.js'\n\nexport const MarkdownTransformer: (enabledHeadingSizes: HeadingTagType[]) => ElementTransformer = (\n  enabledHeadingSizes,\n) => {\n  // Convert enabledHeadingSizes to a list of numbers (1 for h1, 2 for h2, etc.)\n  const enabledSizes = enabledHeadingSizes.map((tag) => Number(tag.slice(1)))\n\n  // Create a regex pattern that matches any of the enabled sizes\n  const pattern = `^(${enabledSizes.map((size) => `#{${size}}`).join('|')})\\\\s`\n  const regExp = new RegExp(pattern)\n\n  return {\n    type: 'element',\n    dependencies: [HeadingNode],\n    export: (node, exportChildren) => {\n      if (!$isHeadingNode(node)) {\n        return null\n      }\n      const level = Number(node.getTag().slice(1))\n      return '#'.repeat(level) + ' ' + exportChildren(node)\n    },\n    regExp,\n    replace: createBlockNode((match) => {\n      const tag = ('h' + match[1]?.length) as HeadingTagType\n      return $createHeadingNode(tag)\n    }),\n  }\n}\n"],"names":["$createHeadingNode","$isHeadingNode","HeadingNode","createBlockNode","MarkdownTransformer","enabledHeadingSizes","enabledSizes","map","tag","Number","slice","pattern","size","join","regExp","RegExp","type","dependencies","export","node","exportChildren","level","getTag","repeat","replace","match","length"],"mappings":";;;;AAEA,SAASA,kBAAkB,EAAEC,cAAc,EAAEC,WAAW,QAAQ;AAIhE,SAASC,eAAe,QAAQ;;;AAEzB,MAAMC,mBAAA,IACXC,mBAAA;IAEA,8EAAA;IACA,MAAMC,YAAA,GAAeD,mBAAA,CAAoBE,GAAG,EAAEC,GAAA,GAAQC,MAAA,CAAOD,GAAA,CAAIE,KAAK,CAAC;IAEvE,+DAAA;IACA,MAAMC,OAAA,GAAU,CAAA,EAAA,EAAKL,YAAA,CAAaC,GAAG,EAAEK,IAAA,GAAS,CAAA,EAAA,EAAKA,IAAA,CAAA,CAAA,CAAO,EAAEC,IAAI,CAAC,KAAA,IAAA,CAAU;IAC7E,MAAMC,MAAA,GAAS,IAAIC,MAAA,CAAOJ,OAAA;IAE1B,OAAO;QACLK,IAAA,EAAM;QACNC,YAAA,EAAc;YAACf,0PAAA;SAAY;QAC3BgB,MAAA,EAAQA,CAACC,IAAA,EAAMC,cAAA;YACb,IAAI,KAACnB,6PAAA,EAAekB,IAAA,GAAO;gBACzB,OAAO;YACT;YACA,MAAME,KAAA,GAAQZ,MAAA,CAAOU,IAAA,CAAKG,MAAM,GAAGZ,KAAK,CAAC;YACzC,OAAO,IAAIa,MAAM,CAACF,KAAA,IAAS,MAAMD,cAAA,CAAeD,IAAA;QAClD;QACAL,MAAA;QACAU,OAAA,MAASrB,2aAAA,GAAiBsB,KAAA;YACxB,MAAMjB,GAAA,GAAO,MAAMiB,KAAK,CAAC,EAAE,EAAEC,MAAA;YAC7B,WAAO1B,iQAAA,EAAmBQ,GAAA;QAC5B;IACF;AACF","ignoreList":[]}},
    {"offset": {"line": 1191, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/heading/server/i18n.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/heading/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'العنوان {{headingLevel}}',\n  },\n  az: {\n    label: 'Başlıq {{headingLevel}}',\n  },\n  bg: {\n    label: 'Заглавие {{headingLevel}}',\n  },\n  cs: {\n    label: 'Nadpis {{headingLevel}}',\n  },\n  da: {\n    label: 'Overskrift {{overskriftNiveau}}',\n  },\n  de: {\n    label: 'Überschrift {{headingLevel}}',\n  },\n  en: {\n    label: 'Heading {{headingLevel}}',\n  },\n  es: {\n    label: 'Encabezado {{headingLevel}}',\n  },\n  et: {\n    label: 'Pealkiri {{headingLevel}}',\n  },\n  fa: {\n    label: '[SKIPPED]',\n  },\n  fr: {\n    label: 'En-tête {{headingLevel}}',\n  },\n  he: {\n    label: 'כותרת {{רמת כותרת}}',\n  },\n  hr: {\n    label: 'Naslov {{headingLevel}}',\n  },\n  hu: {\n    label: 'Címsor {{headingLevel}}',\n  },\n  is: {\n    label: 'Fyrirsögn {{headingLevel}}',\n  },\n  it: {\n    label: 'Intestazione {{headingLevel}}',\n  },\n  ja: {\n    label: '見出し{{headingLevel}}',\n  },\n  ko: {\n    label: '제목 {{headingLevel}}',\n  },\n  my: {\n    label: '[SURAT]\\n\\nKepala {{headingLevel}}',\n  },\n  nb: {\n    label: 'Overskrift {{headingLevel}}',\n  },\n  nl: {\n    label: 'Kop {{headingLevel}}',\n  },\n  pl: {\n    label: 'Nagłówek {{headingLevel}}',\n  },\n  pt: {\n    label: 'Cabeçalho {{headingLevel}}',\n  },\n  ro: {\n    label: 'Titlu {{headingLevel}}',\n  },\n  rs: {\n    label: 'Наслов {{headingLevel}}',\n  },\n  'rs-latin': {\n    label: 'Naslov {{headingLevel}}',\n  },\n  ru: {\n    label: 'Заголовок {{headingLevel}}',\n  },\n  sk: {\n    label: 'Nadpis {{headingLevel}}',\n  },\n  sl: {\n    label: 'Naslov {{headingLevel}}',\n  },\n  sv: {\n    label: 'Rubrik {{headingLevel}}',\n  },\n  ta: {\n    label: 'தலைப்பு {{headingLevel}}',\n  },\n  th: {\n    label: 'หัวข้อ {{headingLevel}}',\n  },\n  tr: {\n    label: 'Başlık {{headingLevel}}',\n  },\n  uk: {\n    label: 'Заголовок {{headingLevel}}',\n  },\n  vi: {\n    label: 'Tiêu đề {{headingLevel}}',\n  },\n  zh: {\n    label: '标题 {{headingLevel}}',\n  },\n  'zh-TW': {\n    label: '標題 {{headingLevel}}',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","is","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","ta","th","tr","uk","vi","zh"],"mappings":";;;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA8B,EAAA,EAAI;QACF9B,KAAA,EAAO;IACT;IACA+B,EAAA,EAAI;QACF/B,KAAA,EAAO;IACT;IACAgC,EAAA,EAAI;QACFhC,KAAA,EAAO;IACT;IACAiC,EAAA,EAAI;QACFjC,KAAA,EAAO;IACT;IACAkC,EAAA,EAAI;QACFlC,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF","ignoreList":[]}},
    {"offset": {"line": 1312, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/heading/server/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/heading/server/index.ts"],"sourcesContent":["import type {\n  SerializedHeadingNode as _SerializedHeadingNode,\n  HeadingTagType,\n} from '@lexical/rich-text'\nimport type { SerializedLexicalNode } from 'lexical'\n\nimport { HeadingNode } from '@lexical/rich-text'\n\nimport type { StronglyTypedElementNode } from '../../../nodeTypes.js'\n\nimport { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { convertLexicalNodesToHTML } from '../../converters/lexicalToHtml_deprecated/converter/index.js'\nimport { createNode } from '../../typeUtilities.js'\nimport { MarkdownTransformer } from '../markdownTransformer.js'\nimport { i18n } from './i18n.js'\n\nexport type SerializedHeadingNode<T extends SerializedLexicalNode = SerializedLexicalNode> =\n  StronglyTypedElementNode<_SerializedHeadingNode, 'heading', T>\n\nexport type HeadingFeatureProps = {\n  enabledHeadingSizes?: HeadingTagType[]\n}\n\nexport const HeadingFeature = createServerFeature<\n  HeadingFeatureProps,\n  HeadingFeatureProps,\n  HeadingFeatureProps\n>({\n  feature: ({ props }) => {\n    if (!props) {\n      props = {}\n    }\n\n    const { enabledHeadingSizes = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] } = props\n\n    enabledHeadingSizes.sort()\n\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#HeadingFeatureClient',\n      clientFeatureProps: props,\n      i18n,\n      markdownTransformers: [MarkdownTransformer(enabledHeadingSizes)],\n      nodes: [\n        createNode({\n          converters: {\n            html: {\n              converter: async ({\n                converters,\n                currentDepth,\n                depth,\n                draft,\n                node,\n                overrideAccess,\n                parent,\n                req,\n                showHiddenFields,\n              }) => {\n                const childrenText = await convertLexicalNodesToHTML({\n                  converters,\n                  currentDepth,\n                  depth,\n                  draft,\n                  lexicalNodes: node.children,\n                  overrideAccess,\n                  parent: {\n                    ...node,\n                    parent,\n                  },\n                  req,\n                  showHiddenFields,\n                })\n                const style = [\n                  node.format ? `text-align: ${node.format};` : '',\n                  // the unit should be px. Do not change it to rem, em, or something else.\n                  // The quantity should be 40px. Do not change it either.\n                  // See rationale in\n                  // https://github.com/payloadcms/payload/issues/13130#issuecomment-3058348085\n                  node.indent > 0 ? `padding-inline-start: ${node.indent * 40}px;` : '',\n                ]\n                  .filter(Boolean)\n                  .join(' ')\n                return `<${node?.tag}${style ? ` style='${style}'` : ''}>${childrenText}</${node?.tag}>`\n              },\n              nodeTypes: [HeadingNode.getType()],\n            },\n          },\n          node: HeadingNode,\n        }),\n      ],\n      sanitizedServerFeatureProps: props,\n    }\n  },\n  key: 'heading',\n})\n"],"names":["HeadingNode","createServerFeature","convertLexicalNodesToHTML","createNode","MarkdownTransformer","i18n","HeadingFeature","feature","props","enabledHeadingSizes","sort","ClientFeature","clientFeatureProps","markdownTransformers","nodes","converters","html","converter","currentDepth","depth","draft","node","overrideAccess","parent","req","showHiddenFields","childrenText","lexicalNodes","children","style","format","indent","filter","Boolean","join","tag","nodeTypes","getType","sanitizedServerFeatureProps","key"],"mappings":";;;;AAMA,SAASA,WAAW,QAAQ;AAI5B,SAASC,mBAAmB,QAAQ;AACpC,SAASC,yBAAyB,QAAQ;AAC1C,SAASC,UAAU,QAAQ;AAC3B,SAASC,mBAAmB,QAAQ;AACpC,SAASC,IAAI,QAAQ;;;;;;;AASd,MAAMC,cAAA,OAAiBL,gaAAA,EAI5B;IACAM,OAAA,EAASA,CAAC,EAAEC,KAAAA,EAAO;QACjB,IAAI,CAACA,KAAA,EAAO;YACVA,KAAA,GAAQ,CAAC;QACX;QAEA,MAAM,EAAEC,mBAAA,GAAsB;YAAC;YAAM;YAAM;YAAM;YAAM;YAAM;SAAA,EAAO,GAAGD,KAAA;QAEvEC,mBAAA,CAAoBC,IAAI;QAExB,OAAO;YACLC,aAAA,EAAe;YACfC,kBAAA,EAAoBJ,KAAA;kBACpBH,sZAAA;YACAQ,oBAAA,EAAsB;oBAACT,0aAAA,EAAoBK,mBAAA;aAAqB;YAChEK,KAAA,EAAO;oBACLX,gZAAA,EAAW;oBACTY,UAAA,EAAY;wBACVC,IAAA,EAAM;4BACJC,SAAA,EAAW,MAAAA,CAAO,EAChBF,UAAU,EACVG,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdC,MAAM,EACNC,GAAG,EACHC,gBAAAA,EACD;gCACC,MAAMC,YAAA,GAAe,UAAMxB,8cAAA,EAA0B;oCACnDa,UAAA;oCACAG,YAAA;oCACAC,KAAA;oCACAC,KAAA;oCACAO,YAAA,EAAcN,IAAA,CAAKO,QAAQ;oCAC3BN,cAAA;oCACAC,MAAA,EAAQ;wCACN,GAAGF,IAAI;wCACPE;oCACF;oCACAC,GAAA;oCACAC;gCACF;gCACA,MAAMI,KAAA,GAAQ;oCACZR,IAAA,CAAKS,MAAM,GAAG,CAAA,YAAA,EAAeT,IAAA,CAAKS,MAAM,CAAA,CAAA,CAAG,GAAG;oCAC9C,yEAAA;oCACA,wDAAA;oCACA,mBAAA;oCACA,6EAAA;oCACAT,IAAA,CAAKU,MAAM,GAAG,IAAI,CAAA,sBAAA,EAAyBV,IAAA,CAAKU,MAAM,GAAG,GAAA,GAAA,CAAO,GAAG;iCACpE,CACEC,MAAM,CAACC,OAAA,EACPC,IAAI,CAAC;gCACR,OAAO,CAAA,CAAA,EAAIb,IAAA,EAAMc,GAAA,GAAMN,KAAA,GAAQ,CAAA,QAAA,EAAWA,KAAA,CAAA,CAAA,CAAQ,GAAG,GAAA,CAAA,EAAMH,YAAA,CAAA,EAAA,EAAiBL,IAAA,EAAMc,GAAA,CAAA,CAAA,CAAM;4BAC1F;4BACAC,SAAA,EAAW;gCAACpC,0PAAA,CAAYqC,OAAO;6BAAA;wBACjC;oBACF;oBACAhB,IAAA,EAAMrB,0PAAAA;gBACR;aACD;YACDsC,2BAAA,EAA6B9B;QAC/B;IACF;IACA+B,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 1395, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/horizontalRule/server/i18n.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/horizontalRule/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'القاعدة الأفقية',\n  },\n  az: {\n    label: 'Üfüqi Xətt',\n  },\n  bg: {\n    label: 'Хоризонтална линия',\n  },\n  cs: {\n    label: 'Vodorovný pravítko',\n  },\n  da: {\n    label: 'Horisontal Regel',\n  },\n  de: {\n    label: 'Trennlinie',\n  },\n  en: {\n    label: 'Horizontal Rule',\n  },\n  es: {\n    label: 'Regla Horizontal',\n  },\n  et: {\n    label: 'Horisontaalne reegel',\n  },\n  fa: {\n    label: 'قاعده افقی',\n  },\n  fr: {\n    label: 'Règle horizontale',\n  },\n  he: {\n    label: 'קו אופקי',\n  },\n  hr: {\n    label: 'Vodoravna linija',\n  },\n  hu: {\n    label: 'Vízszintes vonal',\n  },\n  is: {\n    label: 'Lárétt lína',\n  },\n  it: {\n    label: 'Regola Orizzontale',\n  },\n  ja: {\n    label: '水平線',\n  },\n  ko: {\n    label: '수평 규칙',\n  },\n  my: {\n    label: 'Peraturan Mendatar',\n  },\n  nb: {\n    label: 'Horisontal Regel',\n  },\n  nl: {\n    label: 'Horizontale Regel',\n  },\n  pl: {\n    label: 'Pozioma Linia',\n  },\n  pt: {\n    label: 'Regra Horizontal',\n  },\n  ro: {\n    label: 'Linie orizontală',\n  },\n  rs: {\n    label: 'Хоризонтална линија',\n  },\n  'rs-latin': {\n    label: 'Horizontalna linija',\n  },\n  ru: {\n    label: 'Горизонтальная линия',\n  },\n  sk: {\n    label: 'Vodorovná čiara',\n  },\n  sl: {\n    label: 'Vodoravna črta',\n  },\n  sv: {\n    label: 'Horisontell linje',\n  },\n  ta: {\n    label: 'குறுக்கு வரி',\n  },\n  th: {\n    label: 'เส้นขอบแนวนอน',\n  },\n  tr: {\n    label: 'Yatay Çizgi',\n  },\n  uk: {\n    label: 'Горизонтальна лінія',\n  },\n  vi: {\n    label: 'Quy tắc ngang',\n  },\n  zh: {\n    label: '水平线',\n  },\n  'zh-TW': {\n    label: '水平線',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","is","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","ta","th","tr","uk","vi","zh"],"mappings":";;;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA8B,EAAA,EAAI;QACF9B,KAAA,EAAO;IACT;IACA+B,EAAA,EAAI;QACF/B,KAAA,EAAO;IACT;IACAgC,EAAA,EAAI;QACFhC,KAAA,EAAO;IACT;IACAiC,EAAA,EAAI;QACFjC,KAAA,EAAO;IACT;IACAkC,EAAA,EAAI;QACFlC,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF","ignoreList":[]}},
    {"offset": {"line": 1516, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/horizontalRule/server/nodes/HorizontalRuleNode.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/horizontalRule/server/nodes/HorizontalRuleNode.tsx"],"sourcesContent":["import type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  LexicalCommand,\n  LexicalNode,\n  SerializedLexicalNode,\n} from 'lexical'\nimport type * as React from 'react'\n\nimport { addClassNamesToElement } from '@lexical/utils'\nimport { $applyNodeReplacement, createCommand, DecoratorNode } from 'lexical'\n\nimport type { StronglyTypedLeafNode } from '../../../../nodeTypes.js'\n\n/**\n * Serialized representation of a horizontal rule node. Serialized = converted to JSON. This is what is stored in the database / in the lexical editor state.\n */\nexport type SerializedHorizontalRuleNode = StronglyTypedLeafNode<\n  SerializedLexicalNode,\n  'horizontalrule'\n>\n\nexport const INSERT_HORIZONTAL_RULE_COMMAND: LexicalCommand<void> = createCommand(\n  'INSERT_HORIZONTAL_RULE_COMMAND',\n)\n\n/**\n * This node is a DecoratorNode. DecoratorNodes allow you to render React components in the editor.\n *\n * They need both createDom and decorate functions. createDom => outside of the html. decorate => React Component inside of the html.\n *\n * If we used DecoratorBlockNode instead, we would only need a decorate method\n */\nexport class HorizontalRuleServerNode extends DecoratorNode<null | React.ReactElement> {\n  static override clone(node: HorizontalRuleServerNode): HorizontalRuleServerNode {\n    return new this(node.__key)\n  }\n\n  static override getType(): string {\n    return 'horizontalrule'\n  }\n\n  /**\n   * Defines what happens if you copy an hr element from another page and paste it into the lexical editor\n   *\n   * This also determines the behavior of lexical's internal HTML -> Lexical converter\n   */\n  static override importDOM(): DOMConversionMap | null {\n    return {\n      hr: () => ({\n        conversion: $convertHorizontalRuleElement,\n        priority: 0,\n      }),\n    }\n  }\n\n  /**\n   * The data for this node is stored serialized as JSON. This is the \"load function\" of that node: it takes the saved data and converts it into a node.\n   */\n  static override importJSON(\n    serializedNode: SerializedHorizontalRuleNode,\n  ): HorizontalRuleServerNode {\n    return $createHorizontalRuleServerNode()\n  }\n\n  /**\n   * Determines how the hr element is rendered in the lexical editor. This is only the \"initial\" / \"outer\" HTML element.\n   */\n  override createDOM(config: EditorConfig): HTMLElement {\n    const element = document.createElement('hr')\n    addClassNamesToElement(element, config.theme.hr)\n    return element\n  }\n\n  override decorate(): null | React.ReactElement {\n    return null\n  }\n\n  /**\n   * Opposite of importDOM, this function defines what happens when you copy an hr element from the lexical editor and paste it into another page.\n   *\n   * This also determines the behavior of lexical's internal Lexical -> HTML converter\n   */\n  override exportDOM(): DOMExportOutput {\n    return { element: document.createElement('hr') }\n  }\n  /**\n   * Opposite of importJSON. This determines what data is saved in the database / in the lexical editor state.\n   */\n  override exportJSON(): SerializedLexicalNode {\n    return {\n      type: 'horizontalrule',\n      version: 1,\n    }\n  }\n\n  override getTextContent(): string {\n    return '\\n'\n  }\n\n  override isInline(): false {\n    return false\n  }\n\n  override updateDOM(): boolean {\n    return false\n  }\n}\n\nfunction $convertHorizontalRuleElement(): DOMConversionOutput {\n  return { node: $createHorizontalRuleServerNode() }\n}\n\nexport function $createHorizontalRuleServerNode(): HorizontalRuleServerNode {\n  return $applyNodeReplacement(new HorizontalRuleServerNode())\n}\n\nexport function $isHorizontalRuleServerNode(\n  node: LexicalNode | null | undefined,\n): node is HorizontalRuleServerNode {\n  return node instanceof HorizontalRuleServerNode\n}\n"],"names":["addClassNamesToElement","$applyNodeReplacement","createCommand","DecoratorNode","INSERT_HORIZONTAL_RULE_COMMAND","HorizontalRuleServerNode","clone","node","__key","getType","importDOM","hr","conversion","$convertHorizontalRuleElement","priority","importJSON","serializedNode","$createHorizontalRuleServerNode","createDOM","config","element","document","createElement","theme","decorate","exportDOM","exportJSON","type","version","getTextContent","isInline","updateDOM","$isHorizontalRuleServerNode"],"mappings":";;;;;;;;;;AAWA,SAASA,sBAAsB,QAAQ;AACvC,SAASC,qBAAqB,EAAEC,aAAa,EAAEC,aAAa,QAAQ;;;AAY7D,MAAMC,8BAAA,OAAuDF,gNAAA,EAClE;AAUK,MAAMG,wBAAA,SAAiCF,gNAAA;IAC5C,OAAgBG,MAAMC,IAA8B,EAA4B;QAC9E,OAAO,IAAI,IAAI,CAACA,IAAA,CAAKC,KAAK;IAC5B;IAEA,OAAgBC,QAAA,EAAkB;QAChC,OAAO;IACT;IAEA;;;;KAKA,OAAgBC,UAAA,EAAqC;QACnD,OAAO;YACLC,EAAA,EAAIA,CAAA,GAAA,CAAO;oBACTC,UAAA,EAAYC,6BAAA;oBACZC,QAAA,EAAU;gBACZ,CAAA;QACF;IACF;IAEA;;KAGA,OAAgBC,WACdC,cAA4C,EAClB;QAC1B,OAAOC,+BAAA;IACT;IAEA;;KAGAC,SAASA,CAAUC,MAAoB,EAAe;QACpD,MAAMC,OAAA,GAAUC,QAAA,CAASC,aAAa,CAAC;YACvCtB,oQAAA,EAAuBoB,OAAA,EAASD,MAAA,CAAOI,KAAK,CAACZ,EAAE;QAC/C,OAAOS,OAAA;IACT;IAESI,SAAA,EAAsC;QAC7C,OAAO;IACT;IAEA;;;;KAKAC,SAASA,CAAA,EAA6B;QACpC,OAAO;YAAEL,OAAA,EAASC,QAAA,CAASC,aAAa,CAAC;QAAM;IACjD;IACA;;KAGAI,UAASA,CAAA,EAAoC;QAC3C,OAAO;YACLC,IAAA,EAAM;YACNC,OAAA,EAAS;QACX;IACF;IAESC,eAAA,EAAyB;QAChC,OAAO;IACT;IAESC,SAAA,EAAkB;QACzB,OAAO;IACT;IAESC,UAAA,EAAqB;QAC5B,OAAO;IACT;AACF;AAEA,SAASlB,8BAAA;IACP,OAAO;QAAEN,IAAA,EAAMU,+BAAA;IAAkC;AACnD;AAEO,SAASA,gCAAA;IACd,WAAOhB,wNAAA,EAAsB,IAAII,wBAAA;AACnC;AAEO,SAAS2B,4BACdzB,IAAoC;IAEpC,OAAOA,IAAA,YAAgBF,wBAAA;AACzB","ignoreList":[]}},
    {"offset": {"line": 1607, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/horizontalRule/server/markdownTransformer.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/horizontalRule/server/markdownTransformer.ts"],"sourcesContent":["import type { ElementTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport {\n  $createHorizontalRuleServerNode,\n  $isHorizontalRuleServerNode,\n  HorizontalRuleServerNode,\n} from './nodes/HorizontalRuleNode.js'\n\nexport const MarkdownTransformer: ElementTransformer = {\n  type: 'element',\n  dependencies: [HorizontalRuleServerNode],\n  export: (node, exportChildren) => {\n    if (!$isHorizontalRuleServerNode(node)) {\n      return null\n    }\n    return '---'\n  },\n  // match ---\n  regExp: /^---\\s*$/,\n  replace: (parentNode) => {\n    const node = $createHorizontalRuleServerNode()\n    if (node) {\n      parentNode.replace(node)\n    }\n  },\n}\n"],"names":["$createHorizontalRuleServerNode","$isHorizontalRuleServerNode","HorizontalRuleServerNode","MarkdownTransformer","type","dependencies","export","node","exportChildren","regExp","replace","parentNode"],"mappings":";;;;AAEA,SACEA,+BAA+B,EAC/BC,2BAA2B,EAC3BC,wBAAwB,QACnB;;AAEA,MAAMC,mBAAA,GAA0C;IACrDC,IAAA,EAAM;IACNC,YAAA,EAAc;QAACH,wcAAA;KAAyB;IACxCI,MAAA,EAAQA,CAACC,IAAA,EAAMC,cAAA;QACb,IAAI,KAACP,2cAAA,EAA4BM,IAAA,GAAO;YACtC,OAAO;QACT;QACA,OAAO;IACT;IACA,YAAA;IACAE,MAAA,EAAQ;IACRC,OAAA,GAAUC,UAAA;QACR,MAAMJ,IAAA,OAAOP,+cAAA;QACb,IAAIO,IAAA,EAAM;YACRI,UAAA,CAAWD,OAAO,CAACH,IAAA;QACrB;IACF;AACF","ignoreList":[]}},
    {"offset": {"line": 1637, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/horizontalRule/server/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/horizontalRule/server/index.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { createNode } from '../../typeUtilities.js'\nimport { i18n } from './i18n.js'\nimport { MarkdownTransformer } from './markdownTransformer.js'\nimport { HorizontalRuleServerNode } from './nodes/HorizontalRuleNode.js'\n\nexport const HorizontalRuleFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#HorizontalRuleFeatureClient',\n    i18n,\n    markdownTransformers: [MarkdownTransformer],\n    nodes: [\n      createNode({\n        converters: {\n          html: {\n            converter: () => {\n              return `<hr/>`\n            },\n            nodeTypes: [HorizontalRuleServerNode.getType()],\n          },\n        },\n        node: HorizontalRuleServerNode,\n      }),\n    ],\n  },\n  key: 'horizontalRule',\n})\n"],"names":["createServerFeature","createNode","i18n","MarkdownTransformer","HorizontalRuleServerNode","HorizontalRuleFeature","feature","ClientFeature","markdownTransformers","nodes","converters","html","converter","nodeTypes","getType","node","key"],"mappings":";;;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,UAAU,QAAQ;AAC3B,SAASC,IAAI,QAAQ;AACrB,SAASC,mBAAmB,QAAQ;AACpC,SAASC,wBAAwB,QAAQ;;;;;;AAElC,MAAMC,qBAAA,OAAwBL,gaAAA,EAAoB;IACvDM,OAAA,EAAS;QACPC,aAAA,EAAe;cACfL,6ZAAA;QACAM,oBAAA,EAAsB;YAACL,2bAAA;SAAoB;QAC3CM,KAAA,EAAO;gBACLR,gZAAA,EAAW;gBACTS,UAAA,EAAY;oBACVC,IAAA,EAAM;wBACJC,SAAA,EAAWA,CAAA;4BACT,OAAO,CAAA,KAAA,CAAO;wBAChB;wBACAC,SAAA,EAAW;4BAACT,wcAAA,CAAyBU,OAAO;yBAAA;oBAC9C;gBACF;gBACAC,IAAA,EAAMX,wcAAAA;YACR;SAAA;IAEJ;IACAY,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 1680, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/indent/server/i18n.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/indent/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    decreaseLabel: 'تقليل المسافة البادئة',\n    increaseLabel: 'زيادة المسافة البادئة',\n  },\n  az: {\n    decreaseLabel: 'İntervalı Azaltın',\n    increaseLabel: 'Girintiyi Artırın',\n  },\n  bg: {\n    decreaseLabel: 'Намали отстоянието',\n    increaseLabel: 'Увеличете отстоянието',\n  },\n  cs: {\n    decreaseLabel: 'Zmenšit odsazení',\n    increaseLabel: 'Zvětšit odsazení',\n  },\n  da: {\n    decreaseLabel: 'Reducer Indrykning',\n    increaseLabel: 'Forøg indrykning',\n  },\n  de: {\n    decreaseLabel: 'Einzug verkleinern',\n    increaseLabel: 'Einzug erhöhen',\n  },\n  en: {\n    decreaseLabel: 'Decrease Indent',\n    increaseLabel: 'Increase Indent',\n  },\n  es: {\n    decreaseLabel: 'Disminuir Sangría',\n    increaseLabel: 'Aumentar Sangría',\n  },\n  et: {\n    decreaseLabel: 'Taande vähendamine',\n    increaseLabel: 'Taande suurendamine',\n  },\n  fa: {\n    decreaseLabel: 'کاهش تورفتگی',\n    increaseLabel: 'افزایش تورفتگی',\n  },\n  fr: {\n    decreaseLabel: \"Diminuer l'indentation\",\n    increaseLabel: \"Augmenter l'indentation\",\n  },\n  he: {\n    decreaseLabel: 'הקטן הזחה',\n    increaseLabel: 'הגדל כניסה',\n  },\n  hr: {\n    decreaseLabel: 'Smanji uvlačenje',\n    increaseLabel: 'Povećaj uvlačenje',\n  },\n  hu: {\n    decreaseLabel: 'Csökkentse a behúzást',\n    increaseLabel: 'Behúzás növelése',\n  },\n  is: {\n    decreaseLabel: 'Minnka inndrátt',\n    increaseLabel: 'Auka inndrátt',\n  },\n  it: {\n    decreaseLabel: 'Diminuisci rientro',\n    increaseLabel: 'Aumenta Rientro',\n  },\n  ja: {\n    decreaseLabel: 'インデントを減らす',\n    increaseLabel: 'インデントを増やす',\n  },\n  ko: {\n    decreaseLabel: '들여쓰기 줄이기',\n    increaseLabel: '들여쓰기 늘리기',\n  },\n  my: {\n    decreaseLabel: 'Kurangkan Inden',\n    increaseLabel: 'Tingkatkan Inden',\n  },\n  nb: {\n    decreaseLabel: 'Reduser innrykk',\n    increaseLabel: 'Øke innrykk',\n  },\n  nl: {\n    decreaseLabel: 'Verminder Inspringing',\n    increaseLabel: 'Inspring verhogen',\n  },\n  pl: {\n    decreaseLabel: 'Zmniejsz wcięcie',\n    increaseLabel: 'Zwiększ wcięcie',\n  },\n  pt: {\n    decreaseLabel: 'Diminuir recuo',\n    increaseLabel: 'Aumentar Indentação',\n  },\n  ro: {\n    decreaseLabel: 'Reducere indentare',\n    increaseLabel: 'Crește indentarea',\n  },\n  rs: {\n    decreaseLabel: 'Смањи увлачење',\n    increaseLabel: 'Повећај увлачење',\n  },\n  'rs-latin': {\n    decreaseLabel: 'Smanji uvlačenje',\n    increaseLabel: 'Povećaj uvlačenje',\n  },\n  ru: {\n    decreaseLabel: 'Уменьшить отступ',\n    increaseLabel: 'Увеличить отступ',\n  },\n  sk: {\n    decreaseLabel: 'Znížiť odsadenie',\n    increaseLabel: 'Zväčšiť odsadenie',\n  },\n  sl: {\n    decreaseLabel: 'Zmanjšaj zamik',\n    increaseLabel: 'Povečaj zamik',\n  },\n  sv: {\n    decreaseLabel: 'Minska indrag',\n    increaseLabel: 'Öka indrag',\n  },\n  ta: {\n    decreaseLabel: 'இடதுபுறச் செருகலை குறைக்கவும்',\n    increaseLabel: 'இடதுபுறச் செருகலை அதிகரிக்கவும்',\n  },\n  th: {\n    decreaseLabel: 'ลดการเยื้อง',\n    increaseLabel: 'เพิ่มการเยื้อง',\n  },\n  tr: {\n    decreaseLabel: 'Girintiyi Azalt',\n    increaseLabel: 'Girintiyi Artır',\n  },\n  uk: {\n    decreaseLabel: 'Зменшити відступ',\n    increaseLabel: 'Збільшити відступ',\n  },\n  vi: {\n    decreaseLabel: 'Giảm lề',\n    increaseLabel: 'Tăng lề',\n  },\n  zh: {\n    decreaseLabel: '减少缩进',\n    increaseLabel: '增加缩进',\n  },\n  'zh-TW': {\n    decreaseLabel: '減少縮排',\n    increaseLabel: '增加縮排',\n  },\n}\n"],"names":["i18n","ar","decreaseLabel","increaseLabel","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","is","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","ta","th","tr","uk","vi","zh"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 1838, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/indent/server/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/indent/server/index.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { i18n } from './i18n.js'\n\nexport type IndentFeatureProps = {\n  /**\n   * The nodes that should not be indented. \"type\" property of the nodes you don't want to be indented.\n   * These can be: \"paragraph\", \"heading\", \"listitem\", \"quote\" or other indentable nodes if they exist.\n   */\n  disabledNodes?: string[]\n  /**\n   * If true, pressing Tab in the middle of a block such as a paragraph or heading will not insert a tabNode.\n   * Instead, Tab will only be used for block-level indentation.\n   *\n   * @default false\n   */\n  disableTabNode?: boolean\n}\n\nexport const IndentFeature = createServerFeature<\n  IndentFeatureProps,\n  IndentFeatureProps,\n  IndentFeatureProps\n>({\n  feature: ({ props }) => {\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#IndentFeatureClient',\n      clientFeatureProps: props,\n      i18n,\n    }\n  },\n  key: 'indent',\n})\n"],"names":["createServerFeature","i18n","IndentFeature","feature","props","ClientFeature","clientFeatureProps","key"],"mappings":";;;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,IAAI,QAAQ;;;AAiBd,MAAMC,aAAA,OAAgBF,gaAAA,EAI3B;IACAG,OAAA,EAASA,CAAC,EAAEC,KAAAA,EAAO;QACjB,OAAO;YACLC,aAAA,EAAe;YACfC,kBAAA,EAAoBF,KAAA;kBACpBH,qZAAAA;QACF;IACF;IACAM,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 1860, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/link/nodes/LinkNode.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/link/nodes/LinkNode.ts"],"sourcesContent":["import type {\n  BaseSelection,\n  DOMConversionMap,\n  DOMConversionOutput,\n  EditorConfig,\n  ElementNode as ElementNodeType,\n  LexicalCommand,\n  LexicalNode,\n  LexicalUpdateJSON,\n  NodeKey,\n  RangeSelection,\n} from 'lexical'\n\nimport { addClassNamesToElement, isHTMLAnchorElement } from '@lexical/utils'\nimport ObjectID from 'bson-objectid'\nimport {\n  $applyNodeReplacement,\n  $createTextNode,\n  $getSelection,\n  $isElementNode,\n  $isRangeSelection,\n  createCommand,\n  ElementNode,\n} from 'lexical'\n\nimport type { LinkPayload } from '../client/plugins/floatingLinkEditor/types.js'\nimport type { LinkFields, SerializedLinkNode } from './types.js'\n\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:'])\n\n/** @noInheritDoc */\nexport class LinkNode extends ElementNode {\n  __fields: LinkFields\n  __id: string\n\n  constructor({\n    id,\n    fields = {\n      linkType: 'custom',\n      newTab: false,\n    },\n    key,\n  }: {\n    fields?: LinkFields\n    id: string\n    key?: NodeKey\n  }) {\n    super(key)\n    this.__fields = fields\n    this.__id = id\n  }\n\n  static override clone(node: LinkNode): LinkNode {\n    return new this({\n      id: node.__id,\n      fields: node.__fields,\n      key: node.__key,\n    })\n  }\n\n  static override getType(): string {\n    return 'link'\n  }\n\n  static override importDOM(): DOMConversionMap | null {\n    return {\n      a: (node: Node) => ({\n        conversion: $convertAnchorElement,\n        priority: 1,\n      }),\n    }\n  }\n\n  static override importJSON(serializedNode: SerializedLinkNode): LinkNode {\n    const node = $createLinkNode({}).updateFromJSON(serializedNode)\n\n    /**\n     * @todo remove this in 4.0\n     */\n    if (\n      serializedNode.version === 1 &&\n      typeof serializedNode.fields?.doc?.value === 'object' &&\n      serializedNode.fields?.doc?.value?.id\n    ) {\n      serializedNode.fields.doc.value = serializedNode.fields.doc.value.id\n      serializedNode.version = 2\n    }\n\n    if (serializedNode.version === 2 && !serializedNode.id) {\n      serializedNode.id = new ObjectID.default().toHexString()\n      serializedNode.version = 3\n    }\n    return node\n  }\n\n  override canBeEmpty(): false {\n    return false\n  }\n\n  override canInsertTextAfter(): false {\n    return false\n  }\n\n  override canInsertTextBefore(): false {\n    return false\n  }\n\n  override createDOM(config: EditorConfig): HTMLAnchorElement {\n    const element = document.createElement('a')\n    if (this.__fields?.linkType === 'custom') {\n      element.href = this.sanitizeUrl(this.__fields.url ?? '')\n    }\n    if (this.__fields?.newTab ?? false) {\n      element.target = '_blank'\n    }\n\n    if (this.__fields?.newTab === true && this.__fields?.linkType === 'custom') {\n      element.rel = manageRel(element.rel, 'add', 'noopener')\n    }\n\n    addClassNamesToElement(element, config.theme.link)\n    return element\n  }\n\n  override exportJSON(): SerializedLinkNode {\n    const fields = this.getFields()\n\n    if (fields?.linkType === 'internal') {\n      delete fields.url\n    } else if (fields?.linkType === 'custom') {\n      delete fields.doc\n    }\n\n    const returnObject: SerializedLinkNode = {\n      ...super.exportJSON(),\n      type: 'link',\n      fields,\n      version: 3,\n    }\n    const id = this.getID()\n    if (id) {\n      returnObject.id = id\n    }\n    return returnObject\n  }\n\n  override extractWithChild(\n    child: LexicalNode,\n    selection: BaseSelection,\n    destination: 'clone' | 'html',\n  ): boolean {\n    if (!$isRangeSelection(selection)) {\n      return false\n    }\n\n    const anchorNode = selection.anchor.getNode()\n    const focusNode = selection.focus.getNode()\n\n    return (\n      this.isParentOf(anchorNode) &&\n      this.isParentOf(focusNode) &&\n      selection.getTextContent().length > 0\n    )\n  }\n\n  getFields(): LinkFields {\n    return this.getLatest().__fields\n  }\n\n  getID(): string {\n    return this.getLatest().__id\n  }\n\n  override insertNewAfter(\n    selection: RangeSelection,\n    restoreSelection = true,\n  ): ElementNodeType | null {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection)\n    if ($isElementNode(element)) {\n      const linkNode = $createLinkNode({ fields: this.__fields })\n      element.append(linkNode)\n      return linkNode\n    }\n    return null\n  }\n\n  override isInline(): true {\n    return true\n  }\n\n  sanitizeUrl(url: string): string {\n    try {\n      const parsedUrl = new URL(url)\n\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank'\n      }\n    } catch (e) {\n      return 'https://'\n    }\n    return url\n  }\n\n  setFields(fields: LinkFields): this {\n    const writable = this.getWritable()\n    writable.__fields = fields\n    return writable\n  }\n\n  setID(id: string): this {\n    const writable = this.getWritable()\n    writable.__id = id\n    return writable\n  }\n\n  override updateDOM(prevNode: this, anchor: HTMLAnchorElement, config: EditorConfig): boolean {\n    const url = this.__fields?.url\n    const newTab = this.__fields?.newTab\n    if (url != null && url !== prevNode.__fields?.url && this.__fields?.linkType === 'custom') {\n      anchor.href = url\n    }\n    if (this.__fields?.linkType === 'internal' && prevNode.__fields?.linkType === 'custom') {\n      anchor.removeAttribute('href')\n    }\n\n    // TODO: not 100% sure why we're settign rel to '' - revisit\n    // Start rel config here, then check newTab below\n    if (anchor.rel == null) {\n      anchor.rel = ''\n    }\n\n    if (newTab !== prevNode.__fields?.newTab) {\n      if (newTab ?? false) {\n        anchor.target = '_blank'\n        if (this.__fields?.linkType === 'custom') {\n          anchor.rel = manageRel(anchor.rel, 'add', 'noopener')\n        }\n      } else {\n        anchor.removeAttribute('target')\n        anchor.rel = manageRel(anchor.rel, 'remove', 'noopener')\n      }\n    }\n\n    return false\n  }\n\n  override updateFromJSON(serializedNode: LexicalUpdateJSON<SerializedLinkNode>): this {\n    return super\n      .updateFromJSON(serializedNode)\n      .setFields(serializedNode.fields)\n      .setID(serializedNode.id as string)\n  }\n}\n\nfunction $convertAnchorElement(domNode: Node): DOMConversionOutput {\n  let node: LinkNode | null = null\n  if (isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent\n    if (content !== null && content !== '') {\n      node = $createLinkNode({\n        id: new ObjectID.default().toHexString(),\n        fields: {\n          doc: null,\n          linkType: 'custom',\n          newTab: domNode.getAttribute('target') === '_blank',\n          url: domNode.getAttribute('href') ?? '',\n        },\n      })\n    }\n  }\n  return { node }\n}\n\nexport function $createLinkNode({ id, fields }: { fields?: LinkFields; id?: string }): LinkNode {\n  return $applyNodeReplacement(\n    new LinkNode({\n      id: id ?? new ObjectID.default().toHexString(),\n      fields,\n    }),\n  )\n}\n\nexport function $isLinkNode(node: LexicalNode | null | undefined): node is LinkNode {\n  return node instanceof LinkNode\n}\n\nexport const TOGGLE_LINK_COMMAND: LexicalCommand<LinkPayload | null> =\n  createCommand('TOGGLE_LINK_COMMAND')\n\nexport function $toggleLink(payload: ({ fields: LinkFields } & LinkPayload) | null): void {\n  const selection = $getSelection()\n\n  if (!$isRangeSelection(selection) && (payload === null || !payload.selectedNodes?.length)) {\n    return\n  }\n  const nodes = $isRangeSelection(selection)\n    ? selection.extract()\n    : payload === null\n      ? []\n      : payload.selectedNodes\n\n  if (payload === null) {\n    // Remove LinkNodes\n    nodes?.forEach((node) => {\n      const parent = node.getParent()\n\n      if ($isLinkNode(parent)) {\n        const children = parent.getChildren()\n\n        children.forEach((child) => {\n          parent.insertBefore(child)\n        })\n\n        parent.remove()\n      }\n    })\n\n    return\n  }\n  // Add or merge LinkNodes\n  if (nodes?.length === 1) {\n    const firstNode = nodes[0]!\n    // if the first node is a LinkNode or if its\n    // parent is a LinkNode, we update the URL, target and rel.\n    const linkNode: LinkNode | null = $isLinkNode(firstNode)\n      ? firstNode\n      : $getLinkAncestor(firstNode)\n    if (linkNode !== null) {\n      linkNode.setFields(payload.fields)\n\n      if (payload.text != null && payload.text !== linkNode.getTextContent()) {\n        // remove all children and add child with new textcontent:\n        linkNode.append($createTextNode(payload.text))\n        linkNode.getChildren().forEach((child) => {\n          if (child !== linkNode.getLastChild()) {\n            child.remove()\n          }\n        })\n      }\n      return\n    }\n  }\n\n  let prevParent: ElementNodeType | LinkNode | null = null\n  let linkNode: LinkNode | null = null\n\n  nodes?.forEach((node) => {\n    const parent = node.getParent()\n\n    if (parent === linkNode || parent === null || ($isElementNode(node) && !node.isInline())) {\n      return\n    }\n\n    if ($isLinkNode(parent)) {\n      linkNode = parent\n      parent.setFields(payload.fields)\n      if (payload.text != null && payload.text !== parent.getTextContent()) {\n        // remove all children and add child with new textcontent:\n        parent.append($createTextNode(payload.text))\n        parent.getChildren().forEach((child) => {\n          if (child !== parent.getLastChild()) {\n            child.remove()\n          }\n        })\n      }\n      return\n    }\n\n    if (!parent.is(prevParent)) {\n      prevParent = parent\n      linkNode = $createLinkNode({ fields: payload.fields })\n\n      if ($isLinkNode(parent)) {\n        if (node.getPreviousSibling() === null) {\n          parent.insertBefore(linkNode)\n        } else {\n          parent.insertAfter(linkNode)\n        }\n      } else {\n        node.insertBefore(linkNode)\n      }\n    }\n\n    if ($isLinkNode(node)) {\n      if (node.is(linkNode)) {\n        return\n      }\n      if (linkNode !== null) {\n        const children = node.getChildren()\n        linkNode.append(...children)\n      }\n\n      node.remove()\n      return\n    }\n\n    if (linkNode !== null) {\n      linkNode.append(node)\n    }\n  })\n}\n\nfunction $getLinkAncestor(node: LexicalNode): LinkNode | null {\n  return $getAncestor(node, (ancestor) => $isLinkNode(ancestor)) as LinkNode\n}\n\nfunction $getAncestor(\n  node: LexicalNode,\n  predicate: (ancestor: LexicalNode) => boolean,\n): LexicalNode | null {\n  let parent: LexicalNode | null = node\n  while (parent !== null) {\n    parent = parent.getParent()\n    if (parent === null || predicate(parent)) {\n      break\n    }\n  }\n  return parent\n}\n\nfunction manageRel(input: string, action: 'add' | 'remove', value: string): string {\n  let result: string\n  let mutableInput = `${input}`\n  if (action === 'add') {\n    // if we somehow got out of sync - clean up\n    if (mutableInput.includes(value)) {\n      const re = new RegExp(value, 'g')\n      mutableInput = mutableInput.replace(re, '').trim()\n    }\n    mutableInput = mutableInput.trim()\n    result = mutableInput.length === 0 ? `${value}` : `${mutableInput} ${value}`\n  } else {\n    const re = new RegExp(value, 'g')\n    result = mutableInput.replace(re, '').trim()\n  }\n  return result\n}\n"],"names":["addClassNamesToElement","isHTMLAnchorElement","ObjectID","$applyNodeReplacement","$createTextNode","$getSelection","$isElementNode","$isRangeSelection","createCommand","ElementNode","SUPPORTED_URL_PROTOCOLS","Set","LinkNode","__fields","__id","constructor","id","fields","linkType","newTab","key","clone","node","__key","getType","importDOM","a","conversion","$convertAnchorElement","priority","importJSON","serializedNode","$createLinkNode","updateFromJSON","version","doc","value","default","toHexString","canBeEmpty","canInsertTextAfter","canInsertTextBefore","createDOM","config","element","document","createElement","href","sanitizeUrl","url","target","rel","manageRel","theme","link","exportJSON","getFields","returnObject","type","getID","extractWithChild","child","selection","destination","anchorNode","anchor","getNode","focusNode","focus","isParentOf","getTextContent","length","getLatest","insertNewAfter","restoreSelection","getParentOrThrow","linkNode","append","isInline","parsedUrl","URL","has","protocol","e","setFields","writable","getWritable","setID","updateDOM","prevNode","removeAttribute","domNode","content","textContent","getAttribute","$isLinkNode","TOGGLE_LINK_COMMAND","$toggleLink","payload","selectedNodes","nodes","extract","forEach","parent","getParent","children","getChildren","insertBefore","remove","firstNode","$getLinkAncestor","text","getLastChild","prevParent","is","getPreviousSibling","insertAfter","$getAncestor","ancestor","predicate","input","action","result","mutableInput","includes","re","RegExp","replace","trim"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 2206, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/link/markdownTransformer.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/link/markdownTransformer.ts"],"sourcesContent":["/**\n * Code taken from https://github.com/facebook/lexical/blob/main/packages/lexical-markdown/src/MarkdownTransformers.ts#L357\n */\n\n// Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n\nimport { $createTextNode, $isTextNode } from 'lexical'\n\nimport type { TextMatchTransformer } from '../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport { $createLinkNode, $isLinkNode, LinkNode } from './nodes/LinkNode.js'\n\n// - then longer tags match (e.g. ** or __ should go before * or _)\nexport const LinkMarkdownTransformer: TextMatchTransformer = {\n  type: 'text-match',\n  dependencies: [LinkNode],\n  export: (_node, exportChildren) => {\n    if (!$isLinkNode(_node)) {\n      return null\n    }\n    const node: LinkNode = _node\n    const { url } = node.getFields()\n\n    const textContent = exportChildren(node)\n\n    const linkContent = `[${textContent}](${url})`\n\n    return linkContent\n  },\n  importRegExp: /\\[([^[]+)\\]\\(([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?\\)/,\n  regExp: /\\[([^[]+)\\]\\(([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?\\)$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl] = match\n    const linkNode = $createLinkNode({\n      fields: {\n        doc: null,\n        linkType: 'custom',\n        newTab: false,\n        url: linkUrl,\n      },\n    })\n    const linkTextNode = $createTextNode(linkText)\n    linkTextNode.setFormat(textNode.getFormat())\n    linkNode.append(linkTextNode)\n    textNode.replace(linkNode)\n\n    return linkTextNode\n  },\n  trigger: ')',\n}\n"],"names":["$createTextNode","$createLinkNode","$isLinkNode","LinkNode","LinkMarkdownTransformer","type","dependencies","export","_node","exportChildren","node","url","getFields","textContent","linkContent","importRegExp","regExp","replace","textNode","match","linkText","linkUrl","linkNode","fields","doc","linkType","newTab","linkTextNode","setFormat","getFormat","append","trigger"],"mappings":";;;;AAAA;;GAAA,CAIA,sCAAA;AACA,EAAA;AACA,mEAAA;AAEA,SAASA,eAAe,QAAqB;AAI7C,SAASC,eAAe,EAAEC,WAAW,EAAEC,QAAQ,QAAQ;;;AAGhD,MAAMC,uBAAA,GAAgD;IAC3DC,IAAA,EAAM;IACNC,YAAA,EAAc;QAACH,0ZAAA;KAAS;IACxBI,MAAA,EAAQA,CAACC,KAAA,EAAOC,cAAA;QACd,IAAI,KAACP,6ZAAA,EAAYM,KAAA,GAAQ;YACvB,OAAO;QACT;QACA,MAAME,IAAA,GAAiBF,KAAA;QACvB,MAAM,EAAEG,GAAAA,EAAK,GAAGD,IAAA,CAAKE,SAAS;QAE9B,MAAMC,WAAA,GAAcJ,cAAA,CAAeC,IAAA;QAEnC,MAAMI,WAAA,GAAc,CAAA,CAAA,EAAID,WAAA,CAAA,EAAA,EAAgBF,GAAA,CAAA,CAAA,CAAM;QAE9C,OAAOG,WAAA;IACT;IACAC,YAAA,EAAc;IACdC,MAAA,EAAQ;IACRC,OAAA,EAASA,CAACC,QAAA,EAAUC,KAAA;QAClB,MAAM,GAAGC,QAAA,EAAUC,OAAA,CAAQ,GAAGF,KAAA;QAC9B,MAAMG,QAAA,OAAWrB,iaAAA,EAAgB;YAC/BsB,MAAA,EAAQ;gBACNC,GAAA,EAAK;gBACLC,QAAA,EAAU;gBACVC,MAAA,EAAQ;gBACRf,GAAA,EAAKU;YACP;QACF;QACA,MAAMM,YAAA,OAAe3B,kNAAA,EAAgBoB,QAAA;QACrCO,YAAA,CAAaC,SAAS,CAACV,QAAA,CAASW,SAAS;QACzCP,QAAA,CAASQ,MAAM,CAACH,YAAA;QAChBT,QAAA,CAASD,OAAO,CAACK,QAAA;QAEjB,OAAOK,YAAA;IACT;IACAI,OAAA,EAAS;AACX","ignoreList":[]}},
    {"offset": {"line": 2258, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/link/nodes/AutoLinkNode.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/link/nodes/AutoLinkNode.ts"],"sourcesContent":["import type { ElementNode, LexicalNode, LexicalUpdateJSON, RangeSelection } from 'lexical'\n\nimport { $applyNodeReplacement, $isElementNode } from 'lexical'\n\nimport type { LinkFields, SerializedAutoLinkNode } from './types.js'\n\nimport { LinkNode } from './LinkNode.js'\n\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\n\nexport class AutoLinkNode extends LinkNode {\n  static override clone(node: AutoLinkNode): AutoLinkNode {\n    return new this({ id: '', fields: node.__fields, key: node.__key })\n  }\n\n  static override getType(): string {\n    return 'autolink'\n  }\n\n  static override importDOM(): null {\n    // TODO: Should link node should handle the import over autolink?\n    return null\n  }\n\n  static override importJSON(serializedNode: SerializedAutoLinkNode): AutoLinkNode {\n    const node = $createAutoLinkNode({}).updateFromJSON(serializedNode)\n\n    /**\n     * @todo remove in 4.0\n     */\n    if (\n      serializedNode.version === 1 &&\n      typeof serializedNode.fields?.doc?.value === 'object' &&\n      serializedNode.fields?.doc?.value?.id\n    ) {\n      serializedNode.fields.doc.value = serializedNode.fields.doc.value.id\n      serializedNode.version = 2\n    }\n\n    return node\n  }\n\n  // @ts-expect-error\n  exportJSON(): SerializedAutoLinkNode {\n    const serialized = super.exportJSON()\n    return {\n      type: 'autolink',\n      children: serialized.children,\n      direction: serialized.direction,\n      fields: serialized.fields,\n      format: serialized.format,\n      indent: serialized.indent,\n      version: 2,\n    }\n  }\n\n  override insertNewAfter(selection: RangeSelection, restoreSelection = true): ElementNode | null {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection)\n    if ($isElementNode(element)) {\n      const linkNode = $createAutoLinkNode({ fields: this.__fields })\n      element.append(linkNode)\n      return linkNode\n    }\n    return null\n  }\n\n  override updateFromJSON(serializedNode: LexicalUpdateJSON<SerializedAutoLinkNode>): this {\n    return super.updateFromJSON(serializedNode).setFields(serializedNode.fields)\n  }\n}\n\nexport function $createAutoLinkNode({ fields }: { fields?: LinkFields }): AutoLinkNode {\n  return $applyNodeReplacement(new AutoLinkNode({ id: '', fields }))\n}\nexport function $isAutoLinkNode(node: LexicalNode | null | undefined): node is AutoLinkNode {\n  return node instanceof AutoLinkNode\n}\n"],"names":["$applyNodeReplacement","$isElementNode","LinkNode","AutoLinkNode","clone","node","id","fields","__fields","key","__key","getType","importDOM","importJSON","serializedNode","$createAutoLinkNode","updateFromJSON","version","doc","value","exportJSON","serialized","type","children","direction","format","indent","insertNewAfter","selection","restoreSelection","element","getParentOrThrow","linkNode","append","setFields","$isAutoLinkNode"],"mappings":";;;;;;;;AAEA,SAASA,qBAAqB,EAAEC,cAAc,QAAQ;AAItD,SAASC,QAAQ,QAAQ;;;AAKlB,MAAMC,YAAA,SAAqBD,0ZAAA;IAChC,OAAgBE,MAAMC,IAAkB,EAAgB;QACtD,OAAO,IAAI,IAAI,CAAC;YAAEC,EAAA,EAAI;YAAIC,MAAA,EAAQF,IAAA,CAAKG,QAAQ;YAAEC,GAAA,EAAKJ,IAAA,CAAKK,KAAAA;QAAM;IACnE;IAEA,OAAgBC,QAAA,EAAkB;QAChC,OAAO;IACT;IAEA,OAAgBC,UAAA,EAAkB;QAChC,iEAAA;QACA,OAAO;IACT;IAEA,OAAgBC,WAAWC,cAAsC,EAAgB;QAC/E,MAAMT,IAAA,GAAOU,mBAAA,CAAoB,CAAC,GAAGC,cAAc,CAACF,cAAA;QAEpD;;OAGA,IACEA,cAAA,CAAeG,OAAO,KAAK,KAC3B,OAAOH,cAAA,CAAeP,MAAM,EAAEW,GAAA,EAAKC,KAAA,KAAU,YAC7CL,cAAA,CAAeP,MAAM,EAAEW,GAAA,EAAKC,KAAA,EAAOb,EAAA,EACnC;YACAQ,cAAA,CAAeP,MAAM,CAACW,GAAG,CAACC,KAAK,GAAGL,cAAA,CAAeP,MAAM,CAACW,GAAG,CAACC,KAAK,CAACb,EAAE;YACpEQ,cAAA,CAAeG,OAAO,GAAG;QAC3B;QAEA,OAAOZ,IAAA;IACT;IAEA,mBAAA;IACAe,WAAA,EAAqC;QACnC,MAAMC,UAAA,GAAa,KAAK,CAACD,UAAA;QACzB,OAAO;YACLE,IAAA,EAAM;YACNC,QAAA,EAAUF,UAAA,CAAWE,QAAQ;YAC7BC,SAAA,EAAWH,UAAA,CAAWG,SAAS;YAC/BjB,MAAA,EAAQc,UAAA,CAAWd,MAAM;YACzBkB,MAAA,EAAQJ,UAAA,CAAWI,MAAM;YACzBC,MAAA,EAAQL,UAAA,CAAWK,MAAM;YACzBT,OAAA,EAAS;QACX;IACF;IAESU,eAAeC,SAAyB,EAAEC,gBAAA,GAAmB,IAAI,EAAsB;QAC9F,MAAMC,OAAA,GAAU,IAAI,CAACC,gBAAgB,GAAGJ,cAAc,CAACC,SAAA,EAAWC,gBAAA;QAClE,QAAI5B,iNAAA,EAAe6B,OAAA,GAAU;YAC3B,MAAME,QAAA,GAAWjB,mBAAA,CAAoB;gBAAER,MAAA,EAAQ,IAAI,CAACC,QAAAA;YAAS;YAC7DsB,OAAA,CAAQG,MAAM,CAACD,QAAA;YACf,OAAOA,QAAA;QACT;QACA,OAAO;IACT;IAEShB,eAAeF,cAAyD,EAAQ;QACvF,OAAO,KAAK,CAACE,cAAA,CAAeF,cAAA,EAAgBoB,SAAS,CAACpB,cAAA,CAAeP,MAAM;IAC7E;AACF;AAEO,SAASQ,oBAAoB,EAAER,MAAAA,EAAiC;IACrE,WAAOP,wNAAA,EAAsB,IAAIG,YAAA,CAAa;QAAEG,EAAA,EAAI;QAAIC;IAAO;AACjE;AACO,SAAS4B,gBAAgB9B,IAAoC;IAClE,OAAOA,IAAA,YAAgBF,YAAA;AACzB","ignoreList":[]}},
    {"offset": {"line": 2336, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/populateGraphQL/recursivelyPopulateFieldsForGraphQL.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/populateGraphQL/recursivelyPopulateFieldsForGraphQL.ts"],"sourcesContent":["import type { Field, JsonObject, PayloadRequest, RequestContext } from 'payload'\n\nimport { afterReadTraverseFields } from 'payload'\n\nimport type { PopulationPromise } from '../features/typesServer.js'\n\ntype NestedRichTextFieldsArgs = {\n  context: RequestContext\n  currentDepth?: number\n  data: unknown\n  depth: number\n  draft: boolean\n  /**\n   * This maps all the population promises to the node types\n   */\n  editorPopulationPromises: Map<string, Array<PopulationPromise>>\n  /**\n   * fieldPromises are used for things like field hooks. They should be awaited before awaiting populationPromises\n   */\n  fieldPromises: Promise<void>[]\n  fields: Field[]\n  findMany: boolean\n  flattenLocales: boolean\n  overrideAccess: boolean\n  parentIsLocalized: boolean\n  populationPromises: Promise<void>[]\n  req: PayloadRequest\n  showHiddenFields: boolean\n  siblingDoc: JsonObject\n}\n\nexport const recursivelyPopulateFieldsForGraphQL = ({\n  context,\n  currentDepth = 0,\n  data,\n  depth,\n  draft,\n  fieldPromises,\n  fields,\n  findMany,\n  flattenLocales,\n  overrideAccess = false,\n  parentIsLocalized,\n  populationPromises,\n  req,\n  showHiddenFields,\n  siblingDoc,\n}: NestedRichTextFieldsArgs): void => {\n  afterReadTraverseFields({\n    collection: null, // Pass from core? This is only needed for hooks, so we can leave this null for now\n    context,\n    currentDepth,\n    depth,\n    doc: data as any, // Looks like it's only needed for hooks and access control, so doesn't matter what we pass here right now\n    draft,\n    fallbackLocale: req.fallbackLocale!,\n    fieldPromises,\n    fields,\n    findMany,\n    flattenLocales,\n    global: null, // Pass from core? This is only needed for hooks, so we can leave this null for now\n    locale: req.locale!,\n    overrideAccess,\n    parentIndexPath: '',\n    parentIsLocalized,\n    parentPath: '',\n    parentSchemaPath: '',\n    populationPromises, // This is not the same as populationPromises passed into this recurseNestedFields. These are just promises resolved at the very end.\n    req,\n    showHiddenFields,\n    siblingDoc,\n    triggerHooks: false,\n  })\n}\n"],"names":["afterReadTraverseFields","recursivelyPopulateFieldsForGraphQL","context","currentDepth","data","depth","draft","fieldPromises","fields","findMany","flattenLocales","overrideAccess","parentIsLocalized","populationPromises","req","showHiddenFields","siblingDoc","collection","doc","fallbackLocale","global","locale","parentIndexPath","parentPath","parentSchemaPath","triggerHooks"],"mappings":";;;;AAEA,SAASA,uBAAuB,QAAQ;;AA6BjC,MAAMC,mCAAA,GAAsCA,CAAC,EAClDC,OAAO,EACPC,YAAA,GAAe,CAAC,EAChBC,IAAI,EACJC,KAAK,EACLC,KAAK,EACLC,aAAa,EACbC,MAAM,EACNC,QAAQ,EACRC,cAAc,EACdC,cAAA,GAAiB,KAAK,EACtBC,iBAAiB,EACjBC,kBAAkB,EAClBC,GAAG,EACHC,gBAAgB,EAChBC,UAAAA,EACyB;QACzBhB,iXAAA,EAAwB;QACtBiB,UAAA,EAAY;QACZf,OAAA;QACAC,YAAA;QACAE,KAAA;QACAa,GAAA,EAAKd,IAAA;QACLE,KAAA;QACAa,cAAA,EAAgBL,GAAA,CAAIK,cAAc;QAClCZ,aAAA;QACAC,MAAA;QACAC,QAAA;QACAC,cAAA;QACAU,MAAA,EAAQ;QACRC,MAAA,EAAQP,GAAA,CAAIO,MAAM;QAClBV,cAAA;QACAW,eAAA,EAAiB;QACjBV,iBAAA;QACAW,UAAA,EAAY;QACZC,gBAAA,EAAkB;QAClBX,kBAAA;QACAC,GAAA;QACAC,gBAAA;QACAC,UAAA;QACAS,YAAA,EAAc;IAChB;AACF","ignoreList":[]}},
    {"offset": {"line": 2373, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/link/server/graphQLPopulationPromise.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/link/server/graphQLPopulationPromise.ts"],"sourcesContent":["import type { PopulationPromise } from '../../typesServer.js'\nimport type { SerializedLinkNode } from '../nodes/types.js'\nimport type { LinkFeatureServerProps } from './index.js'\n\nimport { recursivelyPopulateFieldsForGraphQL } from '../../../populateGraphQL/recursivelyPopulateFieldsForGraphQL.js'\n\nexport const linkPopulationPromiseHOC = (\n  props: LinkFeatureServerProps,\n): PopulationPromise<SerializedLinkNode> => {\n  return ({\n    context,\n    currentDepth,\n    depth,\n    draft,\n    editorPopulationPromises,\n    field,\n    fieldPromises,\n    findMany,\n    flattenLocales,\n    node,\n    overrideAccess,\n    parentIsLocalized,\n    populationPromises,\n    req,\n    showHiddenFields,\n  }) => {\n    if (!props.fields?.length) {\n      return\n    }\n\n    /**\n     * Should populate all fields, including the doc field (for internal links), as it's treated like a normal field\n     */\n    if (Array.isArray(props.fields)) {\n      recursivelyPopulateFieldsForGraphQL({\n        context,\n        currentDepth,\n        data: node.fields,\n        depth,\n        draft,\n        editorPopulationPromises,\n        fieldPromises,\n        fields: props.fields,\n        findMany,\n        flattenLocales,\n        overrideAccess,\n        parentIsLocalized: parentIsLocalized || field.localized || false,\n        populationPromises,\n        req,\n        showHiddenFields,\n        siblingDoc: node.fields,\n      })\n    }\n  }\n}\n"],"names":["recursivelyPopulateFieldsForGraphQL","linkPopulationPromiseHOC","props","context","currentDepth","depth","draft","editorPopulationPromises","field","fieldPromises","findMany","flattenLocales","node","overrideAccess","parentIsLocalized","populationPromises","req","showHiddenFields","fields","length","Array","isArray","data","localized","siblingDoc"],"mappings":";;;;AAIA,SAASA,mCAAmC,QAAQ;;AAE7C,MAAMC,wBAAA,IACXC,KAAA;IAEA,OAAO,CAAC,EACNC,OAAO,EACPC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,wBAAwB,EACxBC,KAAK,EACLC,aAAa,EACbC,QAAQ,EACRC,cAAc,EACdC,IAAI,EACJC,cAAc,EACdC,iBAAiB,EACjBC,kBAAkB,EAClBC,GAAG,EACHC,gBAAAA,EACD;QACC,IAAI,CAACf,KAAA,CAAMgB,MAAM,EAAEC,MAAA,EAAQ;YACzB;QACF;QAEA;;OAGA,IAAIC,KAAA,CAAMC,OAAO,CAACnB,KAAA,CAAMgB,MAAM,GAAG;gBAC/BlB,scAAA,EAAoC;gBAClCG,OAAA;gBACAC,YAAA;gBACAkB,IAAA,EAAMV,IAAA,CAAKM,MAAM;gBACjBb,KAAA;gBACAC,KAAA;gBACAC,wBAAA;gBACAE,aAAA;gBACAS,MAAA,EAAQhB,KAAA,CAAMgB,MAAM;gBACpBR,QAAA;gBACAC,cAAA;gBACAE,cAAA;gBACAC,iBAAA,EAAmBA,iBAAA,IAAqBN,KAAA,CAAMe,SAAS,IAAI;gBAC3DR,kBAAA;gBACAC,GAAA;gBACAC,gBAAA;gBACAO,UAAA,EAAYZ,IAAA,CAAKM,MAAAA;YACnB;QACF;IACF;AACF","ignoreList":[]}},
    {"offset": {"line": 2412, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/link/server/i18n.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/link/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'رابط',\n    loadingWithEllipsis: 'جار التحميل...',\n  },\n  az: {\n    label: 'Keçid',\n    loadingWithEllipsis: 'Yüklənir...',\n  },\n  bg: {\n    label: 'Връзка',\n    loadingWithEllipsis: 'Зарежда се...',\n  },\n  cs: {\n    label: 'Odkaz',\n    loadingWithEllipsis: 'Načítání...',\n  },\n  da: {\n    label: 'Link',\n    loadingWithEllipsis: 'Indlæser...',\n  },\n  de: {\n    label: 'Verknüpfung',\n    loadingWithEllipsis: 'Laden...',\n  },\n  en: {\n    label: 'Link',\n    loadingWithEllipsis: 'Loading...',\n  },\n  es: {\n    label: 'Enlace',\n    loadingWithEllipsis: 'Cargando...',\n  },\n  et: {\n    label: 'Link',\n    loadingWithEllipsis: 'Laadimine...',\n  },\n  fa: {\n    label: 'پیوند',\n    loadingWithEllipsis: 'در حال بارگذاری...',\n  },\n  fr: {\n    label: 'Lien',\n    loadingWithEllipsis: 'Chargement...',\n  },\n  he: {\n    label: 'קישור',\n    loadingWithEllipsis: 'טוען...',\n  },\n  hr: {\n    label: 'Poveznica',\n    loadingWithEllipsis: 'Učitavanje...',\n  },\n  hu: {\n    label: 'Hivatkozás',\n    loadingWithEllipsis: 'Betöltés...',\n  },\n  is: {\n    label: 'Hlekkur',\n    loadingWithEllipsis: 'Hleð...',\n  },\n  it: {\n    label: 'Collegamento',\n    loadingWithEllipsis: 'Caricamento...',\n  },\n  ja: {\n    label: 'リンク',\n    loadingWithEllipsis: '読み込み中...',\n  },\n  ko: {\n    label: '링크',\n    loadingWithEllipsis: '로딩 중...',\n  },\n  my: {\n    label: 'လင့်',\n    loadingWithEllipsis: 'ဖွင့်နေသည်...',\n  },\n  nb: {\n    label: 'Lenke',\n    loadingWithEllipsis: 'Laster...',\n  },\n  nl: {\n    label: 'Link',\n    loadingWithEllipsis: 'Laden...',\n  },\n  pl: {\n    label: 'Łącze',\n    loadingWithEllipsis: 'Ładowanie...',\n  },\n  pt: {\n    label: 'Ligação',\n    loadingWithEllipsis: 'Carregando...',\n  },\n  ro: {\n    label: 'Legătură',\n    loadingWithEllipsis: 'Se încarcă...',\n  },\n  rs: {\n    label: 'Веза',\n    loadingWithEllipsis: 'Учитавање...',\n  },\n  'rs-latin': {\n    label: 'Veza',\n    loadingWithEllipsis: 'Učitavanje...',\n  },\n  ru: {\n    label: 'Ссылка',\n    loadingWithEllipsis: 'Загрузка...',\n  },\n  sk: {\n    label: 'Odkaz',\n    loadingWithEllipsis: 'Načítava sa...',\n  },\n  sl: {\n    label: 'Povezava',\n    loadingWithEllipsis: 'Nalaganje...',\n  },\n  sv: {\n    label: 'Länk',\n    loadingWithEllipsis: 'Laddar...',\n  },\n  ta: {\n    label: 'இணைப்பு',\n    loadingWithEllipsis: 'போர்த்துவருகிறது...',\n  },\n  th: {\n    label: 'ลิงค์',\n    loadingWithEllipsis: 'กำลังโหลด...',\n  },\n  tr: {\n    label: 'Bağlantı',\n    loadingWithEllipsis: 'Yükleniyor...',\n  },\n  uk: {\n    label: 'Посилання',\n    loadingWithEllipsis: 'Завантаження...',\n  },\n  vi: {\n    label: 'Liên kết',\n    loadingWithEllipsis: 'Đang tải...',\n  },\n  zh: {\n    label: '链接',\n    loadingWithEllipsis: '加载中...',\n  },\n  'zh-TW': {\n    label: '連結',\n    loadingWithEllipsis: '載入中...',\n  },\n}\n"],"names":["i18n","ar","label","loadingWithEllipsis","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","is","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","ta","th","tr","uk","vi","zh"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 2570, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/lexical/utils/url.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/utils/url.ts"],"sourcesContent":["export function sanitizeUrl(url: string): string {\n  /** A pattern that matches safe  URLs. */\n  const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi\n\n  /** A pattern that matches safe data URLs. */\n  const DATA_URL_PATTERN =\n    /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[a-z\\d+/]+=*$/i\n\n  url = String(url).trim()\n\n  if (url.match(SAFE_URL_PATTERN) != null || url.match(DATA_URL_PATTERN) != null) {\n    return url\n  }\n\n  return 'https://'\n}\n\n/**\n * This regex checks for absolute URLs in a string. Tested for the following use cases:\n * - http://example.com\n * - https://example.com\n * - ftp://files.example.com\n * - http://example.com/resource\n * - https://example.com/resource?key=value\n * - http://example.com/resource#anchor\n * - http://www.example.com\n * - https://sub.example.com/path/file\n * - mailto:\n */\nexport const absoluteRegExp =\n  /^(?:[a-zA-Z][a-zA-Z\\d+.-]*:(?:\\/\\/)?(?:[-;:&=+$,\\w]+@)?[A-Za-z\\d]+(?:\\.[A-Za-z\\d]+)+|www\\.[A-Za-z\\d]+(?:\\.[A-Za-z\\d]+)+|(?:tel|mailto):[\\w+.-]+)(?:\\/[+~%/\\w-]*)?(?:\\?[-;&=%\\w]*)?(?:#\\w+)?$/\n\n/**\n * This regex checks for relative URLs starting with / or anchor links starting with # in a string. Tested for the following use cases:\n * - /privacy-policy\n * - /privacy-policy#primary-terms\n * - #primary-terms\n * - /page?id=123\n * - /page?id=123#section\n *  */\nexport const relativeOrAnchorRegExp = /^(?:\\/[\\w\\-./]*(?:\\?[-;&=%\\w]*)?(?:#[\\w-]+)?|#[\\w\\-]+)$/\n\n/**\n * Prevents unreasonable URLs from being inserted into the editor.\n * @param url\n */\nexport function validateUrlMinimal(url: string): boolean {\n  if (!url) {\n    return false\n  }\n\n  return !url.includes(' ')\n}\n\n// Do not keep validateUrl function too loose. This is run when pasting in text, to determine if links are in that text and if it should create AutoLinkNodes.\n// This is why we do not allow stuff like anchors here, as we don't want copied anchors to be turned into AutoLinkNodes.\nexport function validateUrl(url: string): boolean {\n  // TODO Fix UI for link insertion; it should never default to an invalid URL such as https://.\n  // Maybe show a dialog where they user can type the URL before inserting it.\n  if (!url) {\n    return false\n  }\n\n  // Reject URLs with spaces\n  if (url.includes(' ')) {\n    return false\n  }\n\n  // Reject malformed protocol URLs (e.g., http:/example.com instead of http://example.com)\n  if (/^[a-z][a-z\\d+.-]*:\\/[^/]/i.test(url)) {\n    return false\n  }\n\n  if (url === 'https://') {\n    return true\n  }\n\n  // This makes sure URLs starting with www. instead of https are valid too\n  if (absoluteRegExp.test(url)) {\n    return true\n  }\n\n  // Check relative or anchor links\n  if (relativeOrAnchorRegExp.test(url)) {\n    return true\n  }\n\n  // While this doesn't allow URLs starting with www (which is why we use the regex above), it does properly handle tel: URLs\n  try {\n    const urlObj = new URL(url)\n    // For http/https/ftp protocols, require a proper domain with at least one dot (for TLD)\n    if (['ftp:', 'http:', 'https:'].includes(urlObj.protocol)) {\n      if (!urlObj.hostname.includes('.')) {\n        return false\n      }\n    }\n    return true\n  } catch {\n    /* empty */\n  }\n\n  return false\n}\n"],"names":["sanitizeUrl","url","SAFE_URL_PATTERN","DATA_URL_PATTERN","String","trim","match","absoluteRegExp","relativeOrAnchorRegExp","validateUrlMinimal","includes","validateUrl","test","urlObj","URL","protocol","hostname"],"mappings":";;;;;;;;;;;;AAAO,SAASA,YAAYC,GAAW;IACrC,uCAAA,GACA,MAAMC,gBAAA,GAAmB;IAEzB,2CAAA,GACA,MAAMC,gBAAA,GACJ;IAEFF,GAAA,GAAMG,MAAA,CAAOH,GAAA,EAAKI,IAAI;IAEtB,IAAIJ,GAAA,CAAIK,KAAK,CAACJ,gBAAA,KAAqB,QAAQD,GAAA,CAAIK,KAAK,CAACH,gBAAA,KAAqB,MAAM;QAC9E,OAAOF,GAAA;IACT;IAEA,OAAO;AACT;AAcO,MAAMM,cAAA,GACX;AAUK,MAAMC,sBAAA,GAAyB;AAM/B,SAASC,mBAAmBR,GAAW;IAC5C,IAAI,CAACA,GAAA,EAAK;QACR,OAAO;IACT;IAEA,OAAO,CAACA,GAAA,CAAIS,QAAQ,CAAC;AACvB;AAIO,SAASC,YAAYV,GAAW;IACrC,8FAAA;IACA,4EAAA;IACA,IAAI,CAACA,GAAA,EAAK;QACR,OAAO;IACT;IAEA,0BAAA;IACA,IAAIA,GAAA,CAAIS,QAAQ,CAAC,MAAM;QACrB,OAAO;IACT;IAEA,yFAAA;IACA,IAAI,4BAA4BE,IAAI,CAACX,GAAA,GAAM;QACzC,OAAO;IACT;IAEA,IAAIA,GAAA,KAAQ,YAAY;QACtB,OAAO;IACT;IAEA,yEAAA;IACA,IAAIM,cAAA,CAAeK,IAAI,CAACX,GAAA,GAAM;QAC5B,OAAO;IACT;IAEA,iCAAA;IACA,IAAIO,sBAAA,CAAuBI,IAAI,CAACX,GAAA,GAAM;QACpC,OAAO;IACT;IAEA,2HAAA;IACA,IAAI;QACF,MAAMY,MAAA,GAAS,IAAIC,GAAA,CAAIb,GAAA;QACvB,wFAAA;QACA,IAAI;YAAC;YAAQ;YAAS;SAAS,CAACS,QAAQ,CAACG,MAAA,CAAOE,QAAQ,GAAG;YACzD,IAAI,CAACF,MAAA,CAAOG,QAAQ,CAACN,QAAQ,CAAC,MAAM;gBAClC,OAAO;YACT;QACF;QACA,OAAO;IACT,EAAE,OAAM;IACN,SAAA,GAAA;IAGF,OAAO;AACT","ignoreList":[]}},
    {"offset": {"line": 2646, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/link/server/baseFields.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/link/server/baseFields.ts"],"sourcesContent":["import type {\n  CollectionSlug,\n  FieldAffectingData,\n  RadioField,\n  SanitizedConfig,\n  TextField,\n  TextFieldSingleValidation,\n  TypedUser,\n} from 'payload'\n\nimport type { LinkFields } from '../nodes/types.js'\n\nimport { validateUrl, validateUrlMinimal } from '../../../lexical/utils/url.js'\n\nexport const getBaseFields = (\n  config: SanitizedConfig,\n  enabledCollections?: CollectionSlug[],\n  disabledCollections?: CollectionSlug[],\n  maxDepth?: number,\n): FieldAffectingData[] => {\n  let enabledRelations: CollectionSlug[]\n\n  /**\n   * Figure out which relations should be enabled (enabledRelations) based on a collection's admin.enableRichTextLink property,\n   * or the Link Feature's enabledCollections and disabledCollections properties which override it.\n   */\n  if (enabledCollections) {\n    enabledRelations = enabledCollections\n  } else if (disabledCollections) {\n    enabledRelations = config.collections\n      .filter(({ slug }) => !disabledCollections.includes(slug))\n      .map(({ slug }) => slug)\n  } else {\n    enabledRelations = config.collections\n      .filter(({ admin: { enableRichTextLink, hidden } }) => {\n        if (typeof hidden !== 'function' && hidden) {\n          return false\n        }\n        return enableRichTextLink\n      })\n      .map(({ slug }) => slug)\n  }\n\n  const baseFields: FieldAffectingData[] = [\n    {\n      name: 'text',\n      type: 'text',\n      label: ({ t }) => t('fields:textToDisplay'),\n      required: true,\n    },\n    {\n      name: 'linkType',\n      type: 'radio',\n      admin: {\n        description: ({ t }) => t('fields:chooseBetweenCustomTextOrDocument'),\n      },\n      defaultValue: 'custom',\n      label: ({ t }) => t('fields:linkType'),\n      options: [\n        {\n          label: ({ t }) => t('fields:customURL'),\n          value: 'custom',\n        },\n      ],\n      required: true,\n    } as RadioField,\n    {\n      name: 'url',\n      type: 'text',\n      hooks: {\n        beforeChange: [\n          ({ value }) => {\n            if (!value) {\n              return\n            }\n\n            if (!validateUrl(value)) {\n              return encodeURIComponent(value)\n            }\n            return value\n          },\n        ],\n      },\n      label: ({ t }) => t('fields:enterURL'),\n      required: true,\n      validate: ((value: string, options) => {\n        if ((options?.siblingData as LinkFields)?.linkType === 'internal') {\n          return // no validation needed, as no url should exist for internal links\n        }\n        if (!validateUrlMinimal(value)) {\n          return 'Invalid URL'\n        }\n      }) as TextFieldSingleValidation,\n    },\n  ]\n\n  // Only display internal link-specific fields / options / conditions if there are enabled relations\n  if (enabledRelations?.length) {\n    ;(baseFields[1] as RadioField).options.push({\n      label: ({ t }) => t('fields:internalLink'),\n      value: 'internal',\n    })\n    ;(baseFields[2] as TextField).admin = {\n      condition: (_data, _siblingData) => {\n        return _siblingData.linkType !== 'internal'\n      },\n    }\n\n    baseFields.push({\n      name: 'doc',\n      admin: {\n        condition: (_data, _siblingData) => {\n          return _siblingData.linkType === 'internal'\n        },\n      },\n      // when admin.hidden is a function we need to dynamically call hidden with the user to know if the collection should be shown\n      type: 'relationship',\n      filterOptions:\n        !enabledCollections && !disabledCollections\n          ? async ({ relationTo, req, user }) => {\n              const admin = config.collections.find(({ slug }) => slug === relationTo)?.admin\n\n              const hidden = admin?.hidden\n              if (typeof hidden === 'function' && hidden({ user } as { user: TypedUser })) {\n                return false\n              }\n\n              const baseFilter = admin?.baseFilter ?? admin?.baseListFilter\n              return (\n                (await baseFilter?.({\n                  limit: 0,\n                  page: 1,\n                  req,\n                  sort: 'id',\n                })) ?? true\n              )\n            }\n          : null,\n      label: ({ t }) => t('fields:chooseDocumentToLink'),\n      maxDepth,\n      relationTo: enabledRelations,\n      required: true,\n    })\n  }\n\n  baseFields.push({\n    name: 'newTab',\n    type: 'checkbox',\n    label: ({ t }) => t('fields:openInNewTab'),\n  })\n\n  return baseFields\n}\n"],"names":["validateUrl","validateUrlMinimal","getBaseFields","config","enabledCollections","disabledCollections","maxDepth","enabledRelations","collections","filter","slug","includes","map","admin","enableRichTextLink","hidden","baseFields","name","type","label","t","required","description","defaultValue","options","value","hooks","beforeChange","encodeURIComponent","validate","siblingData","linkType","length","push","condition","_data","_siblingData","filterOptions","relationTo","req","user","find","baseFilter","baseListFilter","limit","page","sort"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 2773, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/link/server/transformExtraFields.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/link/server/transformExtraFields.ts"],"sourcesContent":["import type { CollectionSlug, Field, FieldAffectingData, SanitizedConfig } from 'payload'\n\nimport { getBaseFields } from './baseFields.js'\n\n/**\n * This function is run to enrich the basefields which every link has with potential, custom user-added fields.\n */\nexport function transformExtraFields(\n  customFieldSchema:\n    | ((args: {\n        config: SanitizedConfig\n        defaultFields: FieldAffectingData[]\n      }) => (Field | FieldAffectingData)[])\n    | Field[]\n    | null,\n  config: SanitizedConfig,\n  enabledCollections?: CollectionSlug[],\n  disabledCollections?: CollectionSlug[],\n  maxDepth?: number,\n): Field[] {\n  const baseFields: FieldAffectingData[] = getBaseFields(\n    config,\n    enabledCollections,\n    disabledCollections,\n    maxDepth,\n  )\n\n  let fields: (Field | FieldAffectingData)[]\n\n  if (typeof customFieldSchema === 'function') {\n    fields = customFieldSchema({ config, defaultFields: baseFields })\n  } else if (Array.isArray(customFieldSchema)) {\n    fields = customFieldSchema\n  } else {\n    fields = baseFields\n  }\n\n  return fields as Field[]\n}\n"],"names":["getBaseFields","transformExtraFields","customFieldSchema","config","enabledCollections","disabledCollections","maxDepth","baseFields","fields","defaultFields","Array","isArray"],"mappings":";;;;AAEA,SAASA,aAAa,QAAQ;;AAKvB,SAASC,qBACdC,iBAMQ,EACRC,MAAuB,EACvBC,kBAAqC,EACrCC,mBAAsC,EACtCC,QAAiB;IAEjB,MAAMC,UAAA,OAAmCP,kaAAA,EACvCG,MAAA,EACAC,kBAAA,EACAC,mBAAA,EACAC,QAAA;IAGF,IAAIE,MAAA;IAEJ,IAAI,OAAON,iBAAA,KAAsB,YAAY;QAC3CM,MAAA,GAASN,iBAAA,CAAkB;YAAEC,MAAA;YAAQM,aAAA,EAAeF;QAAW;IACjE,OAAO,IAAIG,KAAA,CAAMC,OAAO,CAACT,iBAAA,GAAoB;QAC3CM,MAAA,GAASN,iBAAA;IACX,OAAO;QACLM,MAAA,GAASD,UAAA;IACX;IAEA,OAAOC,MAAA;AACT","ignoreList":[]}},
    {"offset": {"line": 2798, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/link/server/validate.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/link/server/validate.ts"],"sourcesContent":["import type { Field } from 'payload'\n\nimport { fieldSchemasToFormState } from '@payloadcms/ui/forms/fieldSchemasToFormState'\n\nimport type { NodeValidation } from '../../typesServer.js'\nimport type { SerializedAutoLinkNode, SerializedLinkNode } from '../nodes/types.js'\nimport type { LinkFeatureServerProps } from './index.js'\n\nexport const linkValidation = (\n  props: LinkFeatureServerProps,\n  sanitizedFieldsWithoutText: Field[],\n): NodeValidation<SerializedAutoLinkNode | SerializedLinkNode> => {\n  return async ({\n    node,\n    validation: {\n      options: { id, collectionSlug, data, operation, preferences, req },\n    },\n  }) => {\n    /**\n     * Run fieldSchemasToFormState as that properly validates link fields and link sub-fields\n     */\n\n    const result = await fieldSchemasToFormState({\n      id,\n      collectionSlug,\n      data: node.fields,\n      documentData: data,\n      fields: sanitizedFieldsWithoutText, // Sanitized in feature.server.ts\n      fieldSchemaMap: undefined,\n      initialBlockData: node.fields,\n      operation: operation === 'create' || operation === 'update' ? operation : 'update',\n      permissions: {},\n      preferences,\n      renderAllFields: false,\n      req,\n      schemaPath: '',\n    })\n\n    const errorPathsSet = new Set<string>()\n    for (const fieldKey in result) {\n      const fieldState = result[fieldKey]\n      if (fieldState?.errorPaths?.length) {\n        for (const errorPath of fieldState.errorPaths) {\n          errorPathsSet.add(errorPath)\n        }\n      }\n    }\n    const errorPaths = Array.from(errorPathsSet)\n\n    if (errorPaths.length) {\n      return 'The following fields are invalid: ' + errorPaths.join(', ')\n    }\n\n    return true\n  }\n}\n"],"names":["fieldSchemasToFormState","linkValidation","props","sanitizedFieldsWithoutText","node","validation","options","id","collectionSlug","data","operation","preferences","req","result","fields","documentData","fieldSchemaMap","undefined","initialBlockData","permissions","renderAllFields","schemaPath","errorPathsSet","Set","fieldKey","fieldState","errorPaths","length","errorPath","add","Array","from","join"],"mappings":";;;;AAEA,SAASA,uBAAuB,QAAQ;;AAMjC,MAAMC,cAAA,GAAiBA,CAC5BC,KAAA,EACAC,0BAAA;IAEA,OAAO,OAAO,EACZC,IAAI,EACJC,UAAA,EAAY,EACVC,OAAA,EAAS,EAAEC,EAAE,EAAEC,cAAc,EAAEC,IAAI,EAAEC,SAAS,EAAEC,WAAW,EAAEC,GAAAA,EAAG,EAAE,EAErE;QACC;;OAIA,MAAMC,MAAA,GAAS,UAAMb,+aAAA,EAAwB;YAC3CO,EAAA;YACAC,cAAA;YACAC,IAAA,EAAML,IAAA,CAAKU,MAAM;YACjBC,YAAA,EAAcN,IAAA;YACdK,MAAA,EAAQX,0BAAA;YACRa,cAAA,EAAgBC,SAAA;YAChBC,gBAAA,EAAkBd,IAAA,CAAKU,MAAM;YAC7BJ,SAAA,EAAWA,SAAA,KAAc,YAAYA,SAAA,KAAc,WAAWA,SAAA,GAAY;YAC1ES,WAAA,EAAa,CAAC;YACdR,WAAA;YACAS,eAAA,EAAiB;YACjBR,GAAA;YACAS,UAAA,EAAY;QACd;QAEA,MAAMC,aAAA,GAAgB,IAAIC,GAAA;QAC1B,IAAK,MAAMC,QAAA,IAAYX,MAAA,CAAQ;YAC7B,MAAMY,UAAA,GAAaZ,MAAM,CAACW,QAAA,CAAS;YACnC,IAAIC,UAAA,EAAYC,UAAA,EAAYC,MAAA,EAAQ;gBAClC,KAAK,MAAMC,SAAA,IAAaH,UAAA,CAAWC,UAAU,CAAE;oBAC7CJ,aAAA,CAAcO,GAAG,CAACD,SAAA;gBACpB;YACF;QACF;QACA,MAAMF,UAAA,GAAaI,KAAA,CAAMC,IAAI,CAACT,aAAA;QAE9B,IAAII,UAAA,CAAWC,MAAM,EAAE;YACrB,OAAO,uCAAuCD,UAAA,CAAWM,IAAI,CAAC;QAChE;QAEA,OAAO;IACT;AACF","ignoreList":[]}},
    {"offset": {"line": 2843, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/link/server/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/link/server/index.ts"],"sourcesContent":["import type {\n  CollectionSlug,\n  Config,\n  Field,\n  FieldAffectingData,\n  FieldSchemaMap,\n  SanitizedConfig,\n} from 'payload'\n\nimport escapeHTML from 'escape-html'\nimport { sanitizeFields } from 'payload'\n\nimport type { NodeWithHooks } from '../../typesServer.js'\nimport type { ClientProps } from '../client/index.js'\n\nimport { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { convertLexicalNodesToHTML } from '../../converters/lexicalToHtml_deprecated/converter/index.js'\nimport { createNode } from '../../typeUtilities.js'\nimport { LinkMarkdownTransformer } from '../markdownTransformer.js'\nimport { AutoLinkNode } from '../nodes/AutoLinkNode.js'\nimport { LinkNode } from '../nodes/LinkNode.js'\nimport { linkPopulationPromiseHOC } from './graphQLPopulationPromise.js'\nimport { i18n } from './i18n.js'\nimport { transformExtraFields } from './transformExtraFields.js'\nimport { linkValidation } from './validate.js'\n\nexport type ExclusiveLinkCollectionsProps =\n  | {\n      /**\n       * The collections that should be disabled for internal linking. Overrides the `enableRichTextLink` property in the collection config.\n       * When this property is set, `enabledCollections` will not be available.\n       **/\n      disabledCollections?: CollectionSlug[]\n\n      // Ensures that enabledCollections is not available when disabledCollections is set\n      enabledCollections?: never\n    }\n  | {\n      // Ensures that disabledCollections is not available when enabledCollections is set\n      disabledCollections?: never\n\n      /**\n       * The collections that should be enabled for internal linking. Overrides the `enableRichTextLink` property in the collection config\n       * When this property is set, `disabledCollections` will not be available.\n       **/\n      enabledCollections?: CollectionSlug[]\n    }\n\nexport type LinkFeatureServerProps = {\n  /**\n   * Disables the automatic creation of links from URLs pasted into the editor, as well\n   * as auto link nodes.\n   *\n   * If set to 'creationOnly', only the creation of new auto link nodes will be disabled.\n   * Existing auto link nodes will still be editable.\n   *\n   * @default false\n   */\n  disableAutoLinks?: 'creationOnly' | true\n  /**\n   * A function or array defining additional fields for the link feature. These will be\n   * displayed in the link editor drawer.\n   */\n  fields?:\n    | ((args: {\n        config: SanitizedConfig\n        defaultFields: FieldAffectingData[]\n      }) => (Field | FieldAffectingData)[])\n    | Field[]\n  /**\n   * Sets a maximum population depth for the internal doc default field of link, regardless of the remaining depth when the field is reached.\n   * This behaves exactly like the maxDepth properties of relationship and upload fields.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n} & ExclusiveLinkCollectionsProps\n\nexport const LinkFeature = createServerFeature<\n  LinkFeatureServerProps,\n  LinkFeatureServerProps,\n  ClientProps\n>({\n  feature: async ({ config: _config, isRoot, parentIsLocalized, props }) => {\n    if (!props) {\n      props = {}\n    }\n    const validRelationships = _config.collections.map((c) => c.slug) || []\n\n    const _transformedFields = transformExtraFields(\n      props.fields ? props.fields : null,\n      _config,\n      props.enabledCollections,\n      props.disabledCollections,\n      props.maxDepth,\n    )\n\n    const sanitizedFields = await sanitizeFields({\n      config: _config as unknown as Config,\n      fields: _transformedFields,\n      parentIsLocalized,\n      requireFieldLevelRichTextEditor: isRoot,\n      validRelationships,\n    })\n    props.fields = sanitizedFields\n\n    // the text field is not included in the node data.\n    // Thus, for tasks like validation, we do not want to pass it a text field in the schema which will never have data.\n    // Otherwise, it will cause a validation error (field is required).\n    const sanitizedFieldsWithoutText = sanitizedFields.filter(\n      (field) => !('name' in field) || field.name !== 'text',\n    )\n\n    let linkTypeField: Field | null = null\n    let linkURLField: Field | null = null\n\n    for (const field of sanitizedFields) {\n      if ('name' in field && field.name === 'linkType') {\n        linkTypeField = field\n      }\n\n      if ('name' in field && field.name === 'url') {\n        linkURLField = field\n      }\n    }\n\n    const defaultLinkType = linkTypeField\n      ? 'defaultValue' in linkTypeField && typeof linkTypeField.defaultValue === 'string'\n        ? linkTypeField.defaultValue\n        : 'custom'\n      : undefined\n\n    const defaultLinkURL = linkURLField\n      ? 'defaultValue' in linkURLField && typeof linkURLField.defaultValue === 'string'\n        ? linkURLField.defaultValue\n        : 'https://'\n      : undefined\n\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#LinkFeatureClient',\n      clientFeatureProps: {\n        defaultLinkType,\n        defaultLinkURL,\n        disableAutoLinks: props.disableAutoLinks,\n        disabledCollections: props.disabledCollections,\n        enabledCollections: props.enabledCollections,\n      } as ClientProps,\n      generateSchemaMap: () => {\n        if (!sanitizedFields || !Array.isArray(sanitizedFields) || sanitizedFields.length === 0) {\n          return null\n        }\n\n        const schemaMap: FieldSchemaMap = new Map()\n        schemaMap.set('fields', {\n          fields: sanitizedFields,\n        })\n\n        return schemaMap\n      },\n      i18n,\n      markdownTransformers: [LinkMarkdownTransformer],\n      nodes: [\n        props?.disableAutoLinks === true\n          ? null\n          : createNode({\n              converters: {\n                html: {\n                  converter: async ({\n                    converters,\n                    currentDepth,\n                    depth,\n                    draft,\n                    node,\n                    overrideAccess,\n                    parent,\n                    req,\n                    showHiddenFields,\n                  }) => {\n                    const childrenText = await convertLexicalNodesToHTML({\n                      converters,\n                      currentDepth,\n                      depth,\n                      draft,\n                      lexicalNodes: node.children,\n                      overrideAccess,\n                      parent: {\n                        ...node,\n                        parent,\n                      },\n                      req,\n                      showHiddenFields,\n                    })\n\n                    let href: string = node.fields.url ?? ''\n                    if (node.fields.linkType === 'internal') {\n                      href =\n                        typeof node.fields.doc?.value !== 'object'\n                          ? String(node.fields.doc?.value)\n                          : String(node.fields.doc?.value?.id)\n                    }\n\n                    return `<a href=\"${href}\"${node.fields.newTab ? ' rel=\"noopener noreferrer\" target=\"_blank\"' : ''}>${childrenText}</a>`\n                  },\n                  nodeTypes: [AutoLinkNode.getType()],\n                },\n              },\n              node: AutoLinkNode,\n              // Since AutoLinkNodes are just internal links, they need no hooks or graphQL population promises\n              validations: [linkValidation(props, sanitizedFieldsWithoutText)],\n            }),\n        createNode({\n          converters: {\n            html: {\n              converter: async ({\n                converters,\n                currentDepth,\n                depth,\n                draft,\n                node,\n                overrideAccess,\n                parent,\n                req,\n                showHiddenFields,\n              }) => {\n                const childrenText = await convertLexicalNodesToHTML({\n                  converters,\n                  currentDepth,\n                  depth,\n                  draft,\n                  lexicalNodes: node.children,\n                  overrideAccess,\n                  parent: {\n                    ...node,\n                    parent,\n                  },\n                  req,\n                  showHiddenFields,\n                })\n\n                const href: string =\n                  node.fields.linkType === 'custom'\n                    ? escapeHTML(node.fields.url)\n                    : (node.fields.doc?.value as string)\n\n                return `<a href=\"${href}\"${node.fields.newTab ? ' rel=\"noopener noreferrer\" target=\"_blank\"' : ''}>${childrenText}</a>`\n              },\n              nodeTypes: [LinkNode.getType()],\n            },\n          },\n          getSubFields: () => {\n            return sanitizedFieldsWithoutText\n          },\n          getSubFieldsData: ({ node }) => {\n            return node?.fields\n          },\n          graphQLPopulationPromises: [linkPopulationPromiseHOC(props)],\n          node: LinkNode,\n          validations: [linkValidation(props, sanitizedFieldsWithoutText)],\n        }),\n      ].filter(Boolean) as Array<NodeWithHooks>,\n      sanitizedServerFeatureProps: props,\n    }\n  },\n  key: 'link',\n})\n"],"names":["escapeHTML","sanitizeFields","createServerFeature","convertLexicalNodesToHTML","createNode","LinkMarkdownTransformer","AutoLinkNode","LinkNode","linkPopulationPromiseHOC","i18n","transformExtraFields","linkValidation","LinkFeature","feature","config","_config","isRoot","parentIsLocalized","props","validRelationships","collections","map","c","slug","_transformedFields","fields","enabledCollections","disabledCollections","maxDepth","sanitizedFields","requireFieldLevelRichTextEditor","sanitizedFieldsWithoutText","filter","field","name","linkTypeField","linkURLField","defaultLinkType","defaultValue","undefined","defaultLinkURL","ClientFeature","clientFeatureProps","disableAutoLinks","generateSchemaMap","Array","isArray","length","schemaMap","Map","set","markdownTransformers","nodes","converters","html","converter","currentDepth","depth","draft","node","overrideAccess","parent","req","showHiddenFields","childrenText","lexicalNodes","children","href","url","linkType","doc","value","String","id","newTab","nodeTypes","getType","validations","getSubFields","getSubFieldsData","graphQLPopulationPromises","Boolean","sanitizedServerFeatureProps","key"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 3011, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/lists/htmlConverter.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/htmlConverter.ts"],"sourcesContent":["import { ListItemNode, ListNode } from '@lexical/list'\nimport { v4 as uuidv4 } from 'uuid'\n\nimport type { HTMLConverter } from '../converters/lexicalToHtml_deprecated/converter/types.js'\nimport type { SerializedListItemNode, SerializedListNode } from './plugin/index.js'\n\nimport { convertLexicalNodesToHTML } from '../converters/lexicalToHtml_deprecated/converter/index.js'\n\nexport const ListHTMLConverter: HTMLConverter<SerializedListNode> = {\n  converter: async ({\n    converters,\n    currentDepth,\n    depth,\n    draft,\n    node,\n    overrideAccess,\n    parent,\n    req,\n    showHiddenFields,\n  }) => {\n    const childrenText = await convertLexicalNodesToHTML({\n      converters,\n      currentDepth,\n      depth,\n      draft,\n      lexicalNodes: node.children,\n      overrideAccess,\n      parent: {\n        ...node,\n        parent,\n      },\n      req,\n      showHiddenFields,\n    })\n\n    return `<${node?.tag} class=\"list-${node?.listType}\">${childrenText}</${node?.tag}>`\n  },\n  nodeTypes: [ListNode.getType()],\n}\n\nexport const ListItemHTMLConverter: HTMLConverter<SerializedListItemNode> = {\n  converter: async ({\n    converters,\n    currentDepth,\n    depth,\n    draft,\n    node,\n    overrideAccess,\n    parent,\n    req,\n    showHiddenFields,\n  }) => {\n    const hasSubLists = node.children.some((child) => child.type === 'list')\n\n    const childrenText = await convertLexicalNodesToHTML({\n      converters,\n      currentDepth,\n      depth,\n      draft,\n      lexicalNodes: node.children,\n      overrideAccess,\n      parent: {\n        ...node,\n        parent,\n      },\n      req,\n      showHiddenFields,\n    })\n\n    if ('listType' in parent && parent?.listType === 'check') {\n      const uuid = uuidv4()\n\n      return `<li aria-checked=${node.checked ? 'true' : 'false'} class=\"${\n        'list-item-checkbox' +\n        (node.checked ? ' list-item-checkbox-checked' : ' list-item-checkbox-unchecked') +\n        (hasSubLists ? ' nestedListItem' : '')\n      }\"\n          role=\"checkbox\"\n          tabIndex=${-1}\n          value=${node?.value}\n      >\n      ${\n        hasSubLists\n          ? childrenText\n          : `\n        <input type=\"checkbox\" id=\"${uuid}\"${node.checked ? ' checked' : ''}>\n        <label for=\"${uuid}\">${childrenText}</label><br>\n      `\n      }\n\n\n          </li>`\n    } else {\n      return `<li ${hasSubLists ? `class=\"nestedListItem\" ` : ''}value=${node?.value}>${childrenText}</li>`\n    }\n  },\n  nodeTypes: [ListItemNode.getType()],\n}\n"],"names":["ListItemNode","ListNode","v4","uuidv4","convertLexicalNodesToHTML","ListHTMLConverter","converter","converters","currentDepth","depth","draft","node","overrideAccess","parent","req","showHiddenFields","childrenText","lexicalNodes","children","tag","listType","nodeTypes","getType","ListItemHTMLConverter","hasSubLists","some","child","type","uuid","checked","value"],"mappings":";;;;;;AAAA,SAASA,YAAY,EAAEC,QAAQ,QAAQ;AACvC,SAASC,EAAA,IAAMC,MAAM,QAAQ;AAK7B,SAASC,yBAAyB,QAAQ;;;;AAEnC,MAAMC,iBAAA,GAAuD;IAClEC,SAAA,EAAW,MAAAA,CAAO,EAChBC,UAAU,EACVC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdC,MAAM,EACNC,GAAG,EACHC,gBAAAA,EACD;QACC,MAAMC,YAAA,GAAe,UAAMZ,8cAAA,EAA0B;YACnDG,UAAA;YACAC,YAAA;YACAC,KAAA;YACAC,KAAA;YACAO,YAAA,EAAcN,IAAA,CAAKO,QAAQ;YAC3BN,cAAA;YACAC,MAAA,EAAQ;gBACN,GAAGF,IAAI;gBACPE;YACF;YACAC,GAAA;YACAC;QACF;QAEA,OAAO,CAAA,CAAA,EAAIJ,IAAA,EAAMQ,GAAA,CAAA,aAAA,EAAmBR,IAAA,EAAMS,QAAA,CAAA,EAAA,EAAaJ,YAAA,CAAA,EAAA,EAAiBL,IAAA,EAAMQ,GAAA,CAAA,CAAA,CAAM;IACtF;IACAE,SAAA,EAAW;QAACpB,mOAAA,CAASqB,OAAO;KAAA;AAC9B;AAEO,MAAMC,qBAAA,GAA+D;IAC1EjB,SAAA,EAAW,MAAAA,CAAO,EAChBC,UAAU,EACVC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdC,MAAM,EACNC,GAAG,EACHC,gBAAAA,EACD;QACC,MAAMS,WAAA,GAAcb,IAAA,CAAKO,QAAQ,CAACO,IAAI,EAAEC,KAAA,GAAUA,KAAA,CAAMC,IAAI,KAAK;QAEjE,MAAMX,YAAA,GAAe,UAAMZ,8cAAA,EAA0B;YACnDG,UAAA;YACAC,YAAA;YACAC,KAAA;YACAC,KAAA;YACAO,YAAA,EAAcN,IAAA,CAAKO,QAAQ;YAC3BN,cAAA;YACAC,MAAA,EAAQ;gBACN,GAAGF,IAAI;gBACPE;YACF;YACAC,GAAA;YACAC;QACF;QAEA,IAAI,cAAcF,MAAA,IAAUA,MAAA,EAAQO,QAAA,KAAa,SAAS;YACxD,MAAMQ,IAAA,OAAOzB,0OAAA;YAEb,OAAO,CAAA,iBAAA,EAAoBQ,IAAA,CAAKkB,OAAO,GAAG,SAAS,QAAA,QAAA,EACjD,uBAAA,CACClB,IAAA,CAAKkB,OAAO,GAAG,gCAAgC,+BAA8B,IAAA,CAC7EL,WAAA,GAAc,oBAAoB,EAAC,EAAA;;qBAGvB,CAAC,EAAA;kBACJb,IAAA,EAAMmB,KAAA,CAAA;;QAGhBN,WAAA,GACIR,YAAA,GACA,CAAA;qCACyBY,IAAA,CAAA,CAAA,EAAQjB,IAAA,CAAKkB,OAAO,GAAG,aAAa,GAAA;sBACnDD,IAAA,CAAA,EAAA,EAASZ,YAAA,CAAA;OACxB,CAAA;;;gBAIS;QACZ,OAAO;YACL,OAAO,CAAA,IAAA,EAAOQ,WAAA,GAAc,CAAA,uBAAA,CAAyB,GAAG,GAAA,MAAA,EAAWb,IAAA,EAAMmB,KAAA,CAAA,CAAA,EAASd,YAAA,CAAA,KAAA,CAAmB;QACvG;IACF;IACAK,SAAA,EAAW;QAACrB,uOAAA,CAAasB,OAAO;KAAA;AAClC","ignoreList":[]}},
    {"offset": {"line": 3088, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/lists/shared/shouldRegisterListBaseNodes.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/shared/shouldRegisterListBaseNodes.ts"],"sourcesContent":["// Priority order: unordered > ordered > checklist.\n// That's why we don't include unordered among the parameter options. It registers by default.\nexport function shouldRegisterListBaseNodes(\n  type: 'checklist' | 'ordered',\n  featureProviderMap: Map<string, unknown>,\n) {\n  if (type === 'ordered') {\n    // OrderedList only registers if UnorderedList is NOT present\n    return !featureProviderMap.has('unorderedList')\n  }\n\n  if (type === 'checklist') {\n    // Checklist only registers if neither UnorderedList nor OrderedList are present\n    return !featureProviderMap.has('unorderedList') && !featureProviderMap.has('orderedList')\n  }\n\n  return false\n}\n"],"names":["shouldRegisterListBaseNodes","type","featureProviderMap","has"],"mappings":"AAAA,mDAAA;AACA,8FAAA;;;;;AACO,SAASA,4BACdC,IAA6B,EAC7BC,kBAAwC;IAExC,IAAID,IAAA,KAAS,WAAW;QACtB,6DAAA;QACA,OAAO,CAACC,kBAAA,CAAmBC,GAAG,CAAC;IACjC;IAEA,IAAIF,IAAA,KAAS,aAAa;QACxB,gFAAA;QACA,OAAO,CAACC,kBAAA,CAAmBC,GAAG,CAAC,oBAAoB,CAACD,kBAAA,CAAmBC,GAAG,CAAC;IAC7E;IAEA,OAAO;AACT","ignoreList":[]}},
    {"offset": {"line": 3109, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/lists/shared/markdown.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/shared/markdown.ts"],"sourcesContent":["// Copied from https://github.com/facebook/lexical/blob/176b8cf16ecb332ee5efe2c75219e223b7b019f2/packages/lexical-markdown/src/MarkdownTransformers.ts#L97C1-L172C1\n\nimport type { ListNode, ListType } from '@lexical/list'\nimport type { ElementNode } from 'lexical'\n\nimport { $createListItemNode, $createListNode, $isListItemNode, $isListNode } from '@lexical/list'\n\nimport type { ElementTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\n// Amount of spaces that define indentation level\nconst LIST_INDENT_SIZE = 4\n\nexport const listReplace = (listType: ListType): ElementTransformer['replace'] => {\n  return (parentNode, children, match) => {\n    const previousNode = parentNode.getPreviousSibling()\n    const nextNode = parentNode.getNextSibling()\n    const listItem = $createListItemNode(listType === 'check' ? match[3] === 'x' : undefined)\n    if ($isListNode(nextNode) && nextNode.getListType() === listType) {\n      const firstChild = nextNode.getFirstChild()\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItem)\n      } else {\n        // should never happen, but let's handle gracefully, just in case.\n        nextNode.append(listItem)\n      }\n      parentNode.remove()\n    } else if ($isListNode(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem)\n      parentNode.remove()\n    } else {\n      const list = $createListNode(listType, listType === 'number' ? Number(match[2]) : undefined)\n      list.append(listItem)\n      parentNode.replace(list)\n    }\n    listItem.append(...children)\n    listItem.select(0, 0)\n    const indent = Math.floor(match[1]!.length / LIST_INDENT_SIZE)\n    if (indent) {\n      listItem.setIndent(indent)\n    }\n  }\n}\n\nexport const listExport = (\n  listNode: ListNode,\n  exportChildren: (node: ElementNode) => string,\n  depth: number,\n): string => {\n  const output: string[] = []\n  const children = listNode.getChildren()\n  let index = 0\n  for (const listItemNode of children) {\n    if ($isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild()\n        if ($isListNode(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1))\n          continue\n        }\n      }\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE)\n      const listType = listNode.getListType()\n      const prefix =\n        listType === 'number'\n          ? `${listNode.getStart() + index}. `\n          : listType === 'check'\n            ? `- [${listItemNode.getChecked() ? 'x' : ' '}] `\n            : '- '\n      output.push(indent + prefix + exportChildren(listItemNode))\n      index++\n    }\n  }\n\n  return output.join('\\n')\n}\n"],"names":["$createListItemNode","$createListNode","$isListItemNode","$isListNode","LIST_INDENT_SIZE","listReplace","listType","parentNode","children","match","previousNode","getPreviousSibling","nextNode","getNextSibling","listItem","undefined","getListType","firstChild","getFirstChild","insertBefore","append","remove","list","Number","replace","select","indent","Math","floor","length","setIndent","listExport","listNode","exportChildren","depth","output","getChildren","index","listItemNode","getChildrenSize","push","repeat","prefix","getStart","getChecked","join"],"mappings":";;;;;;AAAA,mKAAA;AAKA,SAASA,mBAAmB,EAAEC,eAAe,EAAEC,eAAe,EAAEC,WAAW,QAAQ;;AAInF,iDAAA;AACA,MAAMC,gBAAA,GAAmB;AAElB,MAAMC,WAAA,IAAeC,QAAA;IAC1B,OAAO,CAACC,UAAA,EAAYC,QAAA,EAAUC,KAAA;QAC5B,MAAMC,YAAA,GAAeH,UAAA,CAAWI,kBAAkB;QAClD,MAAMC,QAAA,GAAWL,UAAA,CAAWM,cAAc;QAC1C,MAAMC,QAAA,OAAWd,8OAAA,EAAoBM,QAAA,KAAa,UAAUG,KAAK,CAAC,EAAE,KAAK,MAAMM,SAAA;QAC/E,QAAIZ,sOAAA,EAAYS,QAAA,KAAaA,QAAA,CAASI,WAAW,OAAOV,QAAA,EAAU;YAChE,MAAMW,UAAA,GAAaL,QAAA,CAASM,aAAa;YACzC,IAAID,UAAA,KAAe,MAAM;gBACvBA,UAAA,CAAWE,YAAY,CAACL,QAAA;YAC1B,OAAO;gBACL,kEAAA;gBACAF,QAAA,CAASQ,MAAM,CAACN,QAAA;YAClB;YACAP,UAAA,CAAWc,MAAM;QACnB,OAAO,QAAIlB,sOAAA,EAAYO,YAAA,KAAiBA,YAAA,CAAaM,WAAW,OAAOV,QAAA,EAAU;YAC/EI,YAAA,CAAaU,MAAM,CAACN,QAAA;YACpBP,UAAA,CAAWc,MAAM;QACnB,OAAO;YACL,MAAMC,IAAA,OAAOrB,0OAAA,EAAgBK,QAAA,EAAUA,QAAA,KAAa,WAAWiB,MAAA,CAAOd,KAAK,CAAC,EAAE,IAAIM,SAAA;YAClFO,IAAA,CAAKF,MAAM,CAACN,QAAA;YACZP,UAAA,CAAWiB,OAAO,CAACF,IAAA;QACrB;QACAR,QAAA,CAASM,MAAM,IAAIZ,QAAA;QACnBM,QAAA,CAASW,MAAM,CAAC,GAAG;QACnB,MAAMC,MAAA,GAASC,IAAA,CAAKC,KAAK,CAACnB,KAAK,CAAC,EAAE,CAAEoB,MAAM,GAAGzB,gBAAA;QAC7C,IAAIsB,MAAA,EAAQ;YACVZ,QAAA,CAASgB,SAAS,CAACJ,MAAA;QACrB;IACF;AACF;AAEO,MAAMK,UAAA,GAAaA,CACxBC,QAAA,EACAC,cAAA,EACAC,KAAA;IAEA,MAAMC,MAAA,GAAmB,EAAE;IAC3B,MAAM3B,QAAA,GAAWwB,QAAA,CAASI,WAAW;IACrC,IAAIC,KAAA,GAAQ;IACZ,KAAK,MAAMC,YAAA,IAAgB9B,QAAA,CAAU;QACnC,QAAIN,0OAAA,EAAgBoC,YAAA,GAAe;YACjC,IAAIA,YAAA,CAAaC,eAAe,OAAO,GAAG;gBACxC,MAAMtB,UAAA,GAAaqB,YAAA,CAAapB,aAAa;gBAC7C,QAAIf,sOAAA,EAAYc,UAAA,GAAa;oBAC3BkB,MAAA,CAAOK,IAAI,CAACT,UAAA,CAAWd,UAAA,EAAYgB,cAAA,EAAgBC,KAAA,GAAQ;oBAC3D;gBACF;YACF;YACA,MAAMR,MAAA,GAAS,IAAIe,MAAM,CAACP,KAAA,GAAQ9B,gBAAA;YAClC,MAAME,QAAA,GAAW0B,QAAA,CAAShB,WAAW;YACrC,MAAM0B,MAAA,GACJpC,QAAA,KAAa,WACT,GAAG0B,QAAA,CAASW,QAAQ,KAAKN,KAAA,CAAA,EAAA,CAAS,GAClC/B,QAAA,KAAa,UACX,CAAA,GAAA,EAAMgC,YAAA,CAAaM,UAAU,KAAK,MAAM,IAAA,EAAA,CAAO,GAC/C;YACRT,MAAA,CAAOK,IAAI,CAACd,MAAA,GAASgB,MAAA,GAAST,cAAA,CAAeK,YAAA;YAC7CD,KAAA;QACF;IACF;IAEA,OAAOF,MAAA,CAAOU,IAAI,CAAC;AACrB","ignoreList":[]}},
    {"offset": {"line": 3176, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/lists/checklist/markdownTransformers.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/checklist/markdownTransformers.ts"],"sourcesContent":["import { $isListNode, ListItemNode, ListNode } from '@lexical/list'\n\nimport type { ElementTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport { listExport, listReplace } from '../shared/markdown.js'\n\nexport const CHECK_LIST: ElementTransformer = {\n  type: 'element',\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null\n  },\n  regExp: /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i,\n  replace: listReplace('check'),\n}\n"],"names":["$isListNode","ListItemNode","ListNode","listExport","listReplace","CHECK_LIST","type","dependencies","export","node","exportChildren","regExp","replace"],"mappings":";;;;AAAA,SAASA,WAAW,EAAEC,YAAY,EAAEC,QAAQ,QAAQ;AAIpD,SAASC,UAAU,EAAEC,WAAW,QAAQ;;;AAEjC,MAAMC,UAAA,GAAiC;IAC5CC,IAAA,EAAM;IACNC,YAAA,EAAc;QAACL,mOAAA;QAAUD,uOAAA;KAAa;IACtCO,MAAA,EAAQA,CAACC,IAAA,EAAMC,cAAA;QACb,WAAOV,sOAAA,EAAYS,IAAA,QAAQN,8ZAAA,EAAWM,IAAA,EAAMC,cAAA,EAAgB,KAAK;IACnE;IACAC,MAAA,EAAQ;IACRC,OAAA,MAASR,+ZAAA,EAAY;AACvB","ignoreList":[]}},
    {"offset": {"line": 3200, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/lists/checklist/server/i18n.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/checklist/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'قائمة التحقق',\n  },\n  az: {\n    label: 'Yoxlama Siyahısı',\n  },\n  bg: {\n    label: 'Списък за проверка',\n  },\n  cs: {\n    label: 'Seznam kontrol',\n  },\n  da: {\n    label: 'Tjekliste',\n  },\n  de: {\n    label: 'Checkliste',\n  },\n  en: {\n    label: 'Check List',\n  },\n  es: {\n    label: 'Lista de comprobación',\n  },\n  et: {\n    label: '',\n  },\n  fa: {\n    label: 'لیست بررسی',\n  },\n  fr: {\n    label: 'Liste de contrôle',\n  },\n  he: {\n    label: 'רשימת בדיקה',\n  },\n  hr: {\n    label: 'Kontrolni popis',\n  },\n  hu: {\n    label: 'Ellenőrzőlista',\n  },\n  is: {\n    label: 'Gátlisti',\n  },\n  it: {\n    label: 'Lista di controllo',\n  },\n  ja: {\n    label: 'チェックリスト',\n  },\n  ko: {\n    label: '체크 리스트',\n  },\n  my: {\n    label: 'Senarai Semak',\n  },\n  nb: {\n    label: 'Sjekkliste',\n  },\n  nl: {\n    label: 'Checklist',\n  },\n  pl: {\n    label: 'Lista kontrolna',\n  },\n  pt: {\n    label: 'Lista de Verificação',\n  },\n  ro: {\n    label: 'Listă de verificare',\n  },\n  rs: {\n    label: 'Контролна листа',\n  },\n  'rs-latin': {\n    label: 'Kontrolna lista',\n  },\n  ru: {\n    label: 'Список Проверки',\n  },\n  sk: {\n    label: 'Kontrolný zoznam',\n  },\n  sl: {\n    label: 'Nimekiri',\n  },\n  sv: {\n    label: 'Kontrollista',\n  },\n  ta: {\n    label: 'சரிபார்ப்பு பட்டியல்',\n  },\n  th: {\n    label: 'รายการตรวจสอบ',\n  },\n  tr: {\n    label: 'Kontrol Listesi',\n  },\n  uk: {\n    label: 'Список перевірки',\n  },\n  vi: {\n    label: 'Danh sách kiểm tra',\n  },\n  zh: {\n    label: '检查清单',\n  },\n  'zh-TW': {\n    label: '檢查清單',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","is","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","ta","th","tr","uk","vi","zh"],"mappings":";;;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA8B,EAAA,EAAI;QACF9B,KAAA,EAAO;IACT;IACA+B,EAAA,EAAI;QACF/B,KAAA,EAAO;IACT;IACAgC,EAAA,EAAI;QACFhC,KAAA,EAAO;IACT;IACAiC,EAAA,EAAI;QACFjC,KAAA,EAAO;IACT;IACAkC,EAAA,EAAI;QACFlC,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF","ignoreList":[]}},
    {"offset": {"line": 3321, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/lists/checklist/server/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/checklist/server/index.ts"],"sourcesContent":["import { ListItemNode, ListNode } from '@lexical/list'\n\nimport { createServerFeature } from '../../../../utilities/createServerFeature.js'\nimport { createNode } from '../../../typeUtilities.js'\nimport { ListHTMLConverter, ListItemHTMLConverter } from '../../htmlConverter.js'\nimport { shouldRegisterListBaseNodes } from '../../shared/shouldRegisterListBaseNodes.js'\nimport { CHECK_LIST } from '../markdownTransformers.js'\nimport { i18n } from './i18n.js'\n\nexport const ChecklistFeature = createServerFeature({\n  feature: ({ featureProviderMap }) => {\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#ChecklistFeatureClient',\n      i18n,\n      markdownTransformers: [CHECK_LIST],\n      nodes: shouldRegisterListBaseNodes('checklist', featureProviderMap)\n        ? [\n            createNode({\n              converters: {\n                html: ListHTMLConverter as any, // ListHTMLConverter uses a different generic type than ListNode[exportJSON], thus we need to cast as any\n              },\n              node: ListNode,\n            }),\n            createNode({\n              converters: {\n                html: ListItemHTMLConverter as any,\n              },\n              node: ListItemNode,\n            }),\n          ]\n        : [],\n    }\n  },\n  key: 'checklist',\n})\n"],"names":["ListItemNode","ListNode","createServerFeature","createNode","ListHTMLConverter","ListItemHTMLConverter","shouldRegisterListBaseNodes","CHECK_LIST","i18n","ChecklistFeature","feature","featureProviderMap","ClientFeature","markdownTransformers","nodes","converters","html","node","key"],"mappings":";;;;AAAA,SAASA,YAAY,EAAEC,QAAQ,QAAQ;AAEvC,SAASC,mBAAmB,QAAQ;AACpC,SAASC,UAAU,QAAQ;AAC3B,SAASC,iBAAiB,EAAEC,qBAAqB,QAAQ;AACzD,SAASC,2BAA2B,QAAQ;AAC5C,SAASC,UAAU,QAAQ;AAC3B,SAASC,IAAI,QAAQ;;;;;;;;AAEd,MAAMC,gBAAA,OAAmBP,gaAAA,EAAoB;IAClDQ,OAAA,EAASA,CAAC,EAAEC,kBAAAA,EAAoB;QAC9B,OAAO;YACLC,aAAA,EAAe;kBACfJ,iaAAA;YACAK,oBAAA,EAAsB;gBAACN,6aAAA;aAAW;YAClCO,KAAA,MAAOR,kcAAA,EAA4B,aAAaK,kBAAA,IAC5C;oBACER,gZAAA,EAAW;oBACTY,UAAA,EAAY;wBACVC,IAAA,EAAMZ,gaAAAA;oBACR;oBACAa,IAAA,EAAMhB,mOAAAA;gBACR;oBACAE,gZAAA,EAAW;oBACTY,UAAA,EAAY;wBACVC,IAAA,EAAMX,oaAAAA;oBACR;oBACAY,IAAA,EAAMjB,uOAAAA;gBACR;aACD,GACD,EAAA;QACN;IACF;IACAkB,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 3369, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/lists/orderedList/markdownTransformer.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/orderedList/markdownTransformer.ts"],"sourcesContent":["import { $isListNode, ListItemNode, ListNode } from '@lexical/list'\n\nimport type { ElementTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport { listExport, listReplace } from '../shared/markdown.js'\n\nexport const ORDERED_LIST: ElementTransformer = {\n  type: 'element',\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null\n  },\n  regExp: /^(\\s*)(\\d+)\\.\\s/,\n  replace: listReplace('number'),\n}\n"],"names":["$isListNode","ListItemNode","ListNode","listExport","listReplace","ORDERED_LIST","type","dependencies","export","node","exportChildren","regExp","replace"],"mappings":";;;;AAAA,SAASA,WAAW,EAAEC,YAAY,EAAEC,QAAQ,QAAQ;AAIpD,SAASC,UAAU,EAAEC,WAAW,QAAQ;;;AAEjC,MAAMC,YAAA,GAAmC;IAC9CC,IAAA,EAAM;IACNC,YAAA,EAAc;QAACL,mOAAA;QAAUD,uOAAA;KAAa;IACtCO,MAAA,EAAQA,CAACC,IAAA,EAAMC,cAAA;QACb,WAAOV,sOAAA,EAAYS,IAAA,QAAQN,8ZAAA,EAAWM,IAAA,EAAMC,cAAA,EAAgB,KAAK;IACnE;IACAC,MAAA,EAAQ;IACRC,OAAA,MAASR,+ZAAA,EAAY;AACvB","ignoreList":[]}},
    {"offset": {"line": 3393, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/lists/orderedList/server/i18n.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/orderedList/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'قائمة مرتبة',\n  },\n  az: {\n    label: 'Sıralı Siyahı',\n  },\n  bg: {\n    label: 'Подреден списък',\n  },\n  cs: {\n    label: 'Seřazený seznam',\n  },\n  da: {\n    label: 'Ordnet Liste',\n  },\n  de: {\n    label: 'Geordnete Liste',\n  },\n  en: {\n    label: 'Ordered List',\n  },\n  es: {\n    label: 'Lista ordenada',\n  },\n  et: {\n    label: 'Sorteeritud loend',\n  },\n  fa: {\n    label: 'لیست مرتب شده',\n  },\n  fr: {\n    label: 'Liste ordonnée',\n  },\n  he: {\n    label: 'רשימה ממוינת',\n  },\n  hr: {\n    label: 'Naručeni popis',\n  },\n  hu: {\n    label: 'Rendelt lista',\n  },\n  is: {\n    label: 'Raðaður listi',\n  },\n  it: {\n    label: 'Elenco ordinato',\n  },\n  ja: {\n    label: '順序付きリスト',\n  },\n  ko: {\n    label: '주문된 목록',\n  },\n  my: {\n    label: 'စီစဉ်ထားသော စာရင်း',\n  },\n  nb: {\n    label: 'Ordnet Liste',\n  },\n  nl: {\n    label: 'Geordende Lijst',\n  },\n  pl: {\n    label: 'Uporządkowana lista',\n  },\n  pt: {\n    label: 'Lista Ordenada',\n  },\n  ro: {\n    label: 'Lista ordonată',\n  },\n  rs: {\n    label: 'Уређена листа',\n  },\n  'rs-latin': {\n    label: 'Uređena lista',\n  },\n  ru: {\n    label: 'Упорядоченный список',\n  },\n  sk: {\n    label: 'Zoradený zoznam',\n  },\n  sl: {\n    label: 'Urejen seznam',\n  },\n  sv: {\n    label: 'Ordnad Lista',\n  },\n  ta: {\n    label: 'வரிசைப்படுத்தப்பட்ட பட்டியல்',\n  },\n  th: {\n    label: 'รายการที่ถูกจัดลำดับ',\n  },\n  tr: {\n    label: 'Sıralı Liste',\n  },\n  uk: {\n    label: 'Впорядкований список',\n  },\n  vi: {\n    label: 'Danh sách đã sắp xếp',\n  },\n  zh: {\n    label: '有序列表',\n  },\n  'zh-TW': {\n    label: '有序列表',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","is","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","ta","th","tr","uk","vi","zh"],"mappings":";;;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA8B,EAAA,EAAI;QACF9B,KAAA,EAAO;IACT;IACA+B,EAAA,EAAI;QACF/B,KAAA,EAAO;IACT;IACAgC,EAAA,EAAI;QACFhC,KAAA,EAAO;IACT;IACAiC,EAAA,EAAI;QACFjC,KAAA,EAAO;IACT;IACAkC,EAAA,EAAI;QACFlC,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF","ignoreList":[]}},
    {"offset": {"line": 3514, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/lists/orderedList/server/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/orderedList/server/index.ts"],"sourcesContent":["import { ListItemNode, ListNode } from '@lexical/list'\n\nimport { createServerFeature } from '../../../../utilities/createServerFeature.js'\nimport { createNode } from '../../../typeUtilities.js'\nimport { ListHTMLConverter, ListItemHTMLConverter } from '../../htmlConverter.js'\nimport { shouldRegisterListBaseNodes } from '../../shared/shouldRegisterListBaseNodes.js'\nimport { ORDERED_LIST } from '../markdownTransformer.js'\nimport { i18n } from './i18n.js'\n\nexport const OrderedListFeature = createServerFeature({\n  feature: ({ featureProviderMap }) => {\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#OrderedListFeatureClient',\n      i18n,\n      markdownTransformers: [ORDERED_LIST],\n      nodes: shouldRegisterListBaseNodes('ordered', featureProviderMap)\n        ? [\n            createNode({\n              converters: {\n                html: ListHTMLConverter as any, // ListHTMLConverter uses a different generic type than ListNode[exportJSON], thus we need to cast as any\n              },\n              node: ListNode,\n            }),\n            createNode({\n              converters: {\n                html: ListItemHTMLConverter as any,\n              },\n              node: ListItemNode,\n            }),\n          ]\n        : [],\n    }\n  },\n  key: 'orderedList',\n})\n"],"names":["ListItemNode","ListNode","createServerFeature","createNode","ListHTMLConverter","ListItemHTMLConverter","shouldRegisterListBaseNodes","ORDERED_LIST","i18n","OrderedListFeature","feature","featureProviderMap","ClientFeature","markdownTransformers","nodes","converters","html","node","key"],"mappings":";;;;AAAA,SAASA,YAAY,EAAEC,QAAQ,QAAQ;AAEvC,SAASC,mBAAmB,QAAQ;AACpC,SAASC,UAAU,QAAQ;AAC3B,SAASC,iBAAiB,EAAEC,qBAAqB,QAAQ;AACzD,SAASC,2BAA2B,QAAQ;AAC5C,SAASC,YAAY,QAAQ;AAC7B,SAASC,IAAI,QAAQ;;;;;;;;AAEd,MAAMC,kBAAA,OAAqBP,gaAAA,EAAoB;IACpDQ,OAAA,EAASA,CAAC,EAAEC,kBAAAA,EAAoB;QAC9B,OAAO;YACLC,aAAA,EAAe;kBACfJ,maAAA;YACAK,oBAAA,EAAsB;gBAACN,gbAAA;aAAa;YACpCO,KAAA,MAAOR,kcAAA,EAA4B,WAAWK,kBAAA,IAC1C;oBACER,gZAAA,EAAW;oBACTY,UAAA,EAAY;wBACVC,IAAA,EAAMZ,gaAAAA;oBACR;oBACAa,IAAA,EAAMhB,mOAAAA;gBACR;oBACAE,gZAAA,EAAW;oBACTY,UAAA,EAAY;wBACVC,IAAA,EAAMX,oaAAAA;oBACR;oBACAY,IAAA,EAAMjB,uOAAAA;gBACR;aACD,GACD,EAAA;QACN;IACF;IACAkB,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 3562, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/lists/unorderedList/markdownTransformer.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/unorderedList/markdownTransformer.ts"],"sourcesContent":["import { $isListNode, ListItemNode, ListNode } from '@lexical/list'\n\nimport type { ElementTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport { listExport, listReplace } from '../shared/markdown.js'\n\nexport const UNORDERED_LIST: ElementTransformer = {\n  type: 'element',\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null\n  },\n  regExp: /^(\\s*)[-*+]\\s/,\n  replace: listReplace('bullet'),\n}\n"],"names":["$isListNode","ListItemNode","ListNode","listExport","listReplace","UNORDERED_LIST","type","dependencies","export","node","exportChildren","regExp","replace"],"mappings":";;;;AAAA,SAASA,WAAW,EAAEC,YAAY,EAAEC,QAAQ,QAAQ;AAIpD,SAASC,UAAU,EAAEC,WAAW,QAAQ;;;AAEjC,MAAMC,cAAA,GAAqC;IAChDC,IAAA,EAAM;IACNC,YAAA,EAAc;QAACL,mOAAA;QAAUD,uOAAA;KAAa;IACtCO,MAAA,EAAQA,CAACC,IAAA,EAAMC,cAAA;QACb,WAAOV,sOAAA,EAAYS,IAAA,QAAQN,8ZAAA,EAAWM,IAAA,EAAMC,cAAA,EAAgB,KAAK;IACnE;IACAC,MAAA,EAAQ;IACRC,OAAA,MAASR,+ZAAA,EAAY;AACvB","ignoreList":[]}},
    {"offset": {"line": 3586, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/lists/unorderedList/server/i18n.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/unorderedList/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'قائمة غير مرتبة',\n  },\n  az: {\n    label: 'Sırasız Siyahı',\n  },\n  bg: {\n    label: 'Неподреден списък',\n  },\n  cs: {\n    label: 'Neuspořádaný seznam',\n  },\n  da: {\n    label: 'Usorteret Liste',\n  },\n  de: {\n    label: 'Ungeordnete Liste',\n  },\n  en: {\n    label: 'Unordered List',\n  },\n  es: {\n    label: 'Lista desordenada',\n  },\n  et: {\n    label: 'Sorteerimata loend',\n  },\n  fa: {\n    label: 'لیست بدون ترتیب',\n  },\n  fr: {\n    label: 'Liste non ordonnée',\n  },\n  he: {\n    label: 'רשימה לא מסודרת',\n  },\n  hr: {\n    label: 'Neuređeni popis',\n  },\n  hu: {\n    label: 'Rendezetlen lista',\n  },\n  is: {\n    label: 'Óraðaður listi',\n  },\n  it: {\n    label: 'Elenco non ordinato',\n  },\n  ja: {\n    label: '順不同リスト',\n  },\n  ko: {\n    label: '비정렬 목록',\n  },\n  my: {\n    label: 'Senarai Tidak Tertib',\n  },\n  nb: {\n    label: 'Usortert liste',\n  },\n  nl: {\n    label: 'Ongeordende lijst',\n  },\n  pl: {\n    label: 'Nieuporządkowana lista',\n  },\n  pt: {\n    label: 'Lista Não Ordenada',\n  },\n  ro: {\n    label: 'Listă neordonată',\n  },\n  rs: {\n    label: 'Неуређена листа',\n  },\n  'rs-latin': {\n    label: 'Neuređena lista',\n  },\n  ru: {\n    label: 'Несортированный список',\n  },\n  sk: {\n    label: 'Neusporiadaný zoznam',\n  },\n  sl: {\n    label: 'Neurejen seznam',\n  },\n  sv: {\n    label: 'Oordnad lista',\n  },\n  ta: {\n    label: 'வரிசைப்படுத்தப்படாத பட்டியல்',\n  },\n  th: {\n    label: 'รายการที่ไม่ได้เรียงลำดับ',\n  },\n  tr: {\n    label: 'Sırasız Liste',\n  },\n  uk: {\n    label: 'Невпорядкований список',\n  },\n  vi: {\n    label: 'Danh sách không theo thứ tự',\n  },\n  zh: {\n    label: '无序列表',\n  },\n  'zh-TW': {\n    label: '無順序列表',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","is","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","ta","th","tr","uk","vi","zh"],"mappings":";;;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA8B,EAAA,EAAI;QACF9B,KAAA,EAAO;IACT;IACA+B,EAAA,EAAI;QACF/B,KAAA,EAAO;IACT;IACAgC,EAAA,EAAI;QACFhC,KAAA,EAAO;IACT;IACAiC,EAAA,EAAI;QACFjC,KAAA,EAAO;IACT;IACAkC,EAAA,EAAI;QACFlC,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF","ignoreList":[]}},
    {"offset": {"line": 3707, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/lists/unorderedList/server/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/unorderedList/server/index.ts"],"sourcesContent":["import { ListItemNode, ListNode } from '@lexical/list'\n\nimport { createServerFeature } from '../../../../utilities/createServerFeature.js'\nimport { createNode } from '../../../typeUtilities.js'\nimport { ListHTMLConverter, ListItemHTMLConverter } from '../../htmlConverter.js'\nimport { UNORDERED_LIST } from '../markdownTransformer.js'\nimport { i18n } from './i18n.js'\n\nexport const UnorderedListFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#UnorderedListFeatureClient',\n    i18n,\n    markdownTransformers: [UNORDERED_LIST],\n    nodes: [\n      createNode({\n        converters: {\n          html: ListHTMLConverter as any, // ListHTMLConverter uses a different generic type than ListNode[exportJSON], thus we need to cast as any\n        },\n        node: ListNode,\n      }),\n      createNode({\n        converters: {\n          html: ListItemHTMLConverter as any,\n        },\n        node: ListItemNode,\n      }),\n    ],\n  },\n  key: 'unorderedList',\n})\n"],"names":["ListItemNode","ListNode","createServerFeature","createNode","ListHTMLConverter","ListItemHTMLConverter","UNORDERED_LIST","i18n","UnorderedListFeature","feature","ClientFeature","markdownTransformers","nodes","converters","html","node","key"],"mappings":";;;;AAAA,SAASA,YAAY,EAAEC,QAAQ,QAAQ;AAEvC,SAASC,mBAAmB,QAAQ;AACpC,SAASC,UAAU,QAAQ;AAC3B,SAASC,iBAAiB,EAAEC,qBAAqB,QAAQ;AACzD,SAASC,cAAc,QAAQ;AAC/B,SAASC,IAAI,QAAQ;;;;;;;AAEd,MAAMC,oBAAA,OAAuBN,gaAAA,EAAoB;IACtDO,OAAA,EAAS;QACPC,aAAA,EAAe;cACfH,qaAAA;QACAI,oBAAA,EAAsB;YAACL,obAAA;SAAe;QACtCM,KAAA,EAAO;gBACLT,gZAAA,EAAW;gBACTU,UAAA,EAAY;oBACVC,IAAA,EAAMV,gaAAAA;gBACR;gBACAW,IAAA,EAAMd,mOAAAA;YACR;gBACAE,gZAAA,EAAW;gBACTU,UAAA,EAAY;oBACVC,IAAA,EAAMT,oaAAAA;gBACR;gBACAU,IAAA,EAAMf,uOAAAA;YACR;SAAA;IAEJ;IACAgB,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 3751, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/paragraph/server/i18n.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/paragraph/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'فقرة',\n    label2: 'نص عادي',\n  },\n  az: {\n    label: 'Paraqraf',\n    label2: 'Normal Mətn',\n  },\n  bg: {\n    label: 'Параграф',\n    label2: 'Нормален текст',\n  },\n  cs: {\n    label: 'Odstavec',\n    label2: 'Normální text',\n  },\n  da: {\n    label: 'Afsnit',\n    label2: 'Normal tekst',\n  },\n  de: {\n    label: 'Paragraph',\n    label2: 'Normaler Text',\n  },\n  en: {\n    label: 'Paragraph',\n    label2: 'Normal Text',\n  },\n  es: {\n    label: 'Párrafo',\n    label2: 'Texto normal',\n  },\n  et: {\n    label: 'Paragrahv',\n    label2: 'Tavaline tekst',\n  },\n  fa: {\n    label: 'پاراگراف',\n    label2: 'متن عادی',\n  },\n  fr: {\n    label: 'Paragraphe',\n    label2: 'Texte normal',\n  },\n  he: {\n    label: 'פסקה',\n    label2: 'טקסט רגיל',\n  },\n  hr: {\n    label: 'Odlomak',\n    label2: 'Normalan tekst',\n  },\n  hu: {\n    label: 'Bekezdés',\n    label2: 'Normál szöveg',\n  },\n  is: {\n    label: 'Málsgrein',\n    label2: 'Venjulegur texti',\n  },\n  it: {\n    label: 'Paragrafo',\n    label2: 'Testo normale',\n  },\n  ja: {\n    label: '段落',\n    label2: '通常のテキスト',\n  },\n  ko: {\n    label: '문단',\n    label2: '일반 텍스트',\n  },\n  my: {\n    label: 'Perenggan',\n    label2: 'ပုံမှန်စာသား',\n  },\n  nb: {\n    label: 'Avsnitt',\n    label2: 'Normal tekst',\n  },\n  nl: {\n    label: 'Paragraaf',\n    label2: 'Normale tekst',\n  },\n  pl: {\n    label: 'Akapit',\n    label2: 'Normalny tekst',\n  },\n  pt: {\n    label: 'Parágrafo',\n    label2: 'Texto Normal',\n  },\n  ro: {\n    label: 'Paragraf',\n    label2: 'Text normal',\n  },\n  rs: {\n    label: 'Параграф',\n    label2: 'Oбичан текст',\n  },\n  'rs-latin': {\n    label: 'Paragraf',\n    label2: 'Običan tekst',\n  },\n  ru: {\n    label: 'Параграф',\n    label2: 'Нормальный текст',\n  },\n  sk: {\n    label: 'Odsek',\n    label2: 'Normálny text',\n  },\n  sl: {\n    label: 'Odstavek',\n    label2: 'Navaden besedilo',\n  },\n  sv: {\n    label: 'Stycke',\n    label2: 'Normal Text',\n  },\n  ta: {\n    label: 'பத்தி',\n    label2: 'சாதாரண உரை',\n  },\n  th: {\n    label: 'ย่อหน้า',\n    label2: 'ข้อความธรรมดา',\n  },\n  tr: {\n    label: 'Paragraf',\n    label2: 'Normal Metin',\n  },\n  uk: {\n    label: 'Абзац',\n    label2: 'Звичайний текст',\n  },\n  vi: {\n    label: 'Đoạn văn',\n    label2: 'Văn bản bình thường',\n  },\n  zh: {\n    label: '段落',\n    label2: '正常文本',\n  },\n  'zh-TW': {\n    label: '段落',\n    label2: '正常文本',\n  },\n}\n"],"names":["i18n","ar","label","label2","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","is","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","ta","th","tr","uk","vi","zh"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 3909, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/paragraph/server/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/paragraph/server/index.ts"],"sourcesContent":["import { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { i18n } from './i18n.js'\n\nexport const ParagraphFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#ParagraphFeatureClient',\n    clientFeatureProps: null,\n    i18n,\n  },\n  key: 'paragraph',\n})\n"],"names":["createServerFeature","i18n","ParagraphFeature","feature","ClientFeature","clientFeatureProps","key"],"mappings":";;;;AAAA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,IAAI,QAAQ;;;AAEd,MAAMC,gBAAA,OAAmBF,gaAAA,EAAoB;IAClDG,OAAA,EAAS;QACPC,aAAA,EAAe;QACfC,kBAAA,EAAoB;cACpBJ,wZAAAA;IACF;IACAK,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 3929, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/populateGraphQL/populate.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/populateGraphQL/populate.ts"],"sourcesContent":["import type { PayloadRequest, SelectType } from 'payload'\n\nimport { createDataloaderCacheKey } from 'payload'\n\ntype PopulateArguments = {\n  collectionSlug: string\n  currentDepth?: number\n  data: unknown\n  depth: number\n  draft: boolean\n  id: number | string\n  key: number | string\n  overrideAccess: boolean\n  req: PayloadRequest\n  select?: SelectType\n  showHiddenFields: boolean\n}\n\ntype PopulateFn = (args: PopulateArguments) => Promise<void>\n\nexport const populate: PopulateFn = async ({\n  id,\n  collectionSlug,\n  currentDepth,\n  data,\n  depth,\n  draft,\n  key,\n  overrideAccess,\n  req,\n  select,\n  showHiddenFields,\n}) => {\n  const shouldPopulate = depth && currentDepth! <= depth\n  // usually depth is checked within recursivelyPopulateFieldsForGraphQL. But since this populate function can be called outside of that (in rest afterRead node hooks) we need to check here too\n  if (!shouldPopulate) {\n    return\n  }\n\n  const dataRef = data as Record<string, unknown>\n\n  const doc = await req.payloadDataLoader?.load(\n    createDataloaderCacheKey({\n      collectionSlug,\n      currentDepth: currentDepth! + 1,\n      depth,\n      docID: id as string,\n      draft,\n      fallbackLocale: req.fallbackLocale!,\n      locale: req.locale!,\n      overrideAccess,\n      select,\n      showHiddenFields,\n      transactionID: req.transactionID!,\n    }),\n  )\n\n  if (doc) {\n    dataRef[key] = doc\n  } else {\n    dataRef[key] = null\n  }\n}\n"],"names":["createDataloaderCacheKey","populate","id","collectionSlug","currentDepth","data","depth","draft","key","overrideAccess","req","select","showHiddenFields","shouldPopulate","dataRef","doc","payloadDataLoader","load","docID","fallbackLocale","locale","transactionID"],"mappings":";;;;AAEA,SAASA,wBAAwB,QAAQ;;AAkBlC,MAAMC,QAAA,GAAuB,MAAAA,CAAO,EACzCC,EAAE,EACFC,cAAc,EACdC,YAAY,EACZC,IAAI,EACJC,KAAK,EACLC,KAAK,EACLC,GAAG,EACHC,cAAc,EACdC,GAAG,EACHC,MAAM,EACNC,gBAAAA,EACD;IACC,MAAMC,cAAA,GAAiBP,KAAA,IAASF,YAAA,IAAiBE,KAAA;IACjD,+LAAA;IACA,IAAI,CAACO,cAAA,EAAgB;QACnB;IACF;IAEA,MAAMC,OAAA,GAAUT,IAAA;IAEhB,MAAMU,GAAA,GAAM,MAAML,GAAA,CAAIM,iBAAiB,EAAEC,IAAA,KACvCjB,gSAAA,EAAyB;QACvBG,cAAA;QACAC,YAAA,EAAcA,YAAA,GAAgB;QAC9BE,KAAA;QACAY,KAAA,EAAOhB,EAAA;QACPK,KAAA;QACAY,cAAA,EAAgBT,GAAA,CAAIS,cAAc;QAClCC,MAAA,EAAQV,GAAA,CAAIU,MAAM;QAClBX,cAAA;QACAE,MAAA;QACAC,gBAAA;QACAS,aAAA,EAAeX,GAAA,CAAIW,aAAAA;IACrB;IAGF,IAAIN,GAAA,EAAK;QACPD,OAAO,CAACN,GAAA,CAAI,GAAGO,GAAA;IACjB,OAAO;QACLD,OAAO,CAACN,GAAA,CAAI,GAAG;IACjB;AACF","ignoreList":[]}},
    {"offset": {"line": 3965, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/relationship/server/graphQLPopulationPromise.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/relationship/server/graphQLPopulationPromise.ts"],"sourcesContent":["import type { PopulationPromise } from '../../typesServer.js'\nimport type { RelationshipFeatureProps } from './index.js'\nimport type { SerializedRelationshipNode } from './nodes/RelationshipNode.js'\n\nimport { populate } from '../../../populateGraphQL/populate.js'\n\nexport const relationshipPopulationPromiseHOC = (\n  props: RelationshipFeatureProps,\n): PopulationPromise<SerializedRelationshipNode> => {\n  const relationshipPopulationPromise: PopulationPromise<SerializedRelationshipNode> = ({\n    currentDepth,\n    depth,\n    draft,\n    node,\n    overrideAccess,\n    populationPromises,\n    req,\n    showHiddenFields,\n  }) => {\n    if (node?.value) {\n      // @ts-expect-error\n      const id = node?.value?.id || node?.value // for backwards-compatibility\n\n      const collection = req.payload.collections[node?.relationTo]\n\n      if (collection) {\n        const populateDepth =\n          props?.maxDepth !== undefined && props?.maxDepth < depth ? props?.maxDepth : depth\n\n        populationPromises.push(\n          populate({\n            id,\n            collectionSlug: collection.config.slug,\n            currentDepth,\n            data: node,\n            depth: populateDepth,\n            draft,\n            key: 'value',\n            overrideAccess,\n            req,\n            showHiddenFields,\n          }),\n        )\n      }\n    }\n  }\n\n  return relationshipPopulationPromise\n}\n"],"names":["populate","relationshipPopulationPromiseHOC","props","relationshipPopulationPromise","currentDepth","depth","draft","node","overrideAccess","populationPromises","req","showHiddenFields","value","id","collection","payload","collections","relationTo","populateDepth","maxDepth","undefined","push","collectionSlug","config","slug","data","key"],"mappings":";;;;AAIA,SAASA,QAAQ,QAAQ;;AAElB,MAAMC,gCAAA,IACXC,KAAA;IAEA,MAAMC,6BAAA,GAA+EA,CAAC,EACpFC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdC,kBAAkB,EAClBC,GAAG,EACHC,gBAAAA,EACD;QACC,IAAIJ,IAAA,EAAMK,KAAA,EAAO;YACf,mBAAA;YACA,MAAMC,EAAA,GAAKN,IAAA,EAAMK,KAAA,EAAOC,EAAA,IAAMN,IAAA,EAAMK,KAAA,CAAM,8BAAA;;YAE1C,MAAME,UAAA,GAAaJ,GAAA,CAAIK,OAAO,CAACC,WAAW,CAACT,IAAA,EAAMU,UAAA,CAAW;YAE5D,IAAIH,UAAA,EAAY;gBACd,MAAMI,aAAA,GACJhB,KAAA,EAAOiB,QAAA,KAAaC,SAAA,IAAalB,KAAA,EAAOiB,QAAA,GAAWd,KAAA,GAAQH,KAAA,EAAOiB,QAAA,GAAWd,KAAA;gBAE/EI,kBAAA,CAAmBY,IAAI,KACrBrB,gZAAA,EAAS;oBACPa,EAAA;oBACAS,cAAA,EAAgBR,UAAA,CAAWS,MAAM,CAACC,IAAI;oBACtCpB,YAAA;oBACAqB,IAAA,EAAMlB,IAAA;oBACNF,KAAA,EAAOa,aAAA;oBACPZ,KAAA;oBACAoB,GAAA,EAAK;oBACLlB,cAAA;oBACAE,GAAA;oBACAC;gBACF;YAEJ;QACF;IACF;IAEA,OAAOR,6BAAA;AACT","ignoreList":[]}},
    {"offset": {"line": 4001, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/relationship/server/i18n.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/relationship/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'العلاقة',\n  },\n  az: {\n    label: 'Münasibət',\n  },\n  bg: {\n    label: 'Връзка',\n  },\n  cs: {\n    label: 'Vztah',\n  },\n  da: {\n    label: 'Forhold',\n  },\n  de: {\n    label: 'Beziehung',\n  },\n  en: {\n    label: 'Relationship',\n  },\n  es: {\n    label: 'Relación',\n  },\n  et: {\n    label: 'Seos',\n  },\n  fa: {\n    label: 'روابط',\n  },\n  fr: {\n    label: 'Relation',\n  },\n  he: {\n    label: 'יחסים',\n  },\n  hr: {\n    label: 'Odnos',\n  },\n  hu: {\n    label: 'Kapcsolat',\n  },\n  is: {\n    label: 'Tengingar',\n  },\n  it: {\n    label: 'Relazione',\n  },\n  ja: {\n    label: '関係性',\n  },\n  ko: {\n    label: '관계',\n  },\n  my: {\n    label: 'Hubungan',\n  },\n  nb: {\n    label: 'Forhold',\n  },\n  nl: {\n    label: 'Relatie',\n  },\n  pl: {\n    label: 'Relacja',\n  },\n  pt: {\n    label: 'Relacionamento',\n  },\n  ro: {\n    label: 'Relație',\n  },\n  rs: {\n    label: 'Релација',\n  },\n  'rs-latin': {\n    label: 'Relacija',\n  },\n  ru: {\n    label: 'Отношения',\n  },\n  sk: {\n    label: 'Vzťah',\n  },\n  sl: {\n    label: 'Odnos',\n  },\n  sv: {\n    label: 'Relation',\n  },\n  ta: {\n    label: 'உறவு',\n  },\n  th: {\n    label: 'ความสัมพันธ์',\n  },\n  tr: {\n    label: 'İlişki',\n  },\n  uk: {\n    label: 'Стосунки',\n  },\n  vi: {\n    label: 'Mối quan hệ',\n  },\n  zh: {\n    label: '关系',\n  },\n  'zh-TW': {\n    label: '關係',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","is","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","ta","th","tr","uk","vi","zh"],"mappings":";;;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA8B,EAAA,EAAI;QACF9B,KAAA,EAAO;IACT;IACA+B,EAAA,EAAI;QACF/B,KAAA,EAAO;IACT;IACAgC,EAAA,EAAI;QACFhC,KAAA,EAAO;IACT;IACAiC,EAAA,EAAI;QACFjC,KAAA,EAAO;IACT;IACAkC,EAAA,EAAI;QACFlC,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF","ignoreList":[]}},
    {"offset": {"line": 4122, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/relationship/server/nodes/RelationshipNode.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/relationship/server/nodes/RelationshipNode.tsx"],"sourcesContent":["import type { SerializedDecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport type { CollectionSlug, DataFromCollectionSlug } from 'payload'\nimport type { JSX } from 'react'\n\nimport { DecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport { addClassNamesToElement } from '@lexical/utils'\nimport {\n  $applyNodeReplacement,\n  type DOMConversionMap,\n  type DOMConversionOutput,\n  type DOMExportOutput,\n  type EditorConfig,\n  type ElementFormatType,\n  type LexicalEditor,\n  type LexicalNode,\n  type NodeKey,\n} from 'lexical'\n\nimport type { StronglyTypedLeafNode } from '../../../../nodeTypes.js'\n\nexport type RelationshipData = {\n  [TCollectionSlug in CollectionSlug]: {\n    relationTo: TCollectionSlug\n    value: DataFromCollectionSlug<TCollectionSlug> | number | string\n  }\n}[CollectionSlug]\n\nexport type SerializedRelationshipNode = RelationshipData &\n  StronglyTypedLeafNode<SerializedDecoratorBlockNode, 'relationship'>\n\nfunction $relationshipElementToServerNode(domNode: HTMLDivElement): DOMConversionOutput | null {\n  const id = domNode.getAttribute('data-lexical-relationship-id')\n  const relationTo = domNode.getAttribute('data-lexical-relationship-relationTo')\n\n  if (id != null && relationTo != null) {\n    const node = $createServerRelationshipNode({\n      relationTo,\n      value: id,\n    })\n    return { node }\n  }\n  return null\n}\n\nexport class RelationshipServerNode extends DecoratorBlockNode {\n  __data: RelationshipData\n\n  constructor({\n    data,\n    format,\n    key,\n  }: {\n    data: RelationshipData\n    format?: ElementFormatType\n    key?: NodeKey\n  }) {\n    super(format, key)\n    this.__data = data\n  }\n\n  static override clone(node: RelationshipServerNode): RelationshipServerNode {\n    return new this({\n      data: node.__data,\n      format: node.__format,\n      key: node.__key,\n    })\n  }\n\n  static override getType(): string {\n    return 'relationship'\n  }\n\n  static override importDOM(): DOMConversionMap<HTMLDivElement> | null {\n    return {\n      div: (domNode: HTMLDivElement) => {\n        if (\n          !domNode.hasAttribute('data-lexical-relationship-relationTo') ||\n          !domNode.hasAttribute('data-lexical-relationship-id')\n        ) {\n          return null\n        }\n        return {\n          conversion: $relationshipElementToServerNode,\n          priority: 2,\n        }\n      },\n    }\n  }\n\n  static override importJSON(serializedNode: SerializedRelationshipNode): RelationshipServerNode {\n    if (serializedNode.version === 1 && (serializedNode?.value as unknown as { id: string })?.id) {\n      serializedNode.value = (serializedNode.value as unknown as { id: string }).id\n    }\n\n    const importedData: RelationshipData = {\n      relationTo: serializedNode.relationTo,\n      value: serializedNode.value,\n    }\n    const node = $createServerRelationshipNode(importedData)\n    node.setFormat(serializedNode.format)\n    return node\n  }\n\n  static isInline(): false {\n    return false\n  }\n\n  override createDOM(config?: EditorConfig): HTMLElement {\n    const element = document.createElement('div')\n    addClassNamesToElement(element, config?.theme?.relationship)\n    return element\n  }\n\n  override decorate(_editor: LexicalEditor, _config: EditorConfig): JSX.Element {\n    return null as unknown as JSX.Element\n  }\n\n  override exportDOM(): DOMExportOutput {\n    const element = document.createElement('div')\n    element.setAttribute(\n      'data-lexical-relationship-id',\n      String(typeof this.__data?.value === 'object' ? this.__data?.value?.id : this.__data?.value),\n    )\n    element.setAttribute('data-lexical-relationship-relationTo', this.__data?.relationTo)\n\n    const text = document.createTextNode(this.getTextContent())\n    element.append(text)\n    return { element }\n  }\n\n  override exportJSON(): SerializedRelationshipNode {\n    return {\n      ...super.exportJSON(),\n      ...this.getData(),\n      type: 'relationship',\n      version: 2,\n    }\n  }\n\n  getData(): RelationshipData {\n    return this.getLatest().__data\n  }\n\n  override getTextContent(): string {\n    return `${this.__data?.relationTo} relation to ${typeof this.__data?.value === 'object' ? this.__data?.value?.id : this.__data?.value}`\n  }\n\n  setData(data: RelationshipData): void {\n    const writable = this.getWritable()\n    writable.__data = data\n  }\n}\n\nexport function $createServerRelationshipNode(data: RelationshipData): RelationshipServerNode {\n  return $applyNodeReplacement(\n    new RelationshipServerNode({\n      data,\n    }),\n  )\n}\n\nexport function $isServerRelationshipNode(\n  node: LexicalNode | null | RelationshipServerNode | undefined,\n): node is RelationshipServerNode {\n  return node instanceof RelationshipServerNode\n}\n"],"names":["DecoratorBlockNode","addClassNamesToElement","$applyNodeReplacement","$relationshipElementToServerNode","domNode","id","getAttribute","relationTo","node","$createServerRelationshipNode","value","RelationshipServerNode","__data","constructor","data","format","key","clone","__format","__key","getType","importDOM","div","hasAttribute","conversion","priority","importJSON","serializedNode","version","importedData","setFormat","isInline","createDOM","config","element","document","createElement","theme","relationship","decorate","_editor","_config","exportDOM","setAttribute","String","text","createTextNode","getTextContent","append","exportJSON","getData","type","getLatest","setData","writable","getWritable","$isServerRelationshipNode"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 4243, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/relationship/server/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/relationship/server/index.ts"],"sourcesContent":["import type { CollectionSlug } from 'payload'\n\nimport { populate } from '../../../populateGraphQL/populate.js'\nimport { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { createNode } from '../../typeUtilities.js'\nimport { relationshipPopulationPromiseHOC } from './graphQLPopulationPromise.js'\nimport { i18n } from './i18n.js'\nimport { RelationshipServerNode } from './nodes/RelationshipNode.js'\n\nexport type ExclusiveRelationshipFeatureProps =\n  | {\n      /**\n       * The collections that should be disabled. Overrides the `enableRichTextRelationship` property in the collection config.\n       * When this property is set, `enabledCollections` will not be available.\n       **/\n      disabledCollections?: CollectionSlug[]\n\n      // Ensures that enabledCollections is not available when disabledCollections is set\n      enabledCollections?: never\n    }\n  | {\n      // Ensures that disabledCollections is not available when enabledCollections is set\n      disabledCollections?: never\n\n      /**\n       * The collections that should be enabled. Overrides the `enableRichTextRelationship` property in the collection config\n       * When this property is set, `disabledCollections` will not be available.\n       **/\n      enabledCollections?: CollectionSlug[]\n    }\n\nexport type RelationshipFeatureProps = {\n  /**\n   * Sets a maximum population depth for this relationship, regardless of the remaining depth when the respective field is reached.\n   * This behaves exactly like the maxDepth properties of relationship and upload fields.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n} & ExclusiveRelationshipFeatureProps\n\nexport const RelationshipFeature = createServerFeature<\n  RelationshipFeatureProps,\n  RelationshipFeatureProps,\n  ExclusiveRelationshipFeatureProps\n>({\n  feature: ({ props }) => {\n    // we don't need to pass maxDepth to the client, it's only used on the server\n    const { maxDepth, ...clientFeatureProps } = props ?? {}\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#RelationshipFeatureClient',\n      clientFeatureProps,\n      i18n,\n      nodes: [\n        createNode({\n          graphQLPopulationPromises: [relationshipPopulationPromiseHOC(props)],\n          hooks: {\n            afterRead: [\n              ({\n                currentDepth,\n                depth,\n                draft,\n                node,\n                overrideAccess,\n                populateArg,\n                populationPromises,\n                req,\n                showHiddenFields,\n              }) => {\n                if (!node?.value) {\n                  return node\n                }\n                const collection = req.payload.collections[node?.relationTo]\n\n                if (!collection) {\n                  return node\n                }\n                // @ts-expect-error\n                const id = node?.value?.id || node?.value // for backwards-compatibility\n\n                const populateDepth = maxDepth !== undefined && maxDepth < depth ? maxDepth : depth\n\n                populationPromises.push(\n                  populate({\n                    id,\n                    collectionSlug: collection.config.slug,\n                    currentDepth,\n                    data: node,\n                    depth: populateDepth,\n                    draft,\n                    key: 'value',\n                    overrideAccess,\n                    req,\n                    select:\n                      populateArg?.[collection.config.slug] ?? collection.config.defaultPopulate,\n                    showHiddenFields,\n                  }),\n                )\n\n                return node\n              },\n            ],\n          },\n          node: RelationshipServerNode,\n        }),\n      ],\n    }\n  },\n  key: 'relationship',\n})\n"],"names":["populate","createServerFeature","createNode","relationshipPopulationPromiseHOC","i18n","RelationshipServerNode","RelationshipFeature","feature","props","maxDepth","clientFeatureProps","ClientFeature","nodes","graphQLPopulationPromises","hooks","afterRead","currentDepth","depth","draft","node","overrideAccess","populateArg","populationPromises","req","showHiddenFields","value","collection","payload","collections","relationTo","id","populateDepth","undefined","push","collectionSlug","config","slug","data","key","select","defaultPopulate"],"mappings":";;;;AAEA,SAASA,QAAQ,QAAQ;AACzB,SAASC,mBAAmB,QAAQ;AACpC,SAASC,UAAU,QAAQ;AAC3B,SAASC,gCAAgC,QAAQ;AACjD,SAASC,IAAI,QAAQ;AACrB,SAASC,sBAAsB,QAAQ;;;;;;;AAkChC,MAAMC,mBAAA,OAAsBL,gaAAA,EAIjC;IACAM,OAAA,EAASA,CAAC,EAAEC,KAAAA,EAAO;QACjB,6EAAA;QACA,MAAM,EAAEC,QAAQ,EAAE,GAAGC,oBAAoB,GAAGF,KAAA,IAAS,CAAC;QACtD,OAAO;YACLG,aAAA,EAAe;YACfD,kBAAA;kBACAN,2ZAAA;YACAQ,KAAA,EAAO;oBACLV,gZAAA,EAAW;oBACTW,yBAAA,EAA2B;4BAACV,2cAAA,EAAiCK,KAAA;qBAAO;oBACpEM,KAAA,EAAO;wBACLC,SAAA,EAAW;4BACT,CAAC,EACCC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdC,WAAW,EACXC,kBAAkB,EAClBC,GAAG,EACHC,gBAAAA,EACD;gCACC,IAAI,CAACL,IAAA,EAAMM,KAAA,EAAO;oCAChB,OAAON,IAAA;gCACT;gCACA,MAAMO,UAAA,GAAaH,GAAA,CAAII,OAAO,CAACC,WAAW,CAACT,IAAA,EAAMU,UAAA,CAAW;gCAE5D,IAAI,CAACH,UAAA,EAAY;oCACf,OAAOP,IAAA;gCACT;gCACA,mBAAA;gCACA,MAAMW,EAAA,GAAKX,IAAA,EAAMM,KAAA,EAAOK,EAAA,IAAMX,IAAA,EAAMM,KAAA,CAAM,8BAAA;;gCAE1C,MAAMM,aAAA,GAAgBtB,QAAA,KAAauB,SAAA,IAAavB,QAAA,GAAWQ,KAAA,GAAQR,QAAA,GAAWQ,KAAA;gCAE9EK,kBAAA,CAAmBW,IAAI,KACrBjC,gZAAA,EAAS;oCACP8B,EAAA;oCACAI,cAAA,EAAgBR,UAAA,CAAWS,MAAM,CAACC,IAAI;oCACtCpB,YAAA;oCACAqB,IAAA,EAAMlB,IAAA;oCACNF,KAAA,EAAOc,aAAA;oCACPb,KAAA;oCACAoB,GAAA,EAAK;oCACLlB,cAAA;oCACAG,GAAA;oCACAgB,MAAA,EACElB,WAAA,EAAA,CAAcK,UAAA,CAAWS,MAAM,CAACC,IAAI,CAAC,IAAIV,UAAA,CAAWS,MAAM,CAACK,eAAe;oCAC5EhB;gCACF;gCAGF,OAAOL,IAAA;4BACT;yBAAA;oBAEJ;oBACAA,IAAA,EAAMd,kcAAAA;gBACR;aAAA;QAEJ;IACF;IACAiC,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 4314, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/toolbars/inline/server/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/toolbars/inline/server/index.ts"],"sourcesContent":["import { createServerFeature } from '../../../../utilities/createServerFeature.js'\n\nexport const InlineToolbarFeature = createServerFeature({\n  feature: {\n    ClientFeature: '@payloadcms/richtext-lexical/client#InlineToolbarFeatureClient',\n  },\n  key: 'toolbarInline',\n})\n"],"names":["createServerFeature","InlineToolbarFeature","feature","ClientFeature","key"],"mappings":";;;;AAAA,SAASA,mBAAmB,QAAQ;;AAE7B,MAAMC,oBAAA,OAAuBD,gaAAA,EAAoB;IACtDE,OAAA,EAAS;QACPC,aAAA,EAAe;IACjB;IACAC,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 4330, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/upload/server/graphQLPopulationPromise.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/upload/server/graphQLPopulationPromise.ts"],"sourcesContent":["import type { PopulationPromise } from '../../typesServer.js'\nimport type { UploadFeatureProps } from './index.js'\nimport type { SerializedUploadNode } from './nodes/UploadNode.js'\n\nimport { populate } from '../../../populateGraphQL/populate.js'\nimport { recursivelyPopulateFieldsForGraphQL } from '../../../populateGraphQL/recursivelyPopulateFieldsForGraphQL.js'\n\nexport const uploadPopulationPromiseHOC = (\n  props?: UploadFeatureProps,\n): PopulationPromise<SerializedUploadNode> => {\n  return ({\n    context,\n    currentDepth,\n    depth,\n    draft,\n    editorPopulationPromises,\n    field,\n    fieldPromises,\n    findMany,\n    flattenLocales,\n    node,\n    overrideAccess,\n    parentIsLocalized,\n    populationPromises,\n    req,\n    showHiddenFields,\n  }) => {\n    if (node?.value) {\n      const collection = req.payload.collections[node?.relationTo]\n\n      if (collection) {\n        // @ts-expect-error\n        const id = node?.value?.id || node?.value // for backwards-compatibility\n\n        const populateDepth =\n          props?.maxDepth !== undefined && props?.maxDepth < depth ? props?.maxDepth : depth\n\n        populationPromises.push(\n          populate({\n            id,\n            collectionSlug: collection.config.slug,\n            currentDepth,\n            data: node,\n            depth: populateDepth,\n            draft,\n            key: 'value',\n            overrideAccess,\n            req,\n            showHiddenFields,\n          }),\n        )\n\n        const collectionFieldSchema = props?.collections?.[node?.relationTo]?.fields\n\n        if (Array.isArray(collectionFieldSchema)) {\n          if (!collectionFieldSchema?.length) {\n            return\n          }\n          recursivelyPopulateFieldsForGraphQL({\n            context,\n            currentDepth,\n            data: node.fields || {},\n            depth,\n            parentIsLocalized: parentIsLocalized || field.localized || false,\n\n            draft,\n            editorPopulationPromises,\n            fieldPromises,\n            fields: collectionFieldSchema,\n            findMany,\n            flattenLocales,\n            overrideAccess,\n            populationPromises,\n            req,\n            showHiddenFields,\n            siblingDoc: node.fields || {},\n          })\n        }\n      }\n    }\n  }\n}\n"],"names":["populate","recursivelyPopulateFieldsForGraphQL","uploadPopulationPromiseHOC","props","context","currentDepth","depth","draft","editorPopulationPromises","field","fieldPromises","findMany","flattenLocales","node","overrideAccess","parentIsLocalized","populationPromises","req","showHiddenFields","value","collection","payload","collections","relationTo","id","populateDepth","maxDepth","undefined","push","collectionSlug","config","slug","data","key","collectionFieldSchema","fields","Array","isArray","length","localized","siblingDoc"],"mappings":";;;;AAIA,SAASA,QAAQ,QAAQ;AACzB,SAASC,mCAAmC,QAAQ;;;AAE7C,MAAMC,0BAAA,IACXC,KAAA;IAEA,OAAO,CAAC,EACNC,OAAO,EACPC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,wBAAwB,EACxBC,KAAK,EACLC,aAAa,EACbC,QAAQ,EACRC,cAAc,EACdC,IAAI,EACJC,cAAc,EACdC,iBAAiB,EACjBC,kBAAkB,EAClBC,GAAG,EACHC,gBAAAA,EACD;QACC,IAAIL,IAAA,EAAMM,KAAA,EAAO;YACf,MAAMC,UAAA,GAAaH,GAAA,CAAII,OAAO,CAACC,WAAW,CAACT,IAAA,EAAMU,UAAA,CAAW;YAE5D,IAAIH,UAAA,EAAY;gBACd,mBAAA;gBACA,MAAMI,EAAA,GAAKX,IAAA,EAAMM,KAAA,EAAOK,EAAA,IAAMX,IAAA,EAAMM,KAAA,CAAM,8BAAA;;gBAE1C,MAAMM,aAAA,GACJtB,KAAA,EAAOuB,QAAA,KAAaC,SAAA,IAAaxB,KAAA,EAAOuB,QAAA,GAAWpB,KAAA,GAAQH,KAAA,EAAOuB,QAAA,GAAWpB,KAAA;gBAE/EU,kBAAA,CAAmBY,IAAI,KACrB5B,gZAAA,EAAS;oBACPwB,EAAA;oBACAK,cAAA,EAAgBT,UAAA,CAAWU,MAAM,CAACC,IAAI;oBACtC1B,YAAA;oBACA2B,IAAA,EAAMnB,IAAA;oBACNP,KAAA,EAAOmB,aAAA;oBACPlB,KAAA;oBACA0B,GAAA,EAAK;oBACLnB,cAAA;oBACAG,GAAA;oBACAC;gBACF;gBAGF,MAAMgB,qBAAA,GAAwB/B,KAAA,EAAOmB,WAAA,EAAA,CAAcT,IAAA,EAAMU,UAAA,CAAW,EAAEY,MAAA;gBAEtE,IAAIC,KAAA,CAAMC,OAAO,CAACH,qBAAA,GAAwB;oBACxC,IAAI,CAACA,qBAAA,EAAuBI,MAAA,EAAQ;wBAClC;oBACF;wBACArC,scAAA,EAAoC;wBAClCG,OAAA;wBACAC,YAAA;wBACA2B,IAAA,EAAMnB,IAAA,CAAKsB,MAAM,IAAI,CAAC;wBACtB7B,KAAA;wBACAS,iBAAA,EAAmBA,iBAAA,IAAqBN,KAAA,CAAM8B,SAAS,IAAI;wBAE3DhC,KAAA;wBACAC,wBAAA;wBACAE,aAAA;wBACAyB,MAAA,EAAQD,qBAAA;wBACRvB,QAAA;wBACAC,cAAA;wBACAE,cAAA;wBACAE,kBAAA;wBACAC,GAAA;wBACAC,gBAAA;wBACAsB,UAAA,EAAY3B,IAAA,CAAKsB,MAAM,IAAI,CAAC;oBAC9B;gBACF;YACF;QACF;IACF;AACF","ignoreList":[]}},
    {"offset": {"line": 4391, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/upload/server/i18n.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/upload/server/i18n.ts"],"sourcesContent":["import type { GenericLanguages } from '@payloadcms/translations'\n\nexport const i18n: Partial<GenericLanguages> = {\n  ar: {\n    label: 'تحميل',\n  },\n  az: {\n    label: 'Yükləyin',\n  },\n  bg: {\n    label: 'Качване',\n  },\n  cs: {\n    label: 'Nahrát',\n  },\n  da: {\n    label: 'Upload',\n  },\n  de: {\n    label: 'Datei',\n  },\n  en: {\n    label: 'Upload',\n  },\n  es: {\n    label: 'Subir',\n  },\n  et: {\n    label: 'Lae üles',\n  },\n  fa: {\n    label: 'بارگذاری',\n  },\n  fr: {\n    label: 'Télécharger',\n  },\n  he: {\n    label: 'העלה',\n  },\n  hr: {\n    label: 'Prenesi',\n  },\n  hu: {\n    label: 'Feltöltés',\n  },\n  is: {\n    label: 'Hlaða upp',\n  },\n  it: {\n    label: 'Carica',\n  },\n  ja: {\n    label: 'アップロード',\n  },\n  ko: {\n    label: '업로드',\n  },\n  my: {\n    label: 'တင်ပြီး',\n  },\n  nb: {\n    label: 'Last opp',\n  },\n  nl: {\n    label: 'Uploaden',\n  },\n  pl: {\n    label: 'Prześlij',\n  },\n  pt: {\n    label: 'Carregar',\n  },\n  ro: {\n    label: 'Încarcă',\n  },\n  rs: {\n    label: 'Отпреми',\n  },\n  'rs-latin': {\n    label: 'Otpremi',\n  },\n  ru: {\n    label: 'Загрузить',\n  },\n  sk: {\n    label: 'Nahrať',\n  },\n  sl: {\n    label: 'Naloži',\n  },\n  sv: {\n    label: 'Ladda upp',\n  },\n  ta: {\n    label: 'பதிவேற்றம்',\n  },\n  th: {\n    label: 'อัปโหลด',\n  },\n  tr: {\n    label: 'Yükle',\n  },\n  uk: {\n    label: 'Завантажити',\n  },\n  vi: {\n    label: 'Tải lên',\n  },\n  zh: {\n    label: '上传',\n  },\n  'zh-TW': {\n    label: '上傳',\n  },\n}\n"],"names":["i18n","ar","label","az","bg","cs","da","de","en","es","et","fa","fr","he","hr","hu","is","it","ja","ko","my","nb","nl","pl","pt","ro","rs","ru","sk","sl","sv","ta","th","tr","uk","vi","zh"],"mappings":";;;;AAEO,MAAMA,IAAA,GAAkC;IAC7CC,EAAA,EAAI;QACFC,KAAA,EAAO;IACT;IACAC,EAAA,EAAI;QACFD,KAAA,EAAO;IACT;IACAE,EAAA,EAAI;QACFF,KAAA,EAAO;IACT;IACAG,EAAA,EAAI;QACFH,KAAA,EAAO;IACT;IACAI,EAAA,EAAI;QACFJ,KAAA,EAAO;IACT;IACAK,EAAA,EAAI;QACFL,KAAA,EAAO;IACT;IACAM,EAAA,EAAI;QACFN,KAAA,EAAO;IACT;IACAO,EAAA,EAAI;QACFP,KAAA,EAAO;IACT;IACAQ,EAAA,EAAI;QACFR,KAAA,EAAO;IACT;IACAS,EAAA,EAAI;QACFT,KAAA,EAAO;IACT;IACAU,EAAA,EAAI;QACFV,KAAA,EAAO;IACT;IACAW,EAAA,EAAI;QACFX,KAAA,EAAO;IACT;IACAY,EAAA,EAAI;QACFZ,KAAA,EAAO;IACT;IACAa,EAAA,EAAI;QACFb,KAAA,EAAO;IACT;IACAc,EAAA,EAAI;QACFd,KAAA,EAAO;IACT;IACAe,EAAA,EAAI;QACFf,KAAA,EAAO;IACT;IACAgB,EAAA,EAAI;QACFhB,KAAA,EAAO;IACT;IACAiB,EAAA,EAAI;QACFjB,KAAA,EAAO;IACT;IACAkB,EAAA,EAAI;QACFlB,KAAA,EAAO;IACT;IACAmB,EAAA,EAAI;QACFnB,KAAA,EAAO;IACT;IACAoB,EAAA,EAAI;QACFpB,KAAA,EAAO;IACT;IACAqB,EAAA,EAAI;QACFrB,KAAA,EAAO;IACT;IACAsB,EAAA,EAAI;QACFtB,KAAA,EAAO;IACT;IACAuB,EAAA,EAAI;QACFvB,KAAA,EAAO;IACT;IACAwB,EAAA,EAAI;QACFxB,KAAA,EAAO;IACT;IACA,YAAY;QACVA,KAAA,EAAO;IACT;IACAyB,EAAA,EAAI;QACFzB,KAAA,EAAO;IACT;IACA0B,EAAA,EAAI;QACF1B,KAAA,EAAO;IACT;IACA2B,EAAA,EAAI;QACF3B,KAAA,EAAO;IACT;IACA4B,EAAA,EAAI;QACF5B,KAAA,EAAO;IACT;IACA6B,EAAA,EAAI;QACF7B,KAAA,EAAO;IACT;IACA8B,EAAA,EAAI;QACF9B,KAAA,EAAO;IACT;IACA+B,EAAA,EAAI;QACF/B,KAAA,EAAO;IACT;IACAgC,EAAA,EAAI;QACFhC,KAAA,EAAO;IACT;IACAiC,EAAA,EAAI;QACFjC,KAAA,EAAO;IACT;IACAkC,EAAA,EAAI;QACFlC,KAAA,EAAO;IACT;IACA,SAAS;QACPA,KAAA,EAAO;IACT;AACF","ignoreList":[]}},
    {"offset": {"line": 4512, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/upload/server/nodes/conversions.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/upload/server/nodes/conversions.ts"],"sourcesContent":["// This file contains functions used to convert dom elements to upload or pending upload lexical nodes. It requires the actual node\n// creation functions to be passed in to stay compatible with both client and server code.\nimport type { DOMConversionOutput } from 'lexical'\n\nimport ObjectID from 'bson-objectid'\n\nimport type { $createUploadNode } from '../../client/nodes/UploadNode.js'\nimport type { $createUploadServerNode, Internal_UploadData } from './UploadNode.js'\n\nexport function isGoogleDocCheckboxImg(img: HTMLImageElement): boolean {\n  return (\n    img.parentElement != null &&\n    img.parentElement.tagName === 'LI' &&\n    img.previousSibling === null &&\n    img.getAttribute('aria-roledescription') === 'checkbox'\n  )\n}\n\nexport function $convertUploadElement(\n  domNode: HTMLImageElement,\n  $createNode: typeof $createUploadNode | typeof $createUploadServerNode,\n): DOMConversionOutput | null {\n  if (domNode.hasAttribute('data-lexical-pending-upload-form-id')) {\n    const formID = domNode.getAttribute('data-lexical-pending-upload-form-id')\n\n    if (formID != null) {\n      const node = $createNode({\n        data: {\n          pending: {\n            formID,\n            src: domNode.getAttribute('src') || '',\n          },\n        } as Internal_UploadData,\n      })\n      return { node }\n    }\n  }\n  if (\n    domNode.hasAttribute('data-lexical-upload-relation-to') &&\n    domNode.hasAttribute('data-lexical-upload-id')\n  ) {\n    const id = domNode.getAttribute('data-lexical-upload-id')\n    const relationTo = domNode.getAttribute('data-lexical-upload-relation-to')\n\n    if (id != null && relationTo != null) {\n      const node = $createNode({\n        data: {\n          fields: {},\n          relationTo,\n          value: id,\n        },\n      })\n      return { node }\n    }\n  }\n\n  // Create pending UploadNode. Auto-Upload functionality will then be handled by the node transform\n  const node = $createNode({\n    data: {\n      pending: {\n        formID: new ObjectID.default().toHexString(),\n        src: domNode.getAttribute('src') || '',\n      },\n    } as Internal_UploadData,\n  })\n\n  return { node }\n}\n"],"names":["ObjectID","isGoogleDocCheckboxImg","img","parentElement","tagName","previousSibling","getAttribute","$convertUploadElement","domNode","$createNode","hasAttribute","formID","node","data","pending","src","id","relationTo","fields","value","default","toHexString"],"mappings":";;;;;;AAAA,mIAAA;AACA,0FAAA;AAGA,OAAOA,QAAA,MAAc;;AAKd,SAASC,uBAAuBC,GAAqB;IAC1D,OACEA,GAAA,CAAIC,aAAa,IAAI,QACrBD,GAAA,CAAIC,aAAa,CAACC,OAAO,KAAK,QAC9BF,GAAA,CAAIG,eAAe,KAAK,QACxBH,GAAA,CAAII,YAAY,CAAC,4BAA4B;AAEjD;AAEO,SAASC,sBACdC,OAAyB,EACzBC,WAAsE;IAEtE,IAAID,OAAA,CAAQE,YAAY,CAAC,wCAAwC;QAC/D,MAAMC,MAAA,GAASH,OAAA,CAAQF,YAAY,CAAC;QAEpC,IAAIK,MAAA,IAAU,MAAM;YAClB,MAAMC,IAAA,GAAOH,WAAA,CAAY;gBACvBI,IAAA,EAAM;oBACJC,OAAA,EAAS;wBACPH,MAAA;wBACAI,GAAA,EAAKP,OAAA,CAAQF,YAAY,CAAC,UAAU;oBACtC;gBACF;YACF;YACA,OAAO;gBAAEM;YAAK;QAChB;IACF;IACA,IACEJ,OAAA,CAAQE,YAAY,CAAC,sCACrBF,OAAA,CAAQE,YAAY,CAAC,2BACrB;QACA,MAAMM,EAAA,GAAKR,OAAA,CAAQF,YAAY,CAAC;QAChC,MAAMW,UAAA,GAAaT,OAAA,CAAQF,YAAY,CAAC;QAExC,IAAIU,EAAA,IAAM,QAAQC,UAAA,IAAc,MAAM;YACpC,MAAML,IAAA,GAAOH,WAAA,CAAY;gBACvBI,IAAA,EAAM;oBACJK,MAAA,EAAQ,CAAC;oBACTD,UAAA;oBACAE,KAAA,EAAOH;gBACT;YACF;YACA,OAAO;gBAAEJ;YAAK;QAChB;IACF;IAEA,kGAAA;IACA,MAAMA,IAAA,GAAOH,WAAA,CAAY;QACvBI,IAAA,EAAM;YACJC,OAAA,EAAS;gBACPH,MAAA,EAAQ,IAAIX,oNAAA,CAASoB,OAAO,GAAGC,WAAW;gBAC1CN,GAAA,EAAKP,OAAA,CAAQF,YAAY,CAAC,UAAU;YACtC;QACF;IACF;IAEA,OAAO;QAAEM;IAAK;AAChB","ignoreList":[]}},
    {"offset": {"line": 4575, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/upload/server/nodes/UploadNode.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/upload/server/nodes/UploadNode.tsx"],"sourcesContent":["import type { SerializedDecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport type {\n  DOMConversionMap,\n  DOMExportOutput,\n  EditorConfig,\n  ElementFormatType,\n  LexicalNode,\n  NodeKey,\n} from 'lexical'\nimport type {\n  CollectionSlug,\n  DataFromCollectionSlug,\n  JsonObject,\n  TypedUploadCollection,\n  UploadCollectionSlug,\n} from 'payload'\nimport type { JSX } from 'react'\n\nimport { DecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport { addClassNamesToElement } from '@lexical/utils'\nimport ObjectID from 'bson-objectid'\nimport { $applyNodeReplacement } from 'lexical'\n\nimport type { StronglyTypedLeafNode } from '../../../../nodeTypes.js'\n\nimport { $convertUploadElement } from './conversions.js'\n\nexport type UploadData<TUploadExtraFieldsData extends JsonObject = JsonObject> = {\n  [TCollectionSlug in CollectionSlug]: {\n    fields: TUploadExtraFieldsData\n    /**\n     * Every lexical node that has sub-fields needs to have a unique ID. This is the ID of this upload node, not the ID of the linked upload document\n     */\n    id: string\n    relationTo: TCollectionSlug\n    /**\n     * Value can be just the document ID, or the full, populated document\n     */\n    value: DataFromCollectionSlug<TCollectionSlug> | number | string\n  }\n}[CollectionSlug]\n\n/**\n * Internal use only - UploadData type that can contain a pending state\n * @internal\n */\nexport type Internal_UploadData<TUploadExtraFieldsData extends JsonObject = JsonObject> = {\n  pending?: {\n    /**\n     * ID that corresponds to the bulk upload form ID\n     */\n    formID: string\n    /**\n     * src value of the image dom element\n     */\n    src: string\n  }\n} & UploadData<TUploadExtraFieldsData>\n\n/**\n * UploadDataImproved is a more precise type, and will replace UploadData in Payload v4.\n * This type is for internal use only as it will be deprecated in the future.\n * @internal\n *\n * @todo Replace UploadData with UploadDataImproved in 4.0\n */\nexport type UploadDataImproved<TUploadExtraFieldsData extends JsonObject = JsonObject> = {\n  [TCollectionSlug in UploadCollectionSlug]: {\n    fields: TUploadExtraFieldsData\n    /**\n     * Every lexical node that has sub-fields needs to have a unique ID. This is the ID of this upload node, not the ID of the linked upload document\n     */\n    id: string\n    relationTo: TCollectionSlug\n    /**\n     * Value can be just the document ID, or the full, populated document\n     */\n    value: number | string | TypedUploadCollection[TCollectionSlug]\n  }\n}[UploadCollectionSlug]\n\nexport type SerializedUploadNode = StronglyTypedLeafNode<SerializedDecoratorBlockNode, 'upload'> &\n  UploadData\n\nexport class UploadServerNode extends DecoratorBlockNode {\n  __data: UploadData\n\n  constructor({\n    data,\n    format,\n    key,\n  }: {\n    data: UploadData\n    format?: ElementFormatType\n    key?: NodeKey\n  }) {\n    super(format, key)\n    this.__data = data\n  }\n\n  static override clone(node: UploadServerNode): UploadServerNode {\n    return new this({\n      data: node.__data,\n      format: node.__format,\n      key: node.__key,\n    })\n  }\n\n  static override getType(): string {\n    return 'upload'\n  }\n\n  static override importDOM(): DOMConversionMap<HTMLImageElement> {\n    return {\n      img: (node) => ({\n        conversion: (domNode) => $convertUploadElement(domNode, $createUploadServerNode),\n        priority: 0,\n      }),\n    }\n  }\n\n  static override importJSON(serializedNode: SerializedUploadNode): UploadServerNode {\n    if (serializedNode.version === 1 && (serializedNode?.value as unknown as { id: string })?.id) {\n      serializedNode.value = (serializedNode.value as unknown as { id: string }).id\n    }\n    if (serializedNode.version === 2 && !serializedNode?.id) {\n      serializedNode.id = new ObjectID.default().toHexString()\n      serializedNode.version = 3\n    }\n\n    const importedData: Internal_UploadData = {\n      id: serializedNode.id,\n      fields: serializedNode.fields,\n      pending: (serializedNode as Internal_UploadData).pending,\n      relationTo: serializedNode.relationTo,\n      value: serializedNode.value,\n    }\n\n    const node = $createUploadServerNode({ data: importedData })\n    node.setFormat(serializedNode.format)\n\n    return node\n  }\n\n  static isInline(): false {\n    return false\n  }\n\n  override createDOM(config?: EditorConfig): HTMLElement {\n    const element = document.createElement('div')\n    addClassNamesToElement(element, config?.theme?.upload)\n    return element\n  }\n\n  override decorate(): JSX.Element {\n    return null as unknown as JSX.Element\n  }\n\n  override exportDOM(): DOMExportOutput {\n    const element = document.createElement('img')\n    const data = this.__data as Internal_UploadData\n    if (data.pending) {\n      element.setAttribute('data-lexical-pending-upload-form-id', String(data?.pending?.formID))\n      element.setAttribute('src', data?.pending?.src || '')\n    } else {\n      element.setAttribute('data-lexical-upload-id', String(data?.value))\n      element.setAttribute('data-lexical-upload-relation-to', data?.relationTo)\n    }\n\n    return { element }\n  }\n\n  override exportJSON(): SerializedUploadNode {\n    return {\n      ...super.exportJSON(),\n      ...this.getData(),\n      type: 'upload',\n      version: 3,\n    }\n  }\n\n  getData(): UploadData {\n    return this.getLatest().__data\n  }\n\n  setData(data: UploadData): void {\n    const writable = this.getWritable()\n    writable.__data = data\n  }\n\n  override updateDOM(): false {\n    return false\n  }\n}\n\nexport function $createUploadServerNode({\n  data,\n}: {\n  data: Omit<UploadData, 'id'> & Partial<Pick<UploadData, 'id'>>\n}): UploadServerNode {\n  if (!data?.id) {\n    data.id = new ObjectID.default().toHexString()\n  }\n  return $applyNodeReplacement(new UploadServerNode({ data: data as UploadData }))\n}\n\nexport function $isUploadServerNode(\n  node: LexicalNode | null | undefined,\n): node is UploadServerNode {\n  return node instanceof UploadServerNode\n}\n"],"names":["DecoratorBlockNode","addClassNamesToElement","ObjectID","$applyNodeReplacement","$convertUploadElement","UploadServerNode","__data","constructor","data","format","key","clone","node","__format","__key","getType","importDOM","img","conversion","domNode","$createUploadServerNode","priority","importJSON","serializedNode","version","value","id","default","toHexString","importedData","fields","pending","relationTo","setFormat","isInline","createDOM","config","element","document","createElement","theme","upload","decorate","exportDOM","setAttribute","String","formID","src","exportJSON","getData","type","getLatest","setData","writable","getWritable","updateDOM","$isUploadServerNode"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 4697, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/upload/server/validate.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/upload/server/validate.ts"],"sourcesContent":["import { fieldSchemasToFormState } from '@payloadcms/ui/forms/fieldSchemasToFormState'\nimport { isValidID } from 'payload'\n\nimport type { NodeValidation } from '../../typesServer.js'\nimport type { UploadFeatureProps } from './index.js'\nimport type { SerializedUploadNode } from './nodes/UploadNode.js'\n\nexport const uploadValidation = (\n  props: UploadFeatureProps,\n): NodeValidation<SerializedUploadNode> => {\n  return async ({\n    node,\n    validation: {\n      options: {\n        id,\n        data,\n        operation,\n        preferences,\n        req,\n        req: { payload, t },\n      },\n    },\n  }) => {\n    const idType = payload.collections[node.relationTo]?.customIDType || payload.db.defaultIDType\n    // @ts-expect-error - Fix in Payload v4\n    const nodeID = node?.value?.id || node?.value // for backwards-compatibility\n\n    if (!isValidID(nodeID, idType)) {\n      return t('validation:validUploadID')\n    }\n\n    if (!props?.collections) {\n      return true\n    }\n\n    if (Object.keys(props?.collections).length === 0) {\n      return true\n    }\n\n    const collection = props?.collections[node.relationTo]\n\n    if (!collection?.fields?.length) {\n      return true\n    }\n\n    const result = await fieldSchemasToFormState({\n      id,\n      collectionSlug: node.relationTo,\n      data: node?.fields ?? {},\n      documentData: data,\n      fields: collection.fields,\n      fieldSchemaMap: undefined,\n      initialBlockData: node?.fields ?? {},\n      operation: operation === 'create' || operation === 'update' ? operation : 'update',\n      permissions: {},\n      preferences,\n      renderAllFields: false,\n      req,\n      schemaPath: '',\n    })\n\n    const errorPathsSet = new Set<string>()\n    for (const fieldKey in result) {\n      const fieldState = result[fieldKey]\n      if (fieldState?.errorPaths?.length) {\n        for (const errorPath of fieldState.errorPaths) {\n          errorPathsSet.add(errorPath)\n        }\n      }\n    }\n    const errorPaths = Array.from(errorPathsSet)\n\n    if (errorPaths.length) {\n      return 'The following fields are invalid: ' + errorPaths.join(', ')\n    }\n\n    return true\n  }\n}\n"],"names":["fieldSchemasToFormState","isValidID","uploadValidation","props","node","validation","options","id","data","operation","preferences","req","payload","t","idType","collections","relationTo","customIDType","db","defaultIDType","nodeID","value","Object","keys","length","collection","fields","result","collectionSlug","documentData","fieldSchemaMap","undefined","initialBlockData","permissions","renderAllFields","schemaPath","errorPathsSet","Set","fieldKey","fieldState","errorPaths","errorPath","add","Array","from","join"],"mappings":";;;;AAAA,SAASA,uBAAuB,QAAQ;AACxC,SAASC,SAAS,QAAQ;;;AAMnB,MAAMC,gBAAA,IACXC,KAAA;IAEA,OAAO,OAAO,EACZC,IAAI,EACJC,UAAA,EAAY,EACVC,OAAA,EAAS,EACPC,EAAE,EACFC,IAAI,EACJC,SAAS,EACTC,WAAW,EACXC,GAAG,EACHA,GAAA,EAAK,EAAEC,OAAO,EAAEC,CAAAA,EAAC,EAAE,EACpB,EAEJ;QACC,MAAMC,MAAA,GAASF,OAAA,CAAQG,WAAW,CAACX,IAAA,CAAKY,UAAU,CAAC,EAAEC,YAAA,IAAgBL,OAAA,CAAQM,EAAE,CAACC,aAAa;QAC7F,uCAAA;QACA,MAAMC,MAAA,GAAShB,IAAA,EAAMiB,KAAA,EAAOd,EAAA,IAAMH,IAAA,EAAMiB,KAAA,CAAM,8BAAA;;QAE9C,IAAI,KAACpB,8QAAA,EAAUmB,MAAA,EAAQN,MAAA,GAAS;YAC9B,OAAOD,CAAA,CAAE;QACX;QAEA,IAAI,CAACV,KAAA,EAAOY,WAAA,EAAa;YACvB,OAAO;QACT;QAEA,IAAIO,MAAA,CAAOC,IAAI,CAACpB,KAAA,EAAOY,WAAA,EAAaS,MAAM,KAAK,GAAG;YAChD,OAAO;QACT;QAEA,MAAMC,UAAA,GAAatB,KAAA,EAAOY,WAAW,CAACX,IAAA,CAAKY,UAAU,CAAC;QAEtD,IAAI,CAACS,UAAA,EAAYC,MAAA,EAAQF,MAAA,EAAQ;YAC/B,OAAO;QACT;QAEA,MAAMG,MAAA,GAAS,UAAM3B,+aAAA,EAAwB;YAC3CO,EAAA;YACAqB,cAAA,EAAgBxB,IAAA,CAAKY,UAAU;YAC/BR,IAAA,EAAMJ,IAAA,EAAMsB,MAAA,IAAU,CAAC;YACvBG,YAAA,EAAcrB,IAAA;YACdkB,MAAA,EAAQD,UAAA,CAAWC,MAAM;YACzBI,cAAA,EAAgBC,SAAA;YAChBC,gBAAA,EAAkB5B,IAAA,EAAMsB,MAAA,IAAU,CAAC;YACnCjB,SAAA,EAAWA,SAAA,KAAc,YAAYA,SAAA,KAAc,WAAWA,SAAA,GAAY;YAC1EwB,WAAA,EAAa,CAAC;YACdvB,WAAA;YACAwB,eAAA,EAAiB;YACjBvB,GAAA;YACAwB,UAAA,EAAY;QACd;QAEA,MAAMC,aAAA,GAAgB,IAAIC,GAAA;QAC1B,IAAK,MAAMC,QAAA,IAAYX,MAAA,CAAQ;YAC7B,MAAMY,UAAA,GAAaZ,MAAM,CAACW,QAAA,CAAS;YACnC,IAAIC,UAAA,EAAYC,UAAA,EAAYhB,MAAA,EAAQ;gBAClC,KAAK,MAAMiB,SAAA,IAAaF,UAAA,CAAWC,UAAU,CAAE;oBAC7CJ,aAAA,CAAcM,GAAG,CAACD,SAAA;gBACpB;YACF;QACF;QACA,MAAMD,UAAA,GAAaG,KAAA,CAAMC,IAAI,CAACR,aAAA;QAE9B,IAAII,UAAA,CAAWhB,MAAM,EAAE;YACrB,OAAO,uCAAuCgB,UAAA,CAAWK,IAAI,CAAC;QAChE;QAEA,OAAO;IACT;AACF","ignoreList":[]}},
    {"offset": {"line": 4759, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/upload/server/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/upload/server/index.ts"],"sourcesContent":["import type {\n  Config,\n  Field,\n  FieldSchemaMap,\n  FileData,\n  FileSizeImproved,\n  Payload,\n  TypeWithID,\n  UploadCollectionSlug,\n} from 'payload'\n\nimport { sanitizeFields } from 'payload'\n\nimport type { UploadFeaturePropsClient } from '../client/index.js'\n\nimport { populate } from '../../../populateGraphQL/populate.js'\nimport { createServerFeature } from '../../../utilities/createServerFeature.js'\nimport { createNode } from '../../typeUtilities.js'\nimport { uploadPopulationPromiseHOC } from './graphQLPopulationPromise.js'\nimport { i18n } from './i18n.js'\nimport { UploadServerNode } from './nodes/UploadNode.js'\nimport { uploadValidation } from './validate.js'\n\nexport type ExclusiveUploadFeatureProps =\n  | {\n      /**\n       * The collections that should be disabled. Overrides the `enableRichTextRelationship` property in the collection config.\n       * When this property is set, `enabledCollections` will not be available.\n       **/\n      disabledCollections?: UploadCollectionSlug[]\n\n      // Ensures that enabledCollections is not available when disabledCollections is set\n      enabledCollections?: never\n    }\n  | {\n      // Ensures that disabledCollections is not available when enabledCollections is set\n      disabledCollections?: never\n\n      /**\n       * The collections that should be enabled. Overrides the `enableRichTextRelationship` property in the collection config\n       * When this property is set, `disabledCollections` will not be available.\n       **/\n      enabledCollections?: UploadCollectionSlug[]\n    }\n\nexport type UploadFeatureProps = {\n  collections?: {\n    [collection: UploadCollectionSlug]: {\n      fields: Field[]\n    }\n  }\n  /**\n   * Sets a maximum population depth for this upload (not the fields for this upload), regardless of the remaining depth when the respective field is reached.\n   * This behaves exactly like the maxDepth properties of relationship and upload fields.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n} & ExclusiveUploadFeatureProps\n\n/**\n * Get the absolute URL for an upload URL by potentially prepending the serverURL\n */\nfunction getAbsoluteURL(url: string, payload: Payload): string {\n  return url?.startsWith('http') ? url : (payload?.config?.serverURL || '') + url\n}\n\nexport const UploadFeature = createServerFeature<\n  UploadFeatureProps,\n  UploadFeatureProps,\n  UploadFeaturePropsClient\n>({\n  feature: async ({ config: _config, isRoot, parentIsLocalized, props }) => {\n    if (!props) {\n      props = { collections: {} }\n    }\n\n    const clientProps: UploadFeaturePropsClient = {\n      collections: {},\n    }\n    if (props.disabledCollections) {\n      clientProps.disabledCollections = props.disabledCollections\n    }\n    if (props.enabledCollections) {\n      clientProps.enabledCollections = props.enabledCollections\n    }\n\n    if (props.collections) {\n      for (const collection in props.collections) {\n        clientProps.collections[collection] = {\n          hasExtraFields: props.collections[collection]!.fields.length >= 1,\n        }\n      }\n    }\n\n    const validRelationships = _config.collections.map((c) => c.slug) || []\n\n    for (const collectionKey in props.collections) {\n      const collection = props.collections[collectionKey]!\n      if (collection.fields?.length) {\n        collection.fields = await sanitizeFields({\n          config: _config as unknown as Config,\n          fields: collection.fields,\n          parentIsLocalized,\n          requireFieldLevelRichTextEditor: isRoot,\n          validRelationships,\n        })\n      }\n    }\n\n    return {\n      ClientFeature: '@payloadcms/richtext-lexical/client#UploadFeatureClient',\n      clientFeatureProps: clientProps,\n      generateSchemaMap: ({ props }) => {\n        if (!props?.collections) {\n          return null\n        }\n\n        const schemaMap: FieldSchemaMap = new Map()\n\n        for (const collectionKey in props.collections) {\n          const collection = props.collections[collectionKey]!\n          if (collection.fields?.length) {\n            schemaMap.set(collectionKey, {\n              fields: collection.fields,\n            })\n          }\n        }\n\n        return schemaMap\n      },\n      i18n,\n      nodes: [\n        createNode({\n          converters: {\n            html: {\n              converter: async ({\n                currentDepth,\n                depth,\n                draft,\n                node,\n                overrideAccess,\n                req,\n                showHiddenFields,\n              }) => {\n                // @ts-expect-error - for backwards-compatibility\n                const id = node?.value?.id || node?.value\n\n                if (req?.payload) {\n                  const uploadDocument: {\n                    value?: FileData & TypeWithID\n                  } = {}\n\n                  try {\n                    await populate({\n                      id,\n                      collectionSlug: node.relationTo,\n                      currentDepth,\n                      data: uploadDocument,\n                      depth,\n                      draft,\n                      key: 'value',\n                      overrideAccess,\n                      req,\n                      showHiddenFields,\n                    })\n                  } catch (ignored) {\n                    // eslint-disable-next-line no-console\n                    console.error(\n                      'Lexical upload node HTML converter: error fetching upload file',\n                      ignored,\n                      'Node:',\n                      node,\n                    )\n                    return `<img />`\n                  }\n\n                  const url = getAbsoluteURL(uploadDocument?.value?.url ?? '', req?.payload)\n\n                  /**\n                   * If the upload is not an image, return a link to the upload\n                   */\n                  if (!uploadDocument?.value?.mimeType?.startsWith('image')) {\n                    return `<a href=\"${url}\" rel=\"noopener noreferrer\">${uploadDocument.value?.filename}</a>`\n                  }\n\n                  /**\n                   * If the upload is a simple image with no different sizes, return a simple img tag\n                   */\n                  if (\n                    !uploadDocument?.value?.sizes ||\n                    !Object.keys(uploadDocument?.value?.sizes).length\n                  ) {\n                    return `<img src=\"${url}\" alt=\"${uploadDocument?.value?.filename}\" width=\"${uploadDocument?.value?.width}\"  height=\"${uploadDocument?.value?.height}\"/>`\n                  }\n\n                  /**\n                   * If the upload is an image with different sizes, return a picture element\n                   */\n                  let pictureHTML = '<picture>'\n\n                  // Iterate through each size in the data.sizes object\n                  for (const size in uploadDocument.value?.sizes) {\n                    const imageSize = uploadDocument.value.sizes[size] as FileSizeImproved\n\n                    // Skip if any property of the size object is null\n                    if (\n                      !imageSize.width ||\n                      !imageSize.height ||\n                      !imageSize.mimeType ||\n                      !imageSize.filesize ||\n                      !imageSize.filename ||\n                      !imageSize.url\n                    ) {\n                      continue\n                    }\n                    const imageSizeURL = getAbsoluteURL(imageSize?.url, req?.payload)\n\n                    pictureHTML += `<source srcset=\"${imageSizeURL}\" media=\"(max-width: ${imageSize.width}px)\" type=\"${imageSize.mimeType}\">`\n                  }\n\n                  // Add the default img tag\n                  pictureHTML += `<img src=\"${url}\" alt=\"Image\" width=\"${uploadDocument.value?.width}\" height=\"${uploadDocument.value?.height}\">`\n                  pictureHTML += '</picture>'\n                  return pictureHTML\n                } else {\n                  return `<img src=\"${id}\" />`\n                }\n              },\n              nodeTypes: [UploadServerNode.getType()],\n            },\n          },\n          getSubFields: ({ node, req }) => {\n            if (!node) {\n              let allSubFields: Field[] = []\n              for (const collection in props?.collections) {\n                const collectionFields = props.collections[collection]!.fields\n                allSubFields = allSubFields.concat(collectionFields)\n              }\n              return allSubFields\n            }\n            const collection = req ? req.payload.collections[node?.relationTo] : null\n\n            if (collection) {\n              const collectionFieldSchema = props?.collections?.[node?.relationTo]?.fields\n\n              if (Array.isArray(collectionFieldSchema)) {\n                if (!collectionFieldSchema?.length) {\n                  return null\n                }\n                return collectionFieldSchema\n              }\n            }\n            return null\n          },\n          getSubFieldsData: ({ node }) => {\n            return node?.fields\n          },\n          graphQLPopulationPromises: [uploadPopulationPromiseHOC(props)],\n          hooks: {\n            afterRead: [\n              ({\n                currentDepth,\n                depth,\n                draft,\n                node,\n                overrideAccess,\n                populateArg,\n                populationPromises,\n                req,\n                showHiddenFields,\n              }) => {\n                if (!node?.value) {\n                  return node\n                }\n                const collection = req.payload.collections[node?.relationTo]\n\n                if (!collection) {\n                  return node\n                }\n                // @ts-expect-error - Fix in Payload v4\n                const id = node?.value?.id || node?.value // for backwards-compatibility\n\n                const populateDepth =\n                  props?.maxDepth !== undefined && props?.maxDepth < depth ? props?.maxDepth : depth\n\n                populationPromises.push(\n                  populate({\n                    id,\n                    collectionSlug: collection.config.slug,\n                    currentDepth,\n                    data: node,\n                    depth: populateDepth,\n                    draft,\n                    key: 'value',\n                    overrideAccess,\n                    req,\n                    select:\n                      populateArg?.[collection.config.slug] ?? collection.config.defaultPopulate,\n                    showHiddenFields,\n                  }),\n                )\n\n                return node\n              },\n            ],\n          },\n          node: UploadServerNode,\n          validations: [uploadValidation(props)],\n        }),\n      ],\n      sanitizedServerFeatureProps: props,\n    }\n  },\n  key: 'upload',\n})\n"],"names":["sanitizeFields","populate","createServerFeature","createNode","uploadPopulationPromiseHOC","i18n","UploadServerNode","uploadValidation","getAbsoluteURL","url","payload","startsWith","config","serverURL","UploadFeature","feature","_config","isRoot","parentIsLocalized","props","collections","clientProps","disabledCollections","enabledCollections","collection","hasExtraFields","fields","length","validRelationships","map","c","slug","collectionKey","requireFieldLevelRichTextEditor","ClientFeature","clientFeatureProps","generateSchemaMap","schemaMap","Map","set","nodes","converters","html","converter","currentDepth","depth","draft","node","overrideAccess","req","showHiddenFields","id","value","uploadDocument","collectionSlug","relationTo","data","key","ignored","console","error","mimeType","filename","sizes","Object","keys","width","height","pictureHTML","size","imageSize","filesize","imageSizeURL","nodeTypes","getType","getSubFields","allSubFields","collectionFields","concat","collectionFieldSchema","Array","isArray","getSubFieldsData","graphQLPopulationPromises","hooks","afterRead","populateArg","populationPromises","populateDepth","maxDepth","undefined","push","select","defaultPopulate","validations","sanitizedServerFeatureProps"],"mappings":";;;;AAWA,SAASA,cAAc,QAAQ;AAI/B,SAASC,QAAQ,QAAQ;AACzB,SAASC,mBAAmB,QAAQ;AACpC,SAASC,UAAU,QAAQ;AAC3B,SAASC,0BAA0B,QAAQ;AAC3C,SAASC,IAAI,QAAQ;AACrB,SAASC,gBAAgB,QAAQ;AACjC,SAASC,gBAAgB,QAAQ;;;;;;;;;AAuCjC;;IAGA,SAASC,eAAeC,GAAW,EAAEC,OAAgB;IACnD,OAAOD,GAAA,EAAKE,UAAA,CAAW,UAAUF,GAAA,GAAM,CAACC,OAAA,EAASE,MAAA,EAAQC,SAAA,IAAa,EAAC,IAAKJ,GAAA;AAC9E;AAEO,MAAMK,aAAA,OAAgBZ,gaAAA,EAI3B;IACAa,OAAA,EAAS,MAAAA,CAAO,EAAEH,MAAA,EAAQI,OAAO,EAAEC,MAAM,EAAEC,iBAAiB,EAAEC,KAAAA,EAAO;QACnE,IAAI,CAACA,KAAA,EAAO;YACVA,KAAA,GAAQ;gBAAEC,WAAA,EAAa,CAAC;YAAE;QAC5B;QAEA,MAAMC,WAAA,GAAwC;YAC5CD,WAAA,EAAa,CAAC;QAChB;QACA,IAAID,KAAA,CAAMG,mBAAmB,EAAE;YAC7BD,WAAA,CAAYC,mBAAmB,GAAGH,KAAA,CAAMG,mBAAmB;QAC7D;QACA,IAAIH,KAAA,CAAMI,kBAAkB,EAAE;YAC5BF,WAAA,CAAYE,kBAAkB,GAAGJ,KAAA,CAAMI,kBAAkB;QAC3D;QAEA,IAAIJ,KAAA,CAAMC,WAAW,EAAE;YACrB,IAAK,MAAMI,UAAA,IAAcL,KAAA,CAAMC,WAAW,CAAE;gBAC1CC,WAAA,CAAYD,WAAW,CAACI,UAAA,CAAW,GAAG;oBACpCC,cAAA,EAAgBN,KAAA,CAAMC,WAAW,CAACI,UAAA,CAAW,CAAEE,MAAM,CAACC,MAAM,IAAI;gBAClE;YACF;QACF;QAEA,MAAMC,kBAAA,GAAqBZ,OAAA,CAAQI,WAAW,CAACS,GAAG,EAAEC,CAAA,GAAMA,CAAA,CAAEC,IAAI,KAAK,EAAE;QAEvE,IAAK,MAAMC,aAAA,IAAiBb,KAAA,CAAMC,WAAW,CAAE;YAC7C,MAAMI,UAAA,GAAaL,KAAA,CAAMC,WAAW,CAACY,aAAA,CAAc;YACnD,IAAIR,UAAA,CAAWE,MAAM,EAAEC,MAAA,EAAQ;gBAC7BH,UAAA,CAAWE,MAAM,GAAG,UAAM1B,yRAAA,EAAe;oBACvCY,MAAA,EAAQI,OAAA;oBACRU,MAAA,EAAQF,UAAA,CAAWE,MAAM;oBACzBR,iBAAA;oBACAe,+BAAA,EAAiChB,MAAA;oBACjCW;gBACF;YACF;QACF;QAEA,OAAO;YACLM,aAAA,EAAe;YACfC,kBAAA,EAAoBd,WAAA;YACpBe,iBAAA,EAAmBA,CAAC,EAAEjB,KAAAA,EAAO;gBAC3B,IAAI,CAACA,KAAA,EAAOC,WAAA,EAAa;oBACvB,OAAO;gBACT;gBAEA,MAAMiB,SAAA,GAA4B,IAAIC,GAAA;gBAEtC,IAAK,MAAMN,aAAA,IAAiBb,KAAA,CAAMC,WAAW,CAAE;oBAC7C,MAAMI,UAAA,GAAaL,KAAA,CAAMC,WAAW,CAACY,aAAA,CAAc;oBACnD,IAAIR,UAAA,CAAWE,MAAM,EAAEC,MAAA,EAAQ;wBAC7BU,SAAA,CAAUE,GAAG,CAACP,aAAA,EAAe;4BAC3BN,MAAA,EAAQF,UAAA,CAAWE,MAAAA;wBACrB;oBACF;gBACF;gBAEA,OAAOW,SAAA;YACT;kBACAhC,qZAAA;YACAmC,KAAA,EAAO;oBACLrC,gZAAA,EAAW;oBACTsC,UAAA,EAAY;wBACVC,IAAA,EAAM;4BACJC,SAAA,EAAW,MAAAA,CAAO,EAChBC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdC,GAAG,EACHC,gBAAAA,EACD;gCACC,iDAAA;gCACA,MAAMC,EAAA,GAAKJ,IAAA,EAAMK,KAAA,EAAOD,EAAA,IAAMJ,IAAA,EAAMK,KAAA;gCAEpC,IAAIH,GAAA,EAAKvC,OAAA,EAAS;oCAChB,MAAM2C,cAAA,GAEF,CAAC;oCAEL,IAAI;wCACF,UAAMpD,gZAAA,EAAS;4CACbkD,EAAA;4CACAG,cAAA,EAAgBP,IAAA,CAAKQ,UAAU;4CAC/BX,YAAA;4CACAY,IAAA,EAAMH,cAAA;4CACNR,KAAA;4CACAC,KAAA;4CACAW,GAAA,EAAK;4CACLT,cAAA;4CACAC,GAAA;4CACAC;wCACF;oCACF,EAAE,OAAOQ,OAAA,EAAS;wCAChB,sCAAA;wCACAC,OAAA,CAAQC,KAAK,CACX,kEACAF,OAAA,EACA,SACAX,IAAA;wCAEF,OAAO,CAAA,OAAA,CAAS;oCAClB;oCAEA,MAAMtC,GAAA,GAAMD,cAAA,CAAe6C,cAAA,EAAgBD,KAAA,EAAO3C,GAAA,IAAO,IAAIwC,GAAA,EAAKvC,OAAA;oCAElE;;mBAGA,IAAI,CAAC2C,cAAA,EAAgBD,KAAA,EAAOS,QAAA,EAAUlD,UAAA,CAAW,UAAU;wCACzD,OAAO,CAAA,SAAA,EAAYF,GAAA,CAAA,4BAAA,EAAkC4C,cAAA,CAAeD,KAAK,EAAEU,QAAA,CAAA,IAAA,CAAc;oCAC3F;oCAEA;;mBAGA,IACE,CAACT,cAAA,EAAgBD,KAAA,EAAOW,KAAA,IACxB,CAACC,MAAA,CAAOC,IAAI,CAACZ,cAAA,EAAgBD,KAAA,EAAOW,KAAA,EAAOpC,MAAM,EACjD;wCACA,OAAO,CAAA,UAAA,EAAalB,GAAA,CAAA,OAAA,EAAa4C,cAAA,EAAgBD,KAAA,EAAOU,QAAA,CAAA,SAAA,EAAoBT,cAAA,EAAgBD,KAAA,EAAOc,KAAA,CAAA,WAAA,EAAmBb,cAAA,EAAgBD,KAAA,EAAOe,MAAA,CAAA,GAAA,CAAW;oCAC1J;oCAEA;;mBAGA,IAAIC,WAAA,GAAc;oCAElB,qDAAA;oCACA,IAAK,MAAMC,IAAA,IAAQhB,cAAA,CAAeD,KAAK,EAAEW,KAAA,CAAO;wCAC9C,MAAMO,SAAA,GAAYjB,cAAA,CAAeD,KAAK,CAACW,KAAK,CAACM,IAAA,CAAK;wCAElD,kDAAA;wCACA,IACE,CAACC,SAAA,CAAUJ,KAAK,IAChB,CAACI,SAAA,CAAUH,MAAM,IACjB,CAACG,SAAA,CAAUT,QAAQ,IACnB,CAACS,SAAA,CAAUC,QAAQ,IACnB,CAACD,SAAA,CAAUR,QAAQ,IACnB,CAACQ,SAAA,CAAU7D,GAAG,EACd;4CACA;wCACF;wCACA,MAAM+D,YAAA,GAAehE,cAAA,CAAe8D,SAAA,EAAW7D,GAAA,EAAKwC,GAAA,EAAKvC,OAAA;wCAEzD0D,WAAA,IAAe,CAAA,gBAAA,EAAmBI,YAAA,CAAA,qBAAA,EAAoCF,SAAA,CAAUJ,KAAK,CAAA,WAAA,EAAcI,SAAA,CAAUT,QAAQ,CAAA,EAAA,CAAI;oCAC3H;oCAEA,0BAAA;oCACAO,WAAA,IAAe,CAAA,UAAA,EAAa3D,GAAA,CAAA,qBAAA,EAA2B4C,cAAA,CAAeD,KAAK,EAAEc,KAAA,CAAA,UAAA,EAAkBb,cAAA,CAAeD,KAAK,EAAEe,MAAA,CAAA,EAAA,CAAU;oCAC/HC,WAAA,IAAe;oCACf,OAAOA,WAAA;gCACT,OAAO;oCACL,OAAO,CAAA,UAAA,EAAajB,EAAA,CAAA,IAAA,CAAQ;gCAC9B;4BACF;4BACAsB,SAAA,EAAW;gCAACnE,gbAAA,CAAiBoE,OAAO;6BAAA;wBACtC;oBACF;oBACAC,YAAA,EAAcA,CAAC,EAAE5B,IAAI,EAAEE,GAAAA,EAAK;wBAC1B,IAAI,CAACF,IAAA,EAAM;4BACT,IAAI6B,YAAA,GAAwB,EAAE;4BAC9B,IAAK,MAAMpD,UAAA,IAAcL,KAAA,EAAOC,WAAA,CAAa;gCAC3C,MAAMyD,gBAAA,GAAmB1D,KAAA,CAAMC,WAAW,CAACI,UAAA,CAAW,CAAEE,MAAM;gCAC9DkD,YAAA,GAAeA,YAAA,CAAaE,MAAM,CAACD,gBAAA;4BACrC;4BACA,OAAOD,YAAA;wBACT;wBACA,MAAMpD,UAAA,GAAayB,GAAA,GAAMA,GAAA,CAAIvC,OAAO,CAACU,WAAW,CAAC2B,IAAA,EAAMQ,UAAA,CAAW,GAAG;wBAErE,IAAI/B,UAAA,EAAY;4BACd,MAAMuD,qBAAA,GAAwB5D,KAAA,EAAOC,WAAA,EAAA,CAAc2B,IAAA,EAAMQ,UAAA,CAAW,EAAE7B,MAAA;4BAEtE,IAAIsD,KAAA,CAAMC,OAAO,CAACF,qBAAA,GAAwB;gCACxC,IAAI,CAACA,qBAAA,EAAuBpD,MAAA,EAAQ;oCAClC,OAAO;gCACT;gCACA,OAAOoD,qBAAA;4BACT;wBACF;wBACA,OAAO;oBACT;oBACAG,gBAAA,EAAkBA,CAAC,EAAEnC,IAAAA,EAAM;wBACzB,OAAOA,IAAA,EAAMrB,MAAA;oBACf;oBACAyD,yBAAA,EAA2B;4BAAC/E,+bAAA,EAA2Be,KAAA;qBAAO;oBAC9DiE,KAAA,EAAO;wBACLC,SAAA,EAAW;4BACT,CAAC,EACCzC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,IAAI,EACJC,cAAc,EACdsC,WAAW,EACXC,kBAAkB,EAClBtC,GAAG,EACHC,gBAAAA,EACD;gCACC,IAAI,CAACH,IAAA,EAAMK,KAAA,EAAO;oCAChB,OAAOL,IAAA;gCACT;gCACA,MAAMvB,UAAA,GAAayB,GAAA,CAAIvC,OAAO,CAACU,WAAW,CAAC2B,IAAA,EAAMQ,UAAA,CAAW;gCAE5D,IAAI,CAAC/B,UAAA,EAAY;oCACf,OAAOuB,IAAA;gCACT;gCACA,uCAAA;gCACA,MAAMI,EAAA,GAAKJ,IAAA,EAAMK,KAAA,EAAOD,EAAA,IAAMJ,IAAA,EAAMK,KAAA,CAAM,8BAAA;;gCAE1C,MAAMoC,aAAA,GACJrE,KAAA,EAAOsE,QAAA,KAAaC,SAAA,IAAavE,KAAA,EAAOsE,QAAA,GAAW5C,KAAA,GAAQ1B,KAAA,EAAOsE,QAAA,GAAW5C,KAAA;gCAE/E0C,kBAAA,CAAmBI,IAAI,KACrB1F,gZAAA,EAAS;oCACPkD,EAAA;oCACAG,cAAA,EAAgB9B,UAAA,CAAWZ,MAAM,CAACmB,IAAI;oCACtCa,YAAA;oCACAY,IAAA,EAAMT,IAAA;oCACNF,KAAA,EAAO2C,aAAA;oCACP1C,KAAA;oCACAW,GAAA,EAAK;oCACLT,cAAA;oCACAC,GAAA;oCACA2C,MAAA,EACEN,WAAA,EAAA,CAAc9D,UAAA,CAAWZ,MAAM,CAACmB,IAAI,CAAC,IAAIP,UAAA,CAAWZ,MAAM,CAACiF,eAAe;oCAC5E3C;gCACF;gCAGF,OAAOH,IAAA;4BACT;yBAAA;oBAEJ;oBACAA,IAAA,EAAMzC,gbAAA;oBACNwF,WAAA,EAAa;4BAACvF,qaAAA,EAAiBY,KAAA;qBAAA;gBACjC;aACD;YACD4E,2BAAA,EAA6B5E;QAC/B;IACF;IACAsC,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 4976, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/lexical/theme/EditorTheme.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/theme/EditorTheme.tsx"],"sourcesContent":["import type { EditorThemeClasses } from 'lexical'\n\nexport const LexicalEditorTheme: EditorThemeClasses = {\n  block: 'LexicalEditorTheme__block',\n  blockCursor: 'LexicalEditorTheme__blockCursor',\n  characterLimit: 'LexicalEditorTheme__characterLimit',\n  code: 'LexicalEditorTheme__code',\n  inlineBlock: 'LexicalEditorTheme__inlineBlock',\n\n  heading: {\n    h1: 'LexicalEditorTheme__h1',\n    h2: 'LexicalEditorTheme__h2',\n    h3: 'LexicalEditorTheme__h3',\n    h4: 'LexicalEditorTheme__h4',\n    h5: 'LexicalEditorTheme__h5',\n    h6: 'LexicalEditorTheme__h6',\n  },\n  hr: 'LexicalEditorTheme__hr',\n  hrSelected: 'LexicalEditorTheme__hrSelected',\n  indent: 'LexicalEditorTheme__indent',\n  link: 'LexicalEditorTheme__link',\n  list: {\n    checklist: 'LexicalEditorTheme__checklist',\n    listitem: 'LexicalEditorTheme__listItem',\n    listitemChecked: 'LexicalEditorTheme__listItemChecked',\n    listitemUnchecked: 'LexicalEditorTheme__listItemUnchecked',\n    nested: {\n      listitem: 'LexicalEditorTheme__nestedListItem',\n    },\n    olDepth: [\n      'LexicalEditorTheme__ol1',\n      'LexicalEditorTheme__ol2',\n      'LexicalEditorTheme__ol3',\n      'LexicalEditorTheme__ol4',\n      'LexicalEditorTheme__ol5',\n    ],\n    ul: 'LexicalEditorTheme__ul',\n  },\n  ltr: 'LexicalEditorTheme__ltr',\n  mark: 'LexicalEditorTheme__mark',\n  markOverlap: 'LexicalEditorTheme__markOverlap',\n  paragraph: 'LexicalEditorTheme__paragraph',\n  placeholder: 'LexicalEditorTheme__placeholder',\n  quote: 'LexicalEditorTheme__quote',\n  relationship: 'LexicalEditorTheme__relationship',\n  rtl: 'LexicalEditorTheme__rtl',\n  tab: 'LexicalEditorTheme__tabNode',\n  table: 'LexicalEditorTheme__table',\n  tableAddColumns: 'LexicalEditorTheme__tableAddColumns',\n  tableAddRows: 'LexicalEditorTheme__tableAddRows',\n  tableAlignment: {\n    center: 'LexicalEditorTheme__tableAlignmentCenter',\n    right: 'LexicalEditorTheme__tableAlignmentRight',\n  },\n  tableCell: 'LexicalEditorTheme__tableCell',\n  tableCellActionButton: 'LexicalEditorTheme__tableCellActionButton',\n  tableCellActionButtonContainer: 'LexicalEditorTheme__tableCellActionButtonContainer',\n  tableCellHeader: 'LexicalEditorTheme__tableCellHeader',\n  tableCellResizer: 'LexicalEditorTheme__tableCellResizer',\n  tableCellSelected: 'LexicalEditorTheme__tableCellSelected',\n  tableFrozenColumn: 'LexicalEditorTheme__tableFrozenColumn',\n  tableRowStriping: 'LexicalEditorTheme__tableRowStriping',\n  tableScrollableWrapper: 'LexicalEditorTheme__tableScrollableWrapper',\n  tableSelected: 'LexicalEditorTheme__tableSelected',\n  tableSelection: 'LexicalEditorTheme__tableSelection',\n  text: {\n    bold: 'LexicalEditorTheme__textBold',\n    code: 'LexicalEditorTheme__textCode',\n    italic: 'LexicalEditorTheme__textItalic',\n    strikethrough: 'LexicalEditorTheme__textStrikethrough',\n    subscript: 'LexicalEditorTheme__textSubscript',\n    superscript: 'LexicalEditorTheme__textSuperscript',\n    underline: 'LexicalEditorTheme__textUnderline',\n    underlineStrikethrough: 'LexicalEditorTheme__textUnderlineStrikethrough',\n  },\n  upload: 'LexicalEditorTheme__upload',\n}\n"],"names":["LexicalEditorTheme","block","blockCursor","characterLimit","code","inlineBlock","heading","h1","h2","h3","h4","h5","h6","hr","hrSelected","indent","link","list","checklist","listitem","listitemChecked","listitemUnchecked","nested","olDepth","ul","ltr","mark","markOverlap","paragraph","placeholder","quote","relationship","rtl","tab","table","tableAddColumns","tableAddRows","tableAlignment","center","right","tableCell","tableCellActionButton","tableCellActionButtonContainer","tableCellHeader","tableCellResizer","tableCellSelected","tableFrozenColumn","tableRowStriping","tableScrollableWrapper","tableSelected","tableSelection","text","bold","italic","strikethrough","subscript","superscript","underline","underlineStrikethrough","upload"],"mappings":";;;;AAEO,MAAMA,kBAAA,GAAyC;IACpDC,KAAA,EAAO;IACPC,WAAA,EAAa;IACbC,cAAA,EAAgB;IAChBC,IAAA,EAAM;IACNC,WAAA,EAAa;IAEbC,OAAA,EAAS;QACPC,EAAA,EAAI;QACJC,EAAA,EAAI;QACJC,EAAA,EAAI;QACJC,EAAA,EAAI;QACJC,EAAA,EAAI;QACJC,EAAA,EAAI;IACN;IACAC,EAAA,EAAI;IACJC,UAAA,EAAY;IACZC,MAAA,EAAQ;IACRC,IAAA,EAAM;IACNC,IAAA,EAAM;QACJC,SAAA,EAAW;QACXC,QAAA,EAAU;QACVC,eAAA,EAAiB;QACjBC,iBAAA,EAAmB;QACnBC,MAAA,EAAQ;YACNH,QAAA,EAAU;QACZ;QACAI,OAAA,EAAS;YACP;YACA;YACA;YACA;YACA;SACD;QACDC,EAAA,EAAI;IACN;IACAC,GAAA,EAAK;IACLC,IAAA,EAAM;IACNC,WAAA,EAAa;IACbC,SAAA,EAAW;IACXC,WAAA,EAAa;IACbC,KAAA,EAAO;IACPC,YAAA,EAAc;IACdC,GAAA,EAAK;IACLC,GAAA,EAAK;IACLC,KAAA,EAAO;IACPC,eAAA,EAAiB;IACjBC,YAAA,EAAc;IACdC,cAAA,EAAgB;QACdC,MAAA,EAAQ;QACRC,KAAA,EAAO;IACT;IACAC,SAAA,EAAW;IACXC,qBAAA,EAAuB;IACvBC,8BAAA,EAAgC;IAChCC,eAAA,EAAiB;IACjBC,gBAAA,EAAkB;IAClBC,iBAAA,EAAmB;IACnBC,iBAAA,EAAmB;IACnBC,gBAAA,EAAkB;IAClBC,sBAAA,EAAwB;IACxBC,aAAA,EAAe;IACfC,cAAA,EAAgB;IAChBC,IAAA,EAAM;QACJC,IAAA,EAAM;QACNhD,IAAA,EAAM;QACNiD,MAAA,EAAQ;QACRC,aAAA,EAAe;QACfC,SAAA,EAAW;QACXC,WAAA,EAAa;QACbC,SAAA,EAAW;QACXC,sBAAA,EAAwB;IAC1B;IACAC,MAAA,EAAQ;AACV","ignoreList":[]}},
    {"offset": {"line": 5058, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/lexical/config/server/default.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/config/server/default.ts"],"sourcesContent":["import type { EditorConfig as LexicalEditorConfig } from 'lexical'\n\nimport type { FeatureProviderServer } from '../../../features/typesServer.js'\nimport type { ServerEditorConfig } from '../types.js'\n\nimport { AlignFeature } from '../../../features/align/server/index.js'\nimport { BlockquoteFeature } from '../../../features/blockquote/server/index.js'\nimport { BoldFeature } from '../../../features/format/bold/feature.server.js'\nimport { InlineCodeFeature } from '../../../features/format/inlineCode/feature.server.js'\nimport { ItalicFeature } from '../../../features/format/italic/feature.server.js'\nimport { StrikethroughFeature } from '../../../features/format/strikethrough/feature.server.js'\nimport { SubscriptFeature } from '../../../features/format/subscript/feature.server.js'\nimport { SuperscriptFeature } from '../../../features/format/superscript/feature.server.js'\nimport { UnderlineFeature } from '../../../features/format/underline/feature.server.js'\nimport { HeadingFeature } from '../../../features/heading/server/index.js'\nimport { HorizontalRuleFeature } from '../../../features/horizontalRule/server/index.js'\nimport { IndentFeature } from '../../../features/indent/server/index.js'\nimport { LinkFeature } from '../../../features/link/server/index.js'\nimport { ChecklistFeature } from '../../../features/lists/checklist/server/index.js'\nimport { OrderedListFeature } from '../../../features/lists/orderedList/server/index.js'\nimport { UnorderedListFeature } from '../../../features/lists/unorderedList/server/index.js'\nimport { ParagraphFeature } from '../../../features/paragraph/server/index.js'\nimport { RelationshipFeature } from '../../../features/relationship/server/index.js'\nimport { InlineToolbarFeature } from '../../../features/toolbars/inline/server/index.js'\nimport { UploadFeature } from '../../../features/upload/server/index.js'\nimport { LexicalEditorTheme } from '../../theme/EditorTheme.js'\n\nexport const defaultEditorLexicalConfig: LexicalEditorConfig = {\n  namespace: 'lexical',\n  theme: LexicalEditorTheme,\n}\n\nexport const defaultEditorFeatures: FeatureProviderServer<any, any, any>[] = [\n  BoldFeature(),\n  ItalicFeature(),\n  UnderlineFeature(),\n  StrikethroughFeature(),\n  SubscriptFeature(),\n  SuperscriptFeature(),\n  InlineCodeFeature(),\n  ParagraphFeature(),\n  HeadingFeature(),\n  AlignFeature(),\n  IndentFeature(),\n  UnorderedListFeature(),\n  OrderedListFeature(),\n  ChecklistFeature(),\n  LinkFeature(),\n  RelationshipFeature(),\n  BlockquoteFeature(),\n  UploadFeature(),\n  HorizontalRuleFeature(),\n  InlineToolbarFeature(),\n]\n\nexport const defaultEditorConfig: ServerEditorConfig = {\n  features: defaultEditorFeatures,\n  lexical: defaultEditorLexicalConfig,\n}\n"],"names":["AlignFeature","BlockquoteFeature","BoldFeature","InlineCodeFeature","ItalicFeature","StrikethroughFeature","SubscriptFeature","SuperscriptFeature","UnderlineFeature","HeadingFeature","HorizontalRuleFeature","IndentFeature","LinkFeature","ChecklistFeature","OrderedListFeature","UnorderedListFeature","ParagraphFeature","RelationshipFeature","InlineToolbarFeature","UploadFeature","LexicalEditorTheme","defaultEditorLexicalConfig","namespace","theme","defaultEditorFeatures","defaultEditorConfig","features","lexical"],"mappings":";;;;;;;;AAKA,SAASA,YAAY,QAAQ;AAC7B,SAASC,iBAAiB,QAAQ;AAClC,SAASC,WAAW,QAAQ;AAC5B,SAASC,iBAAiB,QAAQ;AAClC,SAASC,aAAa,QAAQ;AAC9B,SAASC,oBAAoB,QAAQ;AACrC,SAASC,gBAAgB,QAAQ;AACjC,SAASC,kBAAkB,QAAQ;AACnC,SAASC,gBAAgB,QAAQ;AACjC,SAASC,cAAc,QAAQ;AAC/B,SAASC,qBAAqB,QAAQ;AACtC,SAASC,aAAa,QAAQ;AAC9B,SAASC,WAAW,QAAQ;AAC5B,SAASC,gBAAgB,QAAQ;AACjC,SAASC,kBAAkB,QAAQ;AACnC,SAASC,oBAAoB,QAAQ;AACrC,SAASC,gBAAgB,QAAQ;AACjC,SAASC,mBAAmB,QAAQ;AACpC,SAASC,oBAAoB,QAAQ;AACrC,SAASC,aAAa,QAAQ;AAC9B,SAASC,kBAAkB,QAAQ;;;;;;;;;;;;;;;;;;;;;;AAE5B,MAAMC,0BAAA,GAAkD;IAC7DC,SAAA,EAAW;IACXC,KAAA,EAAOH,8ZAAAA;AACT;AAEO,MAAMI,qBAAA,GAAgE;QAC3EtB,uaAAA;QACAE,2aAAA;QACAI,ibAAA;QACAH,ybAAA;QACAC,ibAAA;QACAC,qbAAA;QACAJ,mbAAA;QACAa,qaAAA;QACAP,iaAAA;QACAT,6ZAAA;QACAW,+ZAAA;QACAI,sbAAA;QACAD,kbAAA;QACAD,8aAAA;QACAD,2ZAAA;QACAK,2aAAA;QACAhB,uaAAA;QACAkB,+ZAAA;QACAT,+aAAA;QACAQ,kbAAA;CACD;AAEM,MAAMO,mBAAA,GAA0C;IACrDC,QAAA,EAAUF,qBAAA;IACVG,OAAA,EAASN;AACX","ignoreList":[]}},
    {"offset": {"line": 5142, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/utilities/forEachNodeRecursively.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/utilities/forEachNodeRecursively.ts"],"sourcesContent":["import type { SerializedLexicalNode } from 'lexical'\n\nexport function recurseNodes({\n  callback,\n  nodes,\n}: {\n  callback: (node: SerializedLexicalNode) => void\n  nodes: SerializedLexicalNode[]\n}) {\n  for (const node of nodes) {\n    callback(node)\n\n    if ('children' in node && Array.isArray(node?.children) && node?.children?.length) {\n      recurseNodes({ callback, nodes: node.children as SerializedLexicalNode[] })\n    }\n  }\n}\n\nexport async function recurseNodesAsync({\n  callback,\n  nodes,\n}: {\n  callback: (node: SerializedLexicalNode) => Promise<void>\n  nodes: SerializedLexicalNode[]\n}) {\n  for (const node of nodes) {\n    await callback(node)\n\n    if ('children' in node && Array.isArray(node?.children) && node?.children?.length) {\n      await recurseNodesAsync({ callback, nodes: node.children as SerializedLexicalNode[] })\n    }\n  }\n}\n"],"names":["recurseNodes","callback","nodes","node","Array","isArray","children","length","recurseNodesAsync"],"mappings":";;;;;;AAEO,SAASA,aAAa,EAC3BC,QAAQ,EACRC,KAAAA,EAID;IACC,KAAK,MAAMC,IAAA,IAAQD,KAAA,CAAO;QACxBD,QAAA,CAASE,IAAA;QAET,IAAI,cAAcA,IAAA,IAAQC,KAAA,CAAMC,OAAO,CAACF,IAAA,EAAMG,QAAA,KAAaH,IAAA,EAAMG,QAAA,EAAUC,MAAA,EAAQ;YACjFP,YAAA,CAAa;gBAAEC,QAAA;gBAAUC,KAAA,EAAOC,IAAA,CAAKG,QAAAA;YAAoC;QAC3E;IACF;AACF;AAEO,eAAeE,kBAAkB,EACtCP,QAAQ,EACRC,KAAAA,EAID;IACC,KAAK,MAAMC,IAAA,IAAQD,KAAA,CAAO;QACxB,MAAMD,QAAA,CAASE,IAAA;QAEf,IAAI,cAAcA,IAAA,IAAQC,KAAA,CAAMC,OAAO,CAACF,IAAA,EAAMG,QAAA,KAAaH,IAAA,EAAMG,QAAA,EAAUC,MAAA,EAAQ;YACjF,MAAMC,iBAAA,CAAkB;gBAAEP,QAAA;gBAAUC,KAAA,EAAOC,IAAA,CAAKG,QAAAA;YAAoC;QACtF;IACF;AACF","ignoreList":[]}},
    {"offset": {"line": 5174, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/populateGraphQL/populateLexicalPopulationPromises.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/populateGraphQL/populateLexicalPopulationPromises.ts"],"sourcesContent":["import type { SerializedEditorState } from 'lexical'\nimport type { RichTextAdapter } from 'payload'\n\nimport type { PopulationPromise } from '../features/typesServer.js'\nimport type { AdapterProps } from '../types.js'\n\nimport { recurseNodes } from '../utilities/forEachNodeRecursively.js'\n\nexport type Args = {\n  editorPopulationPromises: Map<string, Array<PopulationPromise>>\n  parentIsLocalized: boolean\n} & Parameters<\n  NonNullable<RichTextAdapter<SerializedEditorState, AdapterProps>['graphQLPopulationPromises']>\n>[0]\n\n/**\n * Appends all new populationPromises to the populationPromises prop\n */\nexport const populateLexicalPopulationPromises = ({\n  context,\n  currentDepth,\n  depth,\n  draft,\n  editorPopulationPromises,\n  field,\n  fieldPromises,\n  findMany,\n  flattenLocales,\n  overrideAccess,\n  parentIsLocalized,\n  populationPromises,\n  req,\n  showHiddenFields,\n  siblingDoc,\n}: Args) => {\n  const shouldPopulate = depth && currentDepth! <= depth\n\n  if (!shouldPopulate) {\n    return\n  }\n\n  recurseNodes({\n    callback: (node) => {\n      const editorPopulationPromisesOfNodeType = editorPopulationPromises?.get(node.type)\n      if (editorPopulationPromisesOfNodeType) {\n        for (const promise of editorPopulationPromisesOfNodeType) {\n          promise({\n            context,\n            currentDepth: currentDepth!,\n            depth,\n            draft,\n            editorPopulationPromises,\n            field,\n            fieldPromises,\n            findMany,\n            flattenLocales,\n            node,\n            overrideAccess: overrideAccess!,\n            parentIsLocalized,\n            populationPromises,\n            req,\n            showHiddenFields,\n            siblingDoc,\n          })\n        }\n      }\n    },\n\n    nodes: (siblingDoc[field?.name] as SerializedEditorState)?.root?.children ?? [],\n  })\n}\n"],"names":["recurseNodes","populateLexicalPopulationPromises","context","currentDepth","depth","draft","editorPopulationPromises","field","fieldPromises","findMany","flattenLocales","overrideAccess","parentIsLocalized","populationPromises","req","showHiddenFields","siblingDoc","shouldPopulate","callback","node","editorPopulationPromisesOfNodeType","get","type","promise","nodes","name","root","children"],"mappings":";;;;AAMA,SAASA,YAAY,QAAQ;;AAYtB,MAAMC,iCAAA,GAAoCA,CAAC,EAChDC,OAAO,EACPC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,wBAAwB,EACxBC,KAAK,EACLC,aAAa,EACbC,QAAQ,EACRC,cAAc,EACdC,cAAc,EACdC,iBAAiB,EACjBC,kBAAkB,EAClBC,GAAG,EACHC,gBAAgB,EAChBC,UAAAA,EACK;IACL,MAAMC,cAAA,GAAiBb,KAAA,IAASD,YAAA,IAAiBC,KAAA;IAEjD,IAAI,CAACa,cAAA,EAAgB;QACnB;IACF;QAEAjB,4ZAAA,EAAa;QACXkB,QAAA,GAAWC,IAAA;YACT,MAAMC,kCAAA,GAAqCd,wBAAA,EAA0Be,GAAA,CAAIF,IAAA,CAAKG,IAAI;YAClF,IAAIF,kCAAA,EAAoC;gBACtC,KAAK,MAAMG,OAAA,IAAWH,kCAAA,CAAoC;oBACxDG,OAAA,CAAQ;wBACNrB,OAAA;wBACAC,YAAA,EAAcA,YAAA;wBACdC,KAAA;wBACAC,KAAA;wBACAC,wBAAA;wBACAC,KAAA;wBACAC,aAAA;wBACAC,QAAA;wBACAC,cAAA;wBACAS,IAAA;wBACAR,cAAA,EAAgBA,cAAA;wBAChBC,iBAAA;wBACAC,kBAAA;wBACAC,GAAA;wBACAC,gBAAA;wBACAC;oBACF;gBACF;YACF;QACF;QAEAQ,KAAA,EAAOR,UAAW,CAACT,KAAA,EAAOkB,IAAA,CAAK,EAA4BC,IAAA,EAAMC,QAAA,IAAY,EAAA;IAC/E;AACF","ignoreList":[]}},
    {"offset": {"line": 5218, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/lexical/config/server/loader.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/config/server/loader.ts"],"sourcesContent":["import type { SanitizedConfig } from 'payload'\n\nimport type {\n  FeatureProviderServer,\n  ResolvedServerFeature,\n  ResolvedServerFeatureMap,\n  ServerFeatureProviderMap,\n} from '../../../features/typesServer.js'\nimport type { ServerEditorConfig } from '../types.js'\n\ntype DependencyGraph = {\n  [key: string]: {\n    dependencies: string[]\n    dependenciesPriority: string[]\n    dependenciesSoft: string[]\n    featureProvider: FeatureProviderServer<unknown, unknown, unknown>\n  }\n}\n\nfunction createDependencyGraph(\n  featureProviders: FeatureProviderServer<unknown, unknown, unknown>[],\n): DependencyGraph {\n  const graph: DependencyGraph = {}\n  for (const fp of featureProviders) {\n    graph[fp.key] = {\n      dependencies: fp.dependencies || [],\n      dependenciesPriority: fp.dependenciesPriority || [],\n      dependenciesSoft: fp.dependenciesSoft || [],\n      featureProvider: fp,\n    }\n  }\n  return graph\n}\n\nfunction topologicallySortFeatures(\n  featureProviders: FeatureProviderServer<unknown, unknown, unknown>[],\n): FeatureProviderServer<unknown, unknown, unknown>[] {\n  const graph = createDependencyGraph(featureProviders)\n  const visited: { [key: string]: boolean } = {}\n  const stack: FeatureProviderServer<unknown, unknown, unknown>[] = []\n\n  for (const key in graph) {\n    if (!visited[key]) {\n      visit(graph, key, visited, stack)\n    }\n  }\n\n  return stack.reverse()\n}\n\nfunction visit(\n  graph: DependencyGraph,\n  key: string,\n  visited: { [key: string]: boolean },\n  stack: FeatureProviderServer<unknown, unknown, unknown>[],\n  currentPath: string[] = [],\n) {\n  if (!graph[key]) {\n    throw new Error(`Feature key ${key} is not present in the dependency graph.`)\n  }\n\n  if (currentPath.includes(key)) {\n    throw new Error(`Circular dependency detected: ${currentPath.join(' -> ')} -> ${key}`)\n  }\n\n  if (visited[key]) {\n    return\n  }\n\n  visited[key] = true\n  currentPath.push(key)\n\n  // First process the hard priority dependencies\n  for (const dep of graph[key].dependenciesPriority) {\n    if (!visited[dep]) {\n      visit(graph, dep, visited, stack, currentPath)\n    }\n  }\n\n  // Then process the normal dependencies, but make sure to not violate hard dependencies\n  for (const dep of graph[key].dependencies) {\n    if (!visited[dep] && !graph[key].dependenciesPriority.includes(dep)) {\n      visit(graph, dep, visited, stack, currentPath)\n    }\n  }\n\n  // Then process the soft dependencies. Make sure to not violate hard and normal dependencies.\n  for (const dep of graph[key].dependenciesSoft) {\n    if (\n      graph[dep] &&\n      !visited[dep] &&\n      !graph[key].dependenciesPriority.includes(dep) &&\n      !graph[key].dependencies.includes(dep)\n    ) {\n      visit(graph, dep, visited, stack, currentPath)\n    }\n  }\n\n  stack.push(graph[key].featureProvider)\n  currentPath.pop()\n}\n\nexport function sortFeaturesForOptimalLoading(\n  featureProviders: FeatureProviderServer<unknown, unknown, unknown>[],\n): FeatureProviderServer<unknown, unknown, unknown>[] {\n  return topologicallySortFeatures(featureProviders)\n}\n\nexport async function loadFeatures({\n  config,\n  isRoot,\n  parentIsLocalized,\n  unSanitizedEditorConfig,\n}: {\n  config: SanitizedConfig\n  isRoot?: boolean\n  parentIsLocalized: boolean\n  unSanitizedEditorConfig: ServerEditorConfig\n}): Promise<ResolvedServerFeatureMap> {\n  // First remove all duplicate features. The LAST feature with a given key wins.\n  unSanitizedEditorConfig.features = unSanitizedEditorConfig.features\n    .reverse()\n    .filter((f, i, arr) => {\n      const firstIndex = arr.findIndex((f2) => f2.key === f.key)\n      return firstIndex === i\n    })\n    .reverse()\n\n  unSanitizedEditorConfig.features = sortFeaturesForOptimalLoading(unSanitizedEditorConfig.features)\n\n  const featureProviderMap: ServerFeatureProviderMap = new Map(\n    unSanitizedEditorConfig.features.map(\n      (f) => [f.key, f] as [string, FeatureProviderServer<unknown, unknown, unknown>],\n    ),\n  )\n\n  const resolvedFeatures: ResolvedServerFeatureMap = new Map()\n\n  // Make sure all dependencies declared in the respective features exist\n  let loaded = 0\n  for (const featureProvider of unSanitizedEditorConfig.features) {\n    if (!featureProvider.key) {\n      throw new Error(\n        `A Feature you've added does not have a key. Please add a key to the feature. This is used to uniquely identify the feature.`,\n      )\n    }\n    if (featureProvider.dependencies?.length) {\n      for (const dependencyKey of featureProvider.dependencies) {\n        const found = unSanitizedEditorConfig.features.find((f) => f.key === dependencyKey)\n        if (!found) {\n          throw new Error(\n            `Feature ${featureProvider.key} has a dependency ${dependencyKey} which does not exist.`,\n          )\n        }\n      }\n    }\n\n    if (featureProvider.dependenciesPriority?.length) {\n      for (const priorityDependencyKey of featureProvider.dependenciesPriority) {\n        // look in the resolved features instead of the editorConfig.features, as a dependency requires the feature to be loaded before it, contrary to a soft-dependency\n        const found = resolvedFeatures.get(priorityDependencyKey)\n        if (!found) {\n          const existsInEditorConfig = unSanitizedEditorConfig.features.find(\n            (f) => f.key === priorityDependencyKey,\n          )\n          if (!existsInEditorConfig) {\n            throw new Error(\n              `Feature ${featureProvider.key} has a priority dependency ${priorityDependencyKey} which does not exist.`,\n            )\n          } else {\n            throw new Error(\n              `Feature ${featureProvider.key} has a priority dependency ${priorityDependencyKey} which is not loaded before it.`,\n            )\n          }\n        }\n      }\n    }\n\n    const feature =\n      typeof featureProvider.feature === 'function'\n        ? await featureProvider.feature({\n            config,\n            featureProviderMap,\n            isRoot,\n            parentIsLocalized,\n            resolvedFeatures,\n            unSanitizedEditorConfig,\n          })\n        : featureProvider.feature\n\n    const resolvedFeature: ResolvedServerFeature<any, any> = feature as ResolvedServerFeature<\n      any,\n      any\n    >\n\n    // All these new properties would be added to the feature, as it's mutated. However, this does not cause any damage and allows\n    // us to prevent an unnecessary spread operation.\n    resolvedFeature.key = featureProvider.key\n    resolvedFeature.order = loaded\n    resolvedFeature.dependencies = featureProvider.dependencies!\n    resolvedFeature.dependenciesPriority = featureProvider.dependenciesPriority!\n    resolvedFeature.dependenciesSoft = featureProvider.dependenciesSoft!\n\n    resolvedFeatures.set(featureProvider.key, resolvedFeature)\n\n    loaded++\n  }\n\n  return resolvedFeatures\n}\n"],"names":["createDependencyGraph","featureProviders","graph","fp","key","dependencies","dependenciesPriority","dependenciesSoft","featureProvider","topologicallySortFeatures","visited","stack","visit","reverse","currentPath","Error","includes","join","push","dep","pop","sortFeaturesForOptimalLoading","loadFeatures","config","isRoot","parentIsLocalized","unSanitizedEditorConfig","features","filter","f","i","arr","firstIndex","findIndex","f2","featureProviderMap","Map","map","resolvedFeatures","loaded","length","dependencyKey","found","find","priorityDependencyKey","get","existsInEditorConfig","feature","resolvedFeature","order","set"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 5348, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/lexical/config/server/sanitize.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/config/server/sanitize.ts"],"sourcesContent":["import type { SanitizedConfig } from 'payload'\n\nimport type {\n  ResolvedServerFeatureMap,\n  SanitizedServerFeatures,\n} from '../../../features/typesServer.js'\nimport type { SanitizedServerEditorConfig, ServerEditorConfig } from '../types.js'\n\nimport { loadFeatures } from './loader.js'\n\nexport const sanitizeServerFeatures = (\n  features: ResolvedServerFeatureMap,\n): SanitizedServerFeatures => {\n  const sanitized: SanitizedServerFeatures = {\n    converters: {\n      html: [],\n    },\n    enabledFeatures: [],\n    generatedTypes: {\n      modifyOutputSchemas: [],\n    },\n    getSubFields: new Map(),\n    getSubFieldsData: new Map(),\n    graphQLPopulationPromises: new Map(),\n    hooks: {\n      afterChange: [],\n      afterRead: [],\n      beforeChange: [],\n      beforeValidate: [],\n    },\n    i18n: {},\n    markdownTransformers: [],\n    nodeHooks: {\n      afterChange: new Map(),\n      afterRead: new Map(),\n      beforeChange: new Map(),\n      beforeValidate: new Map(),\n    },\n    nodes: [],\n\n    validations: new Map(),\n  }\n\n  if (!features?.size) {\n    return sanitized\n  }\n\n  features.forEach((feature) => {\n    if (feature?.generatedTypes?.modifyOutputSchema) {\n      sanitized.generatedTypes.modifyOutputSchemas.push(feature.generatedTypes.modifyOutputSchema)\n    }\n\n    if (feature?.hooks?.beforeValidate?.length) {\n      sanitized.hooks.beforeValidate = sanitized.hooks.beforeValidate?.concat(\n        feature.hooks.beforeValidate,\n      )\n    }\n    if (feature?.hooks?.beforeChange?.length) {\n      sanitized.hooks.beforeChange = sanitized.hooks.beforeChange?.concat(\n        feature.hooks.beforeChange,\n      )\n    }\n    if (feature?.hooks?.afterRead?.length) {\n      sanitized.hooks.afterRead = sanitized.hooks.afterRead?.concat(feature.hooks.afterRead)\n    }\n    if (feature?.hooks?.afterChange?.length) {\n      sanitized.hooks.afterChange = sanitized.hooks.afterChange?.concat(feature.hooks.afterChange)\n    }\n\n    if (feature?.i18n) {\n      for (const lang in feature.i18n) {\n        if (!sanitized.i18n[lang as keyof typeof sanitized.i18n]) {\n          sanitized.i18n[lang as keyof typeof sanitized.i18n] = {\n            lexical: {},\n          }\n        }\n        // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n        sanitized.i18n[lang].lexical[feature.key] = feature.i18n[lang]\n      }\n    }\n\n    if (feature.nodes?.length) {\n      // Do not concat here. We need to keep the object reference of sanitized.nodes so that function markdown transformers of features automatically get the updated nodes\n      for (const node of feature.nodes) {\n        sanitized.nodes.push(node)\n      }\n      feature.nodes.forEach((node) => {\n        const nodeType = 'with' in node.node ? node.node.replace.getType() : node.node.getType() // TODO: Idk if this works for node replacements\n        if (node?.graphQLPopulationPromises?.length) {\n          sanitized.graphQLPopulationPromises.set(nodeType, node.graphQLPopulationPromises)\n        }\n        if (node?.validations?.length) {\n          sanitized.validations.set(nodeType, node.validations)\n        }\n        if (node?.converters?.html) {\n          sanitized.converters.html.push(node.converters.html)\n        }\n        if (node?.hooks?.afterChange) {\n          sanitized.nodeHooks?.afterChange?.set(nodeType, node.hooks.afterChange)\n        }\n        if (node?.hooks?.afterRead) {\n          sanitized.nodeHooks?.afterRead?.set(nodeType, node.hooks.afterRead)\n        }\n        if (node?.hooks?.beforeChange) {\n          sanitized.nodeHooks?.beforeChange?.set(nodeType, node.hooks.beforeChange)\n        }\n        if (node?.hooks?.beforeValidate) {\n          sanitized.nodeHooks?.beforeValidate?.set(nodeType, node.hooks.beforeValidate)\n        }\n        if (node?.getSubFields) {\n          sanitized.getSubFields?.set(nodeType, node.getSubFields)\n        }\n        if (node?.getSubFieldsData) {\n          sanitized.getSubFieldsData?.set(nodeType, node.getSubFieldsData)\n        }\n      })\n    }\n\n    if (feature.markdownTransformers?.length) {\n      // Do not concat here. We need to keep the object reference of feature.markdownTransformers\n\n      for (const transformer of feature.markdownTransformers) {\n        if (typeof transformer === 'function') {\n          sanitized.markdownTransformers.push(\n            transformer({\n              allNodes: sanitized.nodes,\n              allTransformers: sanitized.markdownTransformers,\n            }),\n          )\n        } else {\n          sanitized.markdownTransformers.push(transformer)\n        }\n      }\n    }\n\n    sanitized.enabledFeatures.push(feature.key)\n  })\n\n  return sanitized\n}\n\nexport async function sanitizeServerEditorConfig(\n  editorConfig: ServerEditorConfig,\n  config: SanitizedConfig,\n  parentIsLocalized?: boolean,\n): Promise<SanitizedServerEditorConfig> {\n  const resolvedFeatureMap = await loadFeatures({\n    config,\n    parentIsLocalized: parentIsLocalized!,\n    unSanitizedEditorConfig: editorConfig,\n  })\n\n  return {\n    features: sanitizeServerFeatures(resolvedFeatureMap),\n    lexical: editorConfig.lexical!,\n    resolvedFeatureMap,\n  }\n}\n"],"names":["loadFeatures","sanitizeServerFeatures","features","sanitized","converters","html","enabledFeatures","generatedTypes","modifyOutputSchemas","getSubFields","Map","getSubFieldsData","graphQLPopulationPromises","hooks","afterChange","afterRead","beforeChange","beforeValidate","i18n","markdownTransformers","nodeHooks","nodes","validations","size","forEach","feature","modifyOutputSchema","push","length","concat","lang","lexical","key","node","nodeType","replace","getType","set","transformer","allNodes","allTransformers","sanitizeServerEditorConfig","editorConfig","config","parentIsLocalized","resolvedFeatureMap","unSanitizedEditorConfig"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 5485, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/utilities/getDefaultSanitizedEditorConfig.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/utilities/getDefaultSanitizedEditorConfig.ts"],"sourcesContent":["import type { SanitizedConfig } from 'payload'\n\nimport { type SanitizedServerEditorConfig } from '../index.js'\nimport { defaultEditorConfig } from '../lexical/config/server/default.js'\nimport { sanitizeServerEditorConfig } from '../lexical/config/server/sanitize.js'\n\nlet cachedDefaultSanitizedServerEditorConfig:\n  | null\n  | Promise<SanitizedServerEditorConfig>\n  | SanitizedServerEditorConfig = (global as any)\n  ._payload_lexical_defaultSanitizedServerEditorConfig\n\nif (!cachedDefaultSanitizedServerEditorConfig) {\n  cachedDefaultSanitizedServerEditorConfig = (\n    global as any\n  )._payload_lexical_defaultSanitizedServerEditorConfig = null\n}\n\nexport const getDefaultSanitizedEditorConfig = async (args: {\n  config: SanitizedConfig\n  parentIsLocalized: boolean\n}): Promise<SanitizedServerEditorConfig> => {\n  const { config, parentIsLocalized } = args\n\n  if (cachedDefaultSanitizedServerEditorConfig) {\n    return await cachedDefaultSanitizedServerEditorConfig\n  }\n\n  cachedDefaultSanitizedServerEditorConfig = sanitizeServerEditorConfig(\n    defaultEditorConfig,\n    config,\n    parentIsLocalized,\n  )\n  ;(global as any).payload_lexical_defaultSanitizedServerEditorConfig =\n    cachedDefaultSanitizedServerEditorConfig\n\n  cachedDefaultSanitizedServerEditorConfig = await cachedDefaultSanitizedServerEditorConfig\n  ;(global as any).payload_lexical_defaultSanitizedServerEditorConfig =\n    cachedDefaultSanitizedServerEditorConfig\n\n  return cachedDefaultSanitizedServerEditorConfig\n}\n"],"names":["defaultEditorConfig","sanitizeServerEditorConfig","cachedDefaultSanitizedServerEditorConfig","global","_payload_lexical_defaultSanitizedServerEditorConfig","getDefaultSanitizedEditorConfig","args","config","parentIsLocalized","payload_lexical_defaultSanitizedServerEditorConfig"],"mappings":";;;;AAGA,SAASA,mBAAmB,QAAQ;AACpC,SAASC,0BAA0B,QAAQ;;;AAE3C,IAAIC,wCAAA,GAG8BC,MAAC,mDAChCC,mDAAmD;AAEtD,IAAI,CAACF,wCAAA,EAA0C;IAC7CA,wCAAA,GAA2CC,MACzC,mDACAC,mDAAmD,GAAG;AAC1D;AAEO,MAAMC,+BAAA,GAAkC,OAAOC,IAAA;IAIpD,MAAM,EAAEC,MAAM,EAAEC,iBAAAA,EAAmB,GAAGF,IAAA;IAEtC,IAAIJ,wCAAA,EAA0C;QAC5C,OAAO,MAAMA,wCAAA;IACf;IAEAA,wCAAA,OAA2CD,8aAAA,EACzCD,saAAA,EACAO,MAAA,EACAC,iBAAA;IAEAL,MAAA,mDAAeM,kDAAkD,GACjEP,wCAAA;IAEFA,wCAAA,GAA2C,MAAMA,wCAAA;IAC/CC,MAAA,mDAAeM,kDAAkD,GACjEP,wCAAA;IAEF,OAAOA,wCAAA;AACT","ignoreList":[]}},
    {"offset": {"line": 5512, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/utilities/editorConfigFactory.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/utilities/editorConfigFactory.ts"],"sourcesContent":["import type { EditorConfig as LexicalEditorConfig } from 'lexical'\nimport type { RichTextAdapterProvider, RichTextField, SanitizedConfig } from 'payload'\n\nimport type { FeatureProviderServer, ResolvedServerFeatureMap } from '../features/typesServer.js'\nimport type { SanitizedServerEditorConfig } from '../lexical/config/types.js'\nimport type {\n  FeaturesInput,\n  LexicalRichTextAdapter,\n  LexicalRichTextAdapterProvider,\n} from '../types.js'\n\nimport { defaultEditorConfig, defaultEditorFeatures } from '../lexical/config/server/default.js'\nimport { loadFeatures } from '../lexical/config/server/loader.js'\nimport { sanitizeServerFeatures } from '../lexical/config/server/sanitize.js'\nimport { getDefaultSanitizedEditorConfig } from './getDefaultSanitizedEditorConfig.js'\n\nexport const editorConfigFactory = {\n  default: async (args: {\n    config: SanitizedConfig\n    parentIsLocalized?: boolean\n  }): Promise<SanitizedServerEditorConfig> => {\n    return getDefaultSanitizedEditorConfig({\n      config: args.config,\n      parentIsLocalized: args.parentIsLocalized ?? false,\n    })\n  },\n  /**\n   * If you have instantiated a lexical editor and are accessing it outside a field (=> this is the unsanitized editor),\n   * you can extract the editor config from it.\n   * This is common if you define the editor in a re-usable module scope variable and pass it to the richText field.\n   *\n   * This is the least efficient way to get the editor config, and not recommended. It is recommended to extract the `features` arg\n   * into a separate variable and use `fromFeatures` instead.\n   */\n  fromEditor: async (args: {\n    config: SanitizedConfig\n    editor: LexicalRichTextAdapterProvider\n    isRoot?: boolean\n    lexical?: LexicalEditorConfig\n    parentIsLocalized?: boolean\n  }): Promise<SanitizedServerEditorConfig> => {\n    const lexicalAdapter: LexicalRichTextAdapter = await args.editor({\n      config: args.config,\n      isRoot: args.isRoot ?? false,\n      parentIsLocalized: args.parentIsLocalized ?? false,\n    })\n\n    const sanitizedServerEditorConfig: SanitizedServerEditorConfig = lexicalAdapter.editorConfig\n    return sanitizedServerEditorConfig\n  },\n  /**\n   * Create a new editor config - behaves just like instantiating a new `lexicalEditor`\n   */\n  fromFeatures: async (args: {\n    config: SanitizedConfig\n    features?: FeaturesInput\n    isRoot?: boolean\n    lexical?: LexicalEditorConfig\n    parentIsLocalized?: boolean\n  }): Promise<SanitizedServerEditorConfig> => {\n    return (await featuresInputToEditorConfig(args)).sanitizedConfig\n  },\n  fromField: (args: { field: RichTextField }): SanitizedServerEditorConfig => {\n    const lexicalAdapter: LexicalRichTextAdapter = args.field.editor as LexicalRichTextAdapter\n\n    const sanitizedServerEditorConfig: SanitizedServerEditorConfig = lexicalAdapter.editorConfig\n    return sanitizedServerEditorConfig\n  },\n  fromUnsanitizedField: async (args: {\n    config: SanitizedConfig\n    field: RichTextField\n    isRoot?: boolean\n    parentIsLocalized?: boolean\n  }): Promise<SanitizedServerEditorConfig> => {\n    const lexicalAdapterProvider: RichTextAdapterProvider = args.field\n      .editor as RichTextAdapterProvider\n\n    const lexicalAdapter: LexicalRichTextAdapter = (await lexicalAdapterProvider({\n      config: args.config,\n      isRoot: args.isRoot ?? false,\n      parentIsLocalized: args.parentIsLocalized ?? false,\n    })) as LexicalRichTextAdapter\n\n    const sanitizedServerEditorConfig: SanitizedServerEditorConfig = lexicalAdapter.editorConfig\n    return sanitizedServerEditorConfig\n  },\n}\n\nexport const featuresInputToEditorConfig = async (args: {\n  config: SanitizedConfig\n  features?: FeaturesInput\n  isRoot?: boolean\n  lexical?: LexicalEditorConfig\n  parentIsLocalized?: boolean\n}): Promise<{\n  features: FeatureProviderServer<unknown, unknown, unknown>[]\n  resolvedFeatureMap: ResolvedServerFeatureMap\n  sanitizedConfig: SanitizedServerEditorConfig\n}> => {\n  let features: FeatureProviderServer<unknown, unknown, unknown>[] = []\n  if (args.features && typeof args.features === 'function') {\n    const rootEditor = args.config.editor\n    let rootEditorFeatures: FeatureProviderServer<unknown, unknown, unknown>[] = []\n    if (typeof rootEditor === 'object' && 'features' in rootEditor) {\n      rootEditorFeatures = (rootEditor as LexicalRichTextAdapter).features\n    }\n    features = args.features({\n      defaultFeatures: defaultEditorFeatures,\n      rootFeatures: rootEditorFeatures,\n    })\n  } else {\n    features = args.features as FeatureProviderServer<unknown, unknown, unknown>[]\n  }\n\n  if (!features) {\n    features = defaultEditorFeatures\n  }\n\n  const lexical = args.lexical ?? defaultEditorConfig.lexical\n\n  const resolvedFeatureMap = await loadFeatures({\n    config: args.config,\n    isRoot: args.isRoot ?? false,\n    parentIsLocalized: args.parentIsLocalized ?? false,\n    unSanitizedEditorConfig: {\n      features,\n      lexical,\n    },\n  })\n\n  return {\n    features,\n    resolvedFeatureMap,\n    sanitizedConfig: {\n      features: sanitizeServerFeatures(resolvedFeatureMap),\n      lexical: args.lexical,\n      resolvedFeatureMap,\n    },\n  }\n}\n"],"names":["defaultEditorConfig","defaultEditorFeatures","loadFeatures","sanitizeServerFeatures","getDefaultSanitizedEditorConfig","editorConfigFactory","default","args","config","parentIsLocalized","fromEditor","lexicalAdapter","editor","isRoot","sanitizedServerEditorConfig","editorConfig","fromFeatures","featuresInputToEditorConfig","sanitizedConfig","fromField","field","fromUnsanitizedField","lexicalAdapterProvider","features","rootEditor","rootEditorFeatures","defaultFeatures","rootFeatures","lexical","resolvedFeatureMap","unSanitizedEditorConfig"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 5612, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/utilities/generateImportMap.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/utilities/generateImportMap.tsx"],"sourcesContent":["import type { RichTextAdapter } from 'payload'\n\nimport { genImportMapIterateFields } from 'payload'\n\nimport type { ResolvedServerFeatureMap } from '../features/typesServer.js'\nimport type { LexicalEditorProps } from '../types.js'\n\nexport const getGenerateImportMap =\n  (args: {\n    lexicalEditorArgs?: LexicalEditorProps\n    resolvedFeatureMap: ResolvedServerFeatureMap\n  }): RichTextAdapter['generateImportMap'] =>\n  ({ addToImportMap, baseDir, config, importMap, imports }) => {\n    addToImportMap('@payloadcms/richtext-lexical/rsc#RscEntryLexicalCell')\n    addToImportMap('@payloadcms/richtext-lexical/rsc#RscEntryLexicalField')\n    addToImportMap('@payloadcms/richtext-lexical/rsc#LexicalDiffComponent')\n\n    for (const resolvedFeature of args.resolvedFeatureMap.values()) {\n      if ('componentImports' in resolvedFeature) {\n        if (typeof resolvedFeature.componentImports === 'function') {\n          resolvedFeature.componentImports({\n            addToImportMap,\n            baseDir,\n            config,\n            importMap,\n            imports,\n          })\n        } else if (Array.isArray(resolvedFeature.componentImports)) {\n          addToImportMap(resolvedFeature.componentImports)\n        } else if (typeof resolvedFeature.componentImports === 'object') {\n          addToImportMap(Object.values(resolvedFeature.componentImports))\n        }\n      }\n\n      addToImportMap(resolvedFeature.ClientFeature)\n\n      /*\n       * Now run for all possible sub-fields\n       */\n      if (resolvedFeature.nodes?.length) {\n        for (const node of resolvedFeature.nodes) {\n          if (typeof node?.getSubFields !== 'function') {\n            continue\n          }\n          const subFields = node.getSubFields({})\n          if (subFields?.length) {\n            genImportMapIterateFields({\n              addToImportMap,\n              baseDir,\n              config,\n              fields: subFields,\n              importMap,\n              imports,\n            })\n          }\n        }\n      }\n    }\n  }\n"],"names":["genImportMapIterateFields","getGenerateImportMap","args","addToImportMap","baseDir","config","importMap","imports","resolvedFeature","resolvedFeatureMap","values","componentImports","Array","isArray","Object","ClientFeature","nodes","length","node","getSubFields","subFields","fields"],"mappings":";;;;AAEA,SAASA,yBAAyB,QAAQ;;AAKnC,MAAMC,oBAAA,IACVC,IAAA,GAID,CAAC,EAAEC,cAAc,EAAEC,OAAO,EAAEC,MAAM,EAAEC,SAAS,EAAEC,OAAAA,EAAS;QACtDJ,cAAA,CAAe;QACfA,cAAA,CAAe;QACfA,cAAA,CAAe;QAEf,KAAK,MAAMK,eAAA,IAAmBN,IAAA,CAAKO,kBAAkB,CAACC,MAAM,GAAI;YAC9D,IAAI,sBAAsBF,eAAA,EAAiB;gBACzC,IAAI,OAAOA,eAAA,CAAgBG,gBAAgB,KAAK,YAAY;oBAC1DH,eAAA,CAAgBG,gBAAgB,CAAC;wBAC/BR,cAAA;wBACAC,OAAA;wBACAC,MAAA;wBACAC,SAAA;wBACAC;oBACF;gBACF,OAAO,IAAIK,KAAA,CAAMC,OAAO,CAACL,eAAA,CAAgBG,gBAAgB,GAAG;oBAC1DR,cAAA,CAAeK,eAAA,CAAgBG,gBAAgB;gBACjD,OAAO,IAAI,OAAOH,eAAA,CAAgBG,gBAAgB,KAAK,UAAU;oBAC/DR,cAAA,CAAeW,MAAA,CAAOJ,MAAM,CAACF,eAAA,CAAgBG,gBAAgB;gBAC/D;YACF;YAEAR,cAAA,CAAeK,eAAA,CAAgBO,aAAa;YAE5C;;OAGA,IAAIP,eAAA,CAAgBQ,KAAK,EAAEC,MAAA,EAAQ;gBACjC,KAAK,MAAMC,IAAA,IAAQV,eAAA,CAAgBQ,KAAK,CAAE;oBACxC,IAAI,OAAOE,IAAA,EAAMC,YAAA,KAAiB,YAAY;wBAC5C;oBACF;oBACA,MAAMC,SAAA,GAAYF,IAAA,CAAKC,YAAY,CAAC,CAAC;oBACrC,IAAIC,SAAA,EAAWH,MAAA,EAAQ;4BACrBjB,iTAAA,EAA0B;4BACxBG,cAAA;4BACAC,OAAA;4BACAC,MAAA;4BACAgB,MAAA,EAAQD,SAAA;4BACRd,SAAA;4BACAC;wBACF;oBACF;gBACF;YACF;QACF;IACF","ignoreList":[]}},
    {"offset": {"line": 5665, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/utilities/generateSchemaMap.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/utilities/generateSchemaMap.ts"],"sourcesContent":["import type { RichTextAdapter } from 'payload'\n\nimport { traverseFields } from '@payloadcms/ui/utilities/buildFieldSchemaMap/traverseFields'\n\nimport type { ResolvedServerFeatureMap } from '../features/typesServer.js'\n\nexport const getGenerateSchemaMap =\n  (args: { resolvedFeatureMap: ResolvedServerFeatureMap }): RichTextAdapter['generateSchemaMap'] =>\n  ({ config, field, i18n, schemaMap, schemaPath }) => {\n    for (const [featureKey, resolvedFeature] of args.resolvedFeatureMap.entries()) {\n      if (\n        !('generateSchemaMap' in resolvedFeature) ||\n        typeof resolvedFeature.generateSchemaMap !== 'function'\n      ) {\n        continue\n      }\n      const schemas = resolvedFeature.generateSchemaMap({\n        config,\n        field,\n        i18n,\n        props: resolvedFeature.sanitizedServerFeatureProps,\n        schemaMap,\n        schemaPath,\n      })\n\n      if (schemas) {\n        for (const [schemaKey, field] of schemas.entries()) {\n          if ('fields' in field) {\n            // generate schema map entries for sub-fields using traverseFields\n            traverseFields({\n              config,\n              fields: field.fields,\n              i18n,\n              parentIndexPath: '',\n              parentSchemaPath: `${schemaPath}.lexical_internal_feature.${featureKey}.${schemaKey}`,\n              schemaMap,\n            })\n          }\n\n          schemaMap.set(`${schemaPath}.lexical_internal_feature.${featureKey}.${schemaKey}`, field)\n        }\n      }\n    }\n\n    return schemaMap\n  }\n"],"names":["traverseFields","getGenerateSchemaMap","args","config","field","i18n","schemaMap","schemaPath","featureKey","resolvedFeature","resolvedFeatureMap","entries","generateSchemaMap","schemas","props","sanitizedServerFeatureProps","schemaKey","fields","parentIndexPath","parentSchemaPath","set"],"mappings":";;;;AAEA,SAASA,cAAc,QAAQ;;AAIxB,MAAMC,oBAAA,IACVC,IAAA,GACD,CAAC,EAAEC,MAAM,EAAEC,KAAK,EAAEC,IAAI,EAAEC,SAAS,EAAEC,UAAAA,EAAY;QAC7C,KAAK,MAAM,CAACC,UAAA,EAAYC,eAAA,CAAgB,IAAIP,IAAA,CAAKQ,kBAAkB,CAACC,OAAO,GAAI;YAC7E,IACE,CAAA,CAAE,uBAAuBF,eAAc,KACvC,OAAOA,eAAA,CAAgBG,iBAAiB,KAAK,YAC7C;gBACA;YACF;YACA,MAAMC,OAAA,GAAUJ,eAAA,CAAgBG,iBAAiB,CAAC;gBAChDT,MAAA;gBACAC,KAAA;gBACAC,IAAA;gBACAS,KAAA,EAAOL,eAAA,CAAgBM,2BAA2B;gBAClDT,SAAA;gBACAC;YACF;YAEA,IAAIM,OAAA,EAAS;gBACX,KAAK,MAAM,CAACG,SAAA,EAAWZ,KAAA,CAAM,IAAIS,OAAA,CAAQF,OAAO,GAAI;oBAClD,IAAI,YAAYP,KAAA,EAAO;wBACrB,kEAAA;4BACAJ,+ZAAA,EAAe;4BACbG,MAAA;4BACAc,MAAA,EAAQb,KAAA,CAAMa,MAAM;4BACpBZ,IAAA;4BACAa,eAAA,EAAiB;4BACjBC,gBAAA,EAAkB,GAAGZ,UAAA,CAAA,0BAAA,EAAuCC,UAAA,CAAA,CAAA,EAAcQ,SAAA,EAAW;4BACrFV;wBACF;oBACF;oBAEAA,SAAA,CAAUc,GAAG,CAAC,GAAGb,UAAA,CAAA,0BAAA,EAAuCC,UAAA,CAAA,CAAA,EAAcQ,SAAA,EAAW,EAAEZ,KAAA;gBACrF;YACF;QACF;QAEA,OAAOE,SAAA;IACT","ignoreList":[]}},
    {"offset": {"line": 5707, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/utilities/recurseNodeTree.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/utilities/recurseNodeTree.ts"],"sourcesContent":["import type { SerializedLexicalNode } from 'lexical'\n\n// Initialize both flattenedNodes and nodeIDMap\nexport const recurseNodeTree = ({\n  flattenedNodes,\n  nodeIDMap,\n  nodes,\n}: {\n  flattenedNodes?: SerializedLexicalNode[]\n  nodeIDMap?: {\n    [key: string]: SerializedLexicalNode\n  }\n  nodes: SerializedLexicalNode[]\n}): void => {\n  if (!nodes?.length) {\n    return\n  }\n\n  for (const node of nodes) {\n    if (flattenedNodes) {\n      flattenedNodes.push(node)\n    }\n    if (nodeIDMap) {\n      if (node && 'id' in node && node.id) {\n        nodeIDMap[node.id as string] = node\n      } else if (\n        'fields' in node &&\n        typeof node.fields === 'object' &&\n        node.fields &&\n        'id' in node.fields &&\n        node?.fields?.id\n      ) {\n        nodeIDMap[node.fields.id as string] = node\n      }\n    }\n\n    if ('children' in node && Array.isArray(node?.children) && node?.children?.length) {\n      recurseNodeTree({\n        flattenedNodes,\n        nodeIDMap,\n        nodes: node.children as SerializedLexicalNode[],\n      })\n    }\n  }\n}\n"],"names":["recurseNodeTree","flattenedNodes","nodeIDMap","nodes","length","node","push","id","fields","Array","isArray","children"],"mappings":"AAEA,+CAAA;;;;;AACO,MAAMA,eAAA,GAAkBA,CAAC,EAC9BC,cAAc,EACdC,SAAS,EACTC,KAAAA,EAOD;IACC,IAAI,CAACA,KAAA,EAAOC,MAAA,EAAQ;QAClB;IACF;IAEA,KAAK,MAAMC,IAAA,IAAQF,KAAA,CAAO;QACxB,IAAIF,cAAA,EAAgB;YAClBA,cAAA,CAAeK,IAAI,CAACD,IAAA;QACtB;QACA,IAAIH,SAAA,EAAW;YACb,IAAIG,IAAA,IAAQ,QAAQA,IAAA,IAAQA,IAAA,CAAKE,EAAE,EAAE;gBACnCL,SAAS,CAACG,IAAA,CAAKE,EAAE,CAAW,GAAGF,IAAA;YACjC,OAAO,IACL,YAAYA,IAAA,IACZ,OAAOA,IAAA,CAAKG,MAAM,KAAK,YACvBH,IAAA,CAAKG,MAAM,IACX,QAAQH,IAAA,CAAKG,MAAM,IACnBH,IAAA,EAAMG,MAAA,EAAQD,EAAA,EACd;gBACAL,SAAS,CAACG,IAAA,CAAKG,MAAM,CAACD,EAAE,CAAW,GAAGF,IAAA;YACxC;QACF;QAEA,IAAI,cAAcA,IAAA,IAAQI,KAAA,CAAMC,OAAO,CAACL,IAAA,EAAMM,QAAA,KAAaN,IAAA,EAAMM,QAAA,EAAUP,MAAA,EAAQ;YACjFJ,eAAA,CAAgB;gBACdC,cAAA;gBACAC,SAAA;gBACAC,KAAA,EAAOE,IAAA,CAAKM,QAAAA;YACd;QACF;IACF;AACF","ignoreList":[]}},
    {"offset": {"line": 5740, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/validate/validateNodes.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/validate/validateNodes.ts"],"sourcesContent":["import type { SerializedEditorState, SerializedLexicalNode } from 'lexical'\nimport type { RichTextField, ValidateOptions } from 'payload'\n\nimport type { NodeValidation } from '../features/typesServer.js'\n\nexport async function validateNodes({\n  nodes,\n  nodeValidations,\n  validation: validationFromProps,\n}: {\n  nodes: SerializedLexicalNode[]\n  nodeValidations: Map<string, Array<NodeValidation>>\n  validation: {\n    options: ValidateOptions<unknown, unknown, RichTextField, SerializedEditorState>\n    value: SerializedEditorState\n  }\n}): Promise<string | true> {\n  for (const node of nodes) {\n    // Validate node\n    const validations = nodeValidations.get(node.type)\n    if (validations) {\n      for (const validation of validations) {\n        const validationResult = await validation({\n          node,\n          nodeValidations,\n          validation: validationFromProps,\n        })\n        if (validationResult !== true) {\n          return `${node.type} node failed to validate: ${validationResult}`\n        }\n      }\n    }\n\n    // Validate node's children\n    if ('children' in node && node?.children) {\n      const childrenValidationResult = await validateNodes({\n        nodes: node.children as SerializedLexicalNode[],\n        nodeValidations,\n        validation: validationFromProps,\n      })\n      if (childrenValidationResult !== true) {\n        return childrenValidationResult\n      }\n    }\n  }\n\n  return true\n}\n"],"names":["validateNodes","nodes","nodeValidations","validation","validationFromProps","node","validations","get","type","validationResult","children","childrenValidationResult"],"mappings":";;;;AAKO,eAAeA,cAAc,EAClCC,KAAK,EACLC,eAAe,EACfC,UAAA,EAAYC,mBAAAA,EAQb;IACC,KAAK,MAAMC,IAAA,IAAQJ,KAAA,CAAO;QACxB,gBAAA;QACA,MAAMK,WAAA,GAAcJ,eAAA,CAAgBK,GAAG,CAACF,IAAA,CAAKG,IAAI;QACjD,IAAIF,WAAA,EAAa;YACf,KAAK,MAAMH,UAAA,IAAcG,WAAA,CAAa;gBACpC,MAAMG,gBAAA,GAAmB,MAAMN,UAAA,CAAW;oBACxCE,IAAA;oBACAH,eAAA;oBACAC,UAAA,EAAYC;gBACd;gBACA,IAAIK,gBAAA,KAAqB,MAAM;oBAC7B,OAAO,GAAGJ,IAAA,CAAKG,IAAI,CAAA,0BAAA,EAA6BC,gBAAA,EAAkB;gBACpE;YACF;QACF;QAEA,2BAAA;QACA,IAAI,cAAcJ,IAAA,IAAQA,IAAA,EAAMK,QAAA,EAAU;YACxC,MAAMC,wBAAA,GAA2B,MAAMX,aAAA,CAAc;gBACnDC,KAAA,EAAOI,IAAA,CAAKK,QAAQ;gBACpBR,eAAA;gBACAC,UAAA,EAAYC;YACd;YACA,IAAIO,wBAAA,KAA6B,MAAM;gBACrC,OAAOA,wBAAA;YACT;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[]}},
    {"offset": {"line": 5778, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/validate/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/validate/index.ts"],"sourcesContent":["import type { SerializedEditorState } from 'lexical'\nimport type { RichTextField, Validate } from 'payload'\n\nimport type { SanitizedServerEditorConfig } from '../lexical/config/types.js'\n\nimport { hasText } from './hasText.js'\nimport { validateNodes } from './validateNodes.js'\n\nexport const richTextValidateHOC = ({\n  editorConfig,\n}: {\n  editorConfig: SanitizedServerEditorConfig\n}) => {\n  const richTextValidate: Validate<SerializedEditorState, unknown, unknown, RichTextField> = async (\n    value,\n    options,\n  ) => {\n    const {\n      req: { t },\n      required,\n    } = options\n\n    if (required && hasText(value) === false) {\n      return t('validation:required')\n    }\n\n    // Traverse through nodes and validate them. Just like a node can hook into the population process (e.g. link or relationship nodes),\n    // they can also hook into the validation process. E.g. a block node probably has fields with validation rules.\n\n    const rootNodes = value?.root?.children\n    if (rootNodes && Array.isArray(rootNodes) && rootNodes?.length) {\n      return await validateNodes({\n        nodes: rootNodes,\n        nodeValidations: editorConfig.features.validations,\n        validation: {\n          options,\n          value,\n        },\n      })\n    }\n\n    return true\n  }\n\n  return richTextValidate\n}\n"],"names":["hasText","validateNodes","richTextValidateHOC","editorConfig","richTextValidate","value","options","req","t","required","rootNodes","root","children","Array","isArray","length","nodes","nodeValidations","features","validations","validation"],"mappings":";;;;AAKA,SAASA,OAAO,QAAQ;AACxB,SAASC,aAAa,QAAQ;;;AAEvB,MAAMC,mBAAA,GAAsBA,CAAC,EAClCC,YAAAA,EAGD;IACC,MAAMC,gBAAA,GAAqF,MAAAA,CACzFC,KAAA,EACAC,OAAA;QAEA,MAAM,EACJC,GAAA,EAAK,EAAEC,CAAAA,EAAG,EACVC,QAAAA,EACD,GAAGH,OAAA;QAEJ,IAAIG,QAAA,QAAYT,uYAAA,EAAQK,KAAA,MAAW,OAAO;YACxC,OAAOG,CAAA,CAAE;QACX;QAEA,qIAAA;QACA,+GAAA;QAEA,MAAME,SAAA,GAAYL,KAAA,EAAOM,IAAA,EAAMC,QAAA;QAC/B,IAAIF,SAAA,IAAaG,KAAA,CAAMC,OAAO,CAACJ,SAAA,KAAcA,SAAA,EAAWK,MAAA,EAAQ;YAC9D,OAAO,UAAMd,mZAAA,EAAc;gBACzBe,KAAA,EAAON,SAAA;gBACPO,eAAA,EAAiBd,YAAA,CAAae,QAAQ,CAACC,WAAW;gBAClDC,UAAA,EAAY;oBACVd,OAAA;oBACAD;gBACF;YACF;QACF;QAEA,OAAO;IACT;IAEA,OAAOD,gBAAA;AACT","ignoreList":[]}},
    {"offset": {"line": 5813, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/index.ts"],"sourcesContent":["import type { GenericLanguages, GenericTranslationsObject } from '@payloadcms/translations'\nimport type { JSONSchema4 } from 'json-schema'\nimport type { SerializedEditorState, SerializedLexicalNode } from 'lexical'\n\nimport {\n  afterChangeTraverseFields,\n  afterReadTraverseFields,\n  beforeChangeTraverseFields,\n  beforeValidateTraverseFields,\n  checkDependencies,\n  deepMergeSimple,\n  type RichTextAdapter,\n  withNullableJSONSchemaType,\n} from 'payload'\n\nimport type { FeatureProviderServer, ResolvedServerFeatureMap } from './features/typesServer.js'\nimport type { SanitizedServerEditorConfig } from './lexical/config/types.js'\nimport type { AdapterProps, LexicalEditorProps, LexicalRichTextAdapterProvider } from './types.js'\n\nimport { i18n } from './i18n.js'\nimport { defaultEditorFeatures } from './lexical/config/server/default.js'\nimport { populateLexicalPopulationPromises } from './populateGraphQL/populateLexicalPopulationPromises.js'\nimport { featuresInputToEditorConfig } from './utilities/editorConfigFactory.js'\nimport { getGenerateImportMap } from './utilities/generateImportMap.js'\nimport { getGenerateSchemaMap } from './utilities/generateSchemaMap.js'\nimport { getDefaultSanitizedEditorConfig } from './utilities/getDefaultSanitizedEditorConfig.js'\nimport { recurseNodeTree } from './utilities/recurseNodeTree.js'\nimport { richTextValidateHOC } from './validate/index.js'\n\nlet checkedDependencies = false\n\nexport const lexicalTargetVersion = '0.35.0'\n\nexport function lexicalEditor(args?: LexicalEditorProps): LexicalRichTextAdapterProvider {\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    process.env.PAYLOAD_DISABLE_DEPENDENCY_CHECKER !== 'true' &&\n    !checkedDependencies\n  ) {\n    checkedDependencies = true\n    void checkDependencies({\n      dependencyGroups: [\n        {\n          name: 'lexical',\n          dependencies: [\n            'lexical',\n            '@lexical/headless',\n            '@lexical/link',\n            '@lexical/list',\n            '@lexical/mark',\n            '@lexical/react',\n            '@lexical/rich-text',\n            '@lexical/selection',\n            '@lexical/utils',\n          ],\n          targetVersion: lexicalTargetVersion,\n        },\n      ],\n    })\n  }\n  return async ({ config, isRoot, parentIsLocalized }) => {\n    let features: FeatureProviderServer<unknown, unknown, unknown>[] = []\n    let resolvedFeatureMap: ResolvedServerFeatureMap\n\n    let finalSanitizedEditorConfig: SanitizedServerEditorConfig // For server only\n    if (!args || (!args.features && !args.lexical)) {\n      finalSanitizedEditorConfig = await getDefaultSanitizedEditorConfig({\n        config,\n        parentIsLocalized,\n      })\n\n      features = defaultEditorFeatures\n\n      resolvedFeatureMap = finalSanitizedEditorConfig.resolvedFeatureMap\n    } else {\n      const result = await featuresInputToEditorConfig({\n        config,\n        features: args?.features,\n        isRoot,\n        lexical: args?.lexical,\n        parentIsLocalized,\n      })\n      finalSanitizedEditorConfig = result.sanitizedConfig\n      features = result.features\n      resolvedFeatureMap = result.resolvedFeatureMap\n    }\n\n    const featureI18n: Partial<GenericLanguages> = finalSanitizedEditorConfig.features.i18n\n    for (const _lang in i18n) {\n      const lang = _lang as keyof typeof i18n\n      const lexicalI18nForLang = ((featureI18n[lang] ??= {}).lexical ??=\n        {}) as GenericTranslationsObject\n\n      lexicalI18nForLang.general = i18n[lang] ?? {}\n    }\n\n    config.i18n.translations = deepMergeSimple(config.i18n.translations, featureI18n)\n\n    return {\n      CellComponent: '@payloadcms/richtext-lexical/rsc#RscEntryLexicalCell',\n      DiffComponent: '@payloadcms/richtext-lexical/rsc#LexicalDiffComponent',\n      editorConfig: finalSanitizedEditorConfig,\n      features,\n      FieldComponent: {\n        path: '@payloadcms/richtext-lexical/rsc#RscEntryLexicalField',\n        serverProps: {\n          admin: args?.admin,\n          // SanitizedEditorConfig is manually passed by `renderField` in `fieldSchemasToFormState/renderField.tsx`\n          // in order to reduce the size of the field schema\n        },\n      },\n      generateImportMap: getGenerateImportMap({\n        resolvedFeatureMap,\n      }),\n      generateSchemaMap: getGenerateSchemaMap({\n        resolvedFeatureMap,\n      }),\n      graphQLPopulationPromises({\n        context,\n        currentDepth,\n        depth,\n        draft,\n        field,\n        fieldPromises,\n        findMany,\n        flattenLocales,\n        overrideAccess,\n        parentIsLocalized,\n        populationPromises,\n        req,\n        showHiddenFields,\n        siblingDoc,\n      }) {\n        // check if there are any features with nodes which have populationPromises for this field\n        if (finalSanitizedEditorConfig?.features?.graphQLPopulationPromises?.size) {\n          populateLexicalPopulationPromises({\n            context,\n            currentDepth: currentDepth ?? 0,\n            depth,\n            draft,\n            editorPopulationPromises: finalSanitizedEditorConfig.features.graphQLPopulationPromises,\n            field,\n            fieldPromises,\n            findMany,\n            flattenLocales,\n            overrideAccess,\n            parentIsLocalized,\n            populationPromises,\n            req,\n            showHiddenFields,\n            siblingDoc,\n          })\n        }\n      },\n      hooks: {\n        afterChange: [\n          async (args) => {\n            const {\n              collection,\n              context: _context,\n              data,\n              field,\n              global,\n              indexPath,\n              operation,\n              originalDoc,\n              parentIsLocalized,\n              path,\n              previousDoc,\n              previousValue,\n              req,\n              schemaPath,\n            } = args\n\n            let { value } = args\n            if (finalSanitizedEditorConfig?.features?.hooks?.afterChange?.length) {\n              for (const hook of finalSanitizedEditorConfig.features.hooks.afterChange) {\n                value = await hook(args)\n              }\n            }\n            if (\n              !finalSanitizedEditorConfig.features.nodeHooks?.afterChange?.size &&\n              !finalSanitizedEditorConfig.features.getSubFields?.size\n            ) {\n              return value\n            }\n            // TO-DO: We should not use context, as it is intended for external use only\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const context: any = _context\n            const nodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            const previousNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            /**\n             * Get the originalNodeIDMap from the beforeValidate hook, which is always run before this hook.\n             */\n            const originalNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = context?.internal?.richText?.[path.join('.')]?.originalNodeIDMap\n\n            if (!originalNodeIDMap || !Object.keys(originalNodeIDMap).length || !value) {\n              return value\n            }\n\n            recurseNodeTree({\n              nodeIDMap,\n              nodes: (value as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            recurseNodeTree({\n              nodeIDMap: previousNodeIDMap,\n              nodes: (previousValue as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            // eslint-disable-next-line prefer-const\n            for (let [id, node] of Object.entries(nodeIDMap)) {\n              const afterChangeHooks = finalSanitizedEditorConfig.features.nodeHooks?.afterChange\n              const afterChangeHooksForNode = afterChangeHooks?.get(node.type)\n              if (afterChangeHooksForNode) {\n                for (const hook of afterChangeHooksForNode) {\n                  if (!originalNodeIDMap[id]) {\n                    console.warn(\n                      '(afterChange) No original node found for node with id',\n                      id,\n                      'node:',\n                      node,\n                      'path',\n                      path.join('.'),\n                    )\n                    continue\n                  }\n                  node = await hook({\n                    context,\n                    node,\n                    operation,\n                    originalNode: originalNodeIDMap[id],\n                    parentRichTextFieldPath: path,\n                    parentRichTextFieldSchemaPath: schemaPath,\n\n                    previousNode: previousNodeIDMap[id]!,\n                    req,\n                  })\n                }\n              }\n              const subFieldFn = finalSanitizedEditorConfig.features.getSubFields?.get(node.type)\n              const subFieldDataFn = finalSanitizedEditorConfig.features.getSubFieldsData?.get(\n                node.type,\n              )\n\n              if (subFieldFn && subFieldDataFn) {\n                const subFields = subFieldFn({ node, req })\n                const nodeSiblingData = subFieldDataFn({ node, req }) ?? {}\n\n                const nodeSiblingDoc = subFieldDataFn({ node: originalNodeIDMap[id]!, req }) ?? {}\n                const nodePreviousSiblingDoc =\n                  subFieldDataFn({ node: previousNodeIDMap[id]!, req }) ?? {}\n\n                if (subFields?.length) {\n                  await afterChangeTraverseFields({\n                    blockData: nodeSiblingData,\n                    collection,\n                    context,\n                    data: data ?? {},\n                    doc: originalDoc,\n                    fields: subFields,\n                    global,\n                    operation,\n                    parentIndexPath: indexPath.join('-'),\n                    parentIsLocalized: parentIsLocalized || field.localized || false,\n                    parentPath: path.join('.'),\n                    parentSchemaPath: schemaPath.join('.'),\n                    previousDoc,\n                    previousSiblingDoc: { ...nodePreviousSiblingDoc },\n                    req,\n                    siblingData: nodeSiblingData || {},\n                    siblingDoc: { ...nodeSiblingDoc },\n                  })\n                }\n              }\n            }\n            return value\n          },\n        ],\n        afterRead: [\n          /**\n           * afterRead hooks do not receive the originalNode. Thus, they can run on all nodes, not just nodes with an ID.\n           */\n          async (args) => {\n            const {\n              collection,\n              context: context,\n              currentDepth,\n              depth,\n              draft,\n              fallbackLocale,\n              field,\n              fieldPromises,\n              findMany,\n              flattenLocales,\n              global,\n              indexPath,\n              locale,\n              originalDoc,\n              overrideAccess,\n              parentIsLocalized,\n              path,\n              populate,\n              populationPromises,\n              req,\n              schemaPath,\n              showHiddenFields,\n              triggerAccessControl,\n              triggerHooks,\n            } = args\n\n            let { value } = args\n\n            if (finalSanitizedEditorConfig?.features?.hooks?.afterRead?.length) {\n              for (const hook of finalSanitizedEditorConfig.features.hooks.afterRead) {\n                value = await hook(args)\n              }\n            }\n\n            if (\n              !finalSanitizedEditorConfig.features.nodeHooks?.afterRead?.size &&\n              !finalSanitizedEditorConfig.features.getSubFields?.size\n            ) {\n              return value\n            }\n            const flattenedNodes: SerializedLexicalNode[] = []\n\n            recurseNodeTree({\n              flattenedNodes,\n              nodes: (value as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            for (let node of flattenedNodes) {\n              const afterReadHooks = finalSanitizedEditorConfig.features.nodeHooks?.afterRead\n              const afterReadHooksForNode = afterReadHooks?.get(node.type)\n              if (afterReadHooksForNode) {\n                for (const hook of afterReadHooksForNode) {\n                  node = await hook({\n                    context,\n                    currentDepth: currentDepth!,\n                    depth: depth!,\n                    draft: draft!,\n                    fallbackLocale: fallbackLocale!,\n                    fieldPromises: fieldPromises!,\n                    findMany: findMany!,\n                    flattenLocales: flattenLocales!,\n                    locale: locale!,\n                    node,\n                    overrideAccess: overrideAccess!,\n                    parentRichTextFieldPath: path,\n                    parentRichTextFieldSchemaPath: schemaPath,\n                    populateArg: populate,\n                    populationPromises: populationPromises!,\n                    req,\n                    showHiddenFields: showHiddenFields!,\n                    triggerAccessControl: triggerAccessControl!,\n                    triggerHooks: triggerHooks!,\n                  })\n                }\n              }\n              const subFieldFn = finalSanitizedEditorConfig.features.getSubFields?.get(node.type)\n              const subFieldDataFn = finalSanitizedEditorConfig.features.getSubFieldsData?.get(\n                node.type,\n              )\n\n              if (subFieldFn && subFieldDataFn) {\n                const subFields = subFieldFn({ node, req })\n                const nodeSiblingData = subFieldDataFn({ node, req }) ?? {}\n\n                if (subFields?.length) {\n                  afterReadTraverseFields({\n                    blockData: nodeSiblingData,\n                    collection,\n                    context,\n                    currentDepth: currentDepth!,\n                    depth: depth!,\n                    doc: originalDoc,\n                    draft: draft!,\n                    fallbackLocale: fallbackLocale!,\n                    fieldPromises: fieldPromises!,\n                    fields: subFields,\n                    findMany: findMany!,\n                    flattenLocales: flattenLocales!,\n                    global,\n                    locale: locale!,\n                    overrideAccess: overrideAccess!,\n                    parentIndexPath: indexPath.join('-'),\n                    parentIsLocalized: parentIsLocalized || field.localized || false,\n                    parentPath: path.join('.'),\n                    parentSchemaPath: schemaPath.join('.'),\n                    populate,\n                    populationPromises: populationPromises!,\n                    req,\n                    showHiddenFields: showHiddenFields!,\n                    siblingDoc: nodeSiblingData,\n                    triggerAccessControl,\n                    triggerHooks,\n                  })\n                }\n              }\n            }\n\n            return value\n          },\n        ],\n        beforeChange: [\n          async (args) => {\n            const {\n              collection,\n              context: _context,\n              data,\n              docWithLocales,\n              errors,\n              field,\n              fieldLabelPath,\n              global,\n              indexPath,\n              mergeLocaleActions,\n              operation,\n              originalDoc,\n              overrideAccess,\n              parentIsLocalized,\n              path,\n              previousValue,\n              req,\n              schemaPath,\n              siblingData,\n              siblingDocWithLocales,\n              skipValidation,\n            } = args\n\n            let { value } = args\n\n            if (finalSanitizedEditorConfig?.features?.hooks?.beforeChange?.length) {\n              for (const hook of finalSanitizedEditorConfig.features.hooks.beforeChange) {\n                value = await hook(args)\n              }\n            }\n\n            if (\n              !finalSanitizedEditorConfig.features.nodeHooks?.beforeChange?.size &&\n              !finalSanitizedEditorConfig.features.getSubFields?.size\n            ) {\n              return value\n            }\n\n            // TO-DO: We should not use context, as it is intended for external use only\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const context: any = _context\n            const nodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            /**\n             * Get the originalNodeIDMap from the beforeValidate hook, which is always run before this hook.\n             */\n            const originalNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = context?.internal?.richText?.[path.join('.')]?.originalNodeIDMap\n\n            if (!originalNodeIDMap || !Object.keys(originalNodeIDMap).length || !value) {\n              return value\n            }\n\n            const previousNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            const originalNodeWithLocalesIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            recurseNodeTree({\n              nodeIDMap,\n              nodes: (value as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            recurseNodeTree({\n              nodeIDMap: previousNodeIDMap,\n              nodes: (previousValue as SerializedEditorState)?.root?.children ?? [],\n            })\n            if (field.name && siblingDocWithLocales?.[field.name]) {\n              recurseNodeTree({\n                nodeIDMap: originalNodeWithLocalesIDMap,\n                nodes:\n                  (siblingDocWithLocales[field.name] as SerializedEditorState)?.root?.children ??\n                  [],\n              })\n            }\n\n            // eslint-disable-next-line prefer-const\n            for (let [id, node] of Object.entries(nodeIDMap)) {\n              const beforeChangeHooks = finalSanitizedEditorConfig.features.nodeHooks?.beforeChange\n              const beforeChangeHooksForNode = beforeChangeHooks?.get(node.type)\n              if (beforeChangeHooksForNode) {\n                for (const hook of beforeChangeHooksForNode) {\n                  if (!originalNodeIDMap[id]) {\n                    console.warn(\n                      '(beforeChange) No original node found for node with id',\n                      id,\n                      'node:',\n                      node,\n                      'path',\n                      path.join('.'),\n                    )\n                    continue\n                  }\n                  node = await hook({\n                    context,\n                    errors: errors!,\n                    mergeLocaleActions: mergeLocaleActions!,\n                    node,\n                    operation: operation!,\n                    originalNode: originalNodeIDMap[id],\n                    originalNodeWithLocales: originalNodeWithLocalesIDMap[id],\n                    parentRichTextFieldPath: path,\n                    parentRichTextFieldSchemaPath: schemaPath,\n                    previousNode: previousNodeIDMap[id]!,\n                    req,\n                    skipValidation: skipValidation!,\n                  })\n                }\n              }\n\n              const subFieldFn = finalSanitizedEditorConfig.features.getSubFields?.get(node.type)\n              const subFieldDataFn = finalSanitizedEditorConfig.features.getSubFieldsData?.get(\n                node.type,\n              )\n\n              if (subFieldFn && subFieldDataFn) {\n                const subFields = subFieldFn({ node, req })\n                const nodeSiblingData = subFieldDataFn({ node, req }) ?? {}\n                const nodeSiblingDocWithLocales =\n                  subFieldDataFn({\n                    node: originalNodeWithLocalesIDMap[id]!,\n                    req,\n                  }) ?? {}\n                const nodePreviousSiblingDoc =\n                  subFieldDataFn({ node: previousNodeIDMap[id]!, req }) ?? {}\n\n                if (subFields?.length) {\n                  await beforeChangeTraverseFields({\n                    id,\n                    blockData: nodeSiblingData,\n                    collection,\n                    context,\n                    data: data ?? {},\n                    doc: originalDoc ?? {},\n                    docWithLocales: docWithLocales ?? {},\n                    errors: errors!,\n                    fieldLabelPath,\n                    fields: subFields,\n                    global,\n                    mergeLocaleActions: mergeLocaleActions!,\n                    operation: operation!,\n                    overrideAccess,\n                    parentIndexPath: indexPath.join('-'),\n                    parentIsLocalized: parentIsLocalized || field.localized || false,\n                    parentPath: path.join('.'),\n                    parentSchemaPath: schemaPath.join('.'),\n                    req,\n                    siblingData: nodeSiblingData,\n                    siblingDoc: nodePreviousSiblingDoc,\n                    siblingDocWithLocales: nodeSiblingDocWithLocales ?? {},\n                    skipValidation,\n                  })\n                }\n              }\n            }\n\n            /**\n             * within the beforeChange hook, id's may be re-generated.\n             * Example:\n             * 1. Seed data contains IDs for block feature blocks.\n             * 2. Those are used in beforeValidate\n             * 3. in beforeChange, those IDs are regenerated, because you cannot provide IDs during document creation. See baseIDField beforeChange hook for reasoning\n             * 4. Thus, in order for all post-beforeChange hooks to receive the correct ID, we need to update the originalNodeIDMap with the new ID's, by regenerating the nodeIDMap.\n             * The reason this is not generated for every hook, is to save on performance. We know we only really have to generate it in beforeValidate, which is the first hook,\n             * and in beforeChange, which is where modifications to the provided IDs can occur.\n             */\n            const newOriginalNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            const previousOriginalValue = siblingData[field.name!]\n\n            recurseNodeTree({\n              nodeIDMap: newOriginalNodeIDMap,\n              nodes: (previousOriginalValue as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            if (!context.internal) {\n              // Add to context, for other hooks to use\n              context.internal = {}\n            }\n            if (!context.internal.richText) {\n              context.internal.richText = {}\n            }\n            context.internal.richText[path.join('.')] = {\n              originalNodeIDMap: newOriginalNodeIDMap,\n            }\n\n            return value\n          },\n        ],\n        beforeValidate: [\n          async (args) => {\n            const {\n              collection,\n              context,\n              data,\n              field,\n              global,\n              indexPath,\n              operation,\n              originalDoc,\n              overrideAccess,\n              parentIsLocalized,\n              path,\n              previousValue,\n              req,\n              schemaPath,\n            } = args\n\n            let { value } = args\n            if (finalSanitizedEditorConfig?.features?.hooks?.beforeValidate?.length) {\n              for (const hook of finalSanitizedEditorConfig.features.hooks.beforeValidate) {\n                value = await hook(args)\n              }\n            }\n\n            // return value if there are NO hooks\n            if (\n              !finalSanitizedEditorConfig.features.nodeHooks?.beforeValidate?.size &&\n              !finalSanitizedEditorConfig.features.nodeHooks?.afterChange?.size &&\n              !finalSanitizedEditorConfig.features.nodeHooks?.beforeChange?.size &&\n              !finalSanitizedEditorConfig.features.getSubFields?.size\n            ) {\n              return value\n            }\n\n            /**\n             * beforeValidate is the first field hook which runs. This is where we can create the node map, which can then be used in the other hooks.\n             *\n             */\n\n            /**\n             * flattenedNodes contains all nodes in the editor, in the order they appear in the editor. They will be used for the following hooks:\n             * - afterRead\n             *\n             * The other hooks require nodes to have IDs, which is why those are ran only from the nodeIDMap. They require IDs because they have both doc/siblingDoc and data/siblingData, and\n             * thus require a reliable way to match new node data to old node data. Given that node positions can change in between hooks, this is only reliably possible for nodes which are saved with\n             * an ID.\n             */\n            //const flattenedNodes: SerializedLexicalNode[] = []\n\n            /**\n             * Only nodes with id's (so, nodes with hooks added to them) will be added to the nodeIDMap. They will be used for the following hooks:\n             * - afterChange\n             * - beforeChange\n             * - beforeValidate\n             *\n             * Other hooks are handled by the flattenedNodes. All nodes in the nodeIDMap are part of flattenedNodes.\n             */\n\n            const originalNodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n\n            recurseNodeTree({\n              nodeIDMap: originalNodeIDMap,\n              nodes: (previousValue as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            if (!context.internal) {\n              // Add to context, for other hooks to use\n              context.internal = {}\n            }\n            if (!(context as any).internal.richText) {\n              ;(context as any).internal.richText = {}\n            }\n            ;(context as any).internal.richText[path.join('.')] = {\n              originalNodeIDMap,\n            }\n\n            /**\n             * Now that the maps for all hooks are set up, we can run the validate hook\n             */\n            if (!finalSanitizedEditorConfig.features.nodeHooks?.beforeValidate?.size) {\n              return value\n            }\n            const nodeIDMap: {\n              [key: string]: SerializedLexicalNode\n            } = {}\n            recurseNodeTree({\n              //flattenedNodes,\n              nodeIDMap,\n              nodes: (value as SerializedEditorState)?.root?.children ?? [],\n            })\n\n            // eslint-disable-next-line prefer-const\n            for (let [id, node] of Object.entries(nodeIDMap)) {\n              const beforeValidateHooks =\n                finalSanitizedEditorConfig.features.nodeHooks.beforeValidate\n              const beforeValidateHooksForNode = beforeValidateHooks?.get(node.type)\n              if (beforeValidateHooksForNode) {\n                for (const hook of beforeValidateHooksForNode) {\n                  if (!originalNodeIDMap[id]) {\n                    console.warn(\n                      '(beforeValidate) No original node found for node with id',\n                      id,\n                      'node:',\n                      node,\n                      'path',\n                      path.join('.'),\n                    )\n                    continue\n                  }\n                  node = await hook({\n                    context,\n                    node,\n                    operation,\n                    originalNode: originalNodeIDMap[id],\n                    overrideAccess: overrideAccess!,\n                    parentRichTextFieldPath: path,\n                    parentRichTextFieldSchemaPath: schemaPath,\n                    req,\n                  })\n                }\n              }\n              const subFieldFn = finalSanitizedEditorConfig.features.getSubFields?.get(node.type)\n              const subFieldDataFn = finalSanitizedEditorConfig.features.getSubFieldsData?.get(\n                node.type,\n              )\n\n              if (subFieldFn && subFieldDataFn) {\n                const subFields = subFieldFn({ node, req })\n                const nodeSiblingData = subFieldDataFn({ node, req }) ?? {}\n\n                const nodeSiblingDoc = subFieldDataFn({ node: originalNodeIDMap[id]!, req }) ?? {}\n\n                if (subFields?.length) {\n                  await beforeValidateTraverseFields({\n                    id,\n                    blockData: nodeSiblingData,\n                    collection,\n                    context,\n                    data,\n                    doc: originalDoc,\n                    fields: subFields,\n                    global,\n                    operation,\n                    overrideAccess: overrideAccess!,\n                    parentIndexPath: indexPath.join('-'),\n                    parentIsLocalized: parentIsLocalized || field.localized || false,\n                    parentPath: path.join('.'),\n                    parentSchemaPath: schemaPath.join('.'),\n                    req,\n                    siblingData: nodeSiblingData,\n                    siblingDoc: nodeSiblingDoc,\n                  })\n                }\n              }\n            }\n\n            return value\n          },\n        ],\n      },\n      outputSchema: ({\n        collectionIDFieldTypes,\n        config,\n        field,\n        i18n,\n        interfaceNameDefinitions,\n        isRequired,\n      }) => {\n        let outputSchema: JSONSchema4 = {\n          // This schema matches the SerializedEditorState type so far, that it's possible to cast SerializedEditorState to this schema without any errors.\n          // In the future, we should\n          // 1) allow recursive children\n          // 2) Pass in all the different types for every node added to the editorconfig. This can be done with refs in the schema.\n          type: withNullableJSONSchemaType('object', isRequired),\n          properties: {\n            root: {\n              type: 'object',\n              additionalProperties: false,\n              properties: {\n                type: {\n                  type: 'string',\n                },\n                children: {\n                  type: 'array',\n                  items: {\n                    type: 'object',\n                    additionalProperties: true,\n                    properties: {\n                      type: {\n                        type: 'string',\n                        tsType: 'any',\n                      },\n                      version: {\n                        type: 'integer',\n                      },\n                    },\n                    required: ['type', 'version'],\n                  },\n                },\n                direction: {\n                  oneOf: [\n                    {\n                      enum: ['ltr', 'rtl'],\n                    },\n                    {\n                      type: 'null',\n                    },\n                  ],\n                },\n                format: {\n                  type: 'string',\n                  enum: ['left', 'start', 'center', 'right', 'end', 'justify', ''], // ElementFormatType, since the root node is an element\n                },\n                indent: {\n                  type: 'integer',\n                },\n                version: {\n                  type: 'integer',\n                },\n              },\n              required: ['children', 'direction', 'format', 'indent', 'type', 'version'],\n            },\n          },\n          required: ['root'],\n        }\n        for (const modifyOutputSchema of finalSanitizedEditorConfig.features.generatedTypes\n          .modifyOutputSchemas) {\n          outputSchema = modifyOutputSchema({\n            collectionIDFieldTypes,\n            config,\n            currentSchema: outputSchema,\n            field,\n            i18n,\n            interfaceNameDefinitions,\n            isRequired,\n          })\n        }\n\n        return outputSchema\n      },\n      validate: richTextValidateHOC({\n        editorConfig: finalSanitizedEditorConfig,\n      }),\n    }\n  }\n}\n\nexport { AlignFeature } from './features/align/server/index.js'\nexport { BlockquoteFeature } from './features/blockquote/server/index.js'\nexport { CodeBlock } from './features/blocks/premade/CodeBlock/index.js'\nexport { BlocksFeature, type BlocksFeatureProps } from './features/blocks/server/index.js'\n\nexport {\n  $createServerBlockNode,\n  $isServerBlockNode,\n  type BlockFields,\n  ServerBlockNode,\n} from './features/blocks/server/nodes/BlocksNode.js'\n\nexport { convertHTMLToLexical } from './features/converters/htmlToLexical/index.js'\n\nexport { lexicalHTMLField } from './features/converters/lexicalToHtml/async/field/index.js'\nexport { LinebreakHTMLConverter } from './features/converters/lexicalToHtml_deprecated/converter/converters/linebreak.js'\n\nexport { ParagraphHTMLConverter } from './features/converters/lexicalToHtml_deprecated/converter/converters/paragraph.js'\n\nexport { TabHTMLConverter } from './features/converters/lexicalToHtml_deprecated/converter/converters/tab.js'\nexport { TextHTMLConverter } from './features/converters/lexicalToHtml_deprecated/converter/converters/text.js'\nexport { defaultHTMLConverters } from './features/converters/lexicalToHtml_deprecated/converter/defaultConverters.js'\n\nexport {\n  convertLexicalNodesToHTML,\n  convertLexicalToHTML,\n} from './features/converters/lexicalToHtml_deprecated/converter/index.js'\nexport type { HTMLConverter } from './features/converters/lexicalToHtml_deprecated/converter/types.js'\nexport {\n  consolidateHTMLConverters,\n  lexicalHTML,\n} from './features/converters/lexicalToHtml_deprecated/field/index.js'\nexport {\n  HTMLConverterFeature,\n  type HTMLConverterFeatureProps,\n} from './features/converters/lexicalToHtml_deprecated/index.js'\nexport { convertLexicalToMarkdown } from './features/converters/lexicalToMarkdown/index.js'\nexport { convertMarkdownToLexical } from './features/converters/markdownToLexical/index.js'\nexport { getPayloadPopulateFn } from './features/converters/utilities/payloadPopulateFn.js'\n\nexport { getRestPopulateFn } from './features/converters/utilities/restPopulateFn.js'\nexport { DebugJsxConverterFeature } from './features/debug/jsxConverter/server/index.js'\nexport { TestRecorderFeature } from './features/debug/testRecorder/server/index.js'\nexport { TreeViewFeature } from './features/debug/treeView/server/index.js'\nexport { EXPERIMENTAL_TableFeature } from './features/experimental_table/server/index.js'\nexport { BoldFeature } from './features/format/bold/feature.server.js'\nexport { InlineCodeFeature } from './features/format/inlineCode/feature.server.js'\n\nexport { ItalicFeature } from './features/format/italic/feature.server.js'\nexport { StrikethroughFeature } from './features/format/strikethrough/feature.server.js'\nexport { SubscriptFeature } from './features/format/subscript/feature.server.js'\nexport { SuperscriptFeature } from './features/format/superscript/feature.server.js'\nexport { UnderlineFeature } from './features/format/underline/feature.server.js'\nexport { HeadingFeature, type HeadingFeatureProps } from './features/heading/server/index.js'\nexport { HorizontalRuleFeature } from './features/horizontalRule/server/index.js'\n\nexport { IndentFeature } from './features/indent/server/index.js'\nexport {\n  $createAutoLinkNode,\n  $isAutoLinkNode,\n  AutoLinkNode,\n} from './features/link/nodes/AutoLinkNode.js'\nexport { $createLinkNode, $isLinkNode, LinkNode } from './features/link/nodes/LinkNode.js'\n\nexport type { LinkFields } from './features/link/nodes/types.js'\nexport { LinkFeature, type LinkFeatureServerProps } from './features/link/server/index.js'\n\nexport { ChecklistFeature } from './features/lists/checklist/server/index.js'\nexport { OrderedListFeature } from './features/lists/orderedList/server/index.js'\n\nexport { UnorderedListFeature } from './features/lists/unorderedList/server/index.js'\nexport type {\n  SlateNode,\n  SlateNodeConverter,\n} from './features/migrations/slateToLexical/converter/types.js'\nexport { ParagraphFeature } from './features/paragraph/server/index.js'\n\nexport {\n  RelationshipFeature,\n  type RelationshipFeatureProps,\n} from './features/relationship/server/index.js'\n\nexport {\n  type RelationshipData,\n  RelationshipServerNode,\n} from './features/relationship/server/nodes/RelationshipNode.js'\nexport { defaultColors } from './features/textState/defaultColors.js'\nexport { TextStateFeature } from './features/textState/feature.server.js'\n\nexport { FixedToolbarFeature } from './features/toolbars/fixed/server/index.js'\n\nexport { InlineToolbarFeature } from './features/toolbars/inline/server/index.js'\nexport type { ToolbarGroup, ToolbarGroupItem } from './features/toolbars/types.js'\nexport type {\n  BaseClientFeatureProps,\n  ClientFeature,\n  ClientFeatureProviderMap,\n  FeatureProviderClient,\n  FeatureProviderProviderClient,\n  PluginComponent,\n  PluginComponentWithAnchor,\n  ResolvedClientFeature,\n  ResolvedClientFeatureMap,\n  SanitizedClientFeatures,\n  SanitizedPlugin,\n} from './features/typesClient.js'\n\nexport type {\n  AfterChangeNodeHook,\n  AfterChangeNodeHookArgs,\n  AfterReadNodeHook,\n  AfterReadNodeHookArgs,\n  BaseNodeHookArgs,\n  BeforeChangeNodeHook,\n  BeforeChangeNodeHookArgs,\n  BeforeValidateNodeHook,\n  BeforeValidateNodeHookArgs,\n  FeatureProviderProviderServer,\n  FeatureProviderServer,\n  NodeValidation,\n  NodeWithHooks,\n  PopulationPromise,\n  ResolvedServerFeature,\n  ResolvedServerFeatureMap,\n  SanitizedServerFeatures,\n  ServerFeature,\n  ServerFeatureProviderMap,\n} from './features/typesServer.js'\n\nexport { createNode } from './features/typeUtilities.js' // Only useful in feature.server.ts\n\nexport { UploadFeature } from './features/upload/server/index.js'\nexport type { UploadFeatureProps } from './features/upload/server/index.js'\n\nexport { type UploadData, UploadServerNode } from './features/upload/server/nodes/UploadNode.js'\nexport type { EditorConfigContextType } from './lexical/config/client/EditorConfigProvider.js'\n\nexport {\n  defaultEditorConfig,\n  defaultEditorFeatures,\n  defaultEditorLexicalConfig,\n} from './lexical/config/server/default.js'\nexport { loadFeatures, sortFeaturesForOptimalLoading } from './lexical/config/server/loader.js'\n\nexport {\n  sanitizeServerEditorConfig,\n  sanitizeServerFeatures,\n} from './lexical/config/server/sanitize.js'\nexport type {\n  ClientEditorConfig,\n  SanitizedClientEditorConfig,\n  SanitizedServerEditorConfig,\n  ServerEditorConfig,\n} from './lexical/config/types.js'\nexport type { AdapterProps }\n\nexport { getEnabledNodes, getEnabledNodesFromServerNodes } from './lexical/nodes/index.js'\n\nexport type {\n  SlashMenuGroup,\n  SlashMenuItem,\n} from './lexical/plugins/SlashMenu/LexicalTypeaheadMenuPlugin/types.js'\nexport {\n  DETAIL_TYPE_TO_DETAIL,\n  DOUBLE_LINE_BREAK,\n  ELEMENT_FORMAT_TO_TYPE,\n  ELEMENT_TYPE_TO_FORMAT,\n  IS_ALL_FORMATTING,\n  LTR_REGEX,\n  NodeFormat,\n  NON_BREAKING_SPACE,\n  RTL_REGEX,\n  TEXT_MODE_TO_TYPE,\n  TEXT_TYPE_TO_FORMAT,\n  TEXT_TYPE_TO_MODE,\n} from './lexical/utils/nodeFormat.js'\n\nexport { sanitizeUrl, validateUrl } from './lexical/utils/url.js'\n\nexport type * from './nodeTypes.js'\n\nexport { $convertFromMarkdownString } from './packages/@lexical/markdown/index.js'\nexport { defaultRichTextValue } from './populateGraphQL/defaultValue.js'\nexport { populate } from './populateGraphQL/populate.js'\n\nexport type { LexicalEditorProps, LexicalFieldAdminProps, LexicalRichTextAdapter } from './types.js'\n\nexport { buildDefaultEditorState, buildEditorState } from './utilities/buildEditorState.js'\nexport { createServerFeature } from './utilities/createServerFeature.js'\n\nexport { editorConfigFactory } from './utilities/editorConfigFactory.js'\nexport type { FieldsDrawerProps } from './utilities/fieldsDrawer/Drawer.js'\n\nexport { extractPropsFromJSXPropsString } from './utilities/jsx/extractPropsFromJSXPropsString.js'\n\nexport {\n  extractFrontmatter,\n  frontmatterToObject,\n  objectToFrontmatter,\n  propsToJSXString,\n} from './utilities/jsx/jsx.js'\nexport { upgradeLexicalData } from './utilities/upgradeLexicalData/index.js'\n"],"names":["afterChangeTraverseFields","afterReadTraverseFields","beforeChangeTraverseFields","beforeValidateTraverseFields","checkDependencies","deepMergeSimple","withNullableJSONSchemaType","i18n","defaultEditorFeatures","populateLexicalPopulationPromises","featuresInputToEditorConfig","getGenerateImportMap","getGenerateSchemaMap","getDefaultSanitizedEditorConfig","recurseNodeTree","richTextValidateHOC","checkedDependencies","lexicalTargetVersion","lexicalEditor","args","process","env","NODE_ENV","PAYLOAD_DISABLE_DEPENDENCY_CHECKER","dependencyGroups","name","dependencies","targetVersion","config","isRoot","parentIsLocalized","features","resolvedFeatureMap","finalSanitizedEditorConfig","lexical","result","sanitizedConfig","featureI18n","_lang","lang","lexicalI18nForLang","general","translations","CellComponent","DiffComponent","editorConfig","FieldComponent","path","serverProps","admin","generateImportMap","generateSchemaMap","graphQLPopulationPromises","context","currentDepth","depth","draft","field","fieldPromises","findMany","flattenLocales","overrideAccess","populationPromises","req","showHiddenFields","siblingDoc","size","editorPopulationPromises","hooks","afterChange","collection","_context","data","global","indexPath","operation","originalDoc","previousDoc","previousValue","schemaPath","value","length","hook","nodeHooks","getSubFields","nodeIDMap","previousNodeIDMap","originalNodeIDMap","internal","richText","join","Object","keys","nodes","root","children","id","node","entries","afterChangeHooks","afterChangeHooksForNode","get","type","console","warn","originalNode","parentRichTextFieldPath","parentRichTextFieldSchemaPath","previousNode","subFieldFn","subFieldDataFn","getSubFieldsData","subFields","nodeSiblingData","nodeSiblingDoc","nodePreviousSiblingDoc","blockData","doc","fields","parentIndexPath","localized","parentPath","parentSchemaPath","previousSiblingDoc","siblingData","afterRead","fallbackLocale","locale","populate","triggerAccessControl","triggerHooks","flattenedNodes","afterReadHooks","afterReadHooksForNode","populateArg","beforeChange","docWithLocales","errors","fieldLabelPath","mergeLocaleActions","siblingDocWithLocales","skipValidation","originalNodeWithLocalesIDMap","beforeChangeHooks","beforeChangeHooksForNode","originalNodeWithLocales","nodeSiblingDocWithLocales","newOriginalNodeIDMap","previousOriginalValue","beforeValidate","beforeValidateHooks","beforeValidateHooksForNode","outputSchema","collectionIDFieldTypes","interfaceNameDefinitions","isRequired","properties","additionalProperties","items","tsType","version","required","direction","oneOf","enum","format","indent","modifyOutputSchema","generatedTypes","modifyOutputSchemas","currentSchema","validate","AlignFeature","BlockquoteFeature","CodeBlock","BlocksFeature","$createServerBlockNode","$isServerBlockNode","ServerBlockNode","convertHTMLToLexical","lexicalHTMLField","LinebreakHTMLConverter","ParagraphHTMLConverter","TabHTMLConverter","TextHTMLConverter","defaultHTMLConverters","convertLexicalNodesToHTML","convertLexicalToHTML","consolidateHTMLConverters","lexicalHTML","HTMLConverterFeature","convertLexicalToMarkdown","convertMarkdownToLexical","getPayloadPopulateFn","getRestPopulateFn","DebugJsxConverterFeature","TestRecorderFeature","TreeViewFeature","EXPERIMENTAL_TableFeature","BoldFeature","InlineCodeFeature","ItalicFeature","StrikethroughFeature","SubscriptFeature","SuperscriptFeature","UnderlineFeature","HeadingFeature","HorizontalRuleFeature","IndentFeature","$createAutoLinkNode","$isAutoLinkNode","AutoLinkNode","$createLinkNode","$isLinkNode","LinkNode","LinkFeature","ChecklistFeature","OrderedListFeature","UnorderedListFeature","ParagraphFeature","RelationshipFeature","RelationshipServerNode","defaultColors","TextStateFeature","FixedToolbarFeature","InlineToolbarFeature","createNode","UploadFeature","UploadServerNode","defaultEditorConfig","defaultEditorLexicalConfig","loadFeatures","sortFeaturesForOptimalLoading","sanitizeServerEditorConfig","sanitizeServerFeatures","getEnabledNodes","getEnabledNodesFromServerNodes","DETAIL_TYPE_TO_DETAIL","DOUBLE_LINE_BREAK","ELEMENT_FORMAT_TO_TYPE","ELEMENT_TYPE_TO_FORMAT","IS_ALL_FORMATTING","LTR_REGEX","NodeFormat","NON_BREAKING_SPACE","RTL_REGEX","TEXT_MODE_TO_TYPE","TEXT_TYPE_TO_FORMAT","TEXT_TYPE_TO_MODE","sanitizeUrl","validateUrl","$convertFromMarkdownString","defaultRichTextValue","buildDefaultEditorState","buildEditorState","createServerFeature","editorConfigFactory","extractPropsFromJSXPropsString","extractFrontmatter","frontmatterToObject","objectToFrontmatter","propsToJSXString","upgradeLexicalData"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 6566, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/cell/rscEntry.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/cell/rscEntry.tsx"],"sourcesContent":["import type { SerializedLexicalNode } from 'lexical'\n\nimport { getTranslation } from '@payloadcms/translations'\nimport { Link } from '@payloadcms/ui'\nimport { formatAdminURL } from 'payload/shared'\nimport React from 'react'\n\nimport type { LexicalRichTextCellProps } from '../types.js'\n\nfunction recurseEditorState(\n  editorState: SerializedLexicalNode[],\n  textContent: React.ReactNode[],\n  i: number = 0,\n): React.ReactNode[] {\n  for (const node of editorState) {\n    i++\n    if ('text' in node && node.text) {\n      textContent.push(node.text as string)\n    } else {\n      if (!('children' in node)) {\n        textContent.push(<code key={i}>&#32;[{node.type}]</code>)\n      }\n    }\n    if ('children' in node && node.children) {\n      textContent = recurseEditorState(node.children as SerializedLexicalNode[], textContent, i)\n    }\n  }\n  return textContent\n}\n\nexport const RscEntryLexicalCell: React.FC<LexicalRichTextCellProps> = (props) => {\n  const {\n    cellData,\n    className: classNameFromProps,\n    collectionConfig,\n    field: { admin },\n    field,\n    i18n,\n    link,\n    onClick: onClickFromProps,\n    payload,\n    rowData,\n  } = props\n\n  const classNameFromConfigContext = admin && 'className' in admin ? admin.className : undefined\n\n  const className =\n    classNameFromProps ||\n    (field.admin && 'className' in field.admin ? field.admin.className : null) ||\n    classNameFromConfigContext\n  const adminRoute = payload.config.routes.admin\n\n  const onClick = onClickFromProps\n\n  let WrapElement: React.ComponentType<any> | string = 'span'\n\n  const wrapElementProps: {\n    className?: string\n    href?: string\n    onClick?: () => void\n    prefetch?: false\n    type?: 'button'\n  } = {\n    className,\n  }\n\n  if (link) {\n    wrapElementProps.prefetch = false\n    WrapElement = Link\n    wrapElementProps.href = collectionConfig?.slug\n      ? formatAdminURL({\n          adminRoute,\n          path: `/collections/${collectionConfig?.slug}/${rowData.id}`,\n        })\n      : ''\n  }\n\n  if (typeof onClick === 'function') {\n    WrapElement = 'button'\n    wrapElementProps.type = 'button'\n    wrapElementProps.onClick = () => {\n      onClick({\n        cellData,\n        collectionSlug: collectionConfig?.slug,\n        rowData,\n      })\n    }\n  }\n\n  let textContent: React.ReactNode[] = []\n\n  if (cellData?.root?.children) {\n    textContent = recurseEditorState(cellData?.root?.children, textContent)\n  }\n\n  if (!textContent?.length) {\n    textContent = [\n      i18n.t('general:noLabel', {\n        label: getTranslation(('label' in field ? field.label : null) || 'data', i18n),\n      }),\n    ]\n  }\n\n  return <WrapElement {...wrapElementProps}>{textContent}</WrapElement>\n}\n"],"names":["getTranslation","Link","formatAdminURL","React","recurseEditorState","editorState","textContent","i","node","text","push","_jsxs","type","children","RscEntryLexicalCell","props","cellData","className","classNameFromProps","collectionConfig","field","admin","i18n","link","onClick","onClickFromProps","payload","rowData","classNameFromConfigContext","undefined","adminRoute","config","routes","WrapElement","wrapElementProps","prefetch","href","slug","path","id","collectionSlug","root","length","t","label","_jsx"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 6651, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/dist/exports/client/index.js/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const $createAutoLinkNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $createAutoLinkNode() from the server but $createAutoLinkNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"$createAutoLinkNode\",\n);\nexport const $createBlockNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $createBlockNode() from the server but $createBlockNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"$createBlockNode\",\n);\nexport const $createHorizontalRuleNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $createHorizontalRuleNode() from the server but $createHorizontalRuleNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"$createHorizontalRuleNode\",\n);\nexport const $createInlineBlockNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $createInlineBlockNode() from the server but $createInlineBlockNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"$createInlineBlockNode\",\n);\nexport const $createLinkNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $createLinkNode() from the server but $createLinkNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"$createLinkNode\",\n);\nexport const $createRelationshipNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $createRelationshipNode() from the server but $createRelationshipNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"$createRelationshipNode\",\n);\nexport const $createUploadNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $createUploadNode() from the server but $createUploadNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"$createUploadNode\",\n);\nexport const $isAutoLinkNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $isAutoLinkNode() from the server but $isAutoLinkNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"$isAutoLinkNode\",\n);\nexport const $isBlockNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $isBlockNode() from the server but $isBlockNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"$isBlockNode\",\n);\nexport const $isHorizontalRuleNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $isHorizontalRuleNode() from the server but $isHorizontalRuleNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"$isHorizontalRuleNode\",\n);\nexport const $isInlineBlockNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $isInlineBlockNode() from the server but $isInlineBlockNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"$isInlineBlockNode\",\n);\nexport const $isLinkNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $isLinkNode() from the server but $isLinkNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"$isLinkNode\",\n);\nexport const $isRelationshipNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $isRelationshipNode() from the server but $isRelationshipNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"$isRelationshipNode\",\n);\nexport const $isUploadNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $isUploadNode() from the server but $isUploadNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"$isUploadNode\",\n);\nexport const AlignFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call AlignFeatureClient() from the server but AlignFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"AlignFeatureClient\",\n);\nexport const AutoLinkNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call AutoLinkNode() from the server but AutoLinkNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"AutoLinkNode\",\n);\nexport const BlockCollapsible = registerClientReference(\n    function() { throw new Error(\"Attempted to call BlockCollapsible() from the server but BlockCollapsible is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"BlockCollapsible\",\n);\nexport const BlockEditButton = registerClientReference(\n    function() { throw new Error(\"Attempted to call BlockEditButton() from the server but BlockEditButton is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"BlockEditButton\",\n);\nexport const BlockNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call BlockNode() from the server but BlockNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"BlockNode\",\n);\nexport const BlockRemoveButton = registerClientReference(\n    function() { throw new Error(\"Attempted to call BlockRemoveButton() from the server but BlockRemoveButton is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"BlockRemoveButton\",\n);\nexport const BlockquoteFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call BlockquoteFeatureClient() from the server but BlockquoteFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"BlockquoteFeatureClient\",\n);\nexport const BlocksFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call BlocksFeatureClient() from the server but BlocksFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"BlocksFeatureClient\",\n);\nexport const BoldFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call BoldFeatureClient() from the server but BoldFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"BoldFeatureClient\",\n);\nexport const CAN_USE_DOM = registerClientReference(\n    function() { throw new Error(\"Attempted to call CAN_USE_DOM() from the server but CAN_USE_DOM is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"CAN_USE_DOM\",\n);\nexport const ChecklistFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call ChecklistFeatureClient() from the server but ChecklistFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"ChecklistFeatureClient\",\n);\nexport const CodeBlockBlockComponent = registerClientReference(\n    function() { throw new Error(\"Attempted to call CodeBlockBlockComponent() from the server but CodeBlockBlockComponent is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"CodeBlockBlockComponent\",\n);\nexport const CodeComponent = registerClientReference(\n    function() { throw new Error(\"Attempted to call CodeComponent() from the server but CodeComponent is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"CodeComponent\",\n);\nexport const DETAIL_TYPE_TO_DETAIL = registerClientReference(\n    function() { throw new Error(\"Attempted to call DETAIL_TYPE_TO_DETAIL() from the server but DETAIL_TYPE_TO_DETAIL is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"DETAIL_TYPE_TO_DETAIL\",\n);\nexport const DOUBLE_LINE_BREAK = registerClientReference(\n    function() { throw new Error(\"Attempted to call DOUBLE_LINE_BREAK() from the server but DOUBLE_LINE_BREAK is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"DOUBLE_LINE_BREAK\",\n);\nexport const DebugJsxConverterFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call DebugJsxConverterFeatureClient() from the server but DebugJsxConverterFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"DebugJsxConverterFeatureClient\",\n);\nexport const ELEMENT_FORMAT_TO_TYPE = registerClientReference(\n    function() { throw new Error(\"Attempted to call ELEMENT_FORMAT_TO_TYPE() from the server but ELEMENT_FORMAT_TO_TYPE is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"ELEMENT_FORMAT_TO_TYPE\",\n);\nexport const ELEMENT_TYPE_TO_FORMAT = registerClientReference(\n    function() { throw new Error(\"Attempted to call ELEMENT_TYPE_TO_FORMAT() from the server but ELEMENT_TYPE_TO_FORMAT is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"ELEMENT_TYPE_TO_FORMAT\",\n);\nexport const ENABLE_SLASH_MENU_COMMAND = registerClientReference(\n    function() { throw new Error(\"Attempted to call ENABLE_SLASH_MENU_COMMAND() from the server but ENABLE_SLASH_MENU_COMMAND is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"ENABLE_SLASH_MENU_COMMAND\",\n);\nexport const EditorConfigProvider = registerClientReference(\n    function() { throw new Error(\"Attempted to call EditorConfigProvider() from the server but EditorConfigProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"EditorConfigProvider\",\n);\nexport const FieldsDrawer = registerClientReference(\n    function() { throw new Error(\"Attempted to call FieldsDrawer() from the server but FieldsDrawer is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"FieldsDrawer\",\n);\nexport const FixedToolbarFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call FixedToolbarFeatureClient() from the server but FixedToolbarFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"FixedToolbarFeatureClient\",\n);\nexport const HeadingFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call HeadingFeatureClient() from the server but HeadingFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"HeadingFeatureClient\",\n);\nexport const HorizontalRuleFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call HorizontalRuleFeatureClient() from the server but HorizontalRuleFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"HorizontalRuleFeatureClient\",\n);\nexport const HorizontalRuleNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call HorizontalRuleNode() from the server but HorizontalRuleNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"HorizontalRuleNode\",\n);\nexport const INSERT_BLOCK_COMMAND = registerClientReference(\n    function() { throw new Error(\"Attempted to call INSERT_BLOCK_COMMAND() from the server but INSERT_BLOCK_COMMAND is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"INSERT_BLOCK_COMMAND\",\n);\nexport const INSERT_INLINE_BLOCK_COMMAND = registerClientReference(\n    function() { throw new Error(\"Attempted to call INSERT_INLINE_BLOCK_COMMAND() from the server but INSERT_INLINE_BLOCK_COMMAND is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"INSERT_INLINE_BLOCK_COMMAND\",\n);\nexport const IS_ALL_FORMATTING = registerClientReference(\n    function() { throw new Error(\"Attempted to call IS_ALL_FORMATTING() from the server but IS_ALL_FORMATTING is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"IS_ALL_FORMATTING\",\n);\nexport const IndentFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call IndentFeatureClient() from the server but IndentFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"IndentFeatureClient\",\n);\nexport const InlineBlockContainer = registerClientReference(\n    function() { throw new Error(\"Attempted to call InlineBlockContainer() from the server but InlineBlockContainer is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"InlineBlockContainer\",\n);\nexport const InlineBlockEditButton = registerClientReference(\n    function() { throw new Error(\"Attempted to call InlineBlockEditButton() from the server but InlineBlockEditButton is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"InlineBlockEditButton\",\n);\nexport const InlineBlockLabel = registerClientReference(\n    function() { throw new Error(\"Attempted to call InlineBlockLabel() from the server but InlineBlockLabel is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"InlineBlockLabel\",\n);\nexport const InlineBlockNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call InlineBlockNode() from the server but InlineBlockNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"InlineBlockNode\",\n);\nexport const InlineBlockRemoveButton = registerClientReference(\n    function() { throw new Error(\"Attempted to call InlineBlockRemoveButton() from the server but InlineBlockRemoveButton is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"InlineBlockRemoveButton\",\n);\nexport const InlineCodeFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call InlineCodeFeatureClient() from the server but InlineCodeFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"InlineCodeFeatureClient\",\n);\nexport const InlineToolbarFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call InlineToolbarFeatureClient() from the server but InlineToolbarFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"InlineToolbarFeatureClient\",\n);\nexport const ItalicFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call ItalicFeatureClient() from the server but ItalicFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"ItalicFeatureClient\",\n);\nexport const LTR_REGEX = registerClientReference(\n    function() { throw new Error(\"Attempted to call LTR_REGEX() from the server but LTR_REGEX is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"LTR_REGEX\",\n);\nexport const LexicalPluginToLexicalFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call LexicalPluginToLexicalFeatureClient() from the server but LexicalPluginToLexicalFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"LexicalPluginToLexicalFeatureClient\",\n);\nexport const LinkFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call LinkFeatureClient() from the server but LinkFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"LinkFeatureClient\",\n);\nexport const LinkNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call LinkNode() from the server but LinkNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"LinkNode\",\n);\nexport const NON_BREAKING_SPACE = registerClientReference(\n    function() { throw new Error(\"Attempted to call NON_BREAKING_SPACE() from the server but NON_BREAKING_SPACE is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"NON_BREAKING_SPACE\",\n);\nexport const NodeFormat = registerClientReference(\n    function() { throw new Error(\"Attempted to call NodeFormat() from the server but NodeFormat is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"NodeFormat\",\n);\nexport const OrderedListFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call OrderedListFeatureClient() from the server but OrderedListFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"OrderedListFeatureClient\",\n);\nexport const ParagraphFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call ParagraphFeatureClient() from the server but ParagraphFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"ParagraphFeatureClient\",\n);\nexport const Point = registerClientReference(\n    function() { throw new Error(\"Attempted to call Point() from the server but Point is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"Point\",\n);\nexport const RTL_REGEX = registerClientReference(\n    function() { throw new Error(\"Attempted to call RTL_REGEX() from the server but RTL_REGEX is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"RTL_REGEX\",\n);\nexport const Rect = registerClientReference(\n    function() { throw new Error(\"Attempted to call Rect() from the server but Rect is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"Rect\",\n);\nexport const RelationshipFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call RelationshipFeatureClient() from the server but RelationshipFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"RelationshipFeatureClient\",\n);\nexport const RelationshipNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call RelationshipNode() from the server but RelationshipNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"RelationshipNode\",\n);\nexport const RenderLexical = registerClientReference(\n    function() { throw new Error(\"Attempted to call RenderLexical() from the server but RenderLexical is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"RenderLexical\",\n);\nexport const RichTextField = registerClientReference(\n    function() { throw new Error(\"Attempted to call RichTextField() from the server but RichTextField is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"RichTextField\",\n);\nexport const SlateToLexicalFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call SlateToLexicalFeatureClient() from the server but SlateToLexicalFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"SlateToLexicalFeatureClient\",\n);\nexport const StrikethroughFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call StrikethroughFeatureClient() from the server but StrikethroughFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"StrikethroughFeatureClient\",\n);\nexport const SubscriptFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call SubscriptFeatureClient() from the server but SubscriptFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"SubscriptFeatureClient\",\n);\nexport const SuperscriptFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call SuperscriptFeatureClient() from the server but SuperscriptFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"SuperscriptFeatureClient\",\n);\nexport const TEXT_MODE_TO_TYPE = registerClientReference(\n    function() { throw new Error(\"Attempted to call TEXT_MODE_TO_TYPE() from the server but TEXT_MODE_TO_TYPE is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"TEXT_MODE_TO_TYPE\",\n);\nexport const TEXT_TYPE_TO_FORMAT = registerClientReference(\n    function() { throw new Error(\"Attempted to call TEXT_TYPE_TO_FORMAT() from the server but TEXT_TYPE_TO_FORMAT is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"TEXT_TYPE_TO_FORMAT\",\n);\nexport const TEXT_TYPE_TO_MODE = registerClientReference(\n    function() { throw new Error(\"Attempted to call TEXT_TYPE_TO_MODE() from the server but TEXT_TYPE_TO_MODE is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"TEXT_TYPE_TO_MODE\",\n);\nexport const TOGGLE_LINK_COMMAND = registerClientReference(\n    function() { throw new Error(\"Attempted to call TOGGLE_LINK_COMMAND() from the server but TOGGLE_LINK_COMMAND is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"TOGGLE_LINK_COMMAND\",\n);\nexport const TableFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call TableFeatureClient() from the server but TableFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"TableFeatureClient\",\n);\nexport const TestRecorderFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call TestRecorderFeatureClient() from the server but TestRecorderFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"TestRecorderFeatureClient\",\n);\nexport const TextStateFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call TextStateFeatureClient() from the server but TextStateFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"TextStateFeatureClient\",\n);\nexport const ToolbarButton = registerClientReference(\n    function() { throw new Error(\"Attempted to call ToolbarButton() from the server but ToolbarButton is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"ToolbarButton\",\n);\nexport const ToolbarDropdown = registerClientReference(\n    function() { throw new Error(\"Attempted to call ToolbarDropdown() from the server but ToolbarDropdown is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"ToolbarDropdown\",\n);\nexport const TreeViewFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call TreeViewFeatureClient() from the server but TreeViewFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"TreeViewFeatureClient\",\n);\nexport const UnderlineFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call UnderlineFeatureClient() from the server but UnderlineFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"UnderlineFeatureClient\",\n);\nexport const UnorderedListFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call UnorderedListFeatureClient() from the server but UnorderedListFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"UnorderedListFeatureClient\",\n);\nexport const UploadFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call UploadFeatureClient() from the server but UploadFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"UploadFeatureClient\",\n);\nexport const UploadNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call UploadNode() from the server but UploadNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"UploadNode\",\n);\nexport const addSwipeDownListener = registerClientReference(\n    function() { throw new Error(\"Attempted to call addSwipeDownListener() from the server but addSwipeDownListener is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"addSwipeDownListener\",\n);\nexport const addSwipeLeftListener = registerClientReference(\n    function() { throw new Error(\"Attempted to call addSwipeLeftListener() from the server but addSwipeLeftListener is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"addSwipeLeftListener\",\n);\nexport const addSwipeRightListener = registerClientReference(\n    function() { throw new Error(\"Attempted to call addSwipeRightListener() from the server but addSwipeRightListener is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"addSwipeRightListener\",\n);\nexport const addSwipeUpListener = registerClientReference(\n    function() { throw new Error(\"Attempted to call addSwipeUpListener() from the server but addSwipeUpListener is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"addSwipeUpListener\",\n);\nexport const buildDefaultEditorState = registerClientReference(\n    function() { throw new Error(\"Attempted to call buildDefaultEditorState() from the server but buildDefaultEditorState is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"buildDefaultEditorState\",\n);\nexport const buildEditorState = registerClientReference(\n    function() { throw new Error(\"Attempted to call buildEditorState() from the server but buildEditorState is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"buildEditorState\",\n);\nexport const codeConverterClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call codeConverterClient() from the server but codeConverterClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"codeConverterClient\",\n);\nexport const createBlockNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call createBlockNode() from the server but createBlockNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"createBlockNode\",\n);\nexport const createClientFeature = registerClientReference(\n    function() { throw new Error(\"Attempted to call createClientFeature() from the server but createClientFeature is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"createClientFeature\",\n);\nexport const defaultColors = registerClientReference(\n    function() { throw new Error(\"Attempted to call defaultColors() from the server but defaultColors is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"defaultColors\",\n);\nexport const defaultEditorLexicalConfig = registerClientReference(\n    function() { throw new Error(\"Attempted to call defaultEditorLexicalConfig() from the server but defaultEditorLexicalConfig is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"defaultEditorLexicalConfig\",\n);\nexport const getDOMRangeRect = registerClientReference(\n    function() { throw new Error(\"Attempted to call getDOMRangeRect() from the server but getDOMRangeRect is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"getDOMRangeRect\",\n);\nexport const getEnabledNodes = registerClientReference(\n    function() { throw new Error(\"Attempted to call getEnabledNodes() from the server but getEnabledNodes is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"getEnabledNodes\",\n);\nexport const getRestPopulateFn = registerClientReference(\n    function() { throw new Error(\"Attempted to call getRestPopulateFn() from the server but getRestPopulateFn is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"getRestPopulateFn\",\n);\nexport const getSelectedNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call getSelectedNode() from the server but getSelectedNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"getSelectedNode\",\n);\nexport const isHTMLElement = registerClientReference(\n    function() { throw new Error(\"Attempted to call isHTMLElement() from the server but isHTMLElement is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"isHTMLElement\",\n);\nexport const isPoint = registerClientReference(\n    function() { throw new Error(\"Attempted to call isPoint() from the server but isPoint is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"isPoint\",\n);\nexport const joinClasses = registerClientReference(\n    function() { throw new Error(\"Attempted to call joinClasses() from the server but joinClasses is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"joinClasses\",\n);\nexport const sanitizeClientEditorConfig = registerClientReference(\n    function() { throw new Error(\"Attempted to call sanitizeClientEditorConfig() from the server but sanitizeClientEditorConfig is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"sanitizeClientEditorConfig\",\n);\nexport const sanitizeClientFeatures = registerClientReference(\n    function() { throw new Error(\"Attempted to call sanitizeClientFeatures() from the server but sanitizeClientFeatures is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"sanitizeClientFeatures\",\n);\nexport const setFloatingElemPosition = registerClientReference(\n    function() { throw new Error(\"Attempted to call setFloatingElemPosition() from the server but setFloatingElemPosition is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"setFloatingElemPosition\",\n);\nexport const setFloatingElemPositionForLinkEditor = registerClientReference(\n    function() { throw new Error(\"Attempted to call setFloatingElemPositionForLinkEditor() from the server but setFloatingElemPositionForLinkEditor is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"setFloatingElemPositionForLinkEditor\",\n);\nexport const slashMenuBasicGroupWithItems = registerClientReference(\n    function() { throw new Error(\"Attempted to call slashMenuBasicGroupWithItems() from the server but slashMenuBasicGroupWithItems is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"slashMenuBasicGroupWithItems\",\n);\nexport const toolbarAddDropdownGroupWithItems = registerClientReference(\n    function() { throw new Error(\"Attempted to call toolbarAddDropdownGroupWithItems() from the server but toolbarAddDropdownGroupWithItems is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"toolbarAddDropdownGroupWithItems\",\n);\nexport const toolbarFeatureButtonsGroupWithItems = registerClientReference(\n    function() { throw new Error(\"Attempted to call toolbarFeatureButtonsGroupWithItems() from the server but toolbarFeatureButtonsGroupWithItems is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"toolbarFeatureButtonsGroupWithItems\",\n);\nexport const toolbarFormatGroupWithItems = registerClientReference(\n    function() { throw new Error(\"Attempted to call toolbarFormatGroupWithItems() from the server but toolbarFormatGroupWithItems is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"toolbarFormatGroupWithItems\",\n);\nexport const toolbarTextDropdownGroupWithItems = registerClientReference(\n    function() { throw new Error(\"Attempted to call toolbarTextDropdownGroupWithItems() from the server but toolbarTextDropdownGroupWithItems is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"toolbarTextDropdownGroupWithItems\",\n);\nexport const useBlockComponentContext = registerClientReference(\n    function() { throw new Error(\"Attempted to call useBlockComponentContext() from the server but useBlockComponentContext is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"useBlockComponentContext\",\n);\nexport const useEditorConfigContext = registerClientReference(\n    function() { throw new Error(\"Attempted to call useEditorConfigContext() from the server but useEditorConfigContext is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"useEditorConfigContext\",\n);\nexport const useInlineBlockComponentContext = registerClientReference(\n    function() { throw new Error(\"Attempted to call useInlineBlockComponentContext() from the server but useInlineBlockComponentContext is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"useInlineBlockComponentContext\",\n);\nexport const useLexicalDocumentDrawer = registerClientReference(\n    function() { throw new Error(\"Attempted to call useLexicalDocumentDrawer() from the server but useLexicalDocumentDrawer is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"useLexicalDocumentDrawer\",\n);\nexport const useLexicalDrawer = registerClientReference(\n    function() { throw new Error(\"Attempted to call useLexicalDrawer() from the server but useLexicalDrawer is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"useLexicalDrawer\",\n);\nexport const useLexicalListDrawer = registerClientReference(\n    function() { throw new Error(\"Attempted to call useLexicalListDrawer() from the server but useLexicalListDrawer is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js <module evaluation>\",\n    \"useLexicalListDrawer\",\n);\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7245, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/dist/exports/client/index.js/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const $createAutoLinkNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $createAutoLinkNode() from the server but $createAutoLinkNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"$createAutoLinkNode\",\n);\nexport const $createBlockNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $createBlockNode() from the server but $createBlockNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"$createBlockNode\",\n);\nexport const $createHorizontalRuleNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $createHorizontalRuleNode() from the server but $createHorizontalRuleNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"$createHorizontalRuleNode\",\n);\nexport const $createInlineBlockNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $createInlineBlockNode() from the server but $createInlineBlockNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"$createInlineBlockNode\",\n);\nexport const $createLinkNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $createLinkNode() from the server but $createLinkNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"$createLinkNode\",\n);\nexport const $createRelationshipNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $createRelationshipNode() from the server but $createRelationshipNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"$createRelationshipNode\",\n);\nexport const $createUploadNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $createUploadNode() from the server but $createUploadNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"$createUploadNode\",\n);\nexport const $isAutoLinkNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $isAutoLinkNode() from the server but $isAutoLinkNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"$isAutoLinkNode\",\n);\nexport const $isBlockNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $isBlockNode() from the server but $isBlockNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"$isBlockNode\",\n);\nexport const $isHorizontalRuleNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $isHorizontalRuleNode() from the server but $isHorizontalRuleNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"$isHorizontalRuleNode\",\n);\nexport const $isInlineBlockNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $isInlineBlockNode() from the server but $isInlineBlockNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"$isInlineBlockNode\",\n);\nexport const $isLinkNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $isLinkNode() from the server but $isLinkNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"$isLinkNode\",\n);\nexport const $isRelationshipNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $isRelationshipNode() from the server but $isRelationshipNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"$isRelationshipNode\",\n);\nexport const $isUploadNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call $isUploadNode() from the server but $isUploadNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"$isUploadNode\",\n);\nexport const AlignFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call AlignFeatureClient() from the server but AlignFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"AlignFeatureClient\",\n);\nexport const AutoLinkNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call AutoLinkNode() from the server but AutoLinkNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"AutoLinkNode\",\n);\nexport const BlockCollapsible = registerClientReference(\n    function() { throw new Error(\"Attempted to call BlockCollapsible() from the server but BlockCollapsible is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"BlockCollapsible\",\n);\nexport const BlockEditButton = registerClientReference(\n    function() { throw new Error(\"Attempted to call BlockEditButton() from the server but BlockEditButton is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"BlockEditButton\",\n);\nexport const BlockNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call BlockNode() from the server but BlockNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"BlockNode\",\n);\nexport const BlockRemoveButton = registerClientReference(\n    function() { throw new Error(\"Attempted to call BlockRemoveButton() from the server but BlockRemoveButton is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"BlockRemoveButton\",\n);\nexport const BlockquoteFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call BlockquoteFeatureClient() from the server but BlockquoteFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"BlockquoteFeatureClient\",\n);\nexport const BlocksFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call BlocksFeatureClient() from the server but BlocksFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"BlocksFeatureClient\",\n);\nexport const BoldFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call BoldFeatureClient() from the server but BoldFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"BoldFeatureClient\",\n);\nexport const CAN_USE_DOM = registerClientReference(\n    function() { throw new Error(\"Attempted to call CAN_USE_DOM() from the server but CAN_USE_DOM is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"CAN_USE_DOM\",\n);\nexport const ChecklistFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call ChecklistFeatureClient() from the server but ChecklistFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"ChecklistFeatureClient\",\n);\nexport const CodeBlockBlockComponent = registerClientReference(\n    function() { throw new Error(\"Attempted to call CodeBlockBlockComponent() from the server but CodeBlockBlockComponent is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"CodeBlockBlockComponent\",\n);\nexport const CodeComponent = registerClientReference(\n    function() { throw new Error(\"Attempted to call CodeComponent() from the server but CodeComponent is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"CodeComponent\",\n);\nexport const DETAIL_TYPE_TO_DETAIL = registerClientReference(\n    function() { throw new Error(\"Attempted to call DETAIL_TYPE_TO_DETAIL() from the server but DETAIL_TYPE_TO_DETAIL is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"DETAIL_TYPE_TO_DETAIL\",\n);\nexport const DOUBLE_LINE_BREAK = registerClientReference(\n    function() { throw new Error(\"Attempted to call DOUBLE_LINE_BREAK() from the server but DOUBLE_LINE_BREAK is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"DOUBLE_LINE_BREAK\",\n);\nexport const DebugJsxConverterFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call DebugJsxConverterFeatureClient() from the server but DebugJsxConverterFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"DebugJsxConverterFeatureClient\",\n);\nexport const ELEMENT_FORMAT_TO_TYPE = registerClientReference(\n    function() { throw new Error(\"Attempted to call ELEMENT_FORMAT_TO_TYPE() from the server but ELEMENT_FORMAT_TO_TYPE is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"ELEMENT_FORMAT_TO_TYPE\",\n);\nexport const ELEMENT_TYPE_TO_FORMAT = registerClientReference(\n    function() { throw new Error(\"Attempted to call ELEMENT_TYPE_TO_FORMAT() from the server but ELEMENT_TYPE_TO_FORMAT is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"ELEMENT_TYPE_TO_FORMAT\",\n);\nexport const ENABLE_SLASH_MENU_COMMAND = registerClientReference(\n    function() { throw new Error(\"Attempted to call ENABLE_SLASH_MENU_COMMAND() from the server but ENABLE_SLASH_MENU_COMMAND is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"ENABLE_SLASH_MENU_COMMAND\",\n);\nexport const EditorConfigProvider = registerClientReference(\n    function() { throw new Error(\"Attempted to call EditorConfigProvider() from the server but EditorConfigProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"EditorConfigProvider\",\n);\nexport const FieldsDrawer = registerClientReference(\n    function() { throw new Error(\"Attempted to call FieldsDrawer() from the server but FieldsDrawer is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"FieldsDrawer\",\n);\nexport const FixedToolbarFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call FixedToolbarFeatureClient() from the server but FixedToolbarFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"FixedToolbarFeatureClient\",\n);\nexport const HeadingFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call HeadingFeatureClient() from the server but HeadingFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"HeadingFeatureClient\",\n);\nexport const HorizontalRuleFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call HorizontalRuleFeatureClient() from the server but HorizontalRuleFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"HorizontalRuleFeatureClient\",\n);\nexport const HorizontalRuleNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call HorizontalRuleNode() from the server but HorizontalRuleNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"HorizontalRuleNode\",\n);\nexport const INSERT_BLOCK_COMMAND = registerClientReference(\n    function() { throw new Error(\"Attempted to call INSERT_BLOCK_COMMAND() from the server but INSERT_BLOCK_COMMAND is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"INSERT_BLOCK_COMMAND\",\n);\nexport const INSERT_INLINE_BLOCK_COMMAND = registerClientReference(\n    function() { throw new Error(\"Attempted to call INSERT_INLINE_BLOCK_COMMAND() from the server but INSERT_INLINE_BLOCK_COMMAND is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"INSERT_INLINE_BLOCK_COMMAND\",\n);\nexport const IS_ALL_FORMATTING = registerClientReference(\n    function() { throw new Error(\"Attempted to call IS_ALL_FORMATTING() from the server but IS_ALL_FORMATTING is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"IS_ALL_FORMATTING\",\n);\nexport const IndentFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call IndentFeatureClient() from the server but IndentFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"IndentFeatureClient\",\n);\nexport const InlineBlockContainer = registerClientReference(\n    function() { throw new Error(\"Attempted to call InlineBlockContainer() from the server but InlineBlockContainer is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"InlineBlockContainer\",\n);\nexport const InlineBlockEditButton = registerClientReference(\n    function() { throw new Error(\"Attempted to call InlineBlockEditButton() from the server but InlineBlockEditButton is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"InlineBlockEditButton\",\n);\nexport const InlineBlockLabel = registerClientReference(\n    function() { throw new Error(\"Attempted to call InlineBlockLabel() from the server but InlineBlockLabel is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"InlineBlockLabel\",\n);\nexport const InlineBlockNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call InlineBlockNode() from the server but InlineBlockNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"InlineBlockNode\",\n);\nexport const InlineBlockRemoveButton = registerClientReference(\n    function() { throw new Error(\"Attempted to call InlineBlockRemoveButton() from the server but InlineBlockRemoveButton is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"InlineBlockRemoveButton\",\n);\nexport const InlineCodeFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call InlineCodeFeatureClient() from the server but InlineCodeFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"InlineCodeFeatureClient\",\n);\nexport const InlineToolbarFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call InlineToolbarFeatureClient() from the server but InlineToolbarFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"InlineToolbarFeatureClient\",\n);\nexport const ItalicFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call ItalicFeatureClient() from the server but ItalicFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"ItalicFeatureClient\",\n);\nexport const LTR_REGEX = registerClientReference(\n    function() { throw new Error(\"Attempted to call LTR_REGEX() from the server but LTR_REGEX is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"LTR_REGEX\",\n);\nexport const LexicalPluginToLexicalFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call LexicalPluginToLexicalFeatureClient() from the server but LexicalPluginToLexicalFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"LexicalPluginToLexicalFeatureClient\",\n);\nexport const LinkFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call LinkFeatureClient() from the server but LinkFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"LinkFeatureClient\",\n);\nexport const LinkNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call LinkNode() from the server but LinkNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"LinkNode\",\n);\nexport const NON_BREAKING_SPACE = registerClientReference(\n    function() { throw new Error(\"Attempted to call NON_BREAKING_SPACE() from the server but NON_BREAKING_SPACE is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"NON_BREAKING_SPACE\",\n);\nexport const NodeFormat = registerClientReference(\n    function() { throw new Error(\"Attempted to call NodeFormat() from the server but NodeFormat is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"NodeFormat\",\n);\nexport const OrderedListFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call OrderedListFeatureClient() from the server but OrderedListFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"OrderedListFeatureClient\",\n);\nexport const ParagraphFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call ParagraphFeatureClient() from the server but ParagraphFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"ParagraphFeatureClient\",\n);\nexport const Point = registerClientReference(\n    function() { throw new Error(\"Attempted to call Point() from the server but Point is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"Point\",\n);\nexport const RTL_REGEX = registerClientReference(\n    function() { throw new Error(\"Attempted to call RTL_REGEX() from the server but RTL_REGEX is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"RTL_REGEX\",\n);\nexport const Rect = registerClientReference(\n    function() { throw new Error(\"Attempted to call Rect() from the server but Rect is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"Rect\",\n);\nexport const RelationshipFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call RelationshipFeatureClient() from the server but RelationshipFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"RelationshipFeatureClient\",\n);\nexport const RelationshipNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call RelationshipNode() from the server but RelationshipNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"RelationshipNode\",\n);\nexport const RenderLexical = registerClientReference(\n    function() { throw new Error(\"Attempted to call RenderLexical() from the server but RenderLexical is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"RenderLexical\",\n);\nexport const RichTextField = registerClientReference(\n    function() { throw new Error(\"Attempted to call RichTextField() from the server but RichTextField is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"RichTextField\",\n);\nexport const SlateToLexicalFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call SlateToLexicalFeatureClient() from the server but SlateToLexicalFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"SlateToLexicalFeatureClient\",\n);\nexport const StrikethroughFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call StrikethroughFeatureClient() from the server but StrikethroughFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"StrikethroughFeatureClient\",\n);\nexport const SubscriptFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call SubscriptFeatureClient() from the server but SubscriptFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"SubscriptFeatureClient\",\n);\nexport const SuperscriptFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call SuperscriptFeatureClient() from the server but SuperscriptFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"SuperscriptFeatureClient\",\n);\nexport const TEXT_MODE_TO_TYPE = registerClientReference(\n    function() { throw new Error(\"Attempted to call TEXT_MODE_TO_TYPE() from the server but TEXT_MODE_TO_TYPE is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"TEXT_MODE_TO_TYPE\",\n);\nexport const TEXT_TYPE_TO_FORMAT = registerClientReference(\n    function() { throw new Error(\"Attempted to call TEXT_TYPE_TO_FORMAT() from the server but TEXT_TYPE_TO_FORMAT is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"TEXT_TYPE_TO_FORMAT\",\n);\nexport const TEXT_TYPE_TO_MODE = registerClientReference(\n    function() { throw new Error(\"Attempted to call TEXT_TYPE_TO_MODE() from the server but TEXT_TYPE_TO_MODE is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"TEXT_TYPE_TO_MODE\",\n);\nexport const TOGGLE_LINK_COMMAND = registerClientReference(\n    function() { throw new Error(\"Attempted to call TOGGLE_LINK_COMMAND() from the server but TOGGLE_LINK_COMMAND is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"TOGGLE_LINK_COMMAND\",\n);\nexport const TableFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call TableFeatureClient() from the server but TableFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"TableFeatureClient\",\n);\nexport const TestRecorderFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call TestRecorderFeatureClient() from the server but TestRecorderFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"TestRecorderFeatureClient\",\n);\nexport const TextStateFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call TextStateFeatureClient() from the server but TextStateFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"TextStateFeatureClient\",\n);\nexport const ToolbarButton = registerClientReference(\n    function() { throw new Error(\"Attempted to call ToolbarButton() from the server but ToolbarButton is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"ToolbarButton\",\n);\nexport const ToolbarDropdown = registerClientReference(\n    function() { throw new Error(\"Attempted to call ToolbarDropdown() from the server but ToolbarDropdown is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"ToolbarDropdown\",\n);\nexport const TreeViewFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call TreeViewFeatureClient() from the server but TreeViewFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"TreeViewFeatureClient\",\n);\nexport const UnderlineFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call UnderlineFeatureClient() from the server but UnderlineFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"UnderlineFeatureClient\",\n);\nexport const UnorderedListFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call UnorderedListFeatureClient() from the server but UnorderedListFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"UnorderedListFeatureClient\",\n);\nexport const UploadFeatureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call UploadFeatureClient() from the server but UploadFeatureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"UploadFeatureClient\",\n);\nexport const UploadNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call UploadNode() from the server but UploadNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"UploadNode\",\n);\nexport const addSwipeDownListener = registerClientReference(\n    function() { throw new Error(\"Attempted to call addSwipeDownListener() from the server but addSwipeDownListener is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"addSwipeDownListener\",\n);\nexport const addSwipeLeftListener = registerClientReference(\n    function() { throw new Error(\"Attempted to call addSwipeLeftListener() from the server but addSwipeLeftListener is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"addSwipeLeftListener\",\n);\nexport const addSwipeRightListener = registerClientReference(\n    function() { throw new Error(\"Attempted to call addSwipeRightListener() from the server but addSwipeRightListener is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"addSwipeRightListener\",\n);\nexport const addSwipeUpListener = registerClientReference(\n    function() { throw new Error(\"Attempted to call addSwipeUpListener() from the server but addSwipeUpListener is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"addSwipeUpListener\",\n);\nexport const buildDefaultEditorState = registerClientReference(\n    function() { throw new Error(\"Attempted to call buildDefaultEditorState() from the server but buildDefaultEditorState is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"buildDefaultEditorState\",\n);\nexport const buildEditorState = registerClientReference(\n    function() { throw new Error(\"Attempted to call buildEditorState() from the server but buildEditorState is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"buildEditorState\",\n);\nexport const codeConverterClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call codeConverterClient() from the server but codeConverterClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"codeConverterClient\",\n);\nexport const createBlockNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call createBlockNode() from the server but createBlockNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"createBlockNode\",\n);\nexport const createClientFeature = registerClientReference(\n    function() { throw new Error(\"Attempted to call createClientFeature() from the server but createClientFeature is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"createClientFeature\",\n);\nexport const defaultColors = registerClientReference(\n    function() { throw new Error(\"Attempted to call defaultColors() from the server but defaultColors is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"defaultColors\",\n);\nexport const defaultEditorLexicalConfig = registerClientReference(\n    function() { throw new Error(\"Attempted to call defaultEditorLexicalConfig() from the server but defaultEditorLexicalConfig is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"defaultEditorLexicalConfig\",\n);\nexport const getDOMRangeRect = registerClientReference(\n    function() { throw new Error(\"Attempted to call getDOMRangeRect() from the server but getDOMRangeRect is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"getDOMRangeRect\",\n);\nexport const getEnabledNodes = registerClientReference(\n    function() { throw new Error(\"Attempted to call getEnabledNodes() from the server but getEnabledNodes is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"getEnabledNodes\",\n);\nexport const getRestPopulateFn = registerClientReference(\n    function() { throw new Error(\"Attempted to call getRestPopulateFn() from the server but getRestPopulateFn is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"getRestPopulateFn\",\n);\nexport const getSelectedNode = registerClientReference(\n    function() { throw new Error(\"Attempted to call getSelectedNode() from the server but getSelectedNode is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"getSelectedNode\",\n);\nexport const isHTMLElement = registerClientReference(\n    function() { throw new Error(\"Attempted to call isHTMLElement() from the server but isHTMLElement is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"isHTMLElement\",\n);\nexport const isPoint = registerClientReference(\n    function() { throw new Error(\"Attempted to call isPoint() from the server but isPoint is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"isPoint\",\n);\nexport const joinClasses = registerClientReference(\n    function() { throw new Error(\"Attempted to call joinClasses() from the server but joinClasses is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"joinClasses\",\n);\nexport const sanitizeClientEditorConfig = registerClientReference(\n    function() { throw new Error(\"Attempted to call sanitizeClientEditorConfig() from the server but sanitizeClientEditorConfig is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"sanitizeClientEditorConfig\",\n);\nexport const sanitizeClientFeatures = registerClientReference(\n    function() { throw new Error(\"Attempted to call sanitizeClientFeatures() from the server but sanitizeClientFeatures is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"sanitizeClientFeatures\",\n);\nexport const setFloatingElemPosition = registerClientReference(\n    function() { throw new Error(\"Attempted to call setFloatingElemPosition() from the server but setFloatingElemPosition is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"setFloatingElemPosition\",\n);\nexport const setFloatingElemPositionForLinkEditor = registerClientReference(\n    function() { throw new Error(\"Attempted to call setFloatingElemPositionForLinkEditor() from the server but setFloatingElemPositionForLinkEditor is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"setFloatingElemPositionForLinkEditor\",\n);\nexport const slashMenuBasicGroupWithItems = registerClientReference(\n    function() { throw new Error(\"Attempted to call slashMenuBasicGroupWithItems() from the server but slashMenuBasicGroupWithItems is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"slashMenuBasicGroupWithItems\",\n);\nexport const toolbarAddDropdownGroupWithItems = registerClientReference(\n    function() { throw new Error(\"Attempted to call toolbarAddDropdownGroupWithItems() from the server but toolbarAddDropdownGroupWithItems is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"toolbarAddDropdownGroupWithItems\",\n);\nexport const toolbarFeatureButtonsGroupWithItems = registerClientReference(\n    function() { throw new Error(\"Attempted to call toolbarFeatureButtonsGroupWithItems() from the server but toolbarFeatureButtonsGroupWithItems is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"toolbarFeatureButtonsGroupWithItems\",\n);\nexport const toolbarFormatGroupWithItems = registerClientReference(\n    function() { throw new Error(\"Attempted to call toolbarFormatGroupWithItems() from the server but toolbarFormatGroupWithItems is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"toolbarFormatGroupWithItems\",\n);\nexport const toolbarTextDropdownGroupWithItems = registerClientReference(\n    function() { throw new Error(\"Attempted to call toolbarTextDropdownGroupWithItems() from the server but toolbarTextDropdownGroupWithItems is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"toolbarTextDropdownGroupWithItems\",\n);\nexport const useBlockComponentContext = registerClientReference(\n    function() { throw new Error(\"Attempted to call useBlockComponentContext() from the server but useBlockComponentContext is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"useBlockComponentContext\",\n);\nexport const useEditorConfigContext = registerClientReference(\n    function() { throw new Error(\"Attempted to call useEditorConfigContext() from the server but useEditorConfigContext is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"useEditorConfigContext\",\n);\nexport const useInlineBlockComponentContext = registerClientReference(\n    function() { throw new Error(\"Attempted to call useInlineBlockComponentContext() from the server but useInlineBlockComponentContext is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"useInlineBlockComponentContext\",\n);\nexport const useLexicalDocumentDrawer = registerClientReference(\n    function() { throw new Error(\"Attempted to call useLexicalDocumentDrawer() from the server but useLexicalDocumentDrawer is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"useLexicalDocumentDrawer\",\n);\nexport const useLexicalDrawer = registerClientReference(\n    function() { throw new Error(\"Attempted to call useLexicalDrawer() from the server but useLexicalDrawer is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"useLexicalDrawer\",\n);\nexport const useLexicalListDrawer = registerClientReference(\n    function() { throw new Error(\"Attempted to call useLexicalListDrawer() from the server but useLexicalListDrawer is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/exports/client/index.js\",\n    \"useLexicalListDrawer\",\n);\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7839, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/shared/slashMenu/basicGroup.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/align/client/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/AlignCenter/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/AlignJustify/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/AlignLeft/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/AlignRight/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/utilities/createClientFeature.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/align/client/toolbarAlignGroup.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blockquote/client/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/Blockquote/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/Text/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/shared/toolbar/textDropdownGroup.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blockquote/markdownTransformer.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/client/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/Block/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/InlineBlocks/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/client/getBlockImageComponent.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/client/markdown/markdownTransformer.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/utilities/jsx/extractPropsFromJSXPropsString.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/utilities/jsx/jsx.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/server/markdown/linesFromMatchToContentAndPropsString.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/client/nodes/BlocksNode.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/server/nodes/BlocksNode.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/client/component/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/client/component/BlockContent.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/client/component/removeEmptyArrayValues.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/client/markdown/getLexicalToMarkdown.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/client/markdown/getMarkdownToLexical.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/client/plugin/commands.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/client/plugin/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/debug/testRecorder/client/plugin/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/utils/environment.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/debug/testRecorder/client/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/debug/treeView/client/plugin/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/debug/treeView/client/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/bold/feature.client.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/Bold/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/shared/toolbarFormatGroup.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/bold/markdownTransformers.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/inlineCode/feature.client.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/Code/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/inlineCode/markdownTransformers.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/italic/feature.client.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/Italic/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/italic/markdownTransformers.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/strikethrough/feature.client.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/Strikethrough/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/strikethrough/markdownTransformers.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/subscript/feature.client.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/Subscript/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/superscript/feature.client.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/Superscript/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/format/underline/feature.client.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/Underline/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/TextState/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/textState/textState.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/textState/feature.client.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/heading/client/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/H1/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/H2/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/H3/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/H4/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/H5/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/H6/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/heading/markdownTransformer.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/utils/markdown/createBlockNode.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/horizontalRule/client/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/HorizontalRule/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/Add/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/shared/toolbar/addDropdownGroup.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/horizontalRule/server/nodes/HorizontalRuleNode.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/horizontalRule/client/nodes/HorizontalRuleNode.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/horizontalRule/client/markdownTransformer.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/horizontalRule/client/plugin/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/indent/client/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/IndentDecrease/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/IndentIncrease/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/indent/client/IndentPlugin.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/indent/client/toolbarIndentGroup.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/link/client/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/Link/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/utils/getSelectedNode.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/shared/toolbar/featureButtonsGroup.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/link/markdownTransformer.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/link/nodes/LinkNode.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/link/nodes/AutoLinkNode.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/link/client/plugins/autoLink/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/link/client/plugins/clickableLink/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/link/client/plugins/floatingLinkEditor/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/link/client/plugins/floatingLinkEditor/LinkEditor/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/utils/setFloatingElemPositionForLinkEditor.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/link/client/plugins/floatingLinkEditor/LinkEditor/commands.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/link/client/plugins/link/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/utils/url.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/checklist/client/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/Checklist/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/plugin/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/shared/shouldRegisterListBaseNodes.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/shared/slashMenuListGroup.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/checklist/markdownTransformers.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/shared/markdown.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/checklist/client/plugin/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/orderedList/client/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/OrderedList/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/orderedList/markdownTransformer.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/unorderedList/client/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/UnorderedList/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/lists/unorderedList/markdownTransformer.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/migrations/lexicalPluginToLexical/nodes/unknownConvertedNode/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/migrations/lexicalPluginToLexical/feature.client.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/migrations/slateToLexical/nodes/unknownConvertedNode/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/migrations/slateToLexical/feature.client.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/paragraph/client/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/debug/jsxConverter/client/plugin/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToJSX/Component/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToJSX/converter/converters/blockquote.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToJSX/converter/converters/heading.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToJSX/converter/converters/horizontalRule.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToJSX/converter/converters/linebreak.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToJSX/converter/converters/link.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToJSX/converter/converters/list.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToJSX/converter/converters/paragraph.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToJSX/converter/converters/tab.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToJSX/converter/converters/table.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToJSX/converter/converters/text.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/utils/nodeFormat.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToJSX/converter/converters/upload.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToJSX/converter/defaultConverters.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToJSX/converter/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/validate/hasText.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/debug/jsxConverter/client/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/textState/defaultColors.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/relationship/client/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/Relationship/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/relationship/client/nodes/RelationshipNode.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/relationship/server/nodes/RelationshipNode.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/relationship/client/plugins/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/relationship/client/drawer/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/utilities/fieldsDrawer/useLexicalListDrawer.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/relationship/client/utils/useEnabledRelationships.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/toolbars/fixed/client/Toolbar/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/toolbars/shared/ToolbarButton/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/toolbars/shared/ToolbarDropdown/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/toolbars/shared/ToolbarDropdown/DropDown.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/toolbars/fixed/client/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/toolbars/inline/client/Toolbar/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/utils/getDOMRangeRect.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/utils/setFloatingElemPosition.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/toolbars/inline/client/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/experimental_table/client/index.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/Table/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/experimental_table/markdownTransformer.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/experimental_table/client/plugins/TableActionMenuPlugin/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/Meatballs/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/experimental_table/client/plugins/TableCellResizerPlugin/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/experimental_table/client/plugins/TableHoverActionsPlugin/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/experimental_table/client/utils/useDebounce.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/experimental_table/client/utils/debounce.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/experimental_table/client/plugins/TablePlugin/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/upload/client/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/Upload/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/upload/client/nodes/UploadNode.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/upload/server/nodes/conversions.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/upload/server/nodes/UploadNode.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/upload/client/component/pending/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/upload/client/plugin/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/upload/client/drawer/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/field/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/theme/EditorTheme.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/config/client/default.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/config/client/loader.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/config/client/sanitize.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/utils/guard.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/utils/joinClasses.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/utils/swipe.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/client/componentInline/components/InlineBlockEditButton.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/client/componentInline/components/InlineBlockRemoveButton.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/client/componentInline/components/InlineBlockLabel.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/client/componentInline/components/InlineBlockContainer.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/client/component/components/BlockCollapsible.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/client/component/components/BlockEditButton.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/client/component/components/BlockRemoveButton.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/utilities/restPopulateFn.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/premade/CodeBlock/converter.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/premade/CodeBlock/Component/Code.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/premade/CodeBlock/Component/defaultLanguages.ts","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/premade/CodeBlock/Component/Block.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/CodeBlock/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/premade/CodeBlock/Component/Collapse/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/ui/icons/Collapse/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/blocks/premade/CodeBlock/Component/FloatingCollapse/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/field/RenderLexical/index.tsx","file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/utilities/buildEditorState.ts"],"sourcesContent":["import type {\n  SlashMenuGroup,\n  SlashMenuItem,\n} from '../../../lexical/plugins/SlashMenu/LexicalTypeaheadMenuPlugin/types.js'\n\nexport function slashMenuBasicGroupWithItems(items: SlashMenuItem[]): SlashMenuGroup {\n  return {\n    items,\n    key: 'basic',\n    label: ({ i18n }) => {\n      return i18n.t('lexical:general:slashMenuBasicGroupLabel')\n    },\n  }\n}\n","'use client'\n\nimport { $isElementNode, $isRangeSelection, FORMAT_ELEMENT_COMMAND } from 'lexical'\n\nimport type { ToolbarGroup } from '../../toolbars/types.js'\n\nimport { AlignCenterIcon } from '../../../lexical/ui/icons/AlignCenter/index.js'\nimport { AlignJustifyIcon } from '../../../lexical/ui/icons/AlignJustify/index.js'\nimport { AlignLeftIcon } from '../../../lexical/ui/icons/AlignLeft/index.js'\nimport { AlignRightIcon } from '../../../lexical/ui/icons/AlignRight/index.js'\nimport { createClientFeature } from '../../../utilities/createClientFeature.js'\nimport { toolbarAlignGroupWithItems } from './toolbarAlignGroup.js'\n\nconst toolbarGroups: ToolbarGroup[] = [\n  toolbarAlignGroupWithItems([\n    {\n      ChildComponent: AlignLeftIcon,\n      isActive: ({ selection }) => {\n        if (!$isRangeSelection(selection)) {\n          return false\n        }\n        for (const node of selection.getNodes()) {\n          if ($isElementNode(node)) {\n            if (node.getFormatType() === 'left') {\n              continue\n            }\n          }\n\n          const parent = node.getParent()\n          if ($isElementNode(parent)) {\n            if (parent.getFormatType() === 'left') {\n              continue\n            }\n          }\n\n          return false\n        }\n        return true\n      },\n      key: 'alignLeft',\n      label: ({ i18n }) => {\n        return i18n.t('lexical:align:alignLeftLabel')\n      },\n      onSelect: ({ editor }) => {\n        editor.dispatchCommand(FORMAT_ELEMENT_COMMAND, 'left')\n      },\n      order: 1,\n    },\n    {\n      ChildComponent: AlignCenterIcon,\n      isActive: ({ selection }) => {\n        if (!$isRangeSelection(selection)) {\n          return false\n        }\n        for (const node of selection.getNodes()) {\n          if ($isElementNode(node)) {\n            if (node.getFormatType() === 'center') {\n              continue\n            }\n          }\n\n          const parent = node.getParent()\n          if ($isElementNode(parent)) {\n            if (parent.getFormatType() === 'center') {\n              continue\n            }\n          }\n\n          return false\n        }\n        return true\n      },\n      key: 'alignCenter',\n      label: ({ i18n }) => {\n        return i18n.t('lexical:align:alignCenterLabel')\n      },\n      onSelect: ({ editor }) => {\n        editor.dispatchCommand(FORMAT_ELEMENT_COMMAND, 'center')\n      },\n      order: 2,\n    },\n    {\n      ChildComponent: AlignRightIcon,\n      isActive: ({ selection }) => {\n        if (!$isRangeSelection(selection)) {\n          return false\n        }\n        for (const node of selection.getNodes()) {\n          if ($isElementNode(node)) {\n            if (node.getFormatType() === 'right') {\n              continue\n            }\n          }\n\n          const parent = node.getParent()\n          if ($isElementNode(parent)) {\n            if (parent.getFormatType() === 'right') {\n              continue\n            }\n          }\n\n          return false\n        }\n        return true\n      },\n      key: 'alignRight',\n      label: ({ i18n }) => {\n        return i18n.t('lexical:align:alignRightLabel')\n      },\n      onSelect: ({ editor }) => {\n        editor.dispatchCommand(FORMAT_ELEMENT_COMMAND, 'right')\n      },\n      order: 3,\n    },\n    {\n      ChildComponent: AlignJustifyIcon,\n      isActive: ({ selection }) => {\n        if (!$isRangeSelection(selection)) {\n          return false\n        }\n        for (const node of selection.getNodes()) {\n          if ($isElementNode(node)) {\n            if (node.getFormatType() === 'justify') {\n              continue\n            }\n          }\n\n          const parent = node.getParent()\n          if ($isElementNode(parent)) {\n            if (parent.getFormatType() === 'justify') {\n              continue\n            }\n          }\n\n          return false\n        }\n        return true\n      },\n      key: 'alignJustify',\n      label: ({ i18n }) => {\n        return i18n.t('lexical:align:alignJustifyLabel')\n      },\n      onSelect: ({ editor }) => {\n        editor.dispatchCommand(FORMAT_ELEMENT_COMMAND, 'justify')\n      },\n      order: 4,\n    },\n  ]),\n]\n\nexport const AlignFeatureClient = createClientFeature({\n  toolbarFixed: {\n    groups: toolbarGroups,\n  },\n  toolbarInline: {\n    groups: toolbarGroups,\n  },\n})\n","'use client'\nimport React from 'react'\n\nexport const AlignCenterIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path d=\"M2.5 5H17.5\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n    <path d=\"M2.5 10H17.5\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n    <path d=\"M5 15H15\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n  </svg>\n)\n","'use client'\nimport React from 'react'\n\nexport const AlignJustifyIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path d=\"M2.5 5H17.5\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n    <path d=\"M2.5 10H17.5\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n    <path d=\"M2.5 15H17.5\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n  </svg>\n)\n","'use client'\nimport React from 'react'\n\nexport const AlignLeftIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path d=\"M2.5 5H17.5\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n    <path d=\"M2.5 10H17.5\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n    <path d=\"M2.5 15H12.5\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n  </svg>\n)\n","'use client'\nimport React from 'react'\n\nexport const AlignRightIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path d=\"M2.5 5H17.5\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n    <path d=\"M2.5 10H17.5\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n    <path d=\"M7.5 15H17.5\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n  </svg>\n)\n","import type { ClientConfig, RichTextFieldClient } from 'payload'\n\nimport type {\n  BaseClientFeatureProps,\n  ClientFeature,\n  ClientFeatureProviderMap,\n  FeatureProviderClient,\n  FeatureProviderProviderClient,\n  ResolvedClientFeatureMap,\n} from '../features/typesClient.js'\nimport type { ClientEditorConfig } from '../lexical/config/types.js'\nimport type { FeatureClientSchemaMap } from '../types.js'\n\nexport type CreateClientFeatureArgs<UnSanitizedClientProps, ClientProps> =\n  | ((props: {\n      config: ClientConfig\n      featureClientImportMap: Record<string, any>\n      featureClientSchemaMap: FeatureClientSchemaMap\n      /** unSanitizedEditorConfig.features, but mapped */\n      featureProviderMap: ClientFeatureProviderMap\n      field?: RichTextFieldClient\n      props: BaseClientFeatureProps<UnSanitizedClientProps>\n      // other resolved features, which have been loaded before this one. All features declared in 'dependencies' should be available here\n      resolvedFeatures: ResolvedClientFeatureMap\n      schemaPath: string\n      // unSanitized EditorConfig,\n      unSanitizedEditorConfig: ClientEditorConfig\n    }) => ClientFeature<ClientProps>)\n  | Omit<ClientFeature<ClientProps>, 'sanitizedClientFeatureProps'>\n\nexport const createClientFeature: <\n  UnSanitizedClientProps = undefined,\n  ClientProps = UnSanitizedClientProps,\n>(\n  args: CreateClientFeatureArgs<UnSanitizedClientProps, ClientProps>,\n) => FeatureProviderProviderClient<UnSanitizedClientProps, ClientProps> = (feature) => {\n  const featureProviderProvideClient: FeatureProviderProviderClient<any, any> = (props) => {\n    const featureProviderClient: Partial<FeatureProviderClient<any, any>> = {\n      clientFeatureProps: props,\n    }\n\n    if (typeof feature === 'function') {\n      featureProviderClient.feature = ({\n        config,\n        featureClientImportMap,\n        featureClientSchemaMap,\n        featureProviderMap,\n        field,\n        resolvedFeatures,\n        schemaPath,\n        unSanitizedEditorConfig,\n      }) => {\n        const toReturn = feature({\n          config,\n          featureClientImportMap,\n          featureClientSchemaMap,\n          featureProviderMap,\n          field,\n          props,\n          resolvedFeatures,\n          schemaPath,\n          unSanitizedEditorConfig,\n        })\n\n        if (toReturn.sanitizedClientFeatureProps === null) {\n          toReturn.sanitizedClientFeatureProps = props\n        }\n\n        return toReturn\n      }\n    } else {\n      // We have to spread feature here! Otherwise, if the arg of createClientFeature is not a function, and 2\n      // richText editors have the same feature (even if both call it, e.g. both call UploadFeature()),\n      // the second richText editor here will override sanitizedClientFeatureProps of the first feature, as both richText\n      // editor features share the same reference to the feature object.\n      // Example: richText editor 1 and 2 both have UploadFeature. richText editor 1 calls UploadFeature() with custom fields,\n      // richText editor 2 calls UploadFeature() with NO custom fields. If we don't spread feature here, richText editor 1\n      // will not have any custom fields, as richText editor 2 will override the feature object.\n      const newFeature: ClientFeature<any> = { ...feature }\n      newFeature.sanitizedClientFeatureProps = props\n      featureProviderClient.feature = newFeature\n    }\n    return featureProviderClient as FeatureProviderClient<any, any>\n  }\n\n  return featureProviderProvideClient\n}\n","'use client'\nimport type { ToolbarGroup, ToolbarGroupItem } from '../../toolbars/types.js'\n\nimport { AlignLeftIcon } from '../../../lexical/ui/icons/AlignLeft/index.js'\n\nexport const toolbarAlignGroupWithItems = (items: ToolbarGroupItem[]): ToolbarGroup => {\n  return {\n    type: 'dropdown',\n    ChildComponent: AlignLeftIcon,\n    items,\n    key: 'align',\n    order: 30,\n  }\n}\n","'use client'\n\nimport { $createQuoteNode, $isQuoteNode, QuoteNode } from '@lexical/rich-text'\nimport { $setBlocksType } from '@lexical/selection'\nimport { $getSelection, $isRangeSelection } from 'lexical'\n\nimport type { ToolbarGroup } from '../../toolbars/types.js'\n\nimport { BlockquoteIcon } from '../../../lexical/ui/icons/Blockquote/index.js'\nimport { createClientFeature } from '../../../utilities/createClientFeature.js'\nimport { slashMenuBasicGroupWithItems } from '../../shared/slashMenu/basicGroup.js'\nimport { toolbarTextDropdownGroupWithItems } from '../../shared/toolbar/textDropdownGroup.js'\nimport { MarkdownTransformer } from '../markdownTransformer.js'\n\nconst toolbarGroups: ToolbarGroup[] = [\n  toolbarTextDropdownGroupWithItems([\n    {\n      ChildComponent: BlockquoteIcon,\n      isActive: ({ selection }) => {\n        if (!$isRangeSelection(selection)) {\n          return false\n        }\n        for (const node of selection.getNodes()) {\n          if (!$isQuoteNode(node) && !$isQuoteNode(node.getParent())) {\n            return false\n          }\n        }\n        return true\n      },\n      key: 'blockquote',\n      label: ({ i18n }) => {\n        return i18n.t('lexical:blockquote:label')\n      },\n      onSelect: ({ editor }) => {\n        editor.update(() => {\n          const selection = $getSelection()\n          $setBlocksType(selection, () => $createQuoteNode())\n        })\n      },\n      order: 20,\n    },\n  ]),\n]\n\nexport const BlockquoteFeatureClient = createClientFeature({\n  markdownTransformers: [MarkdownTransformer],\n  nodes: [QuoteNode],\n\n  slashMenu: {\n    groups: [\n      slashMenuBasicGroupWithItems([\n        {\n          Icon: BlockquoteIcon,\n          key: 'blockquote',\n          keywords: ['quote', 'blockquote'],\n          label: ({ i18n }) => {\n            return i18n.t('lexical:blockquote:label')\n          },\n          onSelect: ({ editor }) => {\n            editor.update(() => {\n              const selection = $getSelection()\n              $setBlocksType(selection, () => $createQuoteNode())\n            })\n          },\n        },\n      ]),\n    ],\n  },\n  toolbarFixed: {\n    groups: toolbarGroups,\n  },\n  toolbarInline: {\n    groups: toolbarGroups,\n  },\n})\n","'use client'\nimport React from 'react'\n\nexport const BlockquoteIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path\n      d=\"M13.5353 10.5725C13.5353 9.47709 11.0456 9.99991 11.0456 7.85883C11.0456 6.46464 12.1162 5.61816 13.361 5.61816C14.805 5.61816 16 6.86298 16 8.92937C16 11.2945 14.4564 13.7841 11.1203 14.3816L10.8216 13.1368C12.888 12.4895 13.5353 11.4937 13.5353 10.5725ZM6.71369 10.5725C6.71369 9.47709 4.22407 9.99991 4.22407 7.85883C4.22407 6.46464 5.29461 5.61816 6.53942 5.61816C7.9834 5.61816 9.17842 6.86298 9.17842 8.92937C9.17842 11.2945 7.63485 13.7841 4.29876 14.3816L4 13.1368C6.06639 12.4895 6.71369 11.4937 6.71369 10.5725Z\"\n      fill=\"currentColor\"\n    />\n  </svg>\n)\n","'use client'\nimport React from 'react'\n\nexport const TextIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"currentColor\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path\n      d=\"M11.708 14.5H7.79785V13.9414H8.01367C9.00391 13.9414 9.15625 13.9033 9.15625 13.6113V6.70508H8.07715C6.82031 6.70508 6.73145 7.08594 6.28711 8.67285H5.80469L5.91895 6.12109H13.5869L13.7012 8.67285H13.2188C12.7744 7.08594 12.6855 6.70508 11.4287 6.70508H10.3496V13.6113C10.3496 13.9033 10.502 13.9414 11.4922 13.9414H11.708V14.5Z\"\n      fill=\"currentColor\"\n    />\n  </svg>\n)\n","import type { ToolbarGroup, ToolbarGroupItem } from '../../toolbars/types.js'\n\nimport { TextIcon } from '../../../lexical/ui/icons/Text/index.js'\n\nexport const toolbarTextDropdownGroupWithItems = (items: ToolbarGroupItem[]): ToolbarGroup => {\n  return {\n    type: 'dropdown',\n    ChildComponent: TextIcon,\n    items,\n    key: 'text',\n    order: 25,\n  }\n}\n","import { $createQuoteNode, $isQuoteNode, QuoteNode } from '@lexical/rich-text'\n\nimport type { ElementTransformer } from '../../packages/@lexical/markdown/index.js'\n\nexport const MarkdownTransformer: ElementTransformer = {\n  type: 'element',\n  dependencies: [QuoteNode],\n  export: (node, exportChildren) => {\n    if (!$isQuoteNode(node)) {\n      return null\n    }\n\n    const lines = exportChildren(node).split('\\n')\n    const output: string[] = []\n    for (const line of lines) {\n      output.push('> ' + line)\n    }\n    return output.join('\\n')\n  },\n  regExp: /^>\\s/,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling()\n      if ($isQuoteNode(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [...children])\n        previousNode.select(0, 0)\n        parentNode.remove()\n        return\n      }\n    }\n\n    const node = $createQuoteNode()\n    node.append(...children)\n    parentNode.replace(node)\n    node.select(0, 0)\n  },\n}\n","'use client'\n\nimport type { I18nClient } from '@payloadcms/translations'\nimport type { BlocksFieldClient, ClientBlock } from 'payload'\n\nimport { getTranslation } from '@payloadcms/translations'\n\nimport type {\n  SlashMenuGroup,\n  SlashMenuItem,\n} from '../../../lexical/plugins/SlashMenu/LexicalTypeaheadMenuPlugin/types.js'\nimport type { ToolbarGroup, ToolbarGroupItem } from '../../toolbars/types.js'\n\nimport { BlockIcon } from '../../../lexical/ui/icons/Block/index.js'\nimport { InlineBlocksIcon } from '../../../lexical/ui/icons/InlineBlocks/index.js'\nimport { createClientFeature } from '../../../utilities/createClientFeature.js'\nimport { getBlockImageComponent } from './getBlockImageComponent.js'\nimport { getBlockMarkdownTransformers } from './markdown/markdownTransformer.js'\nimport { BlockNode } from './nodes/BlocksNode.js'\nimport { InlineBlockNode } from './nodes/InlineBlocksNode.js'\nimport { INSERT_BLOCK_COMMAND, INSERT_INLINE_BLOCK_COMMAND } from './plugin/commands.js'\nimport { BlocksPlugin } from './plugin/index.js'\nexport const BlocksFeatureClient = createClientFeature(\n  ({ config, featureClientSchemaMap, props, schemaPath }) => {\n    const schemaMapRenderedBlockPathPrefix = `${schemaPath}.lexical_internal_feature.blocks.lexical_blocks`\n    const schemaMapRenderedInlineBlockPathPrefix = `${schemaPath}.lexical_internal_feature.blocks.lexical_inline_blocks`\n    const clientSchema = featureClientSchemaMap['blocks']\n\n    if (!clientSchema) {\n      return {}\n    }\n\n    const blocksFields: BlocksFieldClient[] = Object.entries(clientSchema)\n      .filter(\n        ([key]) =>\n          key.startsWith(schemaMapRenderedBlockPathPrefix + '.') &&\n          !key.replace(schemaMapRenderedBlockPathPrefix + '.', '').includes('.'),\n      )\n      .map(([, value]) => value[0] as BlocksFieldClient)\n\n    const inlineBlocksFields: BlocksFieldClient[] = Object.entries(clientSchema)\n      .filter(\n        ([key]) =>\n          key.startsWith(schemaMapRenderedInlineBlockPathPrefix + '.') &&\n          !key.replace(schemaMapRenderedInlineBlockPathPrefix + '.', '').includes('.'),\n      )\n      .map(([, value]) => value[0] as BlocksFieldClient)\n\n    const clientBlocks: ClientBlock[] = blocksFields\n      .map((field) => {\n        return field.blockReferences\n          ? typeof field.blockReferences[0] === 'string'\n            ? config.blocksMap[field.blockReferences[0]]\n            : field.blockReferences[0]\n          : field.blocks[0]\n      })\n      .filter((block) => block !== undefined)\n\n    const clientInlineBlocks: ClientBlock[] = inlineBlocksFields\n      .map((field) => {\n        return field.blockReferences\n          ? typeof field.blockReferences[0] === 'string'\n            ? config.blocksMap[field.blockReferences[0]]\n            : field.blockReferences[0]\n          : field.blocks[0]\n      })\n      .filter((block) => block !== undefined)\n\n    return {\n      markdownTransformers: getBlockMarkdownTransformers({\n        blocks: clientBlocks,\n        inlineBlocks: clientInlineBlocks,\n      }),\n      nodes: [BlockNode, InlineBlockNode],\n      plugins: [\n        {\n          Component: BlocksPlugin,\n          position: 'normal',\n        },\n      ],\n      sanitizedClientFeatureProps: props,\n      slashMenu: {\n        groups: [\n          clientBlocks?.length\n            ? {\n                items: clientBlocks.map((block) => {\n                  return {\n                    Icon: getBlockImageComponent(block.imageURL, block.imageAltText),\n                    key: 'block-' + block.slug,\n                    keywords: ['block', 'blocks', block.slug],\n                    label: ({ i18n }) => {\n                      const blockDisplayName = block?.labels?.singular\n                        ? getTranslation(block.labels.singular, i18n)\n                        : block?.slug\n\n                      return blockDisplayName\n                    },\n                    onSelect: ({ editor }) => {\n                      editor.dispatchCommand(INSERT_BLOCK_COMMAND, {\n                        blockName: '',\n                        blockType: block.slug,\n                      })\n                    },\n                  } as SlashMenuItem\n                }),\n                key: 'blocks',\n                label: ({ i18n }: { i18n: I18nClient<object, 'lexical:blocks:label'> }) => {\n                  return i18n.t('lexical:blocks:label')\n                },\n              }\n            : null,\n          clientInlineBlocks?.length\n            ? {\n                items: clientInlineBlocks.map((inlineBlock) => {\n                  return {\n                    Icon: InlineBlocksIcon,\n                    key: 'inlineBlocks-' + inlineBlock.slug,\n                    keywords: ['inlineBlock', 'inline block', inlineBlock.slug],\n                    label: ({ i18n }) => {\n                      const blockDisplayName = inlineBlock?.labels?.singular\n                        ? getTranslation(inlineBlock.labels.singular, i18n)\n                        : inlineBlock?.slug\n\n                      return blockDisplayName\n                    },\n                    onSelect: ({ editor }) => {\n                      editor.dispatchCommand(INSERT_INLINE_BLOCK_COMMAND, {\n                        blockName: '',\n                        blockType: inlineBlock.slug,\n                      })\n                    },\n                  } as SlashMenuItem\n                }),\n                key: 'inlineBlocks',\n                label: ({\n                  i18n,\n                }: {\n                  i18n: I18nClient<object, 'lexical:blocks:inlineBlocks:label'>\n                }) => {\n                  return i18n.t('lexical:blocks:inlineBlocks:label')\n                },\n              }\n            : null,\n        ].filter(Boolean) as SlashMenuGroup[],\n      },\n      toolbarFixed: {\n        groups: [\n          clientBlocks.length\n            ? {\n                type: 'dropdown',\n                ChildComponent: BlockIcon,\n                items: clientBlocks.map((block, index) => {\n                  return {\n                    ChildComponent: getBlockImageComponent(block.imageURL, block.imageAltText),\n                    isActive: undefined, // At this point, we would be inside a sub-richtext-editor. And at this point this will be run against the focused sub-editor, not the parent editor which has the actual block. Thus, no point in running this\n                    key: 'block-' + block.slug,\n                    label: ({ i18n }) => {\n                      const blockDisplayName = block?.labels?.singular\n                        ? getTranslation(block.labels.singular, i18n)\n                        : block?.slug\n\n                      return blockDisplayName\n                    },\n                    onSelect: ({ editor }) => {\n                      editor.dispatchCommand(INSERT_BLOCK_COMMAND, {\n                        blockName: '',\n                        blockType: block.slug,\n                      })\n                    },\n                    order: index,\n                  } as ToolbarGroupItem\n                }),\n                key: 'blocks',\n                order: 20,\n              }\n            : null,\n          clientInlineBlocks?.length\n            ? {\n                type: 'dropdown',\n                ChildComponent: InlineBlocksIcon,\n                items: clientInlineBlocks.map((inlineBlock, index) => {\n                  return {\n                    ChildComponent: inlineBlock.imageURL\n                      ? getBlockImageComponent(inlineBlock.imageURL, inlineBlock.imageAltText)\n                      : InlineBlocksIcon,\n                    isActive: undefined,\n                    key: 'inlineBlock-' + inlineBlock.slug,\n                    label: ({ i18n }) => {\n                      const blockDisplayName = inlineBlock?.labels?.singular\n                        ? getTranslation(inlineBlock.labels.singular, i18n)\n                        : inlineBlock?.slug\n\n                      return blockDisplayName\n                    },\n                    onSelect: ({ editor }) => {\n                      editor.dispatchCommand(INSERT_INLINE_BLOCK_COMMAND, {\n                        blockName: '',\n                        blockType: inlineBlock.slug,\n                      })\n                    },\n                    order: index,\n                  } as ToolbarGroupItem\n                }),\n                key: 'inlineBlocks',\n                order: 25,\n              }\n            : null,\n        ].filter(Boolean) as ToolbarGroup[],\n      },\n    }\n  },\n)\n","'use client'\nimport React from 'react'\n\nexport const BlockIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <rect height=\"4\" rx=\"0.5\" stroke=\"currentColor\" width=\"4\" x=\"8\" y=\"5\" />\n    <rect height=\"4\" rx=\"0.5\" stroke=\"currentColor\" width=\"4\" x=\"5\" y=\"11\" />\n    <rect height=\"4\" rx=\"0.5\" stroke=\"currentColor\" width=\"4\" x=\"11\" y=\"11\" />\n  </svg>\n)\n","'use client'\nimport React from 'react'\n\nexport const InlineBlocksIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path\n      clipRule=\"evenodd\"\n      d=\"M5.33333 6.5C5.11232 6.5 4.90036 6.5878 4.74408 6.74408C4.5878 6.90036 4.5 7.11232 4.5 7.33333V12.1667C4.5 12.3877 4.5878 12.5996 4.74408 12.7559C4.90036 12.9122 5.11232 13 5.33333 13H14.6667C14.8877 13 15.0996 12.9122 15.2559 12.7559C15.4122 12.5996 15.5 12.3877 15.5 12.1667V11.6667C15.5 11.3905 15.7239 11.1667 16 11.1667C16.2761 11.1667 16.5 11.3905 16.5 11.6667V12.1667C16.5 12.6529 16.3068 13.1192 15.963 13.463C15.6192 13.8068 15.1529 14 14.6667 14H5.33333C4.8471 14 4.38079 13.8068 4.03697 13.463C3.69315 13.1192 3.5 12.6529 3.5 12.1667V7.33333C3.5 6.8471 3.69315 6.38079 4.03697 6.03697C4.38079 5.69315 4.8471 5.5 5.33333 5.5H10.3333C10.6095 5.5 10.8333 5.72386 10.8333 6C10.8333 6.27614 10.6095 6.5 10.3333 6.5H5.33333ZM13 6.5C12.7239 6.5 12.5 6.27614 12.5 6C12.5 5.72386 12.7239 5.5 13 5.5H16C16.2761 5.5 16.5 5.72386 16.5 6V9C16.5 9.27614 16.2761 9.5 16 9.5C15.7239 9.5 15.5 9.27614 15.5 9V7.20711L13.3536 9.35355C13.1583 9.54882 12.8417 9.54882 12.6464 9.35355C12.4512 9.15829 12.4512 8.84171 12.6464 8.64645L14.7929 6.5H13ZM6.16699 8.33325C6.16699 8.05711 6.39085 7.83325 6.66699 7.83325H11.0003C11.2765 7.83325 11.5003 8.05711 11.5003 8.33325C11.5003 8.60939 11.2765 8.83325 11.0003 8.83325H6.66699C6.39085 8.83325 6.16699 8.60939 6.16699 8.33325ZM6.16699 10.9999C6.16699 10.7238 6.39085 10.4999 6.66699 10.4999H13.3337C13.6098 10.4999 13.8337 10.7238 13.8337 10.9999C13.8337 11.2761 13.6098 11.4999 13.3337 11.4999H6.66699C6.39085 11.4999 6.16699 11.2761 6.16699 10.9999Z\"\n      fill=\"currentColor\"\n      fillRule=\"evenodd\"\n    />\n  </svg>\n)\n","import React from 'react'\n\nimport { BlockIcon } from '../../../lexical/ui/icons/Block/index.js'\n\nexport function getBlockImageComponent(imageURL?: string, imageAltText?: string) {\n  if (!imageURL) {\n    return BlockIcon\n  }\n\n  return () => (\n    <img\n      alt={imageAltText ?? 'Block Image'}\n      className=\"lexical-block-custom-image\"\n      src={imageURL}\n      style={{ maxHeight: 20, maxWidth: 20 }}\n    />\n  )\n}\n","import type { ClientBlock } from 'payload'\n\nimport {\n  $parseSerializedNode,\n  type ElementNode,\n  type Klass,\n  type LexicalNode,\n  type LexicalNodeReplacement,\n  type SerializedLexicalNode,\n} from 'lexical'\n\nimport type { Transformer } from '../../../../packages/@lexical/markdown/index.js'\nimport type {\n  MultilineElementTransformer,\n  TextMatchTransformer,\n} from '../../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport { extractPropsFromJSXPropsString } from '../../../../utilities/jsx/extractPropsFromJSXPropsString.js'\nimport { propsToJSXString } from '../../../../utilities/jsx/jsx.js'\nimport { linesFromStartToContentAndPropsString } from '../../server/markdown/linesFromMatchToContentAndPropsString.js'\nimport { $createBlockNode, $isBlockNode, BlockNode } from '../nodes/BlocksNode.js'\nimport {\n  $createInlineBlockNode,\n  $isInlineBlockNode,\n  InlineBlockNode,\n} from '../nodes/InlineBlocksNode.js'\nimport { getLexicalToMarkdown } from './getLexicalToMarkdown.js'\nimport { getMarkdownToLexical } from './getMarkdownToLexical.js'\n\nfunction createTagRegexes(tagName: string) {\n  const escapedTagName = tagName.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n  return {\n    regExpEnd: new RegExp(`</(${escapedTagName})\\\\s*>|<${escapedTagName}[^>]*?/>`, 'i'),\n    regExpStart: new RegExp(`<(${escapedTagName})([^>]*?)\\\\s*(/?)>`, 'i'),\n  }\n}\nexport const getBlockMarkdownTransformers = ({\n  blocks,\n  inlineBlocks,\n}: {\n  blocks: ClientBlock[]\n  inlineBlocks: ClientBlock[]\n}): ((props: {\n  allNodes: Array<Klass<LexicalNode> | LexicalNodeReplacement>\n  allTransformers: Transformer[]\n}) => MultilineElementTransformer | TextMatchTransformer)[] => {\n  if (!blocks?.length && !inlineBlocks?.length) {\n    return []\n  }\n  let transformers: ((props: {\n    allNodes: Array<Klass<LexicalNode> | LexicalNodeReplacement>\n    allTransformers: Transformer[]\n  }) => MultilineElementTransformer | TextMatchTransformer)[] = []\n\n  if (blocks?.length) {\n    for (const block of blocks) {\n      const transformer = getMarkdownTransformerForBlock(block, false)\n\n      if (transformer) {\n        transformers = transformers.concat(transformer)\n      }\n    }\n  }\n\n  if (inlineBlocks?.length) {\n    for (const block of inlineBlocks) {\n      const transformer = getMarkdownTransformerForBlock(block, true)\n\n      if (transformer) {\n        transformers = transformers.concat(transformer)\n      }\n    }\n  }\n\n  return transformers\n}\n\nfunction getMarkdownTransformerForBlock(\n  block: ClientBlock,\n  isInlineBlock: boolean,\n): Array<\n  (props: {\n    allNodes: Array<Klass<LexicalNode> | LexicalNodeReplacement>\n    allTransformers: Transformer[]\n  }) => MultilineElementTransformer | TextMatchTransformer\n> | null {\n  if (!block.jsx) {\n    return null\n  }\n  const regex = createTagRegexes(block.slug)\n  const toReturn: Array<\n    (props: {\n      allNodes: Array<Klass<LexicalNode> | LexicalNodeReplacement>\n      allTransformers: Transformer[]\n    }) => MultilineElementTransformer | TextMatchTransformer\n  > = []\n\n  if (isInlineBlock) {\n    toReturn.push(({ allNodes, allTransformers }) => ({\n      type: 'text-match',\n      dependencies: [InlineBlockNode],\n      export: (node) => {\n        if (!$isInlineBlockNode(node)) {\n          return null\n        }\n\n        if (node.getFields()?.blockType?.toLowerCase() !== block.slug.toLowerCase()) {\n          return null\n        }\n\n        const nodeFields = node.getFields()\n        const lexicalToMarkdown = getLexicalToMarkdown(allNodes, allTransformers)\n\n        const exportResult = block.jsx!.export({\n          fields: nodeFields,\n          lexicalToMarkdown,\n        })\n        if (exportResult === false) {\n          return null\n        }\n        if (typeof exportResult === 'string') {\n          return exportResult\n        }\n\n        const hasProps = exportResult.props && Object.keys(exportResult.props)?.length > 0\n        const props = exportResult.props ?? {}\n\n        if (exportResult?.children?.length) {\n          return `<${nodeFields.blockType}${hasProps ? ' ' + propsToJSXString({ props }) : ''}>${exportResult.children}</${nodeFields.blockType}>`\n        }\n\n        return `<${nodeFields.blockType}${hasProps ? ' ' + propsToJSXString({ props }) : ''}/>`\n      },\n      getEndIndex: (node, match) => {\n        const { endlineLastCharIndex } = linesFromStartToContentAndPropsString({\n          isEndOptional: false,\n          lines: [node.getTextContent()],\n          regexpEndRegex: regex.regExpEnd,\n          startLineIndex: 0,\n          startMatch: match,\n          trimChildren: false,\n        })\n\n        return endlineLastCharIndex\n      },\n      importRegExp: block.jsx?.customStartRegex ?? regex.regExpStart,\n      regExp: /___ignoreignoreignore___/g,\n      replace(node, match) {\n        const { content, propsString } = linesFromStartToContentAndPropsString({\n          isEndOptional: false,\n          lines: [node.getTextContent()],\n          regexpEndRegex: regex.regExpEnd,\n          startLineIndex: 0,\n          startMatch: {\n            ...match,\n            index: 0,\n          },\n          trimChildren: false,\n        })\n\n        if (!block?.jsx?.import) {\n          // No multiline transformer handled this line successfully\n          return\n        }\n\n        const markdownToLexical = getMarkdownToLexical(allNodes, allTransformers)\n\n        const blockFields = block.jsx.import({\n          children: content,\n          closeMatch: null,\n          htmlToLexical: null, // TODO\n          markdownToLexical,\n          openMatch: match,\n          props: propsString\n            ? extractPropsFromJSXPropsString({\n                propsString,\n              })\n            : {},\n        })\n        if (blockFields === false) {\n          return\n        }\n\n        const inlineBlockNode = $createInlineBlockNode({\n          blockType: block.slug,\n          ...(blockFields as any),\n        })\n\n        node.replace(inlineBlockNode)\n      },\n    }))\n\n    return toReturn\n  }\n\n  toReturn.push(({ allNodes, allTransformers }) => ({\n    dependencies: [BlockNode],\n    export: (node) => {\n      if (!$isBlockNode(node)) {\n        return null\n      }\n\n      if (node.getFields()?.blockType?.toLowerCase() !== block.slug.toLowerCase()) {\n        return null\n      }\n\n      const nodeFields = node.getFields()\n      const lexicalToMarkdown = getLexicalToMarkdown(allNodes, allTransformers)\n\n      const exportResult = block.jsx!.export({\n        fields: nodeFields,\n        lexicalToMarkdown,\n      })\n      if (exportResult === false) {\n        return null\n      }\n      if (typeof exportResult === 'string') {\n        return exportResult\n      }\n\n      const hasProps = exportResult.props && Object.keys(exportResult.props)?.length > 0\n      const props = exportResult.props ?? {}\n\n      if (exportResult?.children?.length) {\n        const children = exportResult.children\n        let sanitizedChildren = ''\n\n        // Ensure it has a leftpad of at least 2 spaces. The data is saved without those spaces, so we can just blindly add it to every child\n        if (children.includes('\\n')) {\n          for (const child of children.split('\\n')) {\n            let sanitizedChild = ''\n            if (!block?.jsx?.doNotTrimChildren && child !== '') {\n              sanitizedChild = '  '\n            }\n            sanitizedChild += child + '\\n'\n\n            sanitizedChildren += sanitizedChild\n          }\n        } else {\n          sanitizedChildren = (block?.jsx?.doNotTrimChildren ? '' : '  ') + children + '\\n'\n        }\n\n        return `<${nodeFields.blockType}${hasProps ? ' ' + propsToJSXString({ props }) : ''}>\\n${sanitizedChildren}</${nodeFields.blockType}>`\n      }\n\n      return `<${nodeFields.blockType}${hasProps ? ' ' + propsToJSXString({ props }) : ''}/>`\n    },\n    handleImportAfterStartMatch: block.jsx?.customEndRegex\n      ? undefined\n      : ({ lines, rootNode, startLineIndex, startMatch, transformer }) => {\n          const regexpEndRegex: RegExp | undefined =\n            typeof transformer.regExpEnd === 'object' && 'regExp' in transformer.regExpEnd\n              ? transformer.regExpEnd.regExp\n              : transformer.regExpEnd\n\n          const isEndOptional =\n            transformer.regExpEnd &&\n            typeof transformer.regExpEnd === 'object' &&\n            'optional' in transformer.regExpEnd\n              ? transformer.regExpEnd.optional\n              : !transformer.regExpEnd\n\n          const {\n            afterEndLine,\n            beforeStartLine,\n            content: unsanitizedContent,\n            endLineIndex,\n            propsString,\n          } = linesFromStartToContentAndPropsString({\n            isEndOptional,\n            lines,\n            regexpEndRegex,\n            startLineIndex,\n            startMatch,\n            trimChildren: false,\n          })\n\n          let content = ''\n\n          if (block?.jsx?.doNotTrimChildren) {\n            content = unsanitizedContent.endsWith('\\n')\n              ? unsanitizedContent.slice(0, -1)\n              : unsanitizedContent\n          } else {\n            // Ensure it has a leftpad of at least 2 spaces. The data is saved without those spaces, so we can just blindly add it to every child\n            if (unsanitizedContent.includes('\\n')) {\n              const split = unsanitizedContent.split('\\n')\n              let index = 0\n              for (const child of split) {\n                index++\n\n                if (child.startsWith('  ')) {\n                  content += child.slice(2)\n                } else {\n                  // If one child is misaligned, skip aligning completely, unless it's just empty\n                  if (child === '') {\n                    content += child\n                  } else {\n                    content = unsanitizedContent.endsWith('\\n')\n                      ? unsanitizedContent.slice(0, -1)\n                      : unsanitizedContent\n                    break\n                  }\n                }\n\n                content += index === split.length ? '' : '\\n'\n              }\n            } else {\n              content =\n                (!unsanitizedContent.startsWith('  ')\n                  ? unsanitizedContent\n                  : unsanitizedContent.slice(2)) + '\\n'\n            }\n          }\n\n          if (!block?.jsx?.import) {\n            // No multiline transformer handled this line successfully\n            return [false, startLineIndex]\n          }\n\n          const markdownToLexical = getMarkdownToLexical(allNodes, allTransformers)\n\n          const blockFields = block.jsx.import({\n            children: content,\n            closeMatch: null,\n            htmlToLexical: null, // TODO\n            markdownToLexical,\n            openMatch: startMatch,\n            props: propsString\n              ? extractPropsFromJSXPropsString({\n                  propsString,\n                })\n              : {},\n          })\n          if (blockFields === false) {\n            return [false, startLineIndex]\n          }\n\n          const node = $createBlockNode({\n            blockType: block.slug,\n            ...blockFields,\n          } as any)\n\n          if (node) {\n            // Now handle beforeStartLine and afterEndLine. If those are not empty, we need to add them as text nodes before and after the block node.\n            // However, those themselves can contain other markdown matches, so we need to parse them as well.\n            // Example where this is needed: \"Hello <InlineCode>inline code</InlineCode> test.\"\n            let prevNodes: null | SerializedLexicalNode[] = null\n            let nextNodes: null | SerializedLexicalNode[] = null\n            // TODO: Might not need this prevNodes and nextNodes handling if inline nodes are handled by textmatch transformers\n\n            if (beforeStartLine?.length) {\n              prevNodes = markdownToLexical({ markdown: beforeStartLine })?.root?.children ?? []\n\n              const firstPrevNode = prevNodes?.[0]\n              if (firstPrevNode) {\n                rootNode.append($parseSerializedNode(firstPrevNode))\n              }\n            }\n\n            rootNode.append(node)\n\n            if (afterEndLine?.length) {\n              nextNodes = markdownToLexical({ markdown: afterEndLine })?.root?.children\n              const lastChild = rootNode.getChildren()[rootNode.getChildren().length - 1]\n\n              const children = ($parseSerializedNode(nextNodes[0]!) as ElementNode)?.getChildren()\n              if (children?.length) {\n                for (const child of children) {\n                  ;(lastChild as ElementNode).append(child)\n                }\n              }\n            }\n          }\n\n          return [true, endLineIndex]\n        },\n    regExpEnd: block.jsx?.customEndRegex ?? regex.regExpEnd,\n    regExpStart: block.jsx?.customStartRegex ?? regex.regExpStart,\n    // This replace is ONLY run for ``` code blocks (so any blocks with custom start and end regexes). For others, we use the special JSX handling above:\n    type: 'multiline-element',\n    replace: (rootNode, children, openMatch, closeMatch, linesInBetween) => {\n      if (block?.jsx?.import) {\n        if (!linesInBetween) {\n          // convert children to linesInBetween\n          let line = ''\n          if (children) {\n            for (const child of children) {\n              line += child.getTextContent()\n            }\n          }\n\n          linesInBetween = [line]\n        }\n\n        let childrenString = ''\n        if (block?.jsx?.doNotTrimChildren) {\n          childrenString = linesInBetween.join('\\n')\n        } else {\n          childrenString = linesInBetween.join('\\n').trim()\n        }\n\n        const propsString = openMatch[1]?.trim()\n\n        const markdownToLexical = getMarkdownToLexical(allNodes, allTransformers)\n\n        const blockFields = block.jsx.import({\n          children: childrenString,\n          closeMatch: closeMatch as RegExpMatchArray,\n          htmlToLexical: null, // TODO\n          markdownToLexical,\n          openMatch: openMatch as RegExpMatchArray,\n          props: propsString\n            ? extractPropsFromJSXPropsString({\n                propsString,\n              })\n            : {},\n        })\n        if (blockFields === false) {\n          return false\n        }\n\n        const node = $createBlockNode({\n          blockType: block.slug,\n          ...blockFields,\n        } as any)\n\n        if (node) {\n          rootNode.append(node)\n        }\n\n        return\n      }\n      return false // Run next transformer\n    },\n  }))\n\n  return toReturn\n}\n","import { JSOX } from 'jsox'\n\n/**\n * Turns a JSX props string into an object.\n *\n * @example\n *\n * Input: type=\"info\" hello={{heyyy: 'test', someNumber: 2}}\n * Output: { type: 'info', hello: { heyyy: 'test', someNumber: 2 } }\n */\nexport function extractPropsFromJSXPropsString({\n  propsString,\n}: {\n  propsString: string\n}): Record<string, any> {\n  const props: Record<string, any> = {}\n  let key = ''\n  let collectingKey = true\n\n  for (let i = 0; i < propsString.length; i++) {\n    const char = propsString[i]\n\n    if (collectingKey) {\n      if (char === '=' || char === ' ') {\n        if (key) {\n          if (char === ' ') {\n            props[key] = true\n            key = ''\n          } else {\n            collectingKey = false\n          }\n        }\n      } else {\n        key += char\n      }\n    } else {\n      const result = handleValue(propsString, i)\n      props[key] = result.value\n      i = result.newIndex\n      key = ''\n      collectingKey = true\n    }\n  }\n\n  if (key) {\n    props[key] = true\n  }\n\n  return props\n}\n\nfunction handleValue(propsString: string, startIndex: number): { newIndex: number; value: any } {\n  const char = propsString[startIndex]\n\n  if (char === '\"') {\n    return handleQuotedString(propsString, startIndex)\n  } else if (char === \"'\") {\n    return handleQuotedString(propsString, startIndex, true)\n  } else if (char === '{') {\n    return handleObject(propsString, startIndex)\n  } else if (char === '[') {\n    return handleArray(propsString, startIndex)\n  } else {\n    return handleUnquotedString(propsString, startIndex)\n  }\n}\n\nfunction handleArray(propsString: string, startIndex: number): { newIndex: number; value: any } {\n  let bracketCount = 1\n  let value = ''\n  let i = startIndex + 1\n\n  while (i < propsString.length && bracketCount > 0) {\n    if (propsString[i] === '[') {\n      bracketCount++\n    } else if (propsString[i] === ']') {\n      bracketCount--\n    }\n    if (bracketCount > 0) {\n      value += propsString[i]\n    }\n    i++\n  }\n\n  return { newIndex: i, value: JSOX.parse(`[${value}]`) }\n}\n\nfunction handleQuotedString(\n  propsString: string,\n  startIndex: number,\n  isSingleQuoted = false,\n): { newIndex: number; value: string } {\n  let value = ''\n  let i = startIndex + 1\n  while (\n    i < propsString.length &&\n    (propsString[i] !== (isSingleQuoted ? \"'\" : '\"') || propsString[i - 1] === '\\\\')\n  ) {\n    value += propsString[i]\n    i++\n  }\n  return { newIndex: i, value }\n}\n\nfunction handleObject(propsString: string, startIndex: number): { newIndex: number; value: any } {\n  let bracketCount = 1\n  let value = ''\n  let i = startIndex + 1\n\n  while (i < propsString.length && bracketCount > 0) {\n    if (propsString[i] === '{') {\n      bracketCount++\n    } else if (propsString[i] === '}') {\n      bracketCount--\n    }\n    if (bracketCount > 0) {\n      value += propsString[i]\n    }\n    i++\n  }\n\n  return { newIndex: i, value: parseObject(value) }\n}\n\nfunction parseObject(objString: string): Record<string, any> {\n  if (objString[0] !== '{') {\n    return JSOX.parse(objString)\n  }\n\n  const result = JSOX.parse(objString.replace(/(\\w+):/g, '\"$1\":'))\n\n  return result\n}\n\nfunction handleUnquotedString(\n  propsString: string,\n  startIndex: number,\n): { newIndex: number; value: string } {\n  let value = ''\n  let i = startIndex\n  while (i < propsString.length && propsString[i] !== ' ') {\n    value += propsString[i]\n    i++\n  }\n  return { newIndex: i - 1, value }\n}\n","/**\n * Converts an object of props to a JSX props string.\n *\n * This function is the inverse of `extractPropsFromJSXPropsString`.\n */\nexport function propsToJSXString({ props }: { props: Record<string, any> }): string {\n  const propsArray: string[] = []\n\n  for (const [key, value] of Object.entries(props)) {\n    if (typeof value === 'string') {\n      // Handle simple string props\n      propsArray.push(`${key}=\"${escapeQuotes(value)}\"`)\n    } else if (typeof value === 'number') {\n      // Handle number and boolean props\n      propsArray.push(`${key}={${value}}`)\n    } else if (typeof value === 'boolean') {\n      if (value) {\n        propsArray.push(`${key}`)\n      }\n    } else if (value !== null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        // Handle array props\n        propsArray.push(`${key}={[${value.map((v) => JSON.stringify(v, replacer)).join(', ')}]}`)\n      } else {\n        // Handle complex object props\n        propsArray.push(`${key}={${JSON.stringify(value, replacer)}}`)\n      }\n    }\n  }\n\n  return propsArray.join(' ')\n}\n\n// Helper function to escape quotes in string values\nfunction escapeQuotes(str: string): string {\n  return str.replace(/\"/g, '&quot;')\n}\n\n// Custom replacer function for JSON.stringify to handle single quotes\nfunction replacer(key: string, value: any): any {\n  if (typeof value === 'string') {\n    return value.replace(/'/g, \"\\\\'\")\n  }\n  return value\n}\n\n/**\n * Converts a frontmatter string to an object.\n */\nexport function frontmatterToObject(frontmatter: string): Record<string, any> {\n  const lines = frontmatter.trim().split('\\n')\n  const result = {}\n  let inFrontmatter = false\n\n  for (const line of lines) {\n    if (line.trim() === '---') {\n      inFrontmatter = !inFrontmatter\n      continue\n    }\n\n    if (inFrontmatter) {\n      const [key, ...valueParts] = line.split(':')\n      const value = valueParts.join(':').trim()\n\n      // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n      result[key.trim()] = value\n    }\n  }\n\n  return result\n}\n\n/**\n * Converts an object to a frontmatter string.\n */\nexport function objectToFrontmatter(obj: Record<string, any>): null | string {\n  if (!Object.entries(obj)?.length) {\n    return null\n  }\n  let frontmatter = '---\\n'\n\n  for (const [key, value] of Object.entries(obj)) {\n    if (Array.isArray(value)) {\n      frontmatter += `${key}: ${value.join(', ')}\\n`\n    } else {\n      frontmatter += `${key}: ${value}\\n`\n    }\n  }\n\n  frontmatter += '---\\n'\n  return frontmatter\n}\n\n/**\n * Takes an MDX content string and extracts the frontmatter and content.\n *\n * The resulting object contains the mdx content without the frontmatter and the frontmatter itself.\n */\nexport function extractFrontmatter(mdxContent: string) {\n  // eslint-disable-next-line regexp/no-super-linear-backtracking\n  const frontmatterRegex = /^---\\s*\\n[\\s\\S]*?\\n---\\s*\\n/\n  const match = mdxContent.match(frontmatterRegex)\n\n  if (match) {\n    const frontmatter = match[0]\n    const contentWithoutFrontmatter = mdxContent.slice(frontmatter.length).trim()\n    return {\n      content: contentWithoutFrontmatter,\n      frontmatter: frontmatter.trim(),\n    }\n  } else {\n    // If no frontmatter is found, return the original content\n    return {\n      content: mdxContent.trim(),\n      frontmatter: '',\n    }\n  }\n}\n","export function linesFromStartToContentAndPropsString({\n  isEndOptional,\n  lines,\n  regexpEndRegex,\n  startLineIndex,\n  startMatch,\n  trimChildren,\n}: {\n  isEndOptional?: boolean\n  lines: string[]\n  regexpEndRegex?: RegExp\n  startLineIndex: number\n  startMatch: RegExpMatchArray\n  trimChildren?: boolean\n}): {\n  /**\n   * The matched string after the end match, in the same line as the end match. Useful for inline matches.\n   */\n  afterEndLine: string\n  /**\n   * The matched string before the start match, in the same line as the start match. Useful for inline matches.\n   */\n  beforeStartLine: string\n  content: string\n  endLineIndex: number\n  endlineLastCharIndex: number\n  propsString: string\n} {\n  let propsString = ''\n  let content = ''\n  const linesCopy = lines.slice(startLineIndex)\n\n  let isWithinContent = false // If false => is within prop\n  let contentSubTagStartAmount = 0\n\n  let bracketCount = 0\n  let quoteChar: null | string = null\n  let isSelfClosing = false\n  let isWithinCodeBlockAmount = 0\n\n  const beforeStartLine = linesCopy[0]!.slice(0, startMatch.index)\n  let endlineLastCharIndex = 0\n\n  let endLineIndex = startLineIndex\n\n  mainLoop: for (const [lineIndex, lineCopy] of linesCopy.entries()) {\n    const line = trimChildren ? lineCopy.trim() : lineCopy\n    let amountOfBeginningSpacesRemoved = 0\n    if (trimChildren) {\n      for (let i = 0; i < lineCopy.length; i++) {\n        if (lineCopy[i] === ' ') {\n          amountOfBeginningSpacesRemoved++\n        } else {\n          break\n        }\n      }\n    }\n\n    let charIndex = 0\n\n    if (lineIndex === 0) {\n      charIndex = (startMatch.index ?? 0) + startMatch[0].length - amountOfBeginningSpacesRemoved // We need to also loop over the \">\" in something like \"<InlineCode>\" in order to later set isWithinContent to true\n    }\n\n    while (charIndex < line.length) {\n      const char = line[charIndex]\n      const nextChar = line[charIndex + 1]\n\n      if (!isWithinContent) {\n        if (char === '{' && !quoteChar) {\n          bracketCount++\n        } else if (char === '}' && !quoteChar) {\n          bracketCount--\n        } else if ((char === '\"' || char === \"'\") && !quoteChar) {\n          quoteChar = char\n        } else if (char === quoteChar) {\n          quoteChar = null\n        }\n\n        if (char === '/' && nextChar === '>' && bracketCount === 0 && !quoteChar) {\n          isSelfClosing = true\n          endLineIndex = lineIndex\n          endlineLastCharIndex = charIndex + 2\n\n          break mainLoop\n        } else if (char === '>' && bracketCount === 0 && !quoteChar) {\n          isWithinContent = true\n          charIndex++\n          continue\n        }\n\n        propsString += char\n      } else {\n        if (char === '`') {\n          isWithinCodeBlockAmount++\n        }\n\n        if (isWithinCodeBlockAmount % 2 === 0) {\n          if (char === '<' && nextChar === '/') {\n            contentSubTagStartAmount--\n\n            if (contentSubTagStartAmount < 0) {\n              if (content[content.length - 1] === '\\n') {\n                content = content.slice(0, -1) // Remove the last newline\n              }\n              endLineIndex = lineIndex\n              // Calculate endlineLastCharIndex by finding \">\" in line\n              for (let i = charIndex; i < line.length; i++) {\n                if (line[i] === '>') {\n                  endlineLastCharIndex = i + 1\n\n                  break\n                }\n              }\n              break mainLoop\n            }\n          } else if (char === '/' && nextChar === '>') {\n            contentSubTagStartAmount--\n\n            if (contentSubTagStartAmount < 0) {\n              if (content[content.length - 1] === '\\n') {\n                content = content.slice(0, -1) // Remove the last newline\n              }\n              endLineIndex = lineIndex\n              endlineLastCharIndex = charIndex + 2\n              break mainLoop\n            }\n          } else if (char === '<' && nextChar !== '/') {\n            contentSubTagStartAmount++\n          }\n        }\n\n        content += char\n      }\n\n      charIndex++\n    }\n\n    if (isWithinContent) {\n      if (content?.length > 0 && lineIndex > 0) {\n        content += '\\n'\n      }\n    } else {\n      propsString += '\\n'\n    }\n\n    if (regexpEndRegex && contentSubTagStartAmount < 0) {\n      // If 0 and in same line where it got lowered to 0 then this is not the match we are looking for\n      const match = line.match(regexpEndRegex)\n      if (match?.index !== undefined) {\n        endLineIndex = lineIndex\n        endlineLastCharIndex = match.index + match[0].length - 1\n        break\n      }\n    }\n\n    if (lineIndex === linesCopy.length - 1 && !isEndOptional && !isSelfClosing) {\n      throw new Error(\n        'End match not found for lines ' +\n          lines.join('\\n') +\n          '\\n\\n. Start match: ' +\n          JSON.stringify(startMatch),\n      )\n    }\n  }\n\n  const afterEndLine = linesCopy[endLineIndex]!.trim().slice(endlineLastCharIndex)\n\n  return {\n    afterEndLine,\n    beforeStartLine,\n    content,\n    endLineIndex: startLineIndex + endLineIndex,\n    endlineLastCharIndex,\n    propsString,\n  }\n}\n","'use client'\nimport ObjectID from 'bson-objectid'\nimport {\n  $applyNodeReplacement,\n  type EditorConfig,\n  type LexicalEditor,\n  type LexicalNode,\n} from 'lexical'\nimport React, { type JSX } from 'react'\n\nimport type { BlockFieldsOptionalID, SerializedBlockNode } from '../../server/nodes/BlocksNode.js'\n\nimport { ServerBlockNode } from '../../server/nodes/BlocksNode.js'\nimport { BlockComponent } from '../component/index.js'\n\nexport class BlockNode extends ServerBlockNode {\n  static override clone(node: ServerBlockNode): ServerBlockNode {\n    return super.clone(node)\n  }\n\n  static override getType(): string {\n    return super.getType()\n  }\n\n  static override importJSON(serializedNode: SerializedBlockNode): BlockNode {\n    if (serializedNode.version === 1) {\n      // Convert (version 1 had the fields wrapped in another, unnecessary data property)\n      serializedNode = {\n        ...serializedNode,\n        fields: {\n          ...(serializedNode as any).fields.data,\n        },\n        version: 2,\n      }\n    }\n    const node = $createBlockNode(serializedNode.fields)\n    node.setFormat(serializedNode.format)\n    return node\n  }\n\n  override decorate(_editor: LexicalEditor, config: EditorConfig): JSX.Element {\n    return (\n      <BlockComponent\n        cacheBuster={this.getCacheBuster()}\n        className={config.theme.block ?? 'LexicalEditorTheme__block'}\n        formData={this.getFields()}\n        nodeKey={this.getKey()}\n      />\n    )\n  }\n\n  override exportJSON(): SerializedBlockNode {\n    return super.exportJSON()\n  }\n}\n\nexport function $createBlockNode(fields: BlockFieldsOptionalID): BlockNode {\n  return $applyNodeReplacement(\n    new BlockNode({\n      fields: {\n        ...fields,\n        id: fields?.id || new ObjectID.default().toHexString(),\n      },\n    }),\n  )\n}\n\nexport function $isBlockNode(node: BlockNode | LexicalNode | null | undefined): node is BlockNode {\n  return node instanceof BlockNode\n}\n","import type { SerializedDecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport type { JsonObject } from 'payload'\nimport type { JSX } from 'react'\n\nimport { DecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport { addClassNamesToElement } from '@lexical/utils'\nimport ObjectID from 'bson-objectid'\nimport {\n  $applyNodeReplacement,\n  type DOMConversionMap,\n  type DOMExportOutput,\n  type EditorConfig,\n  type ElementFormatType,\n  type LexicalEditor,\n  type LexicalNode,\n  type NodeKey,\n} from 'lexical'\n\nimport type { StronglyTypedLeafNode } from '../../../../nodeTypes.js'\n\ntype BaseBlockFields<TBlockFields extends JsonObject = JsonObject> = {\n  /** Block form data */\n  blockName: string\n  blockType: string\n} & TBlockFields\n\nexport type BlockFields<TBlockFields extends JsonObject = JsonObject> = {\n  id: string\n} & BaseBlockFields<TBlockFields>\n\nexport type BlockFieldsOptionalID<TBlockFields extends JsonObject = JsonObject> = {\n  id?: string\n} & BaseBlockFields<TBlockFields>\n\nexport type SerializedBlockNode<TBlockFields extends JsonObject = JsonObject> = {\n  fields: BlockFields<TBlockFields>\n} & StronglyTypedLeafNode<SerializedDecoratorBlockNode, 'block'>\n\nexport class ServerBlockNode extends DecoratorBlockNode {\n  __cacheBuster: number\n  __fields: BlockFields\n\n  constructor({\n    cacheBuster,\n    fields,\n    format,\n    key,\n  }: {\n    cacheBuster?: number\n    fields: BlockFields\n    format?: ElementFormatType\n    key?: NodeKey\n  }) {\n    super(format, key)\n    this.__fields = fields\n    this.__cacheBuster = cacheBuster || 0\n  }\n\n  static override clone(node: ServerBlockNode): ServerBlockNode {\n    return new this({\n      cacheBuster: node.__cacheBuster,\n      fields: node.__fields,\n      format: node.__format,\n      key: node.__key,\n    })\n  }\n\n  static override getType(): string {\n    return 'block'\n  }\n\n  static override importDOM(): DOMConversionMap<HTMLDivElement> | null {\n    return {}\n  }\n\n  static override importJSON(serializedNode: SerializedBlockNode): ServerBlockNode {\n    if (serializedNode.version === 1) {\n      // Convert (version 1 had the fields wrapped in another, unnecessary data property)\n      serializedNode = {\n        ...serializedNode,\n        fields: {\n          ...(serializedNode as any).fields.data,\n        },\n        version: 2,\n      }\n    }\n    const node = $createServerBlockNode(serializedNode.fields)\n    node.setFormat(serializedNode.format)\n    return node\n  }\n\n  static isInline(): false {\n    return false\n  }\n\n  override createDOM(config?: EditorConfig): HTMLElement {\n    const element = document.createElement('div')\n    addClassNamesToElement(element, config?.theme?.block)\n    return element\n  }\n\n  override decorate(editor: LexicalEditor, config: EditorConfig): JSX.Element {\n    return null as unknown as JSX.Element\n  }\n\n  override exportDOM(): DOMExportOutput {\n    const element = document.createElement('div')\n\n    const text = document.createTextNode(this.getTextContent())\n    element.append(text)\n    return { element }\n  }\n\n  override exportJSON(): SerializedBlockNode {\n    return {\n      ...super.exportJSON(),\n      type: 'block',\n      fields: this.getFields(),\n      version: 2,\n    }\n  }\n\n  getCacheBuster(): number {\n    return this.getLatest().__cacheBuster\n  }\n\n  getFields(): BlockFields {\n    return this.getLatest().__fields\n  }\n\n  override getTextContent(): string {\n    return `Block Field`\n  }\n\n  setFields(fields: BlockFields, preventFormStateUpdate?: boolean): void {\n    const writable = this.getWritable()\n    writable.__fields = fields\n    if (!preventFormStateUpdate) {\n      writable.__cacheBuster++\n    }\n  }\n}\n\nexport function $createServerBlockNode(fields: BlockFieldsOptionalID): ServerBlockNode {\n  return $applyNodeReplacement(\n    new ServerBlockNode({\n      fields: {\n        ...fields,\n        id: fields?.id || new ObjectID.default().toHexString(),\n      },\n    }),\n  )\n}\n\nexport function $isServerBlockNode(\n  node: LexicalNode | null | ServerBlockNode | undefined,\n): node is ServerBlockNode {\n  return node instanceof ServerBlockNode\n}\n","'use client'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { useLexicalEditable } from '@lexical/react/useLexicalEditable'\nimport { getTranslation } from '@payloadcms/translations'\nimport {\n  Button,\n  Collapsible,\n  Drawer,\n  EditDepthProvider,\n  ErrorPill,\n  Form,\n  formatDrawerSlug,\n  FormSubmit,\n  Pill,\n  RenderFields,\n  SectionTitle,\n  useConfig,\n  useDocumentForm,\n  useDocumentInfo,\n  useEditDepth,\n  useFormSubmitted,\n  useServerFunctions,\n  useTranslation,\n} from '@payloadcms/ui'\nimport { abortAndIgnore } from '@payloadcms/ui/shared'\nimport { $getNodeByKey } from 'lexical'\nimport {\n  type BlocksFieldClient,\n  type ClientBlock,\n  type CollapsedPreferences,\n  type FormState,\n} from 'payload'\nimport { deepCopyObjectSimpleWithoutReactComponents, reduceFieldsToValues } from 'payload/shared'\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react'\nimport { v4 as uuid } from 'uuid'\n\nimport type { BlockFields } from '../../server/nodes/BlocksNode.js'\n\nimport { useEditorConfigContext } from '../../../../lexical/config/client/EditorConfigProvider.js'\nimport './index.scss'\nimport { useLexicalDrawer } from '../../../../utilities/fieldsDrawer/useLexicalDrawer.js'\nimport { $isBlockNode } from '../nodes/BlocksNode.js'\nimport { type BlockCollapsibleWithErrorProps, BlockContent } from './BlockContent.js'\nimport { removeEmptyArrayValues } from './removeEmptyArrayValues.js'\n\ntype Props = {\n  /**\n   * Can be modified by the node in order to trigger the re-fetch of the initial state based on the\n   * formData. This is useful when node.setFields() is explicitly called from outside of the form - in\n   * this case, the new field state is likely not reflected in the form state, so we need to re-fetch\n   */\n  readonly cacheBuster: number\n  readonly className: string\n  readonly formData: BlockFields\n  readonly nodeKey: string\n}\n\nexport const BlockComponent: React.FC<Props> = (props) => {\n  const { cacheBuster, className: baseClass, formData, nodeKey } = props\n  const submitted = useFormSubmitted()\n  const { id, collectionSlug, globalSlug } = useDocumentInfo()\n  const {\n    fieldProps: {\n      featureClientSchemaMap,\n      field: parentLexicalRichTextField,\n      initialLexicalFormState,\n      schemaPath,\n    },\n    uuid: uuidFromContext,\n  } = useEditorConfigContext()\n\n  const { fields: parentDocumentFields } = useDocumentForm()\n  const onChangeAbortControllerRef = useRef(new AbortController())\n  const editDepth = useEditDepth()\n  const [errorCount, setErrorCount] = React.useState(0)\n\n  const { config } = useConfig()\n\n  const drawerSlug = formatDrawerSlug({\n    slug: `lexical-blocks-create-${uuidFromContext}-${formData.id}`,\n    depth: editDepth,\n  })\n  const { toggleDrawer } = useLexicalDrawer(drawerSlug)\n\n  // Used for saving collapsed to preferences (and gettin' it from there again)\n  // Remember, these preferences are scoped to the whole document, not just this form. This\n  // is important to consider for the data path used in setDocFieldPreferences\n  const { getDocPreferences, setDocFieldPreferences } = useDocumentInfo()\n  const [editor] = useLexicalComposerContext()\n  const isEditable = useLexicalEditable()\n\n  const blockType = formData.blockType\n\n  const { getFormState } = useServerFunctions()\n  const schemaFieldsPath = `${schemaPath}.lexical_internal_feature.blocks.lexical_blocks.${blockType}.fields`\n\n  const [initialState, setInitialState] = React.useState<false | FormState | undefined>(() => {\n    // Initial form state that was calculated server-side. May have stale values\n    const cachedFormState = initialLexicalFormState?.[formData.id]?.formState\n    if (!cachedFormState) {\n      return false\n    }\n\n    // Merge current formData values into the cached form state\n    // This ensures that when the component remounts (e.g., due to view changes), we don't lose user edits\n    return Object.fromEntries(\n      Object.entries(cachedFormState).map(([fieldName, fieldState]) => [\n        fieldName,\n        fieldName in formData\n          ? {\n              ...fieldState,\n              initialValue: formData[fieldName],\n              value: formData[fieldName],\n            }\n          : fieldState,\n      ]),\n    )\n  })\n\n  const hasMounted = useRef(false)\n  const prevCacheBuster = useRef(cacheBuster)\n  useEffect(() => {\n    if (hasMounted.current) {\n      if (prevCacheBuster.current !== cacheBuster) {\n        setInitialState(false)\n      }\n      prevCacheBuster.current = cacheBuster\n    } else {\n      hasMounted.current = true\n    }\n  }, [cacheBuster])\n\n  const [CustomLabel, setCustomLabel] = React.useState<React.ReactNode | undefined>(\n    // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n    initialState?.['_components']?.customComponents?.BlockLabel ?? undefined,\n  )\n\n  const [CustomBlock, setCustomBlock] = React.useState<React.ReactNode | undefined>(\n    // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n    initialState?.['_components']?.customComponents?.Block ?? undefined,\n  )\n\n  // Initial state for newly created blocks\n  useEffect(() => {\n    const abortController = new AbortController()\n\n    const awaitInitialState = async () => {\n      /*\n       * This will only run if a new block is created. For all existing blocks that are loaded when the document is loaded, or when the form is saved,\n       * this is not run, as the lexical field RSC will fetch the state server-side and pass it to the client. That way, we avoid unnecessary client-side\n       * requests. Though for newly created blocks, we need to fetch the state client-side, as the server doesn't know about the block yet.\n       */\n      const { state } = await getFormState({\n        id,\n        collectionSlug,\n        data: formData,\n        docPermissions: { fields: true },\n        docPreferences: await getDocPreferences(),\n        documentFormState: deepCopyObjectSimpleWithoutReactComponents(parentDocumentFields),\n        globalSlug,\n        initialBlockData: formData,\n        operation: 'update',\n        readOnly: !isEditable,\n        renderAllFields: true,\n        schemaPath: schemaFieldsPath,\n        signal: abortController.signal,\n      })\n\n      if (state) {\n        state.blockName = {\n          initialValue: formData.blockName,\n          passesCondition: true,\n          valid: true,\n          value: formData.blockName,\n        }\n\n        const newFormStateData: BlockFields = reduceFieldsToValues(\n          deepCopyObjectSimpleWithoutReactComponents(state),\n          true,\n        ) as BlockFields\n\n        // Things like default values may come back from the server => update the node with the new data\n        editor.update(() => {\n          const node = $getNodeByKey(nodeKey)\n          if (node && $isBlockNode(node)) {\n            const newData = newFormStateData\n            newData.blockType = blockType\n\n            node.setFields(newData, true)\n          }\n        })\n\n        setInitialState(state)\n        setCustomLabel(state._components?.customComponents?.BlockLabel ?? undefined)\n        setCustomBlock(state._components?.customComponents?.Block ?? undefined)\n      }\n    }\n\n    if (formData && !initialState) {\n      void awaitInitialState()\n    }\n\n    return () => {\n      abortAndIgnore(abortController)\n    }\n  }, [\n    getFormState,\n    schemaFieldsPath,\n    isEditable,\n    id,\n    formData,\n    editor,\n    nodeKey,\n    initialState,\n    collectionSlug,\n    globalSlug,\n    getDocPreferences,\n    parentDocumentFields,\n    blockType,\n  ])\n\n  const [isCollapsed, setIsCollapsed] = React.useState<boolean>(\n    initialLexicalFormState?.[formData.id]?.collapsed ?? false,\n  )\n\n  const componentMapRenderedBlockPath = `${schemaPath}.lexical_internal_feature.blocks.lexical_blocks.${blockType}`\n\n  const clientSchemaMap = featureClientSchemaMap['blocks']\n\n  const blocksField: BlocksFieldClient | undefined = clientSchemaMap?.[\n    componentMapRenderedBlockPath\n  ]?.[0] as BlocksFieldClient\n\n  const clientBlock: ClientBlock | undefined = blocksField.blockReferences\n    ? typeof blocksField?.blockReferences?.[0] === 'string'\n      ? config.blocksMap[blocksField?.blockReferences?.[0]]\n      : blocksField?.blockReferences?.[0]\n    : blocksField?.blocks?.[0]\n\n  const { i18n, t } = useTranslation<object, string>()\n\n  const onChange = useCallback(\n    async ({ formState: prevFormState, submit }: { formState: FormState; submit?: boolean }) => {\n      abortAndIgnore(onChangeAbortControllerRef.current)\n\n      const controller = new AbortController()\n      onChangeAbortControllerRef.current = controller\n\n      const { state: newFormState } = await getFormState({\n        id,\n        collectionSlug,\n        docPermissions: {\n          fields: true,\n        },\n        docPreferences: await getDocPreferences(),\n        documentFormState: deepCopyObjectSimpleWithoutReactComponents(parentDocumentFields),\n        formState: prevFormState,\n        globalSlug,\n        initialBlockFormState: prevFormState,\n        operation: 'update',\n        readOnly: !isEditable,\n        renderAllFields: submit ? true : false,\n        schemaPath: schemaFieldsPath,\n        signal: controller.signal,\n      })\n\n      if (!newFormState) {\n        return prevFormState\n      }\n\n      if (prevFormState.blockName) {\n        newFormState.blockName = prevFormState.blockName\n      }\n\n      const newFormStateData: BlockFields = reduceFieldsToValues(\n        removeEmptyArrayValues({\n          fields: deepCopyObjectSimpleWithoutReactComponents(newFormState),\n        }),\n        true,\n      ) as BlockFields\n\n      setTimeout(() => {\n        editor.update(() => {\n          const node = $getNodeByKey(nodeKey)\n          if (node && $isBlockNode(node)) {\n            const newData = newFormStateData\n            newData.blockType = blockType\n            node.setFields(newData, true)\n          }\n        })\n      }, 0)\n\n      if (submit) {\n        setCustomLabel(newFormState._components?.customComponents?.BlockLabel ?? undefined)\n        setCustomBlock(newFormState._components?.customComponents?.Block ?? undefined)\n\n        let rowErrorCount = 0\n        for (const formField of Object.values(newFormState)) {\n          if (formField?.valid === false) {\n            rowErrorCount++\n          }\n        }\n        setErrorCount(rowErrorCount)\n      }\n\n      return newFormState\n    },\n\n    [\n      getFormState,\n      id,\n      collectionSlug,\n      getDocPreferences,\n      globalSlug,\n      schemaFieldsPath,\n      blockType,\n      parentDocumentFields,\n      isEditable,\n      editor,\n      nodeKey,\n    ],\n  )\n\n  useEffect(() => {\n    return () => {\n      abortAndIgnore(onChangeAbortControllerRef.current)\n    }\n  }, [])\n\n  const removeBlock = useCallback(() => {\n    editor.update(() => {\n      $getNodeByKey(nodeKey)?.remove()\n    })\n  }, [editor, nodeKey])\n\n  const blockDisplayName = clientBlock?.labels?.singular\n    ? getTranslation(clientBlock.labels.singular, i18n)\n    : clientBlock?.slug\n\n  const onCollapsedChange = useCallback(\n    (changedCollapsed: boolean) => {\n      void getDocPreferences().then((currentDocPreferences) => {\n        const currentFieldPreferences =\n          currentDocPreferences?.fields?.[parentLexicalRichTextField.name]\n\n        const collapsedArray = currentFieldPreferences?.collapsed\n\n        const newCollapsed: CollapsedPreferences =\n          collapsedArray && collapsedArray?.length ? collapsedArray : []\n\n        if (changedCollapsed) {\n          if (!newCollapsed.includes(formData.id)) {\n            newCollapsed.push(formData.id)\n          }\n        } else {\n          if (newCollapsed.includes(formData.id)) {\n            newCollapsed.splice(newCollapsed.indexOf(formData.id), 1)\n          }\n        }\n\n        setDocFieldPreferences(parentLexicalRichTextField.name, {\n          collapsed: newCollapsed,\n          hello: 'hi',\n        })\n      })\n    },\n    [getDocPreferences, parentLexicalRichTextField.name, setDocFieldPreferences, formData.id],\n  )\n\n  const EditButton = useMemo(\n    () => () => (\n      <Button\n        buttonStyle=\"icon-label\"\n        className={`${baseClass}__editButton`}\n        disabled={!isEditable}\n        el=\"button\"\n        icon=\"edit\"\n        onClick={(e) => {\n          e.preventDefault()\n          e.stopPropagation()\n          toggleDrawer()\n          return false\n        }}\n        onMouseDown={(e) => {\n          // Needed to preserve lexical selection for toggleDrawer lexical selection restore.\n          // I believe this is needed due to this button (usually) being inside of a collapsible.\n          e.preventDefault()\n        }}\n        round\n        size=\"small\"\n        tooltip={t('lexical:blocks:inlineBlocks:edit', { label: blockDisplayName })}\n      />\n    ),\n    [baseClass, isEditable, t, blockDisplayName, toggleDrawer],\n  )\n\n  const RemoveButton = useMemo(\n    () => () => (\n      <Button\n        buttonStyle=\"icon-label\"\n        className={`${baseClass}__removeButton`}\n        disabled={!isEditable}\n        icon=\"x\"\n        onClick={(e) => {\n          e.preventDefault()\n          removeBlock()\n        }}\n        round\n        tooltip=\"Remove Block\"\n      />\n    ),\n    [baseClass, isEditable, removeBlock],\n  )\n\n  const BlockCollapsible = useMemo(\n    () =>\n      ({\n        Actions,\n        children,\n        className,\n        collapsibleProps,\n        disableBlockName,\n        editButton,\n        errorCount,\n        fieldHasErrors,\n        Label,\n        Pill: CustomPill,\n        removeButton,\n      }: BlockCollapsibleWithErrorProps) => {\n        return (\n          <div className={`${baseClass}__container ${baseClass}-${blockType}`}>\n            <Collapsible\n              className={[\n                `${baseClass}__row`,\n                fieldHasErrors ? `${baseClass}__row--has-errors` : `${baseClass}__row--no-errors`,\n                className,\n              ]\n                .filter(Boolean)\n                .join(' ')}\n              collapsibleStyle={fieldHasErrors ? 'error' : 'default'}\n              header={\n                <div className={`${baseClass}__block-header`}>\n                  {typeof Label !== 'undefined' ? (\n                    Label\n                  ) : typeof CustomLabel !== 'undefined' ? (\n                    CustomLabel\n                  ) : (\n                    <div className={`${baseClass}__block-label`}>\n                      {typeof CustomPill !== 'undefined' ? (\n                        CustomPill\n                      ) : (\n                        <Pill\n                          className={`${baseClass}__block-pill ${baseClass}__block-pill-${blockType}`}\n                          pillStyle=\"white\"\n                          size=\"small\"\n                        >\n                          {blockDisplayName ?? blockType}\n                        </Pill>\n                      )}\n                      {!disableBlockName && !clientBlock?.admin?.disableBlockName && (\n                        <SectionTitle path=\"blockName\" readOnly={!isEditable} />\n                      )}\n\n                      {fieldHasErrors && (\n                        <ErrorPill count={errorCount ?? 0} i18n={i18n} withMessage />\n                      )}\n                    </div>\n                  )}\n\n                  <div className={`${baseClass}__block-actions`}>\n                    {typeof Actions !== 'undefined' ? (\n                      Actions\n                    ) : (\n                      <>\n                        {(CustomBlock && editButton !== false) || (!CustomBlock && editButton) ? (\n                          <EditButton />\n                        ) : null}\n                        {removeButton !== false && isEditable ? <RemoveButton /> : null}\n                      </>\n                    )}\n                  </div>\n                </div>\n              }\n              isCollapsed={isCollapsed}\n              key={0}\n              onToggle={(incomingCollapsedState) => {\n                onCollapsedChange(incomingCollapsedState)\n                setIsCollapsed(incomingCollapsedState)\n              }}\n              {...(collapsibleProps || {})}\n            >\n              {children}\n            </Collapsible>\n          </div>\n        )\n      },\n    [\n      CustomBlock,\n      CustomLabel,\n      EditButton,\n      RemoveButton,\n      blockDisplayName,\n      baseClass,\n      clientBlock?.admin?.disableBlockName,\n      blockType,\n      i18n,\n      isCollapsed,\n      onCollapsedChange,\n      isEditable,\n    ],\n  )\n\n  const blockID = formData?.id\n\n  const BlockDrawer = useMemo(\n    () => () => (\n      <EditDepthProvider>\n        <Drawer\n          className={''}\n          slug={drawerSlug}\n          title={t(`lexical:blocks:inlineBlocks:${blockID ? 'edit' : 'create'}`, {\n            label: blockDisplayName ?? t('lexical:blocks:inlineBlocks:label'),\n          })}\n        >\n          {initialState ? (\n            <>\n              <RenderFields\n                fields={clientBlock?.fields ?? []}\n                forceRender\n                parentIndexPath=\"\"\n                parentPath=\"\" // See Blocks feature path for details as for why this is empty\n                parentSchemaPath={schemaFieldsPath}\n                permissions={true}\n                readOnly={!isEditable}\n              />\n              <FormSubmit programmaticSubmit={true}>{t('fields:saveChanges')}</FormSubmit>\n            </>\n          ) : null}\n        </Drawer>\n      </EditDepthProvider>\n    ),\n    [\n      initialState,\n      drawerSlug,\n      blockID,\n      blockDisplayName,\n      t,\n      isEditable,\n      clientBlock?.fields,\n      schemaFieldsPath,\n      // DO NOT ADD FORMDATA HERE! Adding formData will kick you out of sub block editors while writing.\n    ],\n  )\n\n  // Memoized Form JSX\n  const Block = useMemo(() => {\n    if (!initialState) {\n      return null\n    }\n    return (\n      <Form\n        beforeSubmit={[\n          async ({ formState }) => {\n            // This is only called when form is submitted from drawer - usually only the case if the block has a custom Block component\n            return await onChange({ formState, submit: true })\n          },\n        ]}\n        el=\"div\"\n        fields={clientBlock?.fields ?? []}\n        initialState={initialState}\n        onChange={[onChange]}\n        onSubmit={(formState, newData) => {\n          // This is only called when form is submitted from drawer - usually only the case if the block has a custom Block component\n          newData.blockType = blockType\n          editor.update(() => {\n            const node = $getNodeByKey(nodeKey)\n            if (node && $isBlockNode(node)) {\n              node.setFields(newData as BlockFields, true)\n            }\n          })\n          toggleDrawer()\n        }}\n        submitted={submitted}\n        uuid={uuid()}\n      >\n        <BlockContent\n          baseClass={baseClass}\n          BlockDrawer={BlockDrawer}\n          Collapsible={BlockCollapsible}\n          CustomBlock={CustomBlock}\n          EditButton={EditButton}\n          errorCount={errorCount}\n          formSchema={clientBlock?.fields ?? []}\n          initialState={initialState}\n          nodeKey={nodeKey}\n          RemoveButton={RemoveButton}\n        />\n      </Form>\n    )\n  }, [\n    BlockCollapsible,\n    BlockDrawer,\n    CustomBlock,\n    blockType,\n    RemoveButton,\n    EditButton,\n    baseClass,\n    editor,\n    errorCount,\n    toggleDrawer,\n    clientBlock?.fields,\n    // DO NOT ADD FORMDATA HERE! Adding formData will kick you out of sub block editors while writing.\n    initialState,\n    nodeKey,\n    onChange,\n    submitted,\n  ])\n\n  if (!clientBlock) {\n    return (\n      <BlockCollapsible disableBlockName={true} fieldHasErrors={true}>\n        <div className={`${baseClass}-not-found`}>\n          Error: Block '{blockType}' not found in the config but exists in the lexical data\n        </div>\n      </BlockCollapsible>\n    )\n  }\n\n  return Block\n}\n","'use client'\nimport type { CollapsibleProps } from '@payloadcms/ui/elements/Collapsible'\nimport type { ClientField, FormState } from 'payload'\n\nimport { useLexicalEditable } from '@lexical/react/useLexicalEditable'\nimport { RenderFields, useFormSubmitted } from '@payloadcms/ui'\nimport React, { createContext, useMemo } from 'react'\n\nexport type BlockCollapsibleProps = {\n  /**\n   * Replace the top-right portion of the header that renders the Edit and Remove buttons with custom content.\n   * If this property is provided, the `removeButton` and `editButton` properties are ignored.\n   */\n  Actions?: React.ReactNode\n  children?: React.ReactNode\n  /**\n   * Additional className to the collapsible wrapper\n   */\n  className?: string\n  /**\n   * Props to pass to the underlying Collapsible component. You could use this to override the `Header` entirely, for example.\n   */\n  collapsibleProps?: Partial<CollapsibleProps>\n  /**\n   * Whether to disable rendering the block name field in the header Label\n   * @default false\n   */\n  disableBlockName?: boolean\n  /**\n   * Whether to show the Edit button\n   * If `Actions` is provided, this property is ignored.\n   * @default true\n   */\n  editButton?: boolean\n  /**\n   * Replace the default Label component with a custom Label\n   */\n  Label?: React.ReactNode\n  /**\n   * Replace the default Pill component component that's rendered within the default Label component with a custom Pill.\n   * This property has no effect if you provide a custom Label component via the `Label` property.\n   */\n  Pill?: React.ReactNode\n  /**\n   * Whether to show the Remove button\n   * If `Actions` is provided, this property is ignored.\n   * @default true\n   */\n  removeButton?: boolean\n}\n\nexport type BlockCollapsibleWithErrorProps = {\n  errorCount?: number\n  fieldHasErrors?: boolean\n} & BlockCollapsibleProps\n\nexport type BlockContentProps = {\n  baseClass: string\n  BlockDrawer: React.FC\n  Collapsible: React.FC<BlockCollapsibleWithErrorProps>\n  CustomBlock: React.ReactNode\n  EditButton: React.FC\n  errorCount: number\n  formSchema: ClientField[]\n  initialState: false | FormState | undefined\n\n  nodeKey: string\n  RemoveButton: React.FC\n}\n\ntype BlockComponentContextType = {\n  BlockCollapsible: React.FC<BlockCollapsibleProps>\n} & Omit<BlockContentProps, 'Collapsible'>\n\nconst BlockComponentContext = createContext<BlockComponentContextType>({\n  baseClass: 'LexicalEditorTheme__block',\n  BlockCollapsible: () => null,\n  BlockDrawer: () => null,\n  CustomBlock: null,\n  EditButton: () => null,\n  errorCount: 0,\n  formSchema: [],\n  initialState: false,\n  nodeKey: '',\n  RemoveButton: () => null,\n})\n\nexport const useBlockComponentContext = () => React.use(BlockComponentContext)\n\n/**\n * The actual content of the Block. This should be INSIDE a Form component,\n * scoped to the block. All format operations in here are thus scoped to the block's form, and\n * not the whole document.\n */\nexport const BlockContent: React.FC<BlockContentProps> = (props) => {\n  const { Collapsible, ...contextProps } = props\n\n  const { BlockDrawer, CustomBlock, errorCount, formSchema } = contextProps\n\n  const hasSubmitted = useFormSubmitted()\n\n  const fieldHasErrors = hasSubmitted && errorCount > 0\n  const isEditable = useLexicalEditable()\n\n  const CollapsibleWithErrorProps = useMemo(\n    () => (props: BlockCollapsibleProps) => {\n      const { children, ...rest } = props\n      return (\n        <Collapsible errorCount={errorCount} fieldHasErrors={fieldHasErrors} {...rest}>\n          {children}\n        </Collapsible>\n      )\n    },\n    [Collapsible, fieldHasErrors, errorCount],\n  )\n\n  return CustomBlock ? (\n    <BlockComponentContext\n      value={{\n        ...contextProps,\n        BlockCollapsible: CollapsibleWithErrorProps,\n      }}\n    >\n      {CustomBlock}\n      <BlockDrawer />\n    </BlockComponentContext>\n  ) : (\n    <CollapsibleWithErrorProps>\n      <RenderFields\n        fields={formSchema}\n        forceRender={true}\n        parentIndexPath=\"\"\n        parentPath={''}\n        parentSchemaPath=\"\"\n        permissions={true}\n        readOnly={!isEditable}\n      />\n    </CollapsibleWithErrorProps>\n  )\n}\n","'use client'\nimport type { FormState } from 'payload'\n\n/**\n * By default, if an array field is empty, it will be included in the form state with a value of 0.\n * We do not need this behavior here, By setting `disableFormData` to true, we can prevent the field from being included in the form state\n * like that.\n * @param fields form state\n */\nexport function removeEmptyArrayValues({ fields }: { fields: FormState }): FormState {\n  for (const key in fields) {\n    const field = fields[key]\n    if (Array.isArray(field?.rows) && 'value' in field) {\n      field.disableFormData = true\n    }\n  }\n  return fields\n}\n","import type { Klass, LexicalNode, LexicalNodeReplacement } from 'lexical'\n\nimport { createHeadlessEditor } from '@lexical/headless'\n\nimport {\n  $convertToMarkdownString,\n  type Transformer,\n} from '../../../../packages/@lexical/markdown/index.js'\n\nexport function getLexicalToMarkdown(\n  allNodes: Array<Klass<LexicalNode> | LexicalNodeReplacement>,\n  allTransformers: Transformer[],\n): (args: { editorState: Record<string, any> }) => string {\n  const lexicalToMarkdown = ({ editorState }: { editorState: Record<string, any> }): string => {\n    const headlessEditor = createHeadlessEditor({\n      nodes: allNodes,\n    })\n\n    try {\n      headlessEditor.setEditorState(headlessEditor.parseEditorState(editorState as any)) // This should commit the editor state immediately\n    } catch (e) {\n      console.error('getLexicalToMarkdown: ERROR parsing editor state', e)\n    }\n\n    let markdown: string = ''\n    headlessEditor.getEditorState().read(() => {\n      markdown = $convertToMarkdownString(allTransformers)\n    })\n\n    return markdown\n  }\n  return lexicalToMarkdown\n}\n","import type { Klass, LexicalNode, LexicalNodeReplacement, SerializedEditorState } from 'lexical'\n\nimport { createHeadlessEditor } from '@lexical/headless'\n\nimport {\n  $convertFromMarkdownString,\n  type Transformer,\n} from '../../../../packages/@lexical/markdown/index.js'\n\nexport function getMarkdownToLexical(\n  allNodes: Array<Klass<LexicalNode> | LexicalNodeReplacement>,\n  allTransformers: Transformer[],\n): (args: { markdown: string }) => SerializedEditorState {\n  const markdownToLexical = ({ markdown }: { markdown: string }): SerializedEditorState => {\n    const headlessEditor = createHeadlessEditor({\n      nodes: allNodes,\n    })\n\n    headlessEditor.update(\n      () => {\n        $convertFromMarkdownString(markdown, allTransformers)\n      },\n      { discrete: true },\n    )\n\n    const editorJSON = headlessEditor.getEditorState().toJSON()\n\n    return editorJSON\n  }\n  return markdownToLexical\n}\n","'use client'\nimport type { LexicalCommand } from 'lexical'\n\nimport { createCommand } from 'lexical'\n\nimport type { InsertBlockPayload } from './index.js'\n\nexport const INSERT_BLOCK_COMMAND: LexicalCommand<InsertBlockPayload> =\n  createCommand('INSERT_BLOCK_COMMAND')\n\nexport const INSERT_INLINE_BLOCK_COMMAND: LexicalCommand<Partial<InsertBlockPayload>> =\n  createCommand('INSERT_INLINE_BLOCK_COMMAND')\n","'use client'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { $insertNodeToNearestRoot, $wrapNodeInElement, mergeRegister } from '@lexical/utils'\nimport { formatDrawerSlug, useEditDepth } from '@payloadcms/ui'\nimport {\n  $createParagraphNode,\n  $getNodeByKey,\n  $getPreviousSelection,\n  $getSelection,\n  $insertNodes,\n  $isParagraphNode,\n  $isRangeSelection,\n  $isRootOrShadowRoot,\n  COMMAND_PRIORITY_EDITOR,\n} from 'lexical'\nimport { useEffect, useState } from 'react'\n\nimport type { PluginComponent } from '../../../typesClient.js'\nimport type { BlockFields, BlockFieldsOptionalID } from '../../server/nodes/BlocksNode.js'\n\nimport { useEditorConfigContext } from '../../../../lexical/config/client/EditorConfigProvider.js'\nimport { useLexicalDrawer } from '../../../../utilities/fieldsDrawer/useLexicalDrawer.js'\nimport { $createBlockNode, BlockNode } from '../nodes/BlocksNode.js'\nimport { $createInlineBlockNode, $isInlineBlockNode } from '../nodes/InlineBlocksNode.js'\nimport { INSERT_BLOCK_COMMAND, INSERT_INLINE_BLOCK_COMMAND } from './commands.js'\n\nexport type InsertBlockPayload = BlockFieldsOptionalID\n\nexport const BlocksPlugin: PluginComponent = () => {\n  const [editor] = useLexicalComposerContext()\n\n  const [targetNodeKey, setTargetNodeKey] = useState<null | string>(null)\n\n  const { setCreatedInlineBlock, uuid } = useEditorConfigContext()\n  const editDepth = useEditDepth()\n\n  const drawerSlug = formatDrawerSlug({\n    slug: `lexical-inlineBlocks-create-` + uuid,\n    depth: editDepth,\n  })\n\n  const { toggleDrawer } = useLexicalDrawer(drawerSlug, true)\n\n  useEffect(() => {\n    if (!editor.hasNodes([BlockNode])) {\n      throw new Error('BlocksPlugin: BlocksNode not registered on editor')\n    }\n\n    return mergeRegister(\n      editor.registerCommand<InsertBlockPayload>(\n        INSERT_BLOCK_COMMAND,\n        (payload: InsertBlockPayload) => {\n          editor.update(() => {\n            const selection = $getSelection() || $getPreviousSelection()\n\n            if ($isRangeSelection(selection)) {\n              const blockNode = $createBlockNode(payload)\n\n              // we need to get the focus node before inserting the block node, as $insertNodeToNearestRoot can change the focus node\n              const { focus } = selection\n              const focusNode = focus.getNode()\n              // Insert blocks node BEFORE potentially removing focusNode, as $insertNodeToNearestRoot errors if the focusNode doesn't exist\n              $insertNodeToNearestRoot(blockNode)\n\n              // Delete the node it it's an empty paragraph\n              if ($isParagraphNode(focusNode) && !focusNode.__first) {\n                focusNode.remove()\n              }\n            }\n          })\n\n          return true\n        },\n        COMMAND_PRIORITY_EDITOR,\n      ),\n      editor.registerCommand(\n        INSERT_INLINE_BLOCK_COMMAND,\n        (fields) => {\n          if (targetNodeKey) {\n            const node = $getNodeByKey(targetNodeKey)\n\n            if (!node || !$isInlineBlockNode(node)) {\n              return false\n            }\n\n            node.setFields(fields as BlockFields)\n\n            setTargetNodeKey(null)\n            return true\n          }\n\n          const inlineBlockNode = $createInlineBlockNode(fields as BlockFields)\n          setCreatedInlineBlock?.(inlineBlockNode)\n          $insertNodes([inlineBlockNode])\n          if ($isRootOrShadowRoot(inlineBlockNode.getParentOrThrow())) {\n            $wrapNodeInElement(inlineBlockNode, $createParagraphNode).selectEnd()\n          }\n\n          return true\n        },\n        COMMAND_PRIORITY_EDITOR,\n      ),\n    )\n  }, [editor, setCreatedInlineBlock, targetNodeKey, toggleDrawer])\n\n  return null\n}\n","'use client'\nimport type { BaseSelection, LexicalEditor } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { $createParagraphNode, $createTextNode, $getRoot, getDOMSelection } from 'lexical'\nimport * as React from 'react'\nimport { type JSX, useCallback, useEffect, useLayoutEffect, useRef, useState } from 'react'\n\nimport type { PluginComponent } from '../../../../typesClient.js'\n\nimport { IS_APPLE } from '../../../../../lexical/utils/environment.js'\nimport './index.scss'\n\nconst copy = (text: null | string) => {\n  const textArea = document.createElement('textarea')\n  textArea.value = text || ''\n  textArea.style.position = 'absolute'\n  textArea.style.opacity = '0'\n  document.body?.appendChild(textArea)\n  textArea.focus()\n  textArea.select()\n  try {\n    const result = document.execCommand('copy')\n    // eslint-disable-next-line no-console\n    console.log(result)\n  } catch (error) {\n    console.error(error)\n  }\n  document.body?.removeChild(textArea)\n}\n\nconst download = (filename: string, text: null | string) => {\n  const a = document.createElement('a')\n  a.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text || ''))\n  a.setAttribute('download', filename)\n  a.style.display = 'none'\n  document.body?.appendChild(a)\n  a.click()\n  document.body?.removeChild(a)\n}\n\nconst formatStep = (step: Step) => {\n  const formatOneStep = (name: string, value: Step['value']) => {\n    switch (name) {\n      case 'click': {\n        return `      await page.mouse.click(${value.x}, ${value.y});`\n      }\n      case 'keydown': {\n        return `      await page.keyboard.keydown('${value}');`\n      }\n      case 'keyup': {\n        return `      await page.keyboard.keyup('${value}');`\n      }\n      case 'press': {\n        return `      await page.keyboard.press('${value}');`\n      }\n      case 'selectAll': {\n        return `      await selectAll(page);`\n      }\n      case 'snapshot': {\n        return `      await assertHTMLSnapshot(page);\n      await assertSelection(page, {\n        anchorPath: [${value.anchorPath.toString()}],\n        anchorOffset: ${value.anchorOffset},\n        focusPath: [${value.focusPath.toString()}],\n        focusOffset: ${value.focusOffset},\n      });\n`\n      }\n      case 'type': {\n        return `      await page.keyboard.type('${value}');`\n      }\n      default:\n        return ``\n    }\n  }\n  const formattedStep = formatOneStep(step.name, step.value)\n  switch (step.count) {\n    case 1:\n      return formattedStep\n    case 2:\n      return [formattedStep, formattedStep].join(`\\n`)\n    default:\n      return `      await repeat(${step.count}, async () => {\n  ${formattedStep}\n      );`\n  }\n}\n\nexport function isSelectAll(event: KeyboardEvent): boolean {\n  return event.key.toLowerCase() === 'a' && (IS_APPLE ? event.metaKey : event.ctrlKey)\n}\n\n// stolen from LexicalSelection-test\nfunction sanitizeSelection(selection: Selection) {\n  const { anchorNode, focusNode } = selection\n  let { anchorOffset, focusOffset } = selection\n  if (anchorOffset !== 0) {\n    anchorOffset--\n  }\n  if (focusOffset !== 0) {\n    focusOffset--\n  }\n  return { anchorNode, anchorOffset, focusNode, focusOffset }\n}\n\nfunction getPathFromNodeToEditor(node: Node, rootElement: HTMLElement | null) {\n  let currentNode: Node | null | undefined = node\n  const path: number[] = []\n  while (currentNode !== rootElement) {\n    if (currentNode !== null && currentNode !== undefined) {\n      path.unshift(\n        Array.from(currentNode?.parentNode?.childNodes ?? []).indexOf(currentNode as ChildNode),\n      )\n    }\n    currentNode = currentNode?.parentNode\n  }\n  return path\n}\n\nconst keyPresses = new Set([\n  'ArrowDown',\n  'ArrowLeft',\n  'ArrowRight',\n  'ArrowUp',\n  'Backspace',\n  'Delete',\n  'Enter',\n  'Escape',\n])\n\ntype Step = {\n  count: number\n  name: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any\n}\n\ntype Steps = Step[]\n\nfunction useTestRecorder(editor: LexicalEditor): [JSX.Element, JSX.Element | null] {\n  const [steps, setSteps] = useState<Steps>([])\n  const [isRecording, setIsRecording] = useState(false)\n  const [, setCurrentInnerHTML] = useState('')\n  const [templatedTest, setTemplatedTest] = useState('')\n  const previousSelectionRef = useRef<BaseSelection | null>(null)\n  const skipNextSelectionChangeRef = useRef(false)\n  const preRef = useRef<HTMLPreElement>(null)\n\n  const getCurrentEditor = useCallback(() => {\n    return editor\n  }, [editor])\n\n  const generateTestContent = useCallback(() => {\n    const rootElement = editor.getRootElement()\n    const browserSelection = getDOMSelection(editor._window)\n\n    if (\n      rootElement == null ||\n      browserSelection == null ||\n      browserSelection.anchorNode == null ||\n      browserSelection.focusNode == null ||\n      !rootElement.contains(browserSelection.anchorNode) ||\n      !rootElement.contains(browserSelection.focusNode)\n    ) {\n      return null\n    }\n\n    return `\nimport {\n  initializeE2E,\n  assertHTMLSnapshot,\n  assertSelection,\n  repeat,\n} from '../utils';\nimport {selectAll} from '../keyboardShortcuts';\nimport { RangeSelection } from 'lexical';\nimport { NodeSelection } from 'lexical';\n\ndescribe('Test case', () => {\n  initializeE2E((e2e) => {\n    it('Should pass this test', async () => {\n      const {page} = e2e;\n\n      await page.focus('div[contenteditable=\"true\"]');\n${steps.map(formatStep).join(`\\n`)}\n    });\n});\n    `\n  }, [editor, steps])\n\n  // just a wrapper around inserting new actions so that we can\n  // coalesce some actions like insertText/moveNativeSelection\n  const pushStep = useCallback(\n    (name: string, value: Step['value']) => {\n      setSteps((currentSteps) => {\n        // trying to group steps\n        const currentIndex = steps.length - 1\n        const lastStep = steps[currentIndex]\n        if (lastStep) {\n          if (lastStep.name === name) {\n            if (name === 'type') {\n              // for typing events we just append the text\n              return [\n                ...steps.slice(0, currentIndex),\n                { ...lastStep, value: lastStep.value + value },\n              ]\n            } else {\n              // for other events we bump the counter if their values are the same\n              if (lastStep.value === value) {\n                return [...steps.slice(0, currentIndex), { ...lastStep, count: lastStep.count + 1 }]\n              }\n            }\n          }\n        }\n        // could not group, just append a new one\n        return [...currentSteps, { name, count: 1, value }]\n      })\n    },\n    [steps, setSteps],\n  )\n\n  useLayoutEffect(() => {\n    const onKeyDown = (event: KeyboardEvent) => {\n      if (!isRecording) {\n        return\n      }\n      const key = event.key\n      if (isSelectAll(event)) {\n        pushStep('selectAll', '')\n      } else if (keyPresses.has(key)) {\n        pushStep('press', event.key)\n      } else if ([...key].length > 1) {\n        pushStep('keydown', event.key)\n      } else {\n        pushStep('type', event.key)\n      }\n    }\n\n    const onKeyUp = (event: KeyboardEvent) => {\n      if (!isRecording) {\n        return\n      }\n      const key = event.key\n      if (!keyPresses.has(key) && [...key].length > 1) {\n        pushStep('keyup', event.key)\n      }\n    }\n\n    return editor.registerRootListener(\n      (rootElement: HTMLElement | null, prevRootElement: HTMLElement | null) => {\n        if (prevRootElement !== null) {\n          prevRootElement.removeEventListener('keydown', onKeyDown)\n          prevRootElement.removeEventListener('keyup', onKeyUp)\n        }\n        if (rootElement !== null) {\n          rootElement.addEventListener('keydown', onKeyDown)\n          rootElement.addEventListener('keyup', onKeyUp)\n        }\n      },\n    )\n  }, [editor, isRecording, pushStep])\n\n  useLayoutEffect(() => {\n    if (preRef.current) {\n      preRef.current.scrollTo(0, preRef.current.scrollHeight)\n    }\n  }, [generateTestContent])\n\n  useEffect(() => {\n    if (steps) {\n      const testContent = generateTestContent()\n      if (testContent !== null) {\n        setTemplatedTest(testContent)\n      }\n      if (preRef.current) {\n        preRef.current.scrollTo(0, preRef.current.scrollHeight)\n      }\n    }\n  }, [generateTestContent, steps])\n\n  useEffect(() => {\n    const removeUpdateListener = editor.registerUpdateListener(\n      ({ dirtyElements, dirtyLeaves, editorState }) => {\n        if (!isRecording) {\n          return\n        }\n        const currentSelection = editorState._selection\n        const previousSelection = previousSelectionRef.current\n        const skipNextSelectionChange = skipNextSelectionChangeRef.current\n        if (previousSelection !== currentSelection) {\n          if (dirtyLeaves.size === 0 && dirtyElements.size === 0 && !skipNextSelectionChange) {\n            const browserSelection = getDOMSelection(editor._window)\n            if (\n              browserSelection &&\n              (browserSelection.anchorNode == null || browserSelection.focusNode == null)\n            ) {\n              return\n            }\n          }\n          previousSelectionRef.current = currentSelection\n        }\n        skipNextSelectionChangeRef.current = false\n        const testContent = generateTestContent()\n        if (testContent !== null) {\n          setTemplatedTest(testContent)\n        }\n      },\n    )\n    return removeUpdateListener\n  }, [editor, generateTestContent, isRecording, pushStep])\n\n  // save innerHTML\n  useEffect(() => {\n    if (!isRecording) {\n      return\n    }\n    const removeUpdateListener = editor.registerUpdateListener(() => {\n      const rootElement = editor.getRootElement()\n      if (rootElement !== null) {\n        setCurrentInnerHTML(rootElement?.innerHTML)\n      }\n    })\n    return removeUpdateListener\n  }, [editor, isRecording])\n\n  // clear editor and start recording\n  const toggleEditorSelection = useCallback(\n    (currentEditor: LexicalEditor) => {\n      if (!isRecording) {\n        currentEditor.update(() => {\n          const root = $getRoot()\n          root.clear()\n          const text = $createTextNode()\n          root.append($createParagraphNode().append(text))\n          text.select()\n        })\n        setSteps([])\n      }\n      setIsRecording((currentIsRecording) => !currentIsRecording)\n    },\n    [isRecording],\n  )\n\n  const onSnapshotClick = useCallback(() => {\n    if (!isRecording) {\n      return\n    }\n    const browserSelection = getDOMSelection(editor._window)\n    if (\n      browserSelection === null ||\n      browserSelection.anchorNode == null ||\n      browserSelection.focusNode == null\n    ) {\n      return\n    }\n    const { anchorNode, anchorOffset, focusNode, focusOffset } = sanitizeSelection(browserSelection)\n    const rootElement = getCurrentEditor().getRootElement()\n    let anchorPath\n    if (anchorNode !== null) {\n      anchorPath = getPathFromNodeToEditor(anchorNode, rootElement)\n    }\n    let focusPath\n    if (focusNode !== null) {\n      focusPath = getPathFromNodeToEditor(focusNode, rootElement)\n    }\n    pushStep('snapshot', {\n      anchorNode,\n      anchorOffset,\n      anchorPath,\n      focusNode,\n      focusOffset,\n      focusPath,\n    })\n  }, [pushStep, isRecording, getCurrentEditor])\n\n  const onCopyClick = useCallback(() => {\n    copy(generateTestContent())\n  }, [generateTestContent])\n\n  const onDownloadClick = useCallback(() => {\n    download('test.js', generateTestContent())\n  }, [generateTestContent])\n\n  const button = (\n    <button\n      className={`editor-dev-button ${isRecording ? 'active' : ''}`}\n      id=\"test-recorder-button\"\n      onClick={(e) => {\n        toggleEditorSelection(getCurrentEditor())\n        e.preventDefault()\n      }}\n      title={isRecording ? 'Disable test recorder' : 'Enable test recorder'}\n      type=\"button\"\n    >\n      {isRecording ? 'Disable test recorder' : 'Enable test recorder'}\n    </button>\n  )\n  const output = isRecording ? (\n    <div className=\"test-recorder-output\">\n      <div className=\"test-recorder-toolbar\">\n        <button\n          className=\"test-recorder-button\"\n          id=\"test-recorder-button-snapshot\"\n          onClick={(e) => {\n            onSnapshotClick()\n            e.preventDefault()\n          }}\n          title=\"Insert snapshot\"\n          type=\"button\"\n        >\n          Insert Snapshot\n        </button>\n        <button\n          className=\"test-recorder-button\"\n          id=\"test-recorder-button-copy\"\n          onClick={(e) => {\n            onCopyClick()\n            e.preventDefault()\n          }}\n          title=\"Copy to clipboard\"\n          type=\"button\"\n        >\n          Copy\n        </button>\n        <button\n          className=\"test-recorder-button\"\n          id=\"test-recorder-button-download\"\n          onClick={(e) => {\n            onDownloadClick()\n            e.preventDefault()\n          }}\n          title=\"Download as a file\"\n          type=\"button\"\n        >\n          Download\n        </button>\n      </div>\n      <pre id=\"test-recorder\" ref={preRef}>\n        {templatedTest}\n      </pre>\n    </div>\n  ) : null\n\n  return [button, output]\n}\nexport const TestRecorderPlugin: PluginComponent<undefined> = () => {\n  const [editor] = useLexicalComposerContext()\n  const [testRecorderButton, testRecorderOutput] = useTestRecorder(editor)\n\n  return (\n    <React.Fragment>\n      <p>HI</p>\n      {testRecorderButton}\n      {testRecorderOutput}\n      <p>DONE</p>\n    </React.Fragment>\n  )\n}\n","'use client'\nimport { CAN_USE_DOM } from './canUseDOM.js'\n\ndeclare global {\n  interface Document {\n    documentMode?: unknown\n  }\n\n  interface Window {\n    MSStream?: unknown\n  }\n}\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null\n\nexport const IS_APPLE: boolean = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform)\n\nexport const IS_FIREFOX: boolean =\n  CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent)\n\nexport const CAN_USE_BEFORE_INPUT: boolean =\n  CAN_USE_DOM && 'InputEvent' in window && !documentMode\n    ? 'getTargetRanges' in new window.InputEvent('input')\n    : false\n\nexport const IS_SAFARI: boolean = CAN_USE_DOM && /Version\\/[\\d.].*Safari/.test(navigator.userAgent)\n\nexport const IS_IOS: boolean =\n  CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream\n\nexport const IS_ANDROID: boolean = CAN_USE_DOM && /Android/.test(navigator.userAgent)\n\nexport const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform)\nexport const IS_CHROME: boolean = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent)\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nexport const IS_APPLE_WEBKIT =\n  CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME\n","'use client'\n\nimport { createClientFeature } from '../../../../utilities/createClientFeature.js'\nimport { TestRecorderPlugin } from './plugin/index.js'\n\nexport const TestRecorderFeatureClient = createClientFeature({\n  plugins: [\n    {\n      Component: TestRecorderPlugin,\n      position: 'bottom',\n    },\n  ],\n})\n","'use client'\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { TreeView } from '@lexical/react/LexicalTreeView.js'\nimport * as React from 'react'\n\nimport type { PluginComponent } from '../../../../typesClient.js'\n\nimport './index.scss'\n\nexport const TreeViewPlugin: PluginComponent<undefined> = () => {\n  const [editor] = useLexicalComposerContext()\n  return (\n    <TreeView\n      editor={editor}\n      timeTravelButtonClassName=\"debug-timetravel-button\"\n      timeTravelPanelButtonClassName=\"debug-timetravel-panel-button\"\n      timeTravelPanelClassName=\"debug-timetravel-panel\"\n      timeTravelPanelSliderClassName=\"debug-timetravel-panel-slider\"\n      treeTypeButtonClassName=\"debug-treetype-button\"\n      viewClassName=\"tree-view-output\"\n    />\n  )\n}\n","'use client'\n\nimport { createClientFeature } from '../../../../utilities/createClientFeature.js'\nimport { TreeViewPlugin } from './plugin/index.js'\n\nexport const TreeViewFeatureClient = createClientFeature({\n  plugins: [\n    {\n      Component: TreeViewPlugin,\n      position: 'bottom',\n    },\n  ],\n})\n","'use client'\nimport { $isTableSelection } from '@lexical/table'\nimport { $isRangeSelection, FORMAT_TEXT_COMMAND } from 'lexical'\n\nimport type { ToolbarGroup } from '../../toolbars/types.js'\n\nimport { BoldIcon } from '../../../lexical/ui/icons/Bold/index.js'\nimport { createClientFeature } from '../../../utilities/createClientFeature.js'\nimport { toolbarFormatGroupWithItems } from '../shared/toolbarFormatGroup.js'\nimport {\n  BOLD_ITALIC_STAR,\n  BOLD_ITALIC_UNDERSCORE,\n  BOLD_STAR,\n  BOLD_UNDERSCORE,\n} from './markdownTransformers.js'\n\nconst toolbarGroups: ToolbarGroup[] = [\n  toolbarFormatGroupWithItems([\n    {\n      ChildComponent: BoldIcon,\n      isActive: ({ selection }) => {\n        if ($isRangeSelection(selection) || $isTableSelection(selection)) {\n          return selection.hasFormat('bold')\n        }\n        return false\n      },\n      key: 'bold',\n      onSelect: ({ editor }) => {\n        editor.dispatchCommand(FORMAT_TEXT_COMMAND, 'bold')\n      },\n      order: 1,\n    },\n  ]),\n]\n\nexport const BoldFeatureClient = createClientFeature(({ featureProviderMap }) => {\n  const markdownTransformers = [BOLD_STAR, BOLD_UNDERSCORE]\n  if (featureProviderMap.get('italic')) {\n    markdownTransformers.push(BOLD_ITALIC_UNDERSCORE, BOLD_ITALIC_STAR)\n  }\n\n  return {\n    enableFormats: ['bold'],\n    markdownTransformers,\n    toolbarFixed: {\n      groups: toolbarGroups,\n    },\n    toolbarInline: {\n      groups: toolbarGroups,\n    },\n  }\n})\n","'use client'\nimport React from 'react'\n\nexport const BoldIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"currentColor\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path\n      d=\"M10.6772 15H6.27017V5.718H10.4172C12.6792 5.718 13.8492 6.602 13.8492 8.292C13.8492 9.098 13.1992 9.982 12.4712 10.216C13.3812 10.476 14.1742 11.256 14.1742 12.322C14.1742 14.09 12.9002 15 10.6772 15ZM8.46717 9.501H10.3262C11.3012 9.501 11.7042 9.046 11.7042 8.409C11.7042 7.72 11.2362 7.317 10.3392 7.317H8.46717V9.501ZM8.46717 11.061V13.401H10.4822C11.4702 13.401 11.9642 12.959 11.9642 12.218C11.9642 11.49 11.4702 11.061 10.4822 11.061H8.46717Z\"\n      fill=\"currentColor\"\n    />\n  </svg>\n)\n","'use client'\nimport type { ToolbarGroup, ToolbarGroupItem } from '../../toolbars/types.js'\n\nexport const toolbarFormatGroupWithItems = (items: ToolbarGroupItem[]): ToolbarGroup => {\n  return {\n    type: 'buttons',\n    items,\n    key: 'format',\n    order: 40,\n  }\n}\n","import type { TextFormatTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nexport const BOLD_ITALIC_STAR: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['bold', 'italic'],\n  tag: '***',\n}\n\nexport const BOLD_ITALIC_UNDERSCORE: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n}\n\nexport const BOLD_STAR: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['bold'],\n  tag: '**',\n}\n\nexport const BOLD_UNDERSCORE: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n}\n","'use client'\n\nimport { $isTableSelection } from '@lexical/table'\nimport { $isRangeSelection, FORMAT_TEXT_COMMAND } from 'lexical'\n\nimport type { ToolbarGroup } from '../../toolbars/types.js'\n\nimport { CodeIcon } from '../../../lexical/ui/icons/Code/index.js'\nimport { createClientFeature } from '../../../utilities/createClientFeature.js'\nimport { toolbarFormatGroupWithItems } from '../shared/toolbarFormatGroup.js'\nimport { INLINE_CODE } from './markdownTransformers.js'\n\nconst toolbarGroups: ToolbarGroup[] = [\n  toolbarFormatGroupWithItems([\n    {\n      ChildComponent: CodeIcon,\n      isActive: ({ selection }) => {\n        if ($isRangeSelection(selection) || $isTableSelection(selection)) {\n          return selection.hasFormat('code')\n        }\n        return false\n      },\n      key: 'inlineCode',\n      onSelect: ({ editor }) => {\n        editor.dispatchCommand(FORMAT_TEXT_COMMAND, 'code')\n      },\n      order: 7,\n    },\n  ]),\n]\n\nexport const InlineCodeFeatureClient = createClientFeature({\n  enableFormats: ['code'],\n  markdownTransformers: [INLINE_CODE],\n  toolbarFixed: {\n    groups: toolbarGroups,\n  },\n  toolbarInline: {\n    groups: toolbarGroups,\n  },\n})\n","'use client'\nimport React from 'react'\n\nexport const CodeIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path d=\"M7.76465 6L3.76465 10L7.76465 14\" stroke=\"currentColor\" />\n    <path d=\"M12.2354 6L16.2354 10L12.2354 14\" stroke=\"currentColor\" />\n  </svg>\n)\n","import type { TextFormatTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nexport const INLINE_CODE: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['code'],\n  tag: '`',\n}\n","'use client'\n\nimport { $isTableSelection } from '@lexical/table'\nimport { $isRangeSelection, FORMAT_TEXT_COMMAND } from 'lexical'\n\nimport type { ToolbarGroup } from '../../toolbars/types.js'\n\nimport { ItalicIcon } from '../../../lexical/ui/icons/Italic/index.js'\nimport { createClientFeature } from '../../../utilities/createClientFeature.js'\nimport { toolbarFormatGroupWithItems } from '../shared/toolbarFormatGroup.js'\nimport { ITALIC_STAR, ITALIC_UNDERSCORE } from './markdownTransformers.js'\n\nconst toolbarGroups: ToolbarGroup[] = [\n  toolbarFormatGroupWithItems([\n    {\n      ChildComponent: ItalicIcon,\n      isActive: ({ selection }) => {\n        if ($isRangeSelection(selection) || $isTableSelection(selection)) {\n          return selection.hasFormat('italic')\n        }\n        return false\n      },\n      key: 'italic',\n      onSelect: ({ editor }) => {\n        editor.dispatchCommand(FORMAT_TEXT_COMMAND, 'italic')\n      },\n      order: 2,\n    },\n  ]),\n]\n\nexport const ItalicFeatureClient = createClientFeature({\n  enableFormats: ['italic'],\n  markdownTransformers: [ITALIC_STAR, ITALIC_UNDERSCORE],\n  toolbarFixed: {\n    groups: toolbarGroups,\n  },\n  toolbarInline: {\n    groups: toolbarGroups,\n  },\n})\n","'use client'\nimport React from 'react'\n\nexport const ItalicIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"currentColor\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path\n      d=\"M11.311 14.2969L11.0327 15H6.18408L6.4624 14.2969C7.54639 14.2969 7.70752 14.209 7.83936 13.8721L10.8423 6.45996C10.8716 6.38672 10.8862 6.32812 10.8862 6.26953C10.8862 6.09375 10.6519 6.03516 9.80225 6.03516L10.0952 5.33203H14.9438L14.6509 6.03516C13.5669 6.03516 13.4204 6.12305 13.2886 6.45996L10.2856 13.8721C10.2563 13.9453 10.2271 14.0039 10.2271 14.0625C10.2271 14.2383 10.4614 14.2969 11.311 14.2969Z\"\n      fill=\"currentColor\"\n    />\n  </svg>\n)\n","import type { TextFormatTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nexport const ITALIC_STAR: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['italic'],\n  tag: '*',\n}\n\nexport const ITALIC_UNDERSCORE: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n}\n","'use client'\n\nimport { $isTableSelection } from '@lexical/table'\nimport { $isRangeSelection, FORMAT_TEXT_COMMAND } from 'lexical'\n\nimport { StrikethroughIcon } from '../../../lexical/ui/icons/Strikethrough/index.js'\nimport { createClientFeature } from '../../../utilities/createClientFeature.js'\nimport { toolbarFormatGroupWithItems } from '../shared/toolbarFormatGroup.js'\nimport { STRIKETHROUGH } from './markdownTransformers.js'\n\nconst toolbarGroups = [\n  toolbarFormatGroupWithItems([\n    {\n      ChildComponent: StrikethroughIcon,\n      isActive: ({ selection }) => {\n        if ($isRangeSelection(selection) || $isTableSelection(selection)) {\n          return selection.hasFormat('strikethrough')\n        }\n        return false\n      },\n      key: 'strikethrough',\n      onSelect: ({ editor }) => {\n        editor.dispatchCommand(FORMAT_TEXT_COMMAND, 'strikethrough')\n      },\n      order: 4,\n    },\n  ]),\n]\n\nexport const StrikethroughFeatureClient = createClientFeature({\n  enableFormats: ['strikethrough'],\n  markdownTransformers: [STRIKETHROUGH],\n  toolbarFixed: {\n    groups: toolbarGroups,\n  },\n  toolbarInline: {\n    groups: toolbarGroups,\n  },\n})\n","'use client'\nimport React from 'react'\n\nexport const StrikethroughIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"currentColor\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path\n      d=\"M5.50756 12.76H7.42756C7.56256 14.215 8.82256 14.71 10.1576 14.71C11.4326 14.71 12.4226 14.14 12.4226 13.06C12.4226 12.28 11.9576 11.845 10.6676 11.605L8.70256 11.245C7.12756 10.96 5.85256 10.21 5.85256 8.335C5.85256 6.43 7.53256 5.11 9.87256 5.11C12.4226 5.11 13.9526 6.22 14.1626 8.23H12.2876C12.1526 7.18 11.2226 6.595 9.88756 6.595C8.59756 6.595 7.78756 7.27 7.78756 8.215C7.78756 9.1 8.34256 9.385 9.49756 9.61L11.5676 10.015C13.3226 10.345 14.3726 11.215 14.3726 12.94C14.3726 14.89 12.5876 16.18 10.2176 16.18C7.66756 16.18 5.70256 15.115 5.50756 12.76Z\"\n      fill=\"currentColor\"\n    />\n    <path d=\"M4.99756 11.44H15.0026V12.19H4.99756V11.44Z\" fill=\"currentColor\" />\n  </svg>\n)\n","import type { TextFormatTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nexport const STRIKETHROUGH: TextFormatTransformer = {\n  type: 'text-format',\n  format: ['strikethrough'],\n  tag: '~~',\n}\n","'use client'\n\nimport { $isTableSelection } from '@lexical/table'\nimport { $isRangeSelection, FORMAT_TEXT_COMMAND } from 'lexical'\n\nimport type { ToolbarGroup } from '../../toolbars/types.js'\n\nimport { SubscriptIcon } from '../../../lexical/ui/icons/Subscript/index.js'\nimport { createClientFeature } from '../../../utilities/createClientFeature.js'\nimport { toolbarFormatGroupWithItems } from '../shared/toolbarFormatGroup.js'\n\nconst toolbarGroups: ToolbarGroup[] = [\n  toolbarFormatGroupWithItems([\n    {\n      ChildComponent: SubscriptIcon,\n      isActive: ({ selection }) => {\n        if ($isRangeSelection(selection) || $isTableSelection(selection)) {\n          return selection.hasFormat('subscript')\n        }\n        return false\n      },\n      key: 'subscript',\n      onSelect: ({ editor }) => {\n        editor.dispatchCommand(FORMAT_TEXT_COMMAND, 'subscript')\n      },\n      order: 5,\n    },\n  ]),\n]\n\nexport const SubscriptFeatureClient = createClientFeature({\n  enableFormats: ['subscript'],\n  toolbarFixed: {\n    groups: toolbarGroups,\n  },\n  toolbarInline: {\n    groups: toolbarGroups,\n  },\n})\n","'use client'\nimport React from 'react'\n\nexport const SubscriptIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"currentColor\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path\n      d=\"M10.167 15L7.45002 11.36L4.73302 15H2.91302L6.55302 10.177L3.23802 5.718H5.20102L7.54102 8.89L9.89402 5.718H11.714L8.43802 10.06L12.13 15H10.167ZM16.7768 13.258C16.7768 14.155 16.1398 14.532 15.2038 15C14.5538 15.325 14.2808 15.546 14.2418 15.78H16.7898V16.82H12.7208V16.339C12.7208 15.286 13.5918 14.675 14.3588 14.233C15.0868 13.83 15.4378 13.635 15.4378 13.232C15.4378 12.894 15.2038 12.686 14.8268 12.686C14.3848 12.686 14.1248 13.024 14.1118 13.427H12.7468C12.8248 12.426 13.5528 11.633 14.8398 11.633C15.9448 11.633 16.7768 12.257 16.7768 13.258Z\"\n      fill=\"currentColor\"\n    />\n  </svg>\n)\n","'use client'\n\nimport { $isTableSelection } from '@lexical/table'\nimport { $isRangeSelection, FORMAT_TEXT_COMMAND } from 'lexical'\n\nimport type { ToolbarGroup } from '../../toolbars/types.js'\n\nimport { SuperscriptIcon } from '../../../lexical/ui/icons/Superscript/index.js'\nimport { createClientFeature } from '../../../utilities/createClientFeature.js'\nimport { toolbarFormatGroupWithItems } from '../shared/toolbarFormatGroup.js'\n\nconst toolbarGroups: ToolbarGroup[] = [\n  toolbarFormatGroupWithItems([\n    {\n      ChildComponent: SuperscriptIcon,\n      isActive: ({ selection }) => {\n        if ($isRangeSelection(selection) || $isTableSelection(selection)) {\n          return selection.hasFormat('superscript')\n        }\n        return false\n      },\n      key: 'superscript',\n      onSelect: ({ editor }) => {\n        editor.dispatchCommand(FORMAT_TEXT_COMMAND, 'superscript')\n      },\n      order: 6,\n    },\n  ]),\n]\n\nexport const SuperscriptFeatureClient = createClientFeature({\n  enableFormats: ['superscript'],\n  toolbarFixed: {\n    groups: toolbarGroups,\n  },\n  toolbarInline: {\n    groups: toolbarGroups,\n  },\n})\n","'use client'\nimport React from 'react'\n\nexport const SuperscriptIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"currentColor\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path\n      d=\"M10.167 15L7.45002 11.36L4.73302 15H2.91302L6.55302 10.177L3.23802 5.718H5.20102L7.54102 8.89L9.89402 5.718H11.714L8.43802 10.06L12.13 15H10.167ZM16.7768 7.252C16.7768 8.149 16.1398 8.526 15.2038 8.994C14.5538 9.319 14.2808 9.54 14.2418 9.774H16.7898V10.814H12.7208V10.333C12.7208 9.28 13.5918 8.669 14.3588 8.227C15.0868 7.824 15.4378 7.629 15.4378 7.226C15.4378 6.888 15.2038 6.68 14.8268 6.68C14.3848 6.68 14.1248 7.018 14.1118 7.421H12.7468C12.8248 6.42 13.5528 5.627 14.8398 5.627C15.9448 5.627 16.7768 6.251 16.7768 7.252Z\"\n      fill=\"currentColor\"\n    />\n  </svg>\n)\n","'use client'\n\nimport { $isTableSelection } from '@lexical/table'\nimport { $isRangeSelection, FORMAT_TEXT_COMMAND } from 'lexical'\n\nimport type { ToolbarGroup } from '../../toolbars/types.js'\n\nimport { UnderlineIcon } from '../../../lexical/ui/icons/Underline/index.js'\nimport { createClientFeature } from '../../../utilities/createClientFeature.js'\nimport { toolbarFormatGroupWithItems } from '../shared/toolbarFormatGroup.js'\n\nconst toolbarGroups: ToolbarGroup[] = [\n  toolbarFormatGroupWithItems([\n    {\n      ChildComponent: UnderlineIcon,\n      isActive: ({ selection }) => {\n        if ($isRangeSelection(selection) || $isTableSelection(selection)) {\n          return selection.hasFormat('underline')\n        }\n        return false\n      },\n      key: 'underline',\n      onSelect: ({ editor }) => {\n        editor.dispatchCommand(FORMAT_TEXT_COMMAND, 'underline')\n      },\n      order: 3,\n    },\n  ]),\n]\n\nexport const UnderlineFeatureClient = createClientFeature({\n  enableFormats: ['underline'],\n  toolbarFixed: {\n    groups: toolbarGroups,\n  },\n  toolbarInline: {\n    groups: toolbarGroups,\n  },\n})\n","'use client'\nimport React from 'react'\n\nexport const UnderlineIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"currentColor\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path\n      d=\"M13.9656 11.256C13.9656 13.791 12.5096 15.156 10.0006 15.156C7.50461 15.156 6.03561 13.791 6.03561 11.23V5.718H7.76461V11.243C7.76461 12.868 8.50561 13.778 10.0006 13.778C11.4956 13.778 12.2496 12.868 12.2496 11.243V5.718H13.9656V11.256Z\"\n      fill=\"currentColor\"\n    />\n    <path d=\"M5.09961 16.3H14.9016V16.95H5.09961V16.3Z\" fill=\"currentColor\" />\n  </svg>\n)\n","import type { StyleObject } from '../../../../features/textState/feature.server.js'\n\nfunction kebabToCamelCase(str: string): string {\n  return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase())\n}\n\nexport const TextStateIcon: React.FC<{\n  css?: StyleObject\n}> = ({ css }) => {\n  const convertedCss = css\n    ? Object.fromEntries(Object.entries(css).map(([key, value]) => [kebabToCamelCase(key), value]))\n    : {}\n\n  return (\n    <span\n      style={{\n        ...convertedCss,\n        alignItems: 'center',\n        borderRadius: '4px',\n        display: 'flex',\n        fontSize: '16px',\n        height: '20px',\n        justifyContent: 'center',\n        width: '20px',\n      }}\n    >\n      A\n    </span>\n  )\n}\n","import type { LexicalEditor, StateConfig } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { $forEachSelectedTextNode } from '@lexical/selection'\nimport { $getNodeByKey, $getState, $setState, createState, TextNode } from 'lexical'\nimport { useEffect } from 'react'\n\nimport { type StateValues, type TextStateFeatureProps } from './feature.server.js'\n\nexport type StateMap = Map<\n  string,\n  {\n    stateConfig: StateConfig<string, string | undefined>\n    stateValues: StateValues\n  }\n>\n\nexport function registerTextStates(state: TextStateFeatureProps['state']) {\n  const stateMap: StateMap = new Map()\n\n  for (const stateKey in state) {\n    const stateValues = state[stateKey]!\n    const stateConfig = createState(stateKey, {\n      parse: (value) =>\n        typeof value === 'string' && Object.keys(stateValues).includes(value) ? value : undefined,\n    })\n    stateMap.set(stateKey, { stateConfig, stateValues })\n  }\n  return stateMap\n}\n\nexport function setTextState(\n  editor: LexicalEditor,\n  stateMap: StateMap,\n  stateKey: string,\n  value: string | undefined,\n) {\n  editor.update(() => {\n    $forEachSelectedTextNode((textNode) => {\n      const stateMapEntry = stateMap.get(stateKey)\n      if (!stateMapEntry) {\n        throw new Error(`State config for ${stateKey} not found`)\n      }\n      $setState(textNode, stateMapEntry.stateConfig, value)\n    })\n  })\n}\n\nexport function StatePlugin({ stateMap }: { stateMap: StateMap }) {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    return editor.registerMutationListener(TextNode, (mutatedNodes) => {\n      editor.getEditorState().read(() => {\n        for (const [nodeKey, mutation] of mutatedNodes) {\n          if (mutation === 'destroyed') {\n            continue\n          }\n          const node = $getNodeByKey(nodeKey)\n          const dom = editor.getElementByKey(nodeKey)\n          if (!node || !dom) {\n            continue\n          }\n\n          const mergedStyles: Record<string, string> = Object.create(null)\n          // Examples:\n          // stateKey: 'color'\n          // stateValue: 'bg-red'\n          stateMap.forEach((stateEntry, stateKey) => {\n            const stateValue = $getState(node, stateEntry.stateConfig)\n            if (!stateValue) {\n              // clear the previous dataset value for this key\n              delete dom.dataset[stateKey]\n              return\n            } // skip - nothing else to do\n\n            dom.dataset[stateKey] = stateValue\n\n            const css = stateEntry.stateValues[stateValue]?.css\n            if (css) {\n              // merge existing styles with the new ones\n              Object.assign(mergedStyles, css)\n            }\n          })\n\n          // wipe previous inline styles once, then set the merged ones\n          dom.style.cssText = ''\n          Object.assign(dom.style, mergedStyles)\n        }\n      })\n    })\n  }, [editor])\n\n  return null\n}\n","'use client'\n\nimport type { ToolbarDropdownGroup, ToolbarGroup } from '../toolbars/types.js'\nimport type { TextStateFeatureProps } from './feature.server.js'\n\nimport { TextStateIcon } from '../../lexical/ui/icons/TextState/index.js'\nimport { createClientFeature } from '../../utilities/createClientFeature.js'\nimport { registerTextStates, setTextState, type StateMap, StatePlugin } from './textState.js'\n\nconst toolbarGroups = (props: TextStateFeatureProps, stateMap: StateMap): ToolbarGroup[] => {\n  const items: ToolbarDropdownGroup['items'] = []\n\n  for (const stateKey in props.state) {\n    const key = props.state[stateKey]!\n    for (const stateValue in key) {\n      const meta = key[stateValue]!\n      items.push({\n        ChildComponent: () => <TextStateIcon css={meta.css} />,\n        key: stateValue,\n        label: meta.label,\n        onSelect: ({ editor }) => {\n          setTextState(editor, stateMap, stateKey, stateValue)\n        },\n      })\n    }\n  }\n\n  const clearStyle: ToolbarDropdownGroup['items'] = [\n    {\n      ChildComponent: () => <TextStateIcon />,\n      key: `clear-style`,\n      label: ({ i18n }) => i18n.t('lexical:textState:defaultStyle'),\n      onSelect: ({ editor }) => {\n        for (const stateKey in props.state) {\n          setTextState(editor, stateMap, stateKey, undefined)\n        }\n      },\n      order: 1,\n    },\n  ]\n\n  return [\n    {\n      type: 'dropdown',\n      ChildComponent: () => <TextStateIcon css={{ color: 'var(--theme-elevation-600)' }} />,\n      items: [...clearStyle, ...items],\n      key: 'textState',\n      order: 30,\n    },\n  ]\n}\n\nexport const TextStateFeatureClient = createClientFeature<TextStateFeatureProps>(({ props }) => {\n  const stateMap = registerTextStates(props.state)\n  return {\n    plugins: [\n      {\n        Component: () => StatePlugin({ stateMap }),\n        position: 'normal',\n      },\n    ],\n    toolbarFixed: {\n      groups: toolbarGroups(props, stateMap),\n    },\n    toolbarInline: {\n      groups: toolbarGroups(props, stateMap),\n    },\n  }\n})\n","'use client'\n\nimport type { HeadingTagType } from '@lexical/rich-text'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { $createHeadingNode, $isHeadingNode, HeadingNode } from '@lexical/rich-text'\nimport { $setBlocksType } from '@lexical/selection'\nimport { $getSelection, $isRangeSelection } from 'lexical'\nimport { useEffect } from 'react'\n\nimport type { ToolbarGroup } from '../../toolbars/types.js'\nimport type { PluginComponent } from '../../typesClient.js'\nimport type { HeadingFeatureProps } from '../server/index.js'\n\nimport { H1Icon } from '../../../lexical/ui/icons/H1/index.js'\nimport { H2Icon } from '../../../lexical/ui/icons/H2/index.js'\nimport { H3Icon } from '../../../lexical/ui/icons/H3/index.js'\nimport { H4Icon } from '../../../lexical/ui/icons/H4/index.js'\nimport { H5Icon } from '../../../lexical/ui/icons/H5/index.js'\nimport { H6Icon } from '../../../lexical/ui/icons/H6/index.js'\nimport { createClientFeature } from '../../../utilities/createClientFeature.js'\nimport { slashMenuBasicGroupWithItems } from '../../shared/slashMenu/basicGroup.js'\nimport { toolbarTextDropdownGroupWithItems } from '../../shared/toolbar/textDropdownGroup.js'\nimport { MarkdownTransformer } from '../markdownTransformer.js'\n\nconst $setHeading = (headingSize: HeadingTagType) => {\n  const selection = $getSelection()\n  $setBlocksType(selection, () => $createHeadingNode(headingSize))\n}\n\nconst iconImports = {\n  h1: H1Icon,\n  h2: H2Icon,\n  h3: H3Icon,\n  h4: H4Icon,\n  h5: H5Icon,\n  h6: H6Icon,\n}\n\nexport const HeadingFeatureClient = createClientFeature<HeadingFeatureProps>(({ props }) => {\n  const { enabledHeadingSizes = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] } = props\n\n  const toolbarGroups: ToolbarGroup[] = [\n    toolbarTextDropdownGroupWithItems(\n      enabledHeadingSizes.map((headingSize, i) => {\n        return {\n          ChildComponent: iconImports[headingSize],\n          isActive: ({ selection }) => {\n            if (!$isRangeSelection(selection)) {\n              return false\n            }\n            for (const node of selection.getNodes()) {\n              if ($isHeadingNode(node) && node.getTag() === headingSize) {\n                continue\n              }\n\n              const parent = node.getParent()\n              if ($isHeadingNode(parent) && parent.getTag() === headingSize) {\n                continue\n              }\n\n              return false\n            }\n            return true\n          },\n          key: headingSize,\n          label: ({ i18n }) => {\n            return i18n.t('lexical:heading:label', { headingLevel: headingSize.charAt(1) })\n          },\n          onSelect: ({ editor }) => {\n            editor.update(() => {\n              $setHeading(headingSize)\n            })\n          },\n          order: i + 2,\n        }\n      }),\n    ),\n  ]\n\n  return {\n    markdownTransformers: [MarkdownTransformer(enabledHeadingSizes)],\n    nodes: [HeadingNode],\n    plugins: [\n      {\n        Component: HeadingPlugin,\n        position: 'normal',\n      },\n    ],\n    sanitizedClientFeatureProps: props,\n    slashMenu: {\n      groups: enabledHeadingSizes?.length\n        ? [\n            slashMenuBasicGroupWithItems(\n              enabledHeadingSizes.map((headingSize) => {\n                return {\n                  Icon: iconImports[headingSize],\n                  key: `heading-${headingSize.charAt(1)}`,\n                  keywords: ['heading', headingSize],\n                  label: ({ i18n }) => {\n                    return i18n.t('lexical:heading:label', {\n                      headingLevel: headingSize.charAt(1),\n                    })\n                  },\n                  onSelect: ({ editor }) => {\n                    editor.update(() => {\n                      $setHeading(headingSize)\n                    })\n                  },\n                }\n              }),\n            ),\n          ]\n        : [],\n    },\n    toolbarFixed: {\n      groups: enabledHeadingSizes?.length ? toolbarGroups : [],\n    },\n    toolbarInline: {\n      groups: enabledHeadingSizes?.length ? toolbarGroups : [],\n    },\n  }\n})\n\nconst HeadingPlugin: PluginComponent<HeadingFeatureProps> = ({ clientProps }) => {\n  const { enabledHeadingSizes = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] } = clientProps\n  const lowestAllowed = enabledHeadingSizes.at(-1)\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    if (!lowestAllowed || enabledHeadingSizes.length === 6) {\n      return\n    }\n    return editor.registerNodeTransform(HeadingNode, (node) => {\n      if (!enabledHeadingSizes.includes(node.getTag())) {\n        node.setTag(lowestAllowed)\n      }\n    })\n  }, [editor, enabledHeadingSizes, lowestAllowed])\n\n  return null\n}\n","'use client'\nimport React from 'react'\n\nexport const H1Icon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path\n      d=\"M4.639 13.5V7.074H6.196V9.648H9.076V7.074H10.642V13.5H9.076V10.836H6.196V13.5H4.639ZM11.5656 9.045V8.019C12.6636 8.019 13.1316 7.731 13.2846 7.065H14.4006V13.5H12.8436V9.045H11.5656Z\"\n      fill=\"currentColor\"\n    />\n  </svg>\n)\n","'use client'\nimport React from 'react'\n\nexport const H2Icon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path\n      d=\"M4.139 13.5V7.074H5.696V9.648H8.576V7.074H10.142V13.5H8.576V10.836H5.696V13.5H4.139ZM15.9796 8.973C15.9796 10.116 15.1696 10.656 14.0356 11.232C13.2256 11.646 12.8206 11.943 12.7846 12.294H15.9886V13.5H11.0566V12.951C11.0566 11.601 12.1636 10.845 13.1176 10.287C14.0356 9.756 14.5126 9.486 14.5126 8.946C14.5126 8.46 14.2156 8.145 13.6306 8.145C13.0186 8.145 12.6586 8.613 12.6226 9.198H11.1196C11.2186 7.947 12.1006 6.966 13.6396 6.966C15.0346 6.966 15.9796 7.785 15.9796 8.973Z\"\n      fill=\"currentColor\"\n    />\n  </svg>\n)\n","'use client'\nimport React from 'react'\n\nexport const H3Icon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path\n      d=\"M4.139 13.5V7.074H5.696V9.648H8.576V7.074H10.142V13.5H8.576V10.836H5.696V13.5H4.139ZM16.1146 11.745C16.1146 12.744 15.2236 13.608 13.6126 13.608C12.0736 13.608 11.0926 12.762 10.9846 11.547H12.4696C12.5146 12.114 13.0006 12.456 13.6126 12.456C14.2876 12.456 14.6746 12.132 14.6746 11.619C14.6746 11.061 14.2426 10.836 13.6216 10.836H12.9826V9.738H13.6036C14.1526 9.738 14.5486 9.486 14.5486 8.937C14.5486 8.46 14.2156 8.127 13.6486 8.127C13.0366 8.127 12.6586 8.514 12.6226 9.045H11.1916C11.2726 7.929 12.1276 6.966 13.6666 6.966C15.1876 6.966 15.9706 7.848 15.9706 8.865C15.9706 9.603 15.5026 10.143 14.8186 10.269C15.6196 10.404 16.1146 10.971 16.1146 11.745Z\"\n      fill=\"currentColor\"\n    />\n  </svg>\n)\n","'use client'\nimport React from 'react'\n\nexport const H4Icon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path\n      d=\"M3.639 13.5V7.074H5.196V9.648H8.076V7.074H9.642V13.5H8.076V10.836H5.196V13.5H3.639ZM15.1736 7.074V10.854H16.3706V12.033H15.1736V13.5H13.6796V12.033H10.5116V10.845L13.4996 7.074H15.1736ZM13.6796 8.46L11.8256 10.854H13.6796V8.46Z\"\n      fill=\"currentColor\"\n    />\n  </svg>\n)\n","'use client'\nimport React from 'react'\n\nexport const H5Icon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path\n      d=\"M3.639 13.5V7.074H5.196V9.648H8.076V7.074H9.642V13.5H8.076V10.836H5.196V13.5H3.639ZM13.1576 10.269C12.6896 10.269 12.3746 10.494 12.2216 10.737H10.8176L11.1956 7.074H15.2546V8.28H12.3206L12.1856 9.549C12.4016 9.351 12.8516 9.126 13.4636 9.126C14.7866 9.126 15.6596 10.053 15.6596 11.358C15.6596 12.609 14.7326 13.608 13.1756 13.608C11.5826 13.608 10.6556 12.753 10.5566 11.511H12.1136C12.1586 12.06 12.5456 12.465 13.1576 12.465C13.8236 12.465 14.1746 11.97 14.1746 11.376C14.1746 10.764 13.8416 10.269 13.1576 10.269Z\"\n      fill=\"currentColor\"\n    />\n  </svg>\n)\n","'use client'\nimport React from 'react'\n\nexport const H6Icon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path\n      d=\"M3.639 13.5V7.074H5.196V9.648H8.076V7.074H9.642V13.5H8.076V10.836H5.196V13.5H3.639ZM13.3646 8.127C12.5456 8.127 12.0416 8.937 12.0416 9.999C12.3296 9.54 12.8246 9.207 13.5536 9.207C14.8586 9.207 15.8036 10.134 15.8036 11.376C15.8036 12.645 14.8226 13.608 13.3196 13.608C11.7266 13.608 10.6196 12.393 10.6196 10.395C10.6196 8.316 11.7716 6.966 13.4186 6.966C14.7056 6.966 15.5786 7.749 15.7316 8.829H14.3186C14.2016 8.415 13.9226 8.127 13.3646 8.127ZM13.3106 12.51C13.9586 12.51 14.3816 12.042 14.3816 11.385C14.3816 10.737 13.9586 10.278 13.3106 10.278C12.6536 10.278 12.2126 10.737 12.2126 11.385C12.2126 12.042 12.6536 12.51 13.3106 12.51Z\"\n      fill=\"currentColor\"\n    />\n  </svg>\n)\n","import type { HeadingTagType } from '@lexical/rich-text'\n\nimport { $createHeadingNode, $isHeadingNode, HeadingNode } from '@lexical/rich-text'\n\nimport type { ElementTransformer } from '../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport { createBlockNode } from '../../lexical/utils/markdown/createBlockNode.js'\n\nexport const MarkdownTransformer: (enabledHeadingSizes: HeadingTagType[]) => ElementTransformer = (\n  enabledHeadingSizes,\n) => {\n  // Convert enabledHeadingSizes to a list of numbers (1 for h1, 2 for h2, etc.)\n  const enabledSizes = enabledHeadingSizes.map((tag) => Number(tag.slice(1)))\n\n  // Create a regex pattern that matches any of the enabled sizes\n  const pattern = `^(${enabledSizes.map((size) => `#{${size}}`).join('|')})\\\\s`\n  const regExp = new RegExp(pattern)\n\n  return {\n    type: 'element',\n    dependencies: [HeadingNode],\n    export: (node, exportChildren) => {\n      if (!$isHeadingNode(node)) {\n        return null\n      }\n      const level = Number(node.getTag().slice(1))\n      return '#'.repeat(level) + ' ' + exportChildren(node)\n    },\n    regExp,\n    replace: createBlockNode((match) => {\n      const tag = ('h' + match[1]?.length) as HeadingTagType\n      return $createHeadingNode(tag)\n    }),\n  }\n}\n","import type { ElementNode } from 'lexical'\n\nimport type { ElementTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nexport const createBlockNode = (\n  createNode: (match: Array<string>) => ElementNode,\n): ElementTransformer['replace'] => {\n  return (parentNode, children, match) => {\n    const node = createNode(match)\n    if (node) {\n      node.append(...children)\n      parentNode.replace(node)\n      node.select(0, 0)\n    }\n  }\n}\n","'use client'\n\nimport { $isNodeSelection } from 'lexical'\n\nimport { HorizontalRuleIcon } from '../../../lexical/ui/icons/HorizontalRule/index.js'\nimport { createClientFeature } from '../../../utilities/createClientFeature.js'\nimport { slashMenuBasicGroupWithItems } from '../../shared/slashMenu/basicGroup.js'\nimport { toolbarAddDropdownGroupWithItems } from '../../shared/toolbar/addDropdownGroup.js'\nimport { INSERT_HORIZONTAL_RULE_COMMAND } from '../server/nodes/HorizontalRuleNode.js'\nimport { MarkdownTransformer } from './markdownTransformer.js'\nimport { $isHorizontalRuleNode, HorizontalRuleNode } from './nodes/HorizontalRuleNode.js'\nimport { HorizontalRulePlugin } from './plugin/index.js'\n\nexport const HorizontalRuleFeatureClient = createClientFeature({\n  markdownTransformers: [MarkdownTransformer],\n  nodes: [HorizontalRuleNode],\n  plugins: [\n    {\n      Component: HorizontalRulePlugin,\n      position: 'normal',\n    },\n  ],\n  slashMenu: {\n    groups: [\n      slashMenuBasicGroupWithItems([\n        {\n          Icon: HorizontalRuleIcon,\n          key: 'horizontalRule',\n          keywords: ['hr', 'horizontal rule', 'line', 'separator'],\n          label: ({ i18n }) => {\n            return i18n.t('lexical:horizontalRule:label')\n          },\n\n          onSelect: ({ editor }) => {\n            editor.dispatchCommand(INSERT_HORIZONTAL_RULE_COMMAND, undefined)\n          },\n        },\n      ]),\n    ],\n  },\n  toolbarFixed: {\n    groups: [\n      toolbarAddDropdownGroupWithItems([\n        {\n          ChildComponent: HorizontalRuleIcon,\n          isActive: ({ selection }) => {\n            if (!$isNodeSelection(selection) || !selection.getNodes().length) {\n              return false\n            }\n\n            const firstNode = selection.getNodes()[0]\n            return $isHorizontalRuleNode(firstNode)\n          },\n          key: 'horizontalRule',\n          label: ({ i18n }) => {\n            return i18n.t('lexical:horizontalRule:label')\n          },\n          onSelect: ({ editor }) => {\n            editor.dispatchCommand(INSERT_HORIZONTAL_RULE_COMMAND, undefined)\n          },\n        },\n      ]),\n    ],\n  },\n})\n","'use client'\nimport React from 'react'\n\nexport const HorizontalRuleIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <rect fill=\"currentColor\" height=\"1\" width=\"12\" x=\"4\" y=\"9.5\" />\n  </svg>\n)\n","'use client'\nimport React from 'react'\n\nexport const AddIcon: React.FC = () => (\n  <svg fill=\"none\" height=\"20\" viewBox=\"0 0 20 20\" width=\"20\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M5 10h10\" stroke=\"currentColor\" />\n    <path d=\"M10 15V5\" stroke=\"currentColor\" />\n  </svg>\n)\n","import type { ToolbarGroup, ToolbarGroupItem } from '../../toolbars/types.js'\n\nimport { AddIcon } from '../../../lexical/ui/icons/Add/index.js'\n\nexport const toolbarAddDropdownGroupWithItems = (items: ToolbarGroupItem[]): ToolbarGroup => {\n  return {\n    type: 'dropdown',\n    ChildComponent: AddIcon,\n    items,\n    key: 'add',\n    order: 10,\n  }\n}\n","import type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  LexicalCommand,\n  LexicalNode,\n  SerializedLexicalNode,\n} from 'lexical'\nimport type * as React from 'react'\n\nimport { addClassNamesToElement } from '@lexical/utils'\nimport { $applyNodeReplacement, createCommand, DecoratorNode } from 'lexical'\n\nimport type { StronglyTypedLeafNode } from '../../../../nodeTypes.js'\n\n/**\n * Serialized representation of a horizontal rule node. Serialized = converted to JSON. This is what is stored in the database / in the lexical editor state.\n */\nexport type SerializedHorizontalRuleNode = StronglyTypedLeafNode<\n  SerializedLexicalNode,\n  'horizontalrule'\n>\n\nexport const INSERT_HORIZONTAL_RULE_COMMAND: LexicalCommand<void> = createCommand(\n  'INSERT_HORIZONTAL_RULE_COMMAND',\n)\n\n/**\n * This node is a DecoratorNode. DecoratorNodes allow you to render React components in the editor.\n *\n * They need both createDom and decorate functions. createDom => outside of the html. decorate => React Component inside of the html.\n *\n * If we used DecoratorBlockNode instead, we would only need a decorate method\n */\nexport class HorizontalRuleServerNode extends DecoratorNode<null | React.ReactElement> {\n  static override clone(node: HorizontalRuleServerNode): HorizontalRuleServerNode {\n    return new this(node.__key)\n  }\n\n  static override getType(): string {\n    return 'horizontalrule'\n  }\n\n  /**\n   * Defines what happens if you copy an hr element from another page and paste it into the lexical editor\n   *\n   * This also determines the behavior of lexical's internal HTML -> Lexical converter\n   */\n  static override importDOM(): DOMConversionMap | null {\n    return {\n      hr: () => ({\n        conversion: $convertHorizontalRuleElement,\n        priority: 0,\n      }),\n    }\n  }\n\n  /**\n   * The data for this node is stored serialized as JSON. This is the \"load function\" of that node: it takes the saved data and converts it into a node.\n   */\n  static override importJSON(\n    serializedNode: SerializedHorizontalRuleNode,\n  ): HorizontalRuleServerNode {\n    return $createHorizontalRuleServerNode()\n  }\n\n  /**\n   * Determines how the hr element is rendered in the lexical editor. This is only the \"initial\" / \"outer\" HTML element.\n   */\n  override createDOM(config: EditorConfig): HTMLElement {\n    const element = document.createElement('hr')\n    addClassNamesToElement(element, config.theme.hr)\n    return element\n  }\n\n  override decorate(): null | React.ReactElement {\n    return null\n  }\n\n  /**\n   * Opposite of importDOM, this function defines what happens when you copy an hr element from the lexical editor and paste it into another page.\n   *\n   * This also determines the behavior of lexical's internal Lexical -> HTML converter\n   */\n  override exportDOM(): DOMExportOutput {\n    return { element: document.createElement('hr') }\n  }\n  /**\n   * Opposite of importJSON. This determines what data is saved in the database / in the lexical editor state.\n   */\n  override exportJSON(): SerializedLexicalNode {\n    return {\n      type: 'horizontalrule',\n      version: 1,\n    }\n  }\n\n  override getTextContent(): string {\n    return '\\n'\n  }\n\n  override isInline(): false {\n    return false\n  }\n\n  override updateDOM(): boolean {\n    return false\n  }\n}\n\nfunction $convertHorizontalRuleElement(): DOMConversionOutput {\n  return { node: $createHorizontalRuleServerNode() }\n}\n\nexport function $createHorizontalRuleServerNode(): HorizontalRuleServerNode {\n  return $applyNodeReplacement(new HorizontalRuleServerNode())\n}\n\nexport function $isHorizontalRuleServerNode(\n  node: LexicalNode | null | undefined,\n): node is HorizontalRuleServerNode {\n  return node instanceof HorizontalRuleServerNode\n}\n","'use client'\nimport type { DOMConversionOutput, LexicalNode, SerializedLexicalNode } from 'lexical'\n\nimport { $applyNodeReplacement } from 'lexical'\nimport * as React from 'react'\n\nimport type { SerializedHorizontalRuleNode } from '../../server/nodes/HorizontalRuleNode.js'\n\nimport { HorizontalRuleServerNode } from '../../server/nodes/HorizontalRuleNode.js'\n\nexport class HorizontalRuleNode extends HorizontalRuleServerNode {\n  static override clone(node: HorizontalRuleServerNode): HorizontalRuleServerNode {\n    return super.clone(node)\n  }\n\n  static override getType(): string {\n    return super.getType()\n  }\n\n  /**\n   * The data for this node is stored serialized as JSON. This is the \"load function\" of that node: it takes the saved data and converts it into a node.\n   */\n  static override importJSON(serializedNode: SerializedHorizontalRuleNode): HorizontalRuleNode {\n    return $createHorizontalRuleNode()\n  }\n\n  /**\n   * Allows you to render a React component within whatever createDOM returns.\n   */\n  override decorate() {\n    return null\n  }\n\n  override exportJSON(): SerializedLexicalNode {\n    return super.exportJSON()\n  }\n}\n\nfunction $convertHorizontalRuleElement(): DOMConversionOutput {\n  return { node: $createHorizontalRuleNode() }\n}\n\nexport function $createHorizontalRuleNode(): HorizontalRuleNode {\n  return $applyNodeReplacement(new HorizontalRuleNode())\n}\n\nexport function $isHorizontalRuleNode(\n  node: LexicalNode | null | undefined,\n): node is HorizontalRuleNode {\n  return node instanceof HorizontalRuleNode\n}\n","import type { ElementTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport {\n  $createHorizontalRuleNode,\n  $isHorizontalRuleNode,\n  HorizontalRuleNode,\n} from './nodes/HorizontalRuleNode.js'\n\nexport const MarkdownTransformer: ElementTransformer = {\n  type: 'element',\n  dependencies: [HorizontalRuleNode],\n  export: (node, exportChildren) => {\n    if (!$isHorizontalRuleNode(node)) {\n      return null\n    }\n    return '---'\n  },\n  // match ---\n  regExp: /^---\\s*$/,\n  replace: (parentNode) => {\n    const node = $createHorizontalRuleNode()\n    if (node) {\n      parentNode.replace(node)\n    }\n  },\n}\n","'use client'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { $insertNodeToNearestRoot } from '@lexical/utils'\nimport { $getSelection, $isRangeSelection, COMMAND_PRIORITY_EDITOR } from 'lexical'\nimport { useEffect } from 'react'\n\nimport type { PluginComponent } from '../../../typesClient.js'\n\nimport { INSERT_HORIZONTAL_RULE_COMMAND } from '../../server/nodes/HorizontalRuleNode.js'\nimport { $createHorizontalRuleNode } from '../nodes/HorizontalRuleNode.js'\nimport './index.scss'\n\n/**\n * Registers the INSERT_HORIZONTAL_RULE_COMMAND lexical command and defines the behavior for when it is called.\n */\nexport const HorizontalRulePlugin: PluginComponent<undefined> = () => {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    return editor.registerCommand(\n      INSERT_HORIZONTAL_RULE_COMMAND,\n      (type) => {\n        const selection = $getSelection()\n\n        if (!$isRangeSelection(selection)) {\n          return false\n        }\n\n        const focusNode = selection.focus.getNode()\n\n        if (focusNode !== null) {\n          const horizontalRuleNode = $createHorizontalRuleNode()\n          $insertNodeToNearestRoot(horizontalRuleNode)\n        }\n\n        return true\n      },\n      COMMAND_PRIORITY_EDITOR,\n    )\n  }, [editor])\n\n  return null\n}\n","'use client'\n\nimport type { ElementNode, LexicalNode } from 'lexical'\n\nimport { $findMatchingParent } from '@lexical/utils'\nimport { $isElementNode, INDENT_CONTENT_COMMAND, OUTDENT_CONTENT_COMMAND } from 'lexical'\n\nimport type { ToolbarGroup } from '../../toolbars/types.js'\n\nimport { IndentDecreaseIcon } from '../../../lexical/ui/icons/IndentDecrease/index.js'\nimport { IndentIncreaseIcon } from '../../../lexical/ui/icons/IndentIncrease/index.js'\nimport { createClientFeature } from '../../../utilities/createClientFeature.js'\nimport { type IndentFeatureProps } from '../server/index.js'\nimport { IndentPlugin } from './IndentPlugin.js'\nimport { toolbarIndentGroupWithItems } from './toolbarIndentGroup.js'\n\nconst toolbarGroups = ({ disabledNodes }: IndentFeatureProps): ToolbarGroup[] => [\n  toolbarIndentGroupWithItems([\n    {\n      ChildComponent: IndentDecreaseIcon,\n      isActive: () => false,\n      isEnabled: ({ selection }) => {\n        const nodes = selection?.getNodes() ?? []\n\n        const isOutdentable = (node: LexicalNode) => {\n          return isIndentable(node) && node.getIndent() > 0\n        }\n\n        return nodes.some((node) => {\n          return isOutdentable(node) || Boolean($findMatchingParent(node, isOutdentable))\n        })\n      },\n      key: 'indentDecrease',\n      label: ({ i18n }) => {\n        return i18n.t('lexical:indent:decreaseLabel')\n      },\n      onSelect: ({ editor }) => {\n        editor.dispatchCommand(OUTDENT_CONTENT_COMMAND, undefined)\n      },\n      order: 1,\n    },\n    {\n      ChildComponent: IndentIncreaseIcon,\n      isActive: () => false,\n      isEnabled: ({ selection }) => {\n        const nodes = selection?.getNodes() ?? []\n\n        const isIndentableAndNotDisabled = (node: LexicalNode) => {\n          return isIndentable(node) && !(disabledNodes ?? []).includes(node.getType())\n        }\n\n        return nodes.some((node) => {\n          return (\n            isIndentableAndNotDisabled(node) ||\n            Boolean($findMatchingParent(node, isIndentableAndNotDisabled))\n          )\n        })\n      },\n      key: 'indentIncrease',\n      label: ({ i18n }) => {\n        return i18n.t('lexical:indent:increaseLabel')\n      },\n      onSelect: ({ editor }) => {\n        editor.dispatchCommand(INDENT_CONTENT_COMMAND, undefined)\n      },\n      order: 2,\n    },\n  ]),\n]\n\nexport const IndentFeatureClient = createClientFeature<IndentFeatureProps>(({ props }) => {\n  const disabledNodes = props.disabledNodes ?? []\n  return {\n    plugins: [\n      {\n        Component: IndentPlugin,\n        position: 'normal',\n      },\n    ],\n    sanitizedClientFeatureProps: props,\n    toolbarFixed: {\n      groups: toolbarGroups({ disabledNodes }),\n    },\n    toolbarInline: {\n      groups: toolbarGroups({ disabledNodes }),\n    },\n  }\n})\n\nconst isIndentable = (node: LexicalNode): node is ElementNode =>\n  $isElementNode(node) && node.canIndent()\n","'use client'\nimport React from 'react'\n\nexport const IndentDecreaseIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path d=\"M2.5 5H10.5\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n    <path d=\"M2.5 10H10.5\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n    <path d=\"M2.5 15H17.5\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n    <path d=\"M12.25 7.25L17.25 3.75V10.75L12.25 7.25Z\" fill=\"currentColor\" />\n  </svg>\n)\n","'use client'\nimport React from 'react'\n\nexport const IndentIncreaseIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path d=\"M17.5 5H9.5\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n    <path d=\"M17.5 10H9.5\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n    <path d=\"M17.5 15H2.5\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n    <path d=\"M7.75 7.25L2.75 3.75V10.75L7.75 7.25Z\" fill=\"currentColor\" />\n  </svg>\n)\n","import type { ElementNode } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { TabIndentationPlugin } from '@lexical/react/LexicalTabIndentationPlugin'\nimport { $findMatchingParent, mergeRegister } from '@lexical/utils'\nimport {\n  $getSelection,\n  $isElementNode,\n  $isRangeSelection,\n  COMMAND_PRIORITY_LOW,\n  INDENT_CONTENT_COMMAND,\n  KEY_TAB_COMMAND,\n  OUTDENT_CONTENT_COMMAND,\n  TabNode,\n} from 'lexical'\nimport { useEffect } from 'react'\n\nimport type { PluginComponent } from '../../typesClient.js'\nimport type { IndentFeatureProps } from '../server/index.js'\n\nexport const IndentPlugin: PluginComponent<IndentFeatureProps> = ({ clientProps }) => {\n  const [editor] = useLexicalComposerContext()\n  const { disabledNodes, disableTabNode } = clientProps\n\n  useEffect(() => {\n    if (!editor || !disabledNodes?.length) {\n      return\n    }\n    return mergeRegister(\n      editor.registerCommand(\n        INDENT_CONTENT_COMMAND,\n        () => {\n          return $handleIndentAndOutdent((block) => {\n            if (!disabledNodes.includes(block.getType())) {\n              const indent = block.getIndent()\n              block.setIndent(indent + 1)\n            }\n          })\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      // If we disable indenting for certain nodes, we need to ensure that these are not indented,\n      // if they get transformed from an indented state (e.g. an indented list node gets transformed into a\n      // paragraph node for which indenting is disabled).\n      editor.registerUpdateListener(({ dirtyElements, editorState }) => {\n        editor.update(() => {\n          for (const [nodeKey] of dirtyElements) {\n            const node = editorState._nodeMap.get(nodeKey)\n            if ($isElementNode(node) && disabledNodes.includes(node.getType())) {\n              const currentIndent = node.getIndent()\n              if (currentIndent > 0) {\n                node.setIndent(0)\n              }\n            }\n          }\n        })\n      }),\n    )\n  }, [editor, disabledNodes])\n\n  useEffect(() => {\n    if (!editor || !disableTabNode) {\n      return\n    }\n    return mergeRegister(\n      // This is so that when you press Tab in the middle of a paragraph,\n      // it indents the paragraph, instead of inserting a TabNode.\n      editor.registerCommand<KeyboardEvent>(\n        KEY_TAB_COMMAND,\n        (event) => {\n          event.preventDefault()\n          return editor.dispatchCommand(\n            event.shiftKey ? OUTDENT_CONTENT_COMMAND : INDENT_CONTENT_COMMAND,\n            undefined,\n          )\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      // Tab isn't the only way to insert a TabNode. We have to make sure\n      // it doesn't happen, for example, when pasting from the clipboard.\n      editor.registerNodeTransform(TabNode, (node) => {\n        node.remove()\n      }),\n    )\n  }, [editor, disableTabNode])\n\n  return <TabIndentationPlugin />\n}\n\nfunction $handleIndentAndOutdent(indentOrOutdent: (block: ElementNode) => void): boolean {\n  const selection = $getSelection()\n  if (!$isRangeSelection(selection)) {\n    return false\n  }\n  const alreadyHandled = new Set()\n  const nodes = selection.getNodes()\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i]!\n    const key = node.getKey()\n    if (alreadyHandled.has(key)) {\n      continue\n    }\n    const parentBlock = $findMatchingParent(\n      node,\n      (parentNode): parentNode is ElementNode =>\n        $isElementNode(parentNode) && !parentNode.isInline(),\n    )\n    if (parentBlock === null) {\n      continue\n    }\n    const parentKey = parentBlock.getKey()\n    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n      alreadyHandled.add(parentKey)\n      indentOrOutdent(parentBlock)\n    }\n  }\n  return alreadyHandled.size > 0\n}\n","'use client'\nimport type { ToolbarGroup, ToolbarGroupItem } from '../../toolbars/types.js'\n\nexport const toolbarIndentGroupWithItems = (items: ToolbarGroupItem[]): ToolbarGroup => {\n  return {\n    type: 'buttons',\n    items,\n    key: 'indent',\n    order: 35,\n  }\n}\n","'use client'\n\nimport type { Klass, LexicalNode } from 'lexical'\n\nimport { $findMatchingParent } from '@lexical/utils'\nimport { $getSelection, $isRangeSelection } from 'lexical'\n\nimport type { ToolbarGroup } from '../../toolbars/types.js'\nimport type { ClientFeature } from '../../typesClient.js'\nimport type { LinkFields } from '../nodes/types.js'\nimport type { ExclusiveLinkCollectionsProps } from '../server/index.js'\n\nimport { LinkIcon } from '../../../lexical/ui/icons/Link/index.js'\nimport { getSelectedNode } from '../../../lexical/utils/getSelectedNode.js'\nimport { createClientFeature } from '../../../utilities/createClientFeature.js'\nimport { toolbarFeatureButtonsGroupWithItems } from '../../shared/toolbar/featureButtonsGroup.js'\nimport { LinkMarkdownTransformer } from '../markdownTransformer.js'\nimport { AutoLinkNode } from '../nodes/AutoLinkNode.js'\nimport { $isLinkNode, LinkNode, TOGGLE_LINK_COMMAND } from '../nodes/LinkNode.js'\nimport { AutoLinkPlugin } from './plugins/autoLink/index.js'\nimport { ClickableLinkPlugin } from './plugins/clickableLink/index.js'\nimport { FloatingLinkEditorPlugin } from './plugins/floatingLinkEditor/index.js'\nimport { TOGGLE_LINK_WITH_MODAL_COMMAND } from './plugins/floatingLinkEditor/LinkEditor/commands.js'\nimport { LinkPlugin } from './plugins/link/index.js'\n\nexport type ClientProps = {\n  defaultLinkType?: string\n  defaultLinkURL?: string\n  disableAutoLinks?: 'creationOnly' | true\n} & ExclusiveLinkCollectionsProps\n\nconst toolbarGroups: ToolbarGroup[] = [\n  toolbarFeatureButtonsGroupWithItems([\n    {\n      ChildComponent: LinkIcon,\n      isActive: ({ selection }) => {\n        if ($isRangeSelection(selection)) {\n          const selectedNode = getSelectedNode(selection)\n          const linkParent = $findMatchingParent(selectedNode, $isLinkNode)\n          return linkParent != null\n        }\n        return false\n      },\n      isEnabled: ({ selection }) => {\n        return !!($isRangeSelection(selection) && $getSelection()?.getTextContent()?.length)\n      },\n      key: 'link',\n      label: ({ i18n }) => {\n        return i18n.t('lexical:link:label')\n      },\n      onSelect: ({ editor, isActive }) => {\n        if (!isActive) {\n          let selectedText: string | undefined\n          let selectedNodes: LexicalNode[] = []\n          editor.getEditorState().read(() => {\n            selectedText = $getSelection()?.getTextContent()\n            // We need to selected nodes here before the drawer opens, as clicking around in the drawer may change the original selection\n            selectedNodes = $getSelection()?.getNodes() ?? []\n          })\n\n          if (!selectedText?.length) {\n            return\n          }\n\n          const linkFields: Partial<LinkFields> = {\n            doc: null,\n          }\n\n          editor.dispatchCommand(TOGGLE_LINK_WITH_MODAL_COMMAND, {\n            fields: linkFields,\n            selectedNodes,\n            text: selectedText,\n          })\n        } else {\n          // remove link\n          editor.dispatchCommand(TOGGLE_LINK_COMMAND, null)\n        }\n      },\n      order: 1,\n    },\n  ]),\n]\n\nexport const LinkFeatureClient = createClientFeature<ClientProps>(({ props }) => ({\n  markdownTransformers: [LinkMarkdownTransformer],\n  nodes: [LinkNode, props?.disableAutoLinks === true ? null : AutoLinkNode].filter(\n    Boolean,\n  ) as Array<Klass<LexicalNode>>,\n  plugins: [\n    {\n      Component: LinkPlugin,\n      position: 'normal',\n    },\n    props?.disableAutoLinks === true || props?.disableAutoLinks === 'creationOnly'\n      ? null\n      : {\n          Component: AutoLinkPlugin,\n          position: 'normal',\n        },\n    {\n      Component: ClickableLinkPlugin,\n      position: 'normal',\n    },\n    {\n      Component: FloatingLinkEditorPlugin,\n      position: 'floatingAnchorElem',\n    },\n  ].filter(Boolean) as ClientFeature<ClientProps>['plugins'],\n  sanitizedClientFeatureProps: props,\n  toolbarFixed: {\n    groups: toolbarGroups,\n  },\n  toolbarInline: {\n    groups: toolbarGroups,\n  },\n}))\n","'use client'\nimport React from 'react'\n\nexport const LinkIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path\n      d=\"M8.5 11.5L11.5 8.5M8.5 7L9.625 5.875C10.868 4.633 12.882 4.633 14.125 5.875C15.368 7.118 15.368 9.133 14.125 10.375L13 11.5M7 8.5L5.746 9.754C4.56 10.94 4.519 12.85 5.652 14.087C6.814 15.354 8.78 15.449 10.058 14.298L11.5 13\"\n      stroke=\"currentColor\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    />\n  </svg>\n)\n","'use client'\nimport type { ElementNode, RangeSelection, TextNode } from 'lexical'\n\nimport { $isAtNodeEnd } from '@lexical/selection'\n\nexport function getSelectedNode(selection: RangeSelection): ElementNode | TextNode {\n  const { anchor } = selection\n  const { focus } = selection\n  const anchorNode = selection.anchor.getNode()\n  const focusNode = selection.focus.getNode()\n  if (anchorNode === focusNode) {\n    return anchorNode\n  }\n  const isBackward = selection.isBackward()\n  if (isBackward) {\n    return $isAtNodeEnd(focus) ? anchorNode : focusNode\n  }\n  return $isAtNodeEnd(anchor) ? anchorNode : focusNode\n}\n","import type { ToolbarGroup, ToolbarGroupItem } from '../../toolbars/types.js'\n\nexport const toolbarFeatureButtonsGroupWithItems = (items: ToolbarGroupItem[]): ToolbarGroup => {\n  return {\n    type: 'buttons',\n    items,\n    key: 'features',\n    order: 50,\n  }\n}\n","/**\n * Code taken from https://github.com/facebook/lexical/blob/main/packages/lexical-markdown/src/MarkdownTransformers.ts#L357\n */\n\n// Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n\nimport { $createTextNode, $isTextNode } from 'lexical'\n\nimport type { TextMatchTransformer } from '../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport { $createLinkNode, $isLinkNode, LinkNode } from './nodes/LinkNode.js'\n\n// - then longer tags match (e.g. ** or __ should go before * or _)\nexport const LinkMarkdownTransformer: TextMatchTransformer = {\n  type: 'text-match',\n  dependencies: [LinkNode],\n  export: (_node, exportChildren) => {\n    if (!$isLinkNode(_node)) {\n      return null\n    }\n    const node: LinkNode = _node\n    const { url } = node.getFields()\n\n    const textContent = exportChildren(node)\n\n    const linkContent = `[${textContent}](${url})`\n\n    return linkContent\n  },\n  importRegExp: /\\[([^[]+)\\]\\(([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?\\)/,\n  regExp: /\\[([^[]+)\\]\\(([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?\\)$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl] = match\n    const linkNode = $createLinkNode({\n      fields: {\n        doc: null,\n        linkType: 'custom',\n        newTab: false,\n        url: linkUrl,\n      },\n    })\n    const linkTextNode = $createTextNode(linkText)\n    linkTextNode.setFormat(textNode.getFormat())\n    linkNode.append(linkTextNode)\n    textNode.replace(linkNode)\n\n    return linkTextNode\n  },\n  trigger: ')',\n}\n","import type {\n  BaseSelection,\n  DOMConversionMap,\n  DOMConversionOutput,\n  EditorConfig,\n  ElementNode as ElementNodeType,\n  LexicalCommand,\n  LexicalNode,\n  LexicalUpdateJSON,\n  NodeKey,\n  RangeSelection,\n} from 'lexical'\n\nimport { addClassNamesToElement, isHTMLAnchorElement } from '@lexical/utils'\nimport ObjectID from 'bson-objectid'\nimport {\n  $applyNodeReplacement,\n  $createTextNode,\n  $getSelection,\n  $isElementNode,\n  $isRangeSelection,\n  createCommand,\n  ElementNode,\n} from 'lexical'\n\nimport type { LinkPayload } from '../client/plugins/floatingLinkEditor/types.js'\nimport type { LinkFields, SerializedLinkNode } from './types.js'\n\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:'])\n\n/** @noInheritDoc */\nexport class LinkNode extends ElementNode {\n  __fields: LinkFields\n  __id: string\n\n  constructor({\n    id,\n    fields = {\n      linkType: 'custom',\n      newTab: false,\n    },\n    key,\n  }: {\n    fields?: LinkFields\n    id: string\n    key?: NodeKey\n  }) {\n    super(key)\n    this.__fields = fields\n    this.__id = id\n  }\n\n  static override clone(node: LinkNode): LinkNode {\n    return new this({\n      id: node.__id,\n      fields: node.__fields,\n      key: node.__key,\n    })\n  }\n\n  static override getType(): string {\n    return 'link'\n  }\n\n  static override importDOM(): DOMConversionMap | null {\n    return {\n      a: (node: Node) => ({\n        conversion: $convertAnchorElement,\n        priority: 1,\n      }),\n    }\n  }\n\n  static override importJSON(serializedNode: SerializedLinkNode): LinkNode {\n    const node = $createLinkNode({}).updateFromJSON(serializedNode)\n\n    /**\n     * @todo remove this in 4.0\n     */\n    if (\n      serializedNode.version === 1 &&\n      typeof serializedNode.fields?.doc?.value === 'object' &&\n      serializedNode.fields?.doc?.value?.id\n    ) {\n      serializedNode.fields.doc.value = serializedNode.fields.doc.value.id\n      serializedNode.version = 2\n    }\n\n    if (serializedNode.version === 2 && !serializedNode.id) {\n      serializedNode.id = new ObjectID.default().toHexString()\n      serializedNode.version = 3\n    }\n    return node\n  }\n\n  override canBeEmpty(): false {\n    return false\n  }\n\n  override canInsertTextAfter(): false {\n    return false\n  }\n\n  override canInsertTextBefore(): false {\n    return false\n  }\n\n  override createDOM(config: EditorConfig): HTMLAnchorElement {\n    const element = document.createElement('a')\n    if (this.__fields?.linkType === 'custom') {\n      element.href = this.sanitizeUrl(this.__fields.url ?? '')\n    }\n    if (this.__fields?.newTab ?? false) {\n      element.target = '_blank'\n    }\n\n    if (this.__fields?.newTab === true && this.__fields?.linkType === 'custom') {\n      element.rel = manageRel(element.rel, 'add', 'noopener')\n    }\n\n    addClassNamesToElement(element, config.theme.link)\n    return element\n  }\n\n  override exportJSON(): SerializedLinkNode {\n    const fields = this.getFields()\n\n    if (fields?.linkType === 'internal') {\n      delete fields.url\n    } else if (fields?.linkType === 'custom') {\n      delete fields.doc\n    }\n\n    const returnObject: SerializedLinkNode = {\n      ...super.exportJSON(),\n      type: 'link',\n      fields,\n      version: 3,\n    }\n    const id = this.getID()\n    if (id) {\n      returnObject.id = id\n    }\n    return returnObject\n  }\n\n  override extractWithChild(\n    child: LexicalNode,\n    selection: BaseSelection,\n    destination: 'clone' | 'html',\n  ): boolean {\n    if (!$isRangeSelection(selection)) {\n      return false\n    }\n\n    const anchorNode = selection.anchor.getNode()\n    const focusNode = selection.focus.getNode()\n\n    return (\n      this.isParentOf(anchorNode) &&\n      this.isParentOf(focusNode) &&\n      selection.getTextContent().length > 0\n    )\n  }\n\n  getFields(): LinkFields {\n    return this.getLatest().__fields\n  }\n\n  getID(): string {\n    return this.getLatest().__id\n  }\n\n  override insertNewAfter(\n    selection: RangeSelection,\n    restoreSelection = true,\n  ): ElementNodeType | null {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection)\n    if ($isElementNode(element)) {\n      const linkNode = $createLinkNode({ fields: this.__fields })\n      element.append(linkNode)\n      return linkNode\n    }\n    return null\n  }\n\n  override isInline(): true {\n    return true\n  }\n\n  sanitizeUrl(url: string): string {\n    try {\n      const parsedUrl = new URL(url)\n\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank'\n      }\n    } catch (e) {\n      return 'https://'\n    }\n    return url\n  }\n\n  setFields(fields: LinkFields): this {\n    const writable = this.getWritable()\n    writable.__fields = fields\n    return writable\n  }\n\n  setID(id: string): this {\n    const writable = this.getWritable()\n    writable.__id = id\n    return writable\n  }\n\n  override updateDOM(prevNode: this, anchor: HTMLAnchorElement, config: EditorConfig): boolean {\n    const url = this.__fields?.url\n    const newTab = this.__fields?.newTab\n    if (url != null && url !== prevNode.__fields?.url && this.__fields?.linkType === 'custom') {\n      anchor.href = url\n    }\n    if (this.__fields?.linkType === 'internal' && prevNode.__fields?.linkType === 'custom') {\n      anchor.removeAttribute('href')\n    }\n\n    // TODO: not 100% sure why we're settign rel to '' - revisit\n    // Start rel config here, then check newTab below\n    if (anchor.rel == null) {\n      anchor.rel = ''\n    }\n\n    if (newTab !== prevNode.__fields?.newTab) {\n      if (newTab ?? false) {\n        anchor.target = '_blank'\n        if (this.__fields?.linkType === 'custom') {\n          anchor.rel = manageRel(anchor.rel, 'add', 'noopener')\n        }\n      } else {\n        anchor.removeAttribute('target')\n        anchor.rel = manageRel(anchor.rel, 'remove', 'noopener')\n      }\n    }\n\n    return false\n  }\n\n  override updateFromJSON(serializedNode: LexicalUpdateJSON<SerializedLinkNode>): this {\n    return super\n      .updateFromJSON(serializedNode)\n      .setFields(serializedNode.fields)\n      .setID(serializedNode.id as string)\n  }\n}\n\nfunction $convertAnchorElement(domNode: Node): DOMConversionOutput {\n  let node: LinkNode | null = null\n  if (isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent\n    if (content !== null && content !== '') {\n      node = $createLinkNode({\n        id: new ObjectID.default().toHexString(),\n        fields: {\n          doc: null,\n          linkType: 'custom',\n          newTab: domNode.getAttribute('target') === '_blank',\n          url: domNode.getAttribute('href') ?? '',\n        },\n      })\n    }\n  }\n  return { node }\n}\n\nexport function $createLinkNode({ id, fields }: { fields?: LinkFields; id?: string }): LinkNode {\n  return $applyNodeReplacement(\n    new LinkNode({\n      id: id ?? new ObjectID.default().toHexString(),\n      fields,\n    }),\n  )\n}\n\nexport function $isLinkNode(node: LexicalNode | null | undefined): node is LinkNode {\n  return node instanceof LinkNode\n}\n\nexport const TOGGLE_LINK_COMMAND: LexicalCommand<LinkPayload | null> =\n  createCommand('TOGGLE_LINK_COMMAND')\n\nexport function $toggleLink(payload: ({ fields: LinkFields } & LinkPayload) | null): void {\n  const selection = $getSelection()\n\n  if (!$isRangeSelection(selection) && (payload === null || !payload.selectedNodes?.length)) {\n    return\n  }\n  const nodes = $isRangeSelection(selection)\n    ? selection.extract()\n    : payload === null\n      ? []\n      : payload.selectedNodes\n\n  if (payload === null) {\n    // Remove LinkNodes\n    nodes?.forEach((node) => {\n      const parent = node.getParent()\n\n      if ($isLinkNode(parent)) {\n        const children = parent.getChildren()\n\n        children.forEach((child) => {\n          parent.insertBefore(child)\n        })\n\n        parent.remove()\n      }\n    })\n\n    return\n  }\n  // Add or merge LinkNodes\n  if (nodes?.length === 1) {\n    const firstNode = nodes[0]!\n    // if the first node is a LinkNode or if its\n    // parent is a LinkNode, we update the URL, target and rel.\n    const linkNode: LinkNode | null = $isLinkNode(firstNode)\n      ? firstNode\n      : $getLinkAncestor(firstNode)\n    if (linkNode !== null) {\n      linkNode.setFields(payload.fields)\n\n      if (payload.text != null && payload.text !== linkNode.getTextContent()) {\n        // remove all children and add child with new textcontent:\n        linkNode.append($createTextNode(payload.text))\n        linkNode.getChildren().forEach((child) => {\n          if (child !== linkNode.getLastChild()) {\n            child.remove()\n          }\n        })\n      }\n      return\n    }\n  }\n\n  let prevParent: ElementNodeType | LinkNode | null = null\n  let linkNode: LinkNode | null = null\n\n  nodes?.forEach((node) => {\n    const parent = node.getParent()\n\n    if (parent === linkNode || parent === null || ($isElementNode(node) && !node.isInline())) {\n      return\n    }\n\n    if ($isLinkNode(parent)) {\n      linkNode = parent\n      parent.setFields(payload.fields)\n      if (payload.text != null && payload.text !== parent.getTextContent()) {\n        // remove all children and add child with new textcontent:\n        parent.append($createTextNode(payload.text))\n        parent.getChildren().forEach((child) => {\n          if (child !== parent.getLastChild()) {\n            child.remove()\n          }\n        })\n      }\n      return\n    }\n\n    if (!parent.is(prevParent)) {\n      prevParent = parent\n      linkNode = $createLinkNode({ fields: payload.fields })\n\n      if ($isLinkNode(parent)) {\n        if (node.getPreviousSibling() === null) {\n          parent.insertBefore(linkNode)\n        } else {\n          parent.insertAfter(linkNode)\n        }\n      } else {\n        node.insertBefore(linkNode)\n      }\n    }\n\n    if ($isLinkNode(node)) {\n      if (node.is(linkNode)) {\n        return\n      }\n      if (linkNode !== null) {\n        const children = node.getChildren()\n        linkNode.append(...children)\n      }\n\n      node.remove()\n      return\n    }\n\n    if (linkNode !== null) {\n      linkNode.append(node)\n    }\n  })\n}\n\nfunction $getLinkAncestor(node: LexicalNode): LinkNode | null {\n  return $getAncestor(node, (ancestor) => $isLinkNode(ancestor)) as LinkNode\n}\n\nfunction $getAncestor(\n  node: LexicalNode,\n  predicate: (ancestor: LexicalNode) => boolean,\n): LexicalNode | null {\n  let parent: LexicalNode | null = node\n  while (parent !== null) {\n    parent = parent.getParent()\n    if (parent === null || predicate(parent)) {\n      break\n    }\n  }\n  return parent\n}\n\nfunction manageRel(input: string, action: 'add' | 'remove', value: string): string {\n  let result: string\n  let mutableInput = `${input}`\n  if (action === 'add') {\n    // if we somehow got out of sync - clean up\n    if (mutableInput.includes(value)) {\n      const re = new RegExp(value, 'g')\n      mutableInput = mutableInput.replace(re, '').trim()\n    }\n    mutableInput = mutableInput.trim()\n    result = mutableInput.length === 0 ? `${value}` : `${mutableInput} ${value}`\n  } else {\n    const re = new RegExp(value, 'g')\n    result = mutableInput.replace(re, '').trim()\n  }\n  return result\n}\n","import type { ElementNode, LexicalNode, LexicalUpdateJSON, RangeSelection } from 'lexical'\n\nimport { $applyNodeReplacement, $isElementNode } from 'lexical'\n\nimport type { LinkFields, SerializedAutoLinkNode } from './types.js'\n\nimport { LinkNode } from './LinkNode.js'\n\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\n\nexport class AutoLinkNode extends LinkNode {\n  static override clone(node: AutoLinkNode): AutoLinkNode {\n    return new this({ id: '', fields: node.__fields, key: node.__key })\n  }\n\n  static override getType(): string {\n    return 'autolink'\n  }\n\n  static override importDOM(): null {\n    // TODO: Should link node should handle the import over autolink?\n    return null\n  }\n\n  static override importJSON(serializedNode: SerializedAutoLinkNode): AutoLinkNode {\n    const node = $createAutoLinkNode({}).updateFromJSON(serializedNode)\n\n    /**\n     * @todo remove in 4.0\n     */\n    if (\n      serializedNode.version === 1 &&\n      typeof serializedNode.fields?.doc?.value === 'object' &&\n      serializedNode.fields?.doc?.value?.id\n    ) {\n      serializedNode.fields.doc.value = serializedNode.fields.doc.value.id\n      serializedNode.version = 2\n    }\n\n    return node\n  }\n\n  // @ts-expect-error\n  exportJSON(): SerializedAutoLinkNode {\n    const serialized = super.exportJSON()\n    return {\n      type: 'autolink',\n      children: serialized.children,\n      direction: serialized.direction,\n      fields: serialized.fields,\n      format: serialized.format,\n      indent: serialized.indent,\n      version: 2,\n    }\n  }\n\n  override insertNewAfter(selection: RangeSelection, restoreSelection = true): ElementNode | null {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection)\n    if ($isElementNode(element)) {\n      const linkNode = $createAutoLinkNode({ fields: this.__fields })\n      element.append(linkNode)\n      return linkNode\n    }\n    return null\n  }\n\n  override updateFromJSON(serializedNode: LexicalUpdateJSON<SerializedAutoLinkNode>): this {\n    return super.updateFromJSON(serializedNode).setFields(serializedNode.fields)\n  }\n}\n\nexport function $createAutoLinkNode({ fields }: { fields?: LinkFields }): AutoLinkNode {\n  return $applyNodeReplacement(new AutoLinkNode({ id: '', fields }))\n}\nexport function $isAutoLinkNode(node: LexicalNode | null | undefined): node is AutoLinkNode {\n  return node instanceof AutoLinkNode\n}\n","'use client'\nimport type { ElementNode, LexicalEditor, LexicalNode, TextNode } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { mergeRegister } from '@lexical/utils'\nimport {\n  $createTextNode,\n  $getSelection,\n  $isElementNode,\n  $isLineBreakNode,\n  $isNodeSelection,\n  $isRangeSelection,\n  $isTextNode,\n  TextNode as TextNodeValue,\n} from 'lexical'\nimport { useEffect } from 'react'\n\nimport type { PluginComponent } from '../../../../typesClient.js'\nimport type { LinkFields } from '../../../nodes/types.js'\nimport type { ClientProps } from '../../index.js'\n\nimport { $createAutoLinkNode, $isAutoLinkNode, AutoLinkNode } from '../../../nodes/AutoLinkNode.js'\nimport { $isLinkNode } from '../../../nodes/LinkNode.js'\n\ntype ChangeHandler = (url: null | string, prevUrl: null | string) => void\n\ninterface LinkMatcherResult {\n  fields?: LinkFields\n  index: number\n  length: number\n  text: string\n  url: string\n}\n\nexport type LinkMatcher = (text: string) => LinkMatcherResult | null\n\nexport function createLinkMatcherWithRegExp(\n  regExp: RegExp,\n  urlTransformer: (text: string) => string = (text) => text,\n) {\n  return (text: string) => {\n    const match = regExp.exec(text)\n    if (match === null) {\n      return null\n    }\n    return {\n      index: match.index,\n      length: match[0].length,\n      text: match[0],\n      url: urlTransformer(match[0]),\n    }\n  }\n}\n\nfunction findFirstMatch(text: string, matchers: LinkMatcher[]): LinkMatcherResult | null {\n  for (const matcher of matchers) {\n    const match = matcher(text)\n\n    if (match != null) {\n      return match\n    }\n  }\n\n  return null\n}\n\nconst PUNCTUATION_OR_SPACE = /[.,;\\s]/\n\nfunction isSeparator(char: string | undefined): boolean {\n  return char !== undefined && PUNCTUATION_OR_SPACE.test(char)\n}\n\nfunction endsWithSeparator(textContent: string): boolean {\n  return isSeparator(textContent[textContent.length - 1])\n}\n\nfunction startsWithSeparator(textContent: string): boolean {\n  return isSeparator(textContent[0])\n}\n\n/**\n * Check if the text content starts with a fullstop followed by a top-level domain.\n * Meaning if the text content can be a beginning of a top level domain.\n * @param textContent\n * @param isEmail\n * @returns boolean\n */\nfunction startsWithTLD(textContent: string, isEmail: boolean): boolean {\n  if (isEmail) {\n    return /^\\.[a-z]{2,}/i.test(textContent)\n  } else {\n    return /^\\.[a-z0-9]+/i.test(textContent)\n  }\n}\n\nfunction isPreviousNodeValid(node: LexicalNode): boolean {\n  let previousNode = node.getPreviousSibling()\n  if ($isElementNode(previousNode)) {\n    previousNode = previousNode.getLastDescendant()\n  }\n  return (\n    previousNode === null ||\n    $isLineBreakNode(previousNode) ||\n    ($isTextNode(previousNode) && endsWithSeparator(previousNode.getTextContent()))\n  )\n}\n\nfunction isNextNodeValid(node: LexicalNode): boolean {\n  let nextNode = node.getNextSibling()\n  if ($isElementNode(nextNode)) {\n    nextNode = nextNode.getFirstDescendant()\n  }\n  return (\n    nextNode === null ||\n    $isLineBreakNode(nextNode) ||\n    ($isTextNode(nextNode) && startsWithSeparator(nextNode.getTextContent()))\n  )\n}\n\nfunction isContentAroundIsValid(\n  matchStart: number,\n  matchEnd: number,\n  text: string,\n  nodes: TextNode[],\n): boolean {\n  const contentBeforeIsValid =\n    matchStart > 0 ? isSeparator(text[matchStart - 1]) : isPreviousNodeValid(nodes[0]!)\n  if (!contentBeforeIsValid) {\n    return false\n  }\n\n  const contentAfterIsValid =\n    matchEnd < text.length ? isSeparator(text[matchEnd]) : isNextNodeValid(nodes[nodes.length - 1]!)\n  return contentAfterIsValid\n}\n\nfunction extractMatchingNodes(\n  nodes: TextNode[],\n  startIndex: number,\n  endIndex: number,\n): [\n  matchingOffset: number,\n  unmodifiedBeforeNodes: TextNode[],\n  matchingNodes: TextNode[],\n  unmodifiedAfterNodes: TextNode[],\n] {\n  const unmodifiedBeforeNodes: TextNode[] = []\n  const matchingNodes: TextNode[] = []\n  const unmodifiedAfterNodes: TextNode[] = []\n  let matchingOffset = 0\n\n  let currentOffset = 0\n  const currentNodes = [...nodes]\n\n  while (currentNodes.length > 0) {\n    const currentNode = currentNodes[0]!\n    const currentNodeText = currentNode.getTextContent()\n    const currentNodeLength = currentNodeText.length\n    const currentNodeStart = currentOffset\n    const currentNodeEnd = currentOffset + currentNodeLength\n\n    if (currentNodeEnd <= startIndex) {\n      unmodifiedBeforeNodes.push(currentNode)\n      matchingOffset += currentNodeLength\n    } else if (currentNodeStart >= endIndex) {\n      unmodifiedAfterNodes.push(currentNode)\n    } else {\n      matchingNodes.push(currentNode)\n    }\n    currentOffset += currentNodeLength\n    currentNodes.shift()\n  }\n  return [matchingOffset, unmodifiedBeforeNodes, matchingNodes, unmodifiedAfterNodes]\n}\n\nfunction $createAutoLinkNode_(\n  nodes: TextNode[],\n  startIndex: number,\n  endIndex: number,\n  match: LinkMatcherResult,\n): TextNode | undefined {\n  const fields = {\n    linkType: 'custom',\n    url: match.url,\n    ...match.fields,\n  } as LinkFields\n\n  const linkNode = $createAutoLinkNode({ fields })\n  if (nodes.length === 1) {\n    const remainingTextNode = nodes[0]!\n    let linkTextNode: TextNode | undefined\n    if (startIndex === 0) {\n      ;[linkTextNode] = remainingTextNode.splitText(endIndex)\n    } else {\n      ;[, linkTextNode] = remainingTextNode.splitText(startIndex, endIndex)\n    }\n    if (linkTextNode) {\n      const textNode = $createTextNode(match.text)\n      textNode.setFormat(linkTextNode.getFormat())\n      textNode.setDetail(linkTextNode.getDetail())\n      textNode.setStyle(linkTextNode.getStyle())\n      linkNode.append(textNode)\n      linkTextNode.replace(linkNode)\n    }\n    return remainingTextNode\n  } else if (nodes.length > 1) {\n    const firstTextNode = nodes[0]!\n    let offset = firstTextNode.getTextContent().length\n    let firstLinkTextNode\n    if (startIndex === 0) {\n      firstLinkTextNode = firstTextNode\n    } else {\n      ;[, firstLinkTextNode] = firstTextNode.splitText(startIndex)\n    }\n    const linkNodes: LexicalNode[] = []\n    let remainingTextNode\n    nodes.forEach((currentNode) => {\n      const currentNodeText = currentNode.getTextContent()\n      const currentNodeLength = currentNodeText.length\n      const currentNodeStart = offset\n      const currentNodeEnd = offset + currentNodeLength\n      if (currentNodeStart < endIndex) {\n        if (currentNodeEnd <= endIndex) {\n          linkNodes.push(currentNode)\n        } else {\n          const [linkTextNode, endNode] = currentNode.splitText(endIndex - currentNodeStart)\n          if (linkTextNode) {\n            linkNodes.push(linkTextNode)\n          }\n          remainingTextNode = endNode\n        }\n      }\n      offset += currentNodeLength\n    })\n\n    if (firstLinkTextNode) {\n      const selection = $getSelection()\n      const selectedTextNode = selection ? selection.getNodes().find($isTextNode) : undefined\n      const textNode = $createTextNode(firstLinkTextNode.getTextContent())\n      textNode.setFormat(firstLinkTextNode.getFormat())\n      textNode.setDetail(firstLinkTextNode.getDetail())\n      textNode.setStyle(firstLinkTextNode.getStyle())\n      linkNode.append(textNode, ...linkNodes)\n      // it does not preserve caret position if caret was at the first text node\n      // so we need to restore caret position\n      if (selectedTextNode && selectedTextNode === firstLinkTextNode) {\n        if ($isRangeSelection(selection)) {\n          textNode.select(selection.anchor.offset, selection.focus.offset)\n        } else if ($isNodeSelection(selection)) {\n          textNode.select(0, textNode.getTextContent().length)\n        }\n      }\n      firstLinkTextNode.replace(linkNode)\n      return remainingTextNode\n    }\n  }\n  return undefined\n}\n\nfunction $handleLinkCreation(\n  nodes: TextNode[],\n  matchers: LinkMatcher[],\n  onChange: ChangeHandler,\n): void {\n  let currentNodes = [...nodes]\n  const initialText = currentNodes.map((node) => node.getTextContent()).join('')\n  let text = initialText\n\n  let match\n  let invalidMatchEnd = 0\n\n  while ((match = findFirstMatch(text, matchers)) != null && match !== null) {\n    const matchStart: number = match.index\n    const matchLength: number = match.length\n    const matchEnd = matchStart + matchLength\n    const isValid = isContentAroundIsValid(\n      invalidMatchEnd + matchStart,\n      invalidMatchEnd + matchEnd,\n      initialText,\n      currentNodes,\n    )\n\n    if (isValid) {\n      const [matchingOffset, , matchingNodes, unmodifiedAfterNodes] = extractMatchingNodes(\n        currentNodes,\n        invalidMatchEnd + matchStart,\n        invalidMatchEnd + matchEnd,\n      )\n\n      const actualMatchStart = invalidMatchEnd + matchStart - matchingOffset\n      const actualMatchEnd = invalidMatchEnd + matchEnd - matchingOffset\n      const remainingTextNode = $createAutoLinkNode_(\n        matchingNodes,\n        actualMatchStart,\n        actualMatchEnd,\n        match,\n      )\n      currentNodes = remainingTextNode\n        ? [remainingTextNode, ...unmodifiedAfterNodes]\n        : unmodifiedAfterNodes\n      onChange(match.url, null)\n      invalidMatchEnd = 0\n    } else {\n      invalidMatchEnd += matchEnd\n    }\n\n    text = text.substring(matchEnd)\n  }\n}\n\nfunction handleLinkEdit(\n  linkNode: AutoLinkNode,\n  matchers: LinkMatcher[],\n  onChange: ChangeHandler,\n): void {\n  // Check children are simple text\n  const children = linkNode.getChildren()\n  const childrenLength = children.length\n  for (let i = 0; i < childrenLength; i++) {\n    const child = children[i]\n    if (!$isTextNode(child) || !child.isSimpleText()) {\n      replaceWithChildren(linkNode)\n      onChange(null, linkNode.getFields()?.url ?? null)\n      return\n    }\n  }\n\n  // Check text content fully matches\n  const text = linkNode.getTextContent()\n  const match = findFirstMatch(text, matchers)\n  if (match === null || match.text !== text) {\n    replaceWithChildren(linkNode)\n    onChange(null, linkNode.getFields()?.url ?? null)\n    return\n  }\n\n  // Check neighbors\n  if (!isPreviousNodeValid(linkNode) || !isNextNodeValid(linkNode)) {\n    replaceWithChildren(linkNode)\n    onChange(null, linkNode.getFields()?.url ?? null)\n    return\n  }\n\n  const url = linkNode.getFields()?.url\n  if (url !== match?.url) {\n    const flds = linkNode.getFields()\n    flds.url = match?.url\n    linkNode.setFields(flds)\n    onChange(match.url, url ?? null)\n  }\n}\n\n// Bad neighbors are edits in neighbor nodes that make AutoLinks incompatible.\n// Given the creation preconditions, these can only be simple text nodes.\nfunction handleBadNeighbors(\n  textNode: TextNode,\n  matchers: LinkMatcher[],\n  onChange: ChangeHandler,\n): void {\n  const previousSibling = textNode.getPreviousSibling()\n  const nextSibling = textNode.getNextSibling()\n  const text = textNode.getTextContent()\n\n  if ($isAutoLinkNode(previousSibling)) {\n    const isEmailURI = previousSibling.getFields()?.url\n      ? (previousSibling.getFields()?.url?.startsWith('mailto:') ?? false)\n      : false\n    if (!startsWithSeparator(text) || startsWithTLD(text, isEmailURI)) {\n      previousSibling.append(textNode)\n      handleLinkEdit(previousSibling, matchers, onChange)\n      onChange(null, previousSibling.getFields()?.url ?? null)\n    }\n  }\n\n  if ($isAutoLinkNode(nextSibling) && !endsWithSeparator(text)) {\n    replaceWithChildren(nextSibling)\n    handleLinkEdit(nextSibling, matchers, onChange)\n    onChange(null, nextSibling.getFields()?.url ?? null)\n  }\n}\n\nfunction replaceWithChildren(node: ElementNode): LexicalNode[] {\n  const children = node.getChildren()\n  const childrenLength = children.length\n\n  for (let j = childrenLength - 1; j >= 0; j--) {\n    node.insertAfter(children[j]!)\n  }\n\n  node.remove()\n  return children.map((child) => child.getLatest())\n}\n\nfunction getTextNodesToMatch(textNode: TextNode): TextNode[] {\n  // check if next siblings are simple text nodes till a node contains a space separator\n  const textNodesToMatch = [textNode]\n  let nextSibling = textNode.getNextSibling()\n  while (nextSibling !== null && $isTextNode(nextSibling) && nextSibling.isSimpleText()) {\n    textNodesToMatch.push(nextSibling)\n    if (/\\s/.test(nextSibling.getTextContent())) {\n      break\n    }\n    nextSibling = nextSibling.getNextSibling()\n  }\n  return textNodesToMatch\n}\n\nfunction useAutoLink(\n  editor: LexicalEditor,\n  matchers: LinkMatcher[],\n  onChange?: ChangeHandler,\n): void {\n  useEffect(() => {\n    if (!editor.hasNodes([AutoLinkNode])) {\n      throw new Error('LexicalAutoLinkPlugin: AutoLinkNode not registered on editor')\n    }\n\n    const onChangeWrapped = (url: null | string, prevUrl: null | string): void => {\n      if (onChange != null) {\n        onChange(url, prevUrl)\n      }\n    }\n\n    return mergeRegister(\n      editor.registerNodeTransform(TextNodeValue, (textNode: TextNode) => {\n        const parent = textNode.getParentOrThrow()\n        const previous = textNode.getPreviousSibling()\n        if ($isAutoLinkNode(parent)) {\n          handleLinkEdit(parent, matchers, onChangeWrapped)\n        } else if (!$isLinkNode(parent)) {\n          if (\n            textNode.isSimpleText() &&\n            (startsWithSeparator(textNode.getTextContent()) || !$isAutoLinkNode(previous))\n          ) {\n            const textNodesToMatch = getTextNodesToMatch(textNode)\n            $handleLinkCreation(textNodesToMatch, matchers, onChangeWrapped)\n          }\n\n          handleBadNeighbors(textNode, matchers, onChangeWrapped)\n        }\n      }),\n    )\n  }, [editor, matchers, onChange])\n}\n\nconst URL_REGEX =\n  /((https?:\\/\\/(www\\.)?)|(www\\.))[-\\w@:%.+~#=]{1,256}\\.[a-zA-Z\\d()]{1,6}\\b([-\\w()@:%+.~#?&/=]*)(?<![-.+():%])/\n\nconst EMAIL_REGEX =\n  /(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\])|(([a-z\\-\\d]+\\.)+[a-z]{2,}))/i\n\nconst MATCHERS = [\n  createLinkMatcherWithRegExp(URL_REGEX, (text) => {\n    return text.startsWith('http') ? text : `https://${text}`\n  }),\n  createLinkMatcherWithRegExp(EMAIL_REGEX, (text) => {\n    return `mailto:${text}`\n  }),\n]\n\nexport const AutoLinkPlugin: PluginComponent<ClientProps> = () => {\n  const [editor] = useLexicalComposerContext()\n\n  useAutoLink(editor, MATCHERS)\n\n  return null\n}\n","'use client'\nimport { ClickableLinkPlugin as LexicalClickableLinkPlugin } from '@lexical/react/LexicalClickableLinkPlugin.js'\nimport React from 'react'\n\nimport type { PluginComponent } from '../../../../typesClient.js'\nimport type { ClientProps } from '../../index.js'\n\nexport const ClickableLinkPlugin: PluginComponent<ClientProps> = () => {\n  return <LexicalClickableLinkPlugin />\n}\n","'use client'\nimport * as React from 'react'\nimport { createPortal } from 'react-dom'\n\nimport type { PluginComponentWithAnchor } from '../../../../typesClient.js'\nimport type { ClientProps } from '../../index.js'\n\nimport './index.scss'\nimport { LinkEditor } from './LinkEditor/index.js'\n\nexport const FloatingLinkEditorPlugin: PluginComponentWithAnchor<ClientProps> = (props) => {\n  const { anchorElem = document.body } = props\n\n  return createPortal(<LinkEditor anchorElem={anchorElem} />, anchorElem)\n}\n","'use client'\nimport type { ElementNode, LexicalNode } from 'lexical'\nimport type { Data, FormState } from 'payload'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { useLexicalEditable } from '@lexical/react/useLexicalEditable'\nimport { $findMatchingParent, mergeRegister } from '@lexical/utils'\nimport { getTranslation } from '@payloadcms/translations'\nimport {\n  CloseMenuIcon,\n  EditIcon,\n  ExternalLinkIcon,\n  formatDrawerSlug,\n  useConfig,\n  useEditDepth,\n  useLocale,\n  useTranslation,\n} from '@payloadcms/ui'\nimport { requests } from '@payloadcms/ui/shared'\nimport {\n  $getSelection,\n  $isLineBreakNode,\n  $isRangeSelection,\n  COMMAND_PRIORITY_HIGH,\n  COMMAND_PRIORITY_LOW,\n  getDOMSelection,\n  KEY_ESCAPE_COMMAND,\n  SELECTION_CHANGE_COMMAND,\n} from 'lexical'\nimport React, { useCallback, useEffect, useRef, useState } from 'react'\n\nimport type { LinkNode } from '../../../../nodes/LinkNode.js'\nimport type { LinkFields } from '../../../../nodes/types.js'\nimport type { LinkPayload } from '../types.js'\n\nimport { useEditorConfigContext } from '../../../../../../lexical/config/client/EditorConfigProvider.js'\nimport { getSelectedNode } from '../../../../../../lexical/utils/getSelectedNode.js'\nimport { setFloatingElemPositionForLinkEditor } from '../../../../../../lexical/utils/setFloatingElemPositionForLinkEditor.js'\nimport { FieldsDrawer } from '../../../../../../utilities/fieldsDrawer/Drawer.js'\nimport { useLexicalDrawer } from '../../../../../../utilities/fieldsDrawer/useLexicalDrawer.js'\nimport { $isAutoLinkNode } from '../../../../nodes/AutoLinkNode.js'\nimport { $createLinkNode, $isLinkNode, TOGGLE_LINK_COMMAND } from '../../../../nodes/LinkNode.js'\nimport { TOGGLE_LINK_WITH_MODAL_COMMAND } from './commands.js'\n\nfunction preventDefault(\n  event: React.KeyboardEvent<HTMLInputElement> | React.MouseEvent<HTMLElement>,\n): void {\n  event.preventDefault()\n}\n\nexport function LinkEditor({ anchorElem }: { anchorElem: HTMLElement }): React.ReactNode {\n  const [editor] = useLexicalComposerContext()\n  // TO-DO: There are several states that should not be state, because they\n  // are derived from linkNode (linkUrl, linkLabel, stateData, isLink, isAutoLink...)\n  const [linkNode, setLinkNode] = useState<LinkNode>()\n\n  const editorRef = useRef<HTMLDivElement | null>(null)\n  const [linkUrl, setLinkUrl] = useState<null | string>(null)\n  const [linkLabel, setLinkLabel] = useState<null | string>(null)\n\n  const {\n    fieldProps: { schemaPath },\n    uuid,\n  } = useEditorConfigContext()\n  const isEditable = useLexicalEditable()\n\n  const { config, getEntityConfig } = useConfig()\n\n  const { i18n, t } = useTranslation<object, 'lexical:link:loadingWithEllipsis'>()\n\n  const [stateData, setStateData] = useState<\n    ({ id?: string; text: string } & LinkFields) | undefined\n  >()\n\n  const editDepth = useEditDepth()\n  const [isLink, setIsLink] = useState(false)\n  const [selectedNodes, setSelectedNodes] = useState<LexicalNode[]>([])\n  const locale = useLocale()\n\n  const [isAutoLink, setIsAutoLink] = useState(false)\n\n  const drawerSlug = formatDrawerSlug({\n    slug: `lexical-rich-text-link-` + uuid,\n    depth: editDepth,\n  })\n\n  const { toggleDrawer } = useLexicalDrawer(drawerSlug)\n\n  const setNotLink = useCallback(() => {\n    setIsLink(false)\n    if (editorRef && editorRef.current) {\n      editorRef.current.style.opacity = '0'\n      editorRef.current.style.transform = 'translate(-10000px, -10000px)'\n    }\n    setIsAutoLink(false)\n    setLinkUrl(null)\n    setLinkLabel(null)\n    setSelectedNodes([])\n    setStateData(undefined)\n  }, [setIsLink, setLinkUrl, setLinkLabel, setSelectedNodes])\n\n  const $updateLinkEditor = useCallback(() => {\n    const selection = $getSelection()\n    let selectedNodeDomRect: DOMRect | undefined\n\n    if (!$isRangeSelection(selection) || !selection) {\n      void setNotLink()\n      return\n    }\n\n    // Handle the data displayed in the floating link editor & drawer when you click on a link node\n\n    const focusNode = getSelectedNode(selection)\n    selectedNodeDomRect = editor.getElementByKey(focusNode.getKey())?.getBoundingClientRect()\n    const focusLinkParent = $findMatchingParent(focusNode, $isLinkNode)\n\n    // Prevent link modal from showing if selection spans further than the link: https://github.com/facebook/lexical/issues/4064\n    const badNode = selection\n      .getNodes()\n      .filter((node) => !$isLineBreakNode(node))\n      .find((node) => {\n        const linkNode = $findMatchingParent(node, $isLinkNode)\n        return (\n          (focusLinkParent && !focusLinkParent.is(linkNode)) ||\n          (linkNode && !linkNode.is(focusLinkParent))\n        )\n      })\n\n    if (focusLinkParent == null || badNode) {\n      setNotLink()\n      return\n    }\n    setLinkNode(focusLinkParent)\n\n    const fields = focusLinkParent.getFields()\n\n    // Initial state:\n    const data: { text: string } & LinkFields = {\n      ...fields,\n      id: focusLinkParent.getID(),\n      text: focusLinkParent.getTextContent(),\n    }\n\n    if (fields?.linkType === 'custom') {\n      setLinkUrl(fields?.url ?? null)\n      setLinkLabel(null)\n    } else {\n      // internal link\n      setLinkUrl(\n        `${config.routes.admin === '/' ? '' : config.routes.admin}/collections/${fields?.doc?.relationTo}/${\n          fields?.doc?.value\n        }`,\n      )\n\n      const relatedField = fields?.doc?.relationTo\n        ? getEntityConfig({ collectionSlug: fields?.doc?.relationTo })\n        : undefined\n      if (!relatedField) {\n        // Usually happens if the user removed all default fields. In this case, we let them specify the label or do not display the label at all.\n        // label could be a virtual field the user added. This is useful if they want to use the link feature for things other than links.\n        setLinkLabel(fields?.label ? String(fields?.label) : null)\n        setLinkUrl(fields?.url ? String(fields?.url) : null)\n      } else {\n        const id = typeof fields.doc?.value === 'object' ? fields.doc.value.id : fields.doc?.value\n        const collection = fields.doc?.relationTo\n        if (!id || !collection) {\n          throw new Error(`Focus link parent is missing doc.value or doc.relationTo`)\n        }\n\n        const loadingLabel = t('fields:linkedTo', {\n          label: `${getTranslation(relatedField.labels.singular, i18n)} - ${t('lexical:link:loadingWithEllipsis', i18n)}`,\n        }).replace(/<[^>]*>?/g, '')\n        setLinkLabel(loadingLabel)\n\n        requests\n          .get(`${config.serverURL}${config.routes.api}/${collection}/${id}`, {\n            headers: {\n              'Accept-Language': i18n.language,\n            },\n            params: {\n              depth: 0,\n              locale: locale?.code,\n            },\n          })\n          .then(async (res) => {\n            if (!res.ok) {\n              throw new Error(`HTTP error! Status: ${res.status}`)\n            }\n            const data = await res.json()\n            const useAsTitle = relatedField?.admin?.useAsTitle || 'id'\n            const title = data[useAsTitle]\n            const label = t('fields:linkedTo', {\n              label: `${getTranslation(relatedField.labels.singular, i18n)} - ${title}`,\n            }).replace(/<[^>]*>?/g, '')\n            setLinkLabel(label)\n          })\n          .catch(() => {\n            const label = t('fields:linkedTo', {\n              label: `${getTranslation(relatedField.labels.singular, i18n)} - ${t('general:untitled', i18n)} - ID: ${id}`,\n            }).replace(/<[^>]*>?/g, '')\n            setLinkLabel(label)\n          })\n      }\n    }\n\n    setStateData(data)\n    setIsLink(true)\n    setSelectedNodes(selection ? selection?.getNodes() : [])\n\n    if ($isAutoLinkNode(focusLinkParent)) {\n      setIsAutoLink(true)\n    } else {\n      setIsAutoLink(false)\n    }\n\n    const editorElem = editorRef.current\n    const nativeSelection = getDOMSelection(editor._window)\n    const { activeElement } = document\n\n    if (editorElem === null) {\n      return\n    }\n\n    const rootElement = editor.getRootElement()\n\n    if (\n      nativeSelection !== null &&\n      rootElement !== null &&\n      rootElement.contains(nativeSelection.anchorNode)\n    ) {\n      if (!selectedNodeDomRect) {\n        // Get the DOM rect of the selected node using the native selection. This sometimes produces the wrong\n        // result, which is why we use lexical's selection preferably.\n        selectedNodeDomRect = nativeSelection.getRangeAt(0).getBoundingClientRect()\n      }\n\n      if (selectedNodeDomRect != null) {\n        selectedNodeDomRect.y += 40\n        setFloatingElemPositionForLinkEditor(selectedNodeDomRect, editorElem, anchorElem)\n      }\n    } else if (activeElement == null || activeElement.className !== 'link-input') {\n      if (rootElement !== null) {\n        setFloatingElemPositionForLinkEditor(null, editorElem, anchorElem)\n      }\n      setLinkUrl(null)\n      setLinkLabel(null)\n    }\n\n    return true\n  }, [\n    editor,\n    setNotLink,\n    config.routes.admin,\n    config.routes.api,\n    config.serverURL,\n    getEntityConfig,\n    t,\n    i18n,\n    locale?.code,\n    anchorElem,\n  ])\n\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerCommand(\n        TOGGLE_LINK_WITH_MODAL_COMMAND,\n        (payload: LinkPayload) => {\n          editor.dispatchCommand(TOGGLE_LINK_COMMAND, payload)\n\n          // Now, open the modal\n          $updateLinkEditor()\n          toggleDrawer()\n\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n    )\n  }, [editor, $updateLinkEditor, toggleDrawer, drawerSlug])\n\n  useEffect(() => {\n    const scrollerElem = anchorElem.parentElement\n\n    const update = (): void => {\n      editor.getEditorState().read(() => {\n        void $updateLinkEditor()\n      })\n    }\n\n    window.addEventListener('resize', update)\n\n    if (scrollerElem != null) {\n      scrollerElem.addEventListener('scroll', update)\n    }\n\n    return () => {\n      window.removeEventListener('resize', update)\n\n      if (scrollerElem != null) {\n        scrollerElem.removeEventListener('scroll', update)\n      }\n    }\n  }, [anchorElem.parentElement, editor, $updateLinkEditor])\n\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerUpdateListener(({ editorState }) => {\n        editorState.read(() => {\n          void $updateLinkEditor()\n        })\n      }),\n\n      editor.registerCommand(\n        SELECTION_CHANGE_COMMAND,\n        () => {\n          void $updateLinkEditor()\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand(\n        KEY_ESCAPE_COMMAND,\n        () => {\n          if (isLink) {\n            setNotLink()\n\n            return true\n          }\n          return false\n        },\n        COMMAND_PRIORITY_HIGH,\n      ),\n    )\n  }, [editor, $updateLinkEditor, isLink, setNotLink])\n\n  useEffect(() => {\n    editor.getEditorState().read(() => {\n      void $updateLinkEditor()\n    })\n  }, [editor, $updateLinkEditor])\n\n  return (\n    <React.Fragment>\n      <div className=\"link-editor\" ref={editorRef}>\n        <div className=\"link-input\">\n          {linkUrl && linkUrl.length > 0 ? (\n            <a href={linkUrl} rel=\"noopener noreferrer\" target=\"_blank\">\n              {linkNode?.__fields.newTab ? <ExternalLinkIcon /> : null}\n              {linkLabel != null && linkLabel.length > 0 ? linkLabel : linkUrl}\n            </a>\n          ) : linkLabel != null && linkLabel.length > 0 ? (\n            <>\n              {linkNode?.__fields.newTab ? <ExternalLinkIcon /> : null}\n              <span className=\"link-input__label-pure\">{linkLabel}</span>\n            </>\n          ) : null}\n\n          {isEditable && (\n            <React.Fragment>\n              <button\n                aria-label=\"Edit link\"\n                className=\"link-edit\"\n                onClick={(event) => {\n                  event.preventDefault()\n                  toggleDrawer()\n                }}\n                onMouseDown={preventDefault}\n                tabIndex={0}\n                type=\"button\"\n              >\n                <EditIcon />\n              </button>\n              {!isAutoLink && (\n                <button\n                  aria-label=\"Remove link\"\n                  className=\"link-trash\"\n                  onClick={() => {\n                    editor.dispatchCommand(TOGGLE_LINK_COMMAND, null)\n                  }}\n                  onMouseDown={preventDefault}\n                  tabIndex={0}\n                  type=\"button\"\n                >\n                  <CloseMenuIcon />\n                </button>\n              )}\n            </React.Fragment>\n          )}\n        </div>\n      </div>\n      <FieldsDrawer\n        className=\"lexical-link-edit-drawer\"\n        data={stateData}\n        drawerSlug={drawerSlug}\n        drawerTitle={t('fields:editLink')}\n        featureKey=\"link\"\n        handleDrawerSubmit={(fields: FormState, data: Data) => {\n          const newLinkPayload = data as { text: string } & LinkFields\n\n          const bareLinkFields: LinkFields = {\n            ...newLinkPayload,\n          }\n          delete bareLinkFields.text\n\n          // See: https://github.com/facebook/lexical/pull/5536. This updates autolink nodes to link nodes whenever a change was made (which is good!).\n          editor.update(() => {\n            const selection = $getSelection()\n            let linkParent: ElementNode | null = null\n            if ($isRangeSelection(selection)) {\n              linkParent = getSelectedNode(selection).getParent()\n            } else {\n              if (selectedNodes.length) {\n                linkParent = selectedNodes[0]?.getParent() ?? null\n              }\n            }\n\n            if (linkParent && $isAutoLinkNode(linkParent)) {\n              const linkNode = $createLinkNode({\n                fields: bareLinkFields,\n              })\n              linkParent.replace(linkNode, true)\n            }\n          })\n\n          // Needs to happen AFTER a potential auto link => link node conversion, as otherwise, the updated text to display may be lost due to\n          // it being applied to the auto link node instead of the link node.\n          editor.dispatchCommand(TOGGLE_LINK_COMMAND, {\n            fields: bareLinkFields,\n            selectedNodes,\n            text: newLinkPayload.text,\n          })\n        }}\n        schemaPath={schemaPath}\n        schemaPathSuffix=\"fields\"\n      />\n    </React.Fragment>\n  )\n}\n","'use client'\nconst VERTICAL_GAP = 10\nconst HORIZONTAL_OFFSET = 5\n\nexport function setFloatingElemPositionForLinkEditor(\n  targetRect: DOMRect | null,\n  floatingElem: HTMLElement,\n  anchorElem: HTMLElement,\n  verticalGap: number = VERTICAL_GAP,\n  horizontalOffset: number = HORIZONTAL_OFFSET,\n): void {\n  const scrollerElem = anchorElem.parentElement\n\n  if (targetRect === null || scrollerElem == null) {\n    floatingElem.style.opacity = '0'\n    floatingElem.style.transform = 'translate(-10000px, -10000px)'\n    return\n  }\n\n  const floatingElemRect = floatingElem.getBoundingClientRect()\n  const anchorElementRect = anchorElem.getBoundingClientRect()\n  const editorScrollerRect = scrollerElem.getBoundingClientRect()\n\n  let top = targetRect.top - verticalGap\n  let left = targetRect.left - horizontalOffset\n\n  if (top < editorScrollerRect.top) {\n    top += floatingElemRect.height + targetRect.height + verticalGap * 2\n  }\n\n  if (left + floatingElemRect.width > editorScrollerRect.right) {\n    left = editorScrollerRect.right - floatingElemRect.width - horizontalOffset\n  }\n\n  top -= anchorElementRect.top\n  left -= anchorElementRect.left\n\n  floatingElem.style.opacity = '1'\n  floatingElem.style.transform = `translate(${left}px, ${top}px)`\n}\n","'use client'\nimport type { LexicalCommand } from 'lexical'\n\nimport { createCommand } from 'lexical'\n\nimport type { LinkPayload } from '../types.js'\n\nexport const TOGGLE_LINK_WITH_MODAL_COMMAND: LexicalCommand<LinkPayload | null> = createCommand(\n  'TOGGLE_LINK_WITH_MODAL_COMMAND',\n)\n","'use client'\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { mergeRegister } from '@lexical/utils'\nimport {\n  $getSelection,\n  $isElementNode,\n  $isRangeSelection,\n  COMMAND_PRIORITY_LOW,\n  PASTE_COMMAND,\n} from 'lexical'\nimport { useEffect } from 'react'\n\nimport type { PluginComponent } from '../../../../typesClient.js'\nimport type { LinkFields } from '../../../nodes/types.js'\nimport type { ClientProps } from '../../index.js'\nimport type { LinkPayload } from '../floatingLinkEditor/types.js'\n\nimport { validateUrl } from '../../../../../lexical/utils/url.js'\nimport { $toggleLink, LinkNode, TOGGLE_LINK_COMMAND } from '../../../nodes/LinkNode.js'\n\nexport const LinkPlugin: PluginComponent<ClientProps> = ({ clientProps }) => {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    if (!editor.hasNodes([LinkNode])) {\n      throw new Error('LinkPlugin: LinkNode not registered on editor')\n    }\n    return mergeRegister(\n      editor.registerCommand(\n        TOGGLE_LINK_COMMAND,\n        (payload: LinkPayload) => {\n          if (payload === null) {\n            $toggleLink(null)\n            return true\n          }\n          if (!payload.fields?.linkType) {\n            payload.fields.linkType = clientProps.defaultLinkType as any\n          }\n          if (!payload.fields?.url) {\n            payload.fields.url = clientProps.defaultLinkURL as any\n          }\n          $toggleLink(payload as { fields: LinkFields } & LinkPayload)\n          return true\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      editor.registerCommand(\n        PASTE_COMMAND,\n        (event) => {\n          const selection = $getSelection()\n          if (\n            !$isRangeSelection(selection) ||\n            selection.isCollapsed() ||\n            !(event instanceof ClipboardEvent) ||\n            event.clipboardData == null\n          ) {\n            return false\n          }\n          const clipboardText = event.clipboardData.getData('text')\n          if (!validateUrl(clipboardText)) {\n            return false\n          }\n          // If we select nodes that are elements then avoid applying the link.\n          if (!selection.getNodes().some((node) => $isElementNode(node))) {\n            const linkFields: LinkFields = {\n              doc: null,\n              linkType: 'custom',\n              newTab: false,\n              url: clipboardText,\n            }\n            editor.dispatchCommand(TOGGLE_LINK_COMMAND, {\n              fields: linkFields,\n              text: null,\n            })\n            event.preventDefault()\n            return true\n          }\n          return false\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n    )\n  }, [clientProps.defaultLinkType, clientProps.defaultLinkURL, editor])\n\n  return null\n}\n","export function sanitizeUrl(url: string): string {\n  /** A pattern that matches safe  URLs. */\n  const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi\n\n  /** A pattern that matches safe data URLs. */\n  const DATA_URL_PATTERN =\n    /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[a-z\\d+/]+=*$/i\n\n  url = String(url).trim()\n\n  if (url.match(SAFE_URL_PATTERN) != null || url.match(DATA_URL_PATTERN) != null) {\n    return url\n  }\n\n  return 'https://'\n}\n\n/**\n * This regex checks for absolute URLs in a string. Tested for the following use cases:\n * - http://example.com\n * - https://example.com\n * - ftp://files.example.com\n * - http://example.com/resource\n * - https://example.com/resource?key=value\n * - http://example.com/resource#anchor\n * - http://www.example.com\n * - https://sub.example.com/path/file\n * - mailto:\n */\nexport const absoluteRegExp =\n  /^(?:[a-zA-Z][a-zA-Z\\d+.-]*:(?:\\/\\/)?(?:[-;:&=+$,\\w]+@)?[A-Za-z\\d]+(?:\\.[A-Za-z\\d]+)+|www\\.[A-Za-z\\d]+(?:\\.[A-Za-z\\d]+)+|(?:tel|mailto):[\\w+.-]+)(?:\\/[+~%/\\w-]*)?(?:\\?[-;&=%\\w]*)?(?:#\\w+)?$/\n\n/**\n * This regex checks for relative URLs starting with / or anchor links starting with # in a string. Tested for the following use cases:\n * - /privacy-policy\n * - /privacy-policy#primary-terms\n * - #primary-terms\n * - /page?id=123\n * - /page?id=123#section\n *  */\nexport const relativeOrAnchorRegExp = /^(?:\\/[\\w\\-./]*(?:\\?[-;&=%\\w]*)?(?:#[\\w-]+)?|#[\\w\\-]+)$/\n\n/**\n * Prevents unreasonable URLs from being inserted into the editor.\n * @param url\n */\nexport function validateUrlMinimal(url: string): boolean {\n  if (!url) {\n    return false\n  }\n\n  return !url.includes(' ')\n}\n\n// Do not keep validateUrl function too loose. This is run when pasting in text, to determine if links are in that text and if it should create AutoLinkNodes.\n// This is why we do not allow stuff like anchors here, as we don't want copied anchors to be turned into AutoLinkNodes.\nexport function validateUrl(url: string): boolean {\n  // TODO Fix UI for link insertion; it should never default to an invalid URL such as https://.\n  // Maybe show a dialog where they user can type the URL before inserting it.\n  if (!url) {\n    return false\n  }\n\n  // Reject URLs with spaces\n  if (url.includes(' ')) {\n    return false\n  }\n\n  // Reject malformed protocol URLs (e.g., http:/example.com instead of http://example.com)\n  if (/^[a-z][a-z\\d+.-]*:\\/[^/]/i.test(url)) {\n    return false\n  }\n\n  if (url === 'https://') {\n    return true\n  }\n\n  // This makes sure URLs starting with www. instead of https are valid too\n  if (absoluteRegExp.test(url)) {\n    return true\n  }\n\n  // Check relative or anchor links\n  if (relativeOrAnchorRegExp.test(url)) {\n    return true\n  }\n\n  // While this doesn't allow URLs starting with www (which is why we use the regex above), it does properly handle tel: URLs\n  try {\n    const urlObj = new URL(url)\n    // For http/https/ftp protocols, require a proper domain with at least one dot (for TLD)\n    if (['ftp:', 'http:', 'https:'].includes(urlObj.protocol)) {\n      if (!urlObj.hostname.includes('.')) {\n        return false\n      }\n    }\n    return true\n  } catch {\n    /* empty */\n  }\n\n  return false\n}\n","'use client'\nimport { $isListNode, INSERT_CHECK_LIST_COMMAND, ListItemNode, ListNode } from '@lexical/list'\nimport { $isRangeSelection } from 'lexical'\n\nimport type { ToolbarGroup } from '../../../toolbars/types.js'\nimport type { ClientFeature } from '../../../typesClient.js'\n\nimport { ChecklistIcon } from '../../../../lexical/ui/icons/Checklist/index.js'\nimport { createClientFeature } from '../../../../utilities/createClientFeature.js'\nimport { toolbarTextDropdownGroupWithItems } from '../../../shared/toolbar/textDropdownGroup.js'\nimport { LexicalListPlugin } from '../../plugin/index.js'\nimport { shouldRegisterListBaseNodes } from '../../shared/shouldRegisterListBaseNodes.js'\nimport { slashMenuListGroupWithItems } from '../../shared/slashMenuListGroup.js'\nimport { CHECK_LIST } from '../markdownTransformers.js'\nimport { LexicalCheckListPlugin } from './plugin/index.js'\n\nconst toolbarGroups: ToolbarGroup[] = [\n  toolbarTextDropdownGroupWithItems([\n    {\n      ChildComponent: ChecklistIcon,\n      isActive: ({ selection }) => {\n        if (!$isRangeSelection(selection)) {\n          return false\n        }\n        for (const node of selection.getNodes()) {\n          if ($isListNode(node) && node.getListType() === 'check') {\n            continue\n          }\n\n          const parent = node.getParent()\n\n          if ($isListNode(parent) && parent.getListType() === 'check') {\n            continue\n          }\n\n          const parentParent = parent?.getParent()\n          // Example scenario: Node = textNode, parent = listItemNode, parentParent = listNode\n          if ($isListNode(parentParent) && parentParent.getListType() === 'check') {\n            continue\n          }\n\n          return false\n        }\n        return true\n      },\n      key: 'checklist',\n      label: ({ i18n }) => {\n        return i18n.t('lexical:checklist:label')\n      },\n      onSelect: ({ editor }) => {\n        editor.dispatchCommand(INSERT_CHECK_LIST_COMMAND, undefined)\n      },\n      order: 12,\n    },\n  ]),\n]\n\nexport const ChecklistFeatureClient = createClientFeature(({ featureProviderMap }) => {\n  const plugins: ClientFeature<undefined>['plugins'] = [\n    {\n      Component: LexicalCheckListPlugin,\n      position: 'normal',\n    },\n  ]\n\n  const shouldRegister = shouldRegisterListBaseNodes('checklist', featureProviderMap)\n  if (shouldRegister) {\n    plugins.push({\n      Component: LexicalListPlugin,\n      position: 'normal',\n    })\n  }\n\n  return {\n    markdownTransformers: [CHECK_LIST],\n    nodes: shouldRegister ? [ListNode, ListItemNode] : [],\n    plugins,\n    slashMenu: {\n      groups: [\n        slashMenuListGroupWithItems([\n          {\n            Icon: ChecklistIcon,\n            key: 'checklist',\n            keywords: ['check list', 'check', 'checklist', 'cl'],\n            label: ({ i18n }) => {\n              return i18n.t('lexical:checklist:label')\n            },\n            onSelect: ({ editor }) => {\n              editor.dispatchCommand(INSERT_CHECK_LIST_COMMAND, undefined)\n            },\n          },\n        ]),\n      ],\n    },\n    toolbarFixed: {\n      groups: toolbarGroups,\n    },\n    toolbarInline: {\n      groups: toolbarGroups,\n    },\n  }\n})\n","'use client'\nimport React from 'react'\n\nexport const ChecklistIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <rect height=\"13\" rx=\"1.5\" stroke=\"currentColor\" width=\"13\" x=\"3.5\" y=\"3.5\" />\n    <path d=\"M7 10L9 12.5L13 7.5\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n  </svg>\n)\n","'use client'\nimport type {\n  SerializedListItemNode as _SerializedListItemNode,\n  SerializedListNode as _SerializedListNode,\n} from '@lexical/list'\nimport type { SerializedLexicalNode } from 'lexical'\n\nimport { ListPlugin } from '@lexical/react/LexicalListPlugin.js'\nimport React from 'react'\n\nimport type { StronglyTypedElementNode } from '../../../nodeTypes.js'\nimport type { PluginComponent } from '../../typesClient.js'\n\nexport type SerializedListItemNode<T extends SerializedLexicalNode = SerializedLexicalNode> = {\n  checked?: boolean\n} & StronglyTypedElementNode<_SerializedListItemNode, 'listitem', T>\n\nexport type SerializedListNode<T extends SerializedLexicalNode = SerializedLexicalNode> = {\n  checked?: boolean\n} & StronglyTypedElementNode<_SerializedListNode, 'list', T>\n\nexport const LexicalListPlugin: PluginComponent<undefined> = () => {\n  return <ListPlugin />\n}\n","// Priority order: unordered > ordered > checklist.\n// That's why we don't include unordered among the parameter options. It registers by default.\nexport function shouldRegisterListBaseNodes(\n  type: 'checklist' | 'ordered',\n  featureProviderMap: Map<string, unknown>,\n) {\n  if (type === 'ordered') {\n    // OrderedList only registers if UnorderedList is NOT present\n    return !featureProviderMap.has('unorderedList')\n  }\n\n  if (type === 'checklist') {\n    // Checklist only registers if neither UnorderedList nor OrderedList are present\n    return !featureProviderMap.has('unorderedList') && !featureProviderMap.has('orderedList')\n  }\n\n  return false\n}\n","import type {\n  SlashMenuGroup,\n  SlashMenuItem,\n} from '../../../lexical/plugins/SlashMenu/LexicalTypeaheadMenuPlugin/types.js'\n\nexport function slashMenuListGroupWithItems(items: SlashMenuItem[]): SlashMenuGroup {\n  return {\n    items,\n    key: 'lists',\n    label: ({ i18n }) => {\n      return i18n.t('lexical:general:slashMenuListGroupLabel')\n    },\n  }\n}\n","import { $isListNode, ListItemNode, ListNode } from '@lexical/list'\n\nimport type { ElementTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport { listExport, listReplace } from '../shared/markdown.js'\n\nexport const CHECK_LIST: ElementTransformer = {\n  type: 'element',\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null\n  },\n  regExp: /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i,\n  replace: listReplace('check'),\n}\n","// Copied from https://github.com/facebook/lexical/blob/176b8cf16ecb332ee5efe2c75219e223b7b019f2/packages/lexical-markdown/src/MarkdownTransformers.ts#L97C1-L172C1\n\nimport type { ListNode, ListType } from '@lexical/list'\nimport type { ElementNode } from 'lexical'\n\nimport { $createListItemNode, $createListNode, $isListItemNode, $isListNode } from '@lexical/list'\n\nimport type { ElementTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\n// Amount of spaces that define indentation level\nconst LIST_INDENT_SIZE = 4\n\nexport const listReplace = (listType: ListType): ElementTransformer['replace'] => {\n  return (parentNode, children, match) => {\n    const previousNode = parentNode.getPreviousSibling()\n    const nextNode = parentNode.getNextSibling()\n    const listItem = $createListItemNode(listType === 'check' ? match[3] === 'x' : undefined)\n    if ($isListNode(nextNode) && nextNode.getListType() === listType) {\n      const firstChild = nextNode.getFirstChild()\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItem)\n      } else {\n        // should never happen, but let's handle gracefully, just in case.\n        nextNode.append(listItem)\n      }\n      parentNode.remove()\n    } else if ($isListNode(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem)\n      parentNode.remove()\n    } else {\n      const list = $createListNode(listType, listType === 'number' ? Number(match[2]) : undefined)\n      list.append(listItem)\n      parentNode.replace(list)\n    }\n    listItem.append(...children)\n    listItem.select(0, 0)\n    const indent = Math.floor(match[1]!.length / LIST_INDENT_SIZE)\n    if (indent) {\n      listItem.setIndent(indent)\n    }\n  }\n}\n\nexport const listExport = (\n  listNode: ListNode,\n  exportChildren: (node: ElementNode) => string,\n  depth: number,\n): string => {\n  const output: string[] = []\n  const children = listNode.getChildren()\n  let index = 0\n  for (const listItemNode of children) {\n    if ($isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild()\n        if ($isListNode(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1))\n          continue\n        }\n      }\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE)\n      const listType = listNode.getListType()\n      const prefix =\n        listType === 'number'\n          ? `${listNode.getStart() + index}. `\n          : listType === 'check'\n            ? `- [${listItemNode.getChecked() ? 'x' : ' '}] `\n            : '- '\n      output.push(indent + prefix + exportChildren(listItemNode))\n      index++\n    }\n  }\n\n  return output.join('\\n')\n}\n","'use client'\nimport { CheckListPlugin } from '@lexical/react/LexicalCheckListPlugin.js'\nimport React from 'react'\n\nimport type { PluginComponent } from '../../../../typesClient.js'\n\nexport const LexicalCheckListPlugin: PluginComponent<undefined> = () => {\n  return <CheckListPlugin />\n}\n","'use client'\nimport { $isListNode, INSERT_ORDERED_LIST_COMMAND, ListItemNode, ListNode } from '@lexical/list'\nimport { $isRangeSelection } from 'lexical'\n\nimport type { ToolbarGroup } from '../../../toolbars/types.js'\n\nimport { OrderedListIcon } from '../../../../lexical/ui/icons/OrderedList/index.js'\nimport { createClientFeature } from '../../../../utilities/createClientFeature.js'\nimport { toolbarTextDropdownGroupWithItems } from '../../../shared/toolbar/textDropdownGroup.js'\nimport { LexicalListPlugin } from '../../plugin/index.js'\nimport { shouldRegisterListBaseNodes } from '../../shared/shouldRegisterListBaseNodes.js'\nimport { slashMenuListGroupWithItems } from '../../shared/slashMenuListGroup.js'\nimport { ORDERED_LIST } from '../markdownTransformer.js'\n\nconst toolbarGroups: ToolbarGroup[] = [\n  toolbarTextDropdownGroupWithItems([\n    {\n      ChildComponent: OrderedListIcon,\n      isActive: ({ selection }) => {\n        if (!$isRangeSelection(selection)) {\n          return false\n        }\n        for (const node of selection.getNodes()) {\n          if ($isListNode(node) && node.getListType() === 'number') {\n            continue\n          }\n\n          const parent = node.getParent()\n\n          if ($isListNode(parent) && parent.getListType() === 'number') {\n            continue\n          }\n\n          const parentParent = parent?.getParent()\n          // Example scenario: Node = textNode, parent = listItemNode, parentParent = listNode\n          if ($isListNode(parentParent) && parentParent.getListType() === 'number') {\n            continue\n          }\n\n          return false\n        }\n        return true\n      },\n      key: 'orderedList',\n      label: ({ i18n }) => {\n        return i18n.t('lexical:orderedList:label')\n      },\n      onSelect: ({ editor }) => {\n        editor.dispatchCommand(INSERT_ORDERED_LIST_COMMAND, undefined)\n      },\n      order: 10,\n    },\n  ]),\n]\n\nexport const OrderedListFeatureClient = createClientFeature(({ featureProviderMap }) => {\n  const shouldRegister = shouldRegisterListBaseNodes('ordered', featureProviderMap)\n  return {\n    markdownTransformers: [ORDERED_LIST],\n    nodes: shouldRegister ? [ListNode, ListItemNode] : [],\n    plugins: shouldRegister\n      ? [\n          {\n            Component: LexicalListPlugin,\n            position: 'normal',\n          },\n        ]\n      : [],\n    slashMenu: {\n      groups: [\n        slashMenuListGroupWithItems([\n          {\n            Icon: OrderedListIcon,\n            key: 'orderedList',\n            keywords: ['ordered list', 'ol'],\n            label: ({ i18n }) => {\n              return i18n.t('lexical:orderedList:label')\n            },\n            onSelect: ({ editor }) => {\n              editor.dispatchCommand(INSERT_ORDERED_LIST_COMMAND, undefined)\n            },\n          },\n        ]),\n      ],\n    },\n    toolbarFixed: {\n      groups: toolbarGroups,\n    },\n    toolbarInline: {\n      groups: toolbarGroups,\n    },\n  }\n})\n","'use client'\nimport React from 'react'\n\nexport const OrderedListIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path\n      d=\"M5.89284 12.479C5.89284 13.368 5.26284 13.788 4.38084 14.236C3.75084 14.558 3.43584 14.789 3.40784 15.062H5.89984V16H2.06384V15.573C2.06384 14.523 2.92484 13.935 3.66684 13.501C4.38084 13.088 4.75184 12.878 4.75184 12.458C4.75184 12.08 4.52084 11.835 4.06584 11.835C3.58984 11.835 3.30984 12.199 3.28184 12.654H2.11284C2.18984 11.681 2.87584 10.918 4.07284 10.918C5.15784 10.918 5.89284 11.555 5.89284 12.479Z\"\n      fill=\"currentColor\"\n    />\n    <path\n      d=\"M2.68608 4.535V3.737C3.54008 3.737 3.90408 3.513 4.02308 2.995H4.89108V8H3.68008L3.68008 4.535H2.68608Z\"\n      fill=\"currentColor\"\n    />\n    <path d=\"M8 15L17 15\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n    <path d=\"M8 10L17 10\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n    <path d=\"M8 5L17 5\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n  </svg>\n)\n","import { $isListNode, ListItemNode, ListNode } from '@lexical/list'\n\nimport type { ElementTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport { listExport, listReplace } from '../shared/markdown.js'\n\nexport const ORDERED_LIST: ElementTransformer = {\n  type: 'element',\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null\n  },\n  regExp: /^(\\s*)(\\d+)\\.\\s/,\n  replace: listReplace('number'),\n}\n","'use client'\n\nimport { $isListNode, INSERT_UNORDERED_LIST_COMMAND, ListItemNode, ListNode } from '@lexical/list'\nimport { $isRangeSelection } from 'lexical'\n\nimport type { ToolbarGroup } from '../../../toolbars/types.js'\n\nimport { UnorderedListIcon } from '../../../../lexical/ui/icons/UnorderedList/index.js'\nimport { createClientFeature } from '../../../../utilities/createClientFeature.js'\nimport { toolbarTextDropdownGroupWithItems } from '../../../shared/toolbar/textDropdownGroup.js'\nimport { LexicalListPlugin } from '../../plugin/index.js'\nimport { slashMenuListGroupWithItems } from '../../shared/slashMenuListGroup.js'\nimport { UNORDERED_LIST } from '../markdownTransformer.js'\n\nconst toolbarGroups: ToolbarGroup[] = [\n  toolbarTextDropdownGroupWithItems([\n    {\n      ChildComponent: UnorderedListIcon,\n      isActive: ({ selection }) => {\n        if (!$isRangeSelection(selection)) {\n          return false\n        }\n        for (const node of selection.getNodes()) {\n          if ($isListNode(node) && node.getListType() === 'bullet') {\n            continue\n          }\n\n          const parent = node.getParent()\n\n          if ($isListNode(parent) && parent.getListType() === 'bullet') {\n            continue\n          }\n\n          const parentParent = parent?.getParent()\n          // Example scenario: Node = textNode, parent = listItemNode, parentParent = listNode\n          if ($isListNode(parentParent) && parentParent.getListType() === 'bullet') {\n            continue\n          }\n\n          return false\n        }\n        return true\n      },\n      key: 'unorderedList',\n      label: ({ i18n }) => {\n        return i18n.t('lexical:unorderedList:label')\n      },\n      onSelect: ({ editor }) => {\n        editor.dispatchCommand(INSERT_UNORDERED_LIST_COMMAND, undefined)\n      },\n      order: 11,\n    },\n  ]),\n]\n\nexport const UnorderedListFeatureClient = createClientFeature({\n  markdownTransformers: [UNORDERED_LIST],\n  nodes: [ListNode, ListItemNode],\n  plugins: [\n    {\n      Component: LexicalListPlugin,\n      position: 'normal',\n    },\n  ],\n  slashMenu: {\n    groups: [\n      slashMenuListGroupWithItems([\n        {\n          Icon: UnorderedListIcon,\n          key: 'unorderedList',\n          keywords: ['unordered list', 'ul'],\n          label: ({ i18n }) => {\n            return i18n.t('lexical:unorderedList:label')\n          },\n          onSelect: ({ editor }) => {\n            editor.dispatchCommand(INSERT_UNORDERED_LIST_COMMAND, undefined)\n          },\n        },\n      ]),\n    ],\n  },\n  toolbarFixed: {\n    groups: toolbarGroups,\n  },\n  toolbarInline: {\n    groups: toolbarGroups,\n  },\n})\n","'use client'\nimport React from 'react'\n\nexport const UnorderedListIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <circle cx=\"4\" cy=\"5\" fill=\"currentColor\" r=\"1.15\" stroke=\"currentColor\" strokeWidth=\"0.3\" />\n    <circle cx=\"4\" cy=\"10\" fill=\"currentColor\" r=\"1.15\" stroke=\"currentColor\" strokeWidth=\"0.3\" />\n    <circle cx=\"4\" cy=\"15\" fill=\"currentColor\" r=\"1.15\" stroke=\"currentColor\" strokeWidth=\"0.3\" />\n    <path d=\"M17 5H7\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n    <path d=\"M17 10H7\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n    <path d=\"M17 15H7\" stroke=\"currentColor\" strokeWidth=\"1.5\" />\n  </svg>\n)\n","import { $isListNode, ListItemNode, ListNode } from '@lexical/list'\n\nimport type { ElementTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport { listExport, listReplace } from '../shared/markdown.js'\n\nexport const UNORDERED_LIST: ElementTransformer = {\n  type: 'element',\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null\n  },\n  regExp: /^(\\s*)[-*+]\\s/,\n  replace: listReplace('bullet'),\n}\n","import type { EditorConfig, LexicalNode, NodeKey, SerializedLexicalNode, Spread } from 'lexical'\nimport type { JSX } from 'react'\n\nimport { addClassNamesToElement } from '@lexical/utils'\nimport { $applyNodeReplacement, DecoratorNode } from 'lexical'\nimport * as React from 'react'\n\nexport type UnknownConvertedNodeData = {\n  nodeData: unknown\n  nodeType: string\n}\n\nexport type SerializedUnknownConvertedNode = Spread<\n  {\n    data: UnknownConvertedNodeData\n  },\n  SerializedLexicalNode\n>\n\nconst Component = React.lazy(() =>\n  import('./Component.js').then((module) => ({\n    default: module.UnknownConvertedNodeComponent,\n  })),\n)\n\n/** @noInheritDoc */\nexport class UnknownConvertedNode extends DecoratorNode<JSX.Element> {\n  __data: UnknownConvertedNodeData\n\n  constructor({ data, key }: { data: UnknownConvertedNodeData; key?: NodeKey }) {\n    super(key)\n    this.__data = data\n  }\n\n  static override clone(node: UnknownConvertedNode): UnknownConvertedNode {\n    return new this({\n      data: node.__data,\n      key: node.__key,\n    })\n  }\n\n  static override getType(): string {\n    return 'unknownConverted'\n  }\n\n  static override importJSON(serializedNode: SerializedUnknownConvertedNode): UnknownConvertedNode {\n    const node = $createUnknownConvertedNode({ data: serializedNode.data })\n    return node\n  }\n\n  canInsertTextAfter(): true {\n    return true\n  }\n\n  canInsertTextBefore(): true {\n    return true\n  }\n\n  override createDOM(config: EditorConfig): HTMLElement {\n    const element = document.createElement('span')\n    addClassNamesToElement(element, 'unknownConverted')\n    return element\n  }\n\n  override decorate(): JSX.Element {\n    return <Component data={this.__data} />\n  }\n\n  override exportJSON(): SerializedUnknownConvertedNode {\n    return {\n      type: this.getType(),\n      data: this.__data,\n      version: 1,\n    }\n  }\n\n  // Mutation\n\n  override isInline(): boolean {\n    return true\n  }\n\n  override updateDOM(prevNode: this, dom: HTMLElement): boolean {\n    return false\n  }\n}\n\nexport function $createUnknownConvertedNode({\n  data,\n}: {\n  data: UnknownConvertedNodeData\n}): UnknownConvertedNode {\n  return $applyNodeReplacement(\n    new UnknownConvertedNode({\n      data,\n    }),\n  )\n}\n\nexport function $isUnknownConvertedNode(\n  node: LexicalNode | null | undefined,\n): node is UnknownConvertedNode {\n  return node instanceof UnknownConvertedNode\n}\n","'use client'\n\nimport { createClientFeature } from '../../../utilities/createClientFeature.js'\nimport { UnknownConvertedNode } from './nodes/unknownConvertedNode/index.js'\n\nexport const LexicalPluginToLexicalFeatureClient = createClientFeature(() => {\n  return {\n    nodes: [UnknownConvertedNode],\n  }\n})\n","import type { EditorConfig, LexicalNode, NodeKey, SerializedLexicalNode, Spread } from 'lexical'\nimport type { JSX } from 'react'\n\nimport { addClassNamesToElement } from '@lexical/utils'\nimport { $applyNodeReplacement, DecoratorNode } from 'lexical'\nimport * as React from 'react'\n\nexport type UnknownConvertedNodeData = {\n  nodeData: unknown\n  nodeType: string\n}\n\nexport type SerializedUnknownConvertedNode = Spread<\n  {\n    data: UnknownConvertedNodeData\n  },\n  SerializedLexicalNode\n>\n\nconst Component = React.lazy(() =>\n  import('./Component.js').then((module) => ({\n    default: module.UnknownConvertedNodeComponent,\n  })),\n)\n\n/** @noInheritDoc */\nexport class UnknownConvertedNode extends DecoratorNode<JSX.Element> {\n  __data: UnknownConvertedNodeData\n\n  constructor({ data, key }: { data: UnknownConvertedNodeData; key?: NodeKey }) {\n    super(key)\n    this.__data = data\n  }\n\n  static override clone(node: UnknownConvertedNode): UnknownConvertedNode {\n    return new this({\n      data: node.__data,\n      key: node.__key,\n    })\n  }\n\n  static override getType(): string {\n    return 'unknownConverted'\n  }\n\n  static override importJSON(serializedNode: SerializedUnknownConvertedNode): UnknownConvertedNode {\n    const node = $createUnknownConvertedNode({ data: serializedNode.data })\n    return node\n  }\n\n  canInsertTextAfter(): true {\n    return true\n  }\n\n  canInsertTextBefore(): true {\n    return true\n  }\n\n  override createDOM(config: EditorConfig): HTMLElement {\n    const element = document.createElement('span')\n    addClassNamesToElement(element, 'unknownConverted')\n    return element\n  }\n\n  override decorate(): JSX.Element {\n    return <Component data={this.__data} />\n  }\n\n  override exportJSON(): SerializedUnknownConvertedNode {\n    return {\n      type: this.getType(),\n      data: this.__data,\n      version: 1,\n    }\n  }\n\n  // Mutation\n\n  override isInline(): boolean {\n    return true\n  }\n\n  override updateDOM(prevNode: this, dom: HTMLElement): boolean {\n    return false\n  }\n}\n\nexport function $createUnknownConvertedNode({\n  data,\n}: {\n  data: UnknownConvertedNodeData\n}): UnknownConvertedNode {\n  return $applyNodeReplacement(\n    new UnknownConvertedNode({\n      data,\n    }),\n  )\n}\n\nexport function $isUnknownConvertedNode(\n  node: LexicalNode | null | undefined,\n): node is UnknownConvertedNode {\n  return node instanceof UnknownConvertedNode\n}\n","'use client'\n\nimport { createClientFeature } from '../../../utilities/createClientFeature.js'\nimport { UnknownConvertedNode } from './nodes/unknownConvertedNode/index.js'\n\nexport const SlateToLexicalFeatureClient = createClientFeature(() => {\n  return {\n    nodes: [UnknownConvertedNode],\n  }\n})\n","'use client'\n\nimport { $setBlocksType } from '@lexical/selection'\nimport { $createParagraphNode, $getSelection, $isParagraphNode, $isRangeSelection } from 'lexical'\n\nimport type { ToolbarGroup } from '../../toolbars/types.js'\n\nimport { TextIcon } from '../../../lexical/ui/icons/Text/index.js'\nimport { createClientFeature } from '../../../utilities/createClientFeature.js'\nimport { slashMenuBasicGroupWithItems } from '../../shared/slashMenu/basicGroup.js'\nimport { toolbarTextDropdownGroupWithItems } from '../../shared/toolbar/textDropdownGroup.js'\n\nconst toolbarGroups: ToolbarGroup[] = [\n  toolbarTextDropdownGroupWithItems([\n    {\n      ChildComponent: TextIcon,\n      isActive: ({ selection }) => {\n        if (!$isRangeSelection(selection)) {\n          return false\n        }\n        for (const node of selection.getNodes()) {\n          if (!$isParagraphNode(node) && !$isParagraphNode(node.getParent())) {\n            return false\n          }\n        }\n        return true\n      },\n      key: 'paragraph',\n      label: ({ i18n }) => {\n        return i18n.t('lexical:paragraph:label2')\n      },\n      onSelect: ({ editor }) => {\n        editor.update(() => {\n          const selection = $getSelection()\n          $setBlocksType(selection, () => $createParagraphNode())\n        })\n      },\n      order: 1,\n    },\n  ]),\n]\n\nexport const ParagraphFeatureClient = createClientFeature({\n  slashMenu: {\n    groups: [\n      slashMenuBasicGroupWithItems([\n        {\n          Icon: TextIcon,\n          key: 'paragraph',\n          keywords: ['normal', 'paragraph', 'p', 'text'],\n          label: ({ i18n }) => {\n            return i18n.t('lexical:paragraph:label')\n          },\n          onSelect: ({ editor }) => {\n            editor.update(() => {\n              const selection = $getSelection()\n              $setBlocksType(selection, () => $createParagraphNode())\n            })\n          },\n        },\n      ]),\n    ],\n  },\n  toolbarFixed: {\n    groups: toolbarGroups,\n  },\n  toolbarInline: {\n    groups: toolbarGroups,\n  },\n})\n","'use client'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { useEffect, useState } from 'react'\n\n// eslint-disable-next-line payload/no-imports-from-exports-dir\nimport { defaultJSXConverters, RichText } from '../../../../../exports/react/index.js'\nimport './style.scss'\n\nexport function RichTextPlugin() {\n  const [editor] = useLexicalComposerContext()\n  const [editorState, setEditorState] = useState(editor.getEditorState().toJSON())\n\n  useEffect(() => {\n    return editor.registerUpdateListener(({ editorState }) => {\n      setEditorState(editorState.toJSON())\n    })\n  }, [editor])\n\n  return (\n    <div className=\"debug-jsx-converter\">\n      <RichText converters={defaultJSXConverters} data={editorState} />\n    </div>\n  )\n}\n","import type { SerializedEditorState } from 'lexical'\n\nimport React from 'react'\n\nimport type {\n  DefaultNodeTypes,\n  SerializedBlockNode,\n  SerializedInlineBlockNode,\n} from '../../../../nodeTypes.js'\nimport type { JSXConverters } from '../converter/types.js'\n\nimport { defaultJSXConverters } from '../converter/defaultConverters.js'\nimport { convertLexicalToJSX } from '../converter/index.js'\n\nexport type JSXConvertersFunction<\n  T extends { [key: string]: any; type?: string } =\n    | DefaultNodeTypes\n    | SerializedBlockNode<{ blockName?: null | string }>\n    | SerializedInlineBlockNode<{ blockName?: null | string }>,\n> = (args: { defaultConverters: JSXConverters<DefaultNodeTypes> }) => JSXConverters<T>\n\ntype RichTextProps = {\n  /**\n   * Override class names for the container.\n   */\n  className?: string\n  /**\n   * Custom converters to transform your nodes to JSX. Can be an object or a function that receives the default converters.\n   */\n  converters?: JSXConverters | JSXConvertersFunction\n  /**\n   * Serialized editor state to render.\n   */\n  data: SerializedEditorState\n  /**\n   * If true, removes the container div wrapper.\n   */\n  disableContainer?: boolean\n  /**\n   * If true, disables indentation globally. If an array, disables for specific node `type` values.\n   */\n  disableIndent?: boolean | string[]\n  /**\n   * If true, disables text alignment globally. If an array, disables for specific node `type` values.\n   */\n  disableTextAlign?: boolean | string[]\n}\n\nexport const RichText: React.FC<RichTextProps> = ({\n  className,\n  converters,\n  data: editorState,\n  disableContainer,\n  disableIndent,\n  disableTextAlign,\n}) => {\n  if (!editorState) {\n    return null\n  }\n\n  let finalConverters: JSXConverters = {}\n  if (converters) {\n    if (typeof converters === 'function') {\n      finalConverters = converters({ defaultConverters: defaultJSXConverters })\n    } else {\n      finalConverters = converters\n    }\n  } else {\n    finalConverters = defaultJSXConverters\n  }\n\n  const content =\n    editorState &&\n    !Array.isArray(editorState) &&\n    typeof editorState === 'object' &&\n    'root' in editorState &&\n    convertLexicalToJSX({\n      converters: finalConverters,\n      data: editorState,\n      disableIndent,\n      disableTextAlign,\n    })\n\n  if (disableContainer) {\n    return <>{content}</>\n  }\n\n  return <div className={className ?? 'payload-richtext'}>{content}</div>\n}\n","import type { SerializedQuoteNode } from '../../../../../nodeTypes.js'\nimport type { JSXConverters } from '../types.js'\n\nexport const BlockquoteJSXConverter: JSXConverters<SerializedQuoteNode> = {\n  quote: ({ node, nodesToJSX }) => {\n    const children = nodesToJSX({\n      nodes: node.children,\n    })\n\n    return <blockquote>{children}</blockquote>\n  },\n}\n","import type { SerializedHeadingNode } from '../../../../../nodeTypes.js'\nimport type { JSXConverters } from '../types.js'\n\nexport const HeadingJSXConverter: JSXConverters<SerializedHeadingNode> = {\n  heading: ({ node, nodesToJSX }) => {\n    const children = nodesToJSX({\n      nodes: node.children,\n    })\n\n    const NodeTag = node.tag\n\n    return <NodeTag>{children}</NodeTag>\n  },\n}\n","import type { SerializedHorizontalRuleNode } from '../../../../../nodeTypes.js'\nimport type { JSXConverters } from '../types.js'\nexport const HorizontalRuleJSXConverter: JSXConverters<SerializedHorizontalRuleNode> = {\n  horizontalrule: <hr />,\n}\n","import type { SerializedLineBreakNode } from '../../../../../nodeTypes.js'\nimport type { JSXConverters } from '../types.js'\n\nexport const LinebreakJSXConverter: JSXConverters<SerializedLineBreakNode> = {\n  linebreak: <br />,\n}\n","import type { SerializedAutoLinkNode, SerializedLinkNode } from '../../../../../nodeTypes.js'\nimport type { JSXConverters } from '../types.js'\n\nexport const LinkJSXConverter: (args: {\n  internalDocToHref?: (args: { linkNode: SerializedLinkNode }) => string\n}) => JSXConverters<SerializedAutoLinkNode | SerializedLinkNode> = ({ internalDocToHref }) => ({\n  autolink: ({ node, nodesToJSX }) => {\n    const children = nodesToJSX({\n      nodes: node.children,\n    })\n\n    const rel: string | undefined = node.fields.newTab ? 'noopener noreferrer' : undefined\n    const target: string | undefined = node.fields.newTab ? '_blank' : undefined\n\n    return (\n      <a href={node.fields.url} {...{ rel, target }}>\n        {children}\n      </a>\n    )\n  },\n  link: ({ node, nodesToJSX }) => {\n    const children = nodesToJSX({\n      nodes: node.children,\n    })\n\n    const rel: string | undefined = node.fields.newTab ? 'noopener noreferrer' : undefined\n    const target: string | undefined = node.fields.newTab ? '_blank' : undefined\n\n    let href: string = node.fields.url ?? ''\n    if (node.fields.linkType === 'internal') {\n      if (internalDocToHref) {\n        href = internalDocToHref({ linkNode: node })\n      } else {\n        console.error(\n          'Lexical => JSX converter: Link converter: found internal link, but internalDocToHref is not provided',\n        )\n        href = '#' // fallback\n      }\n    }\n\n    return (\n      <a href={href} {...{ rel, target }}>\n        {children}\n      </a>\n    )\n  },\n})\n","import { v4 as uuidv4 } from 'uuid'\n\nimport type { SerializedListItemNode, SerializedListNode } from '../../../../../nodeTypes.js'\nimport type { JSXConverters } from '../types.js'\n\nexport const ListJSXConverter: JSXConverters<SerializedListItemNode | SerializedListNode> = {\n  list: ({ node, nodesToJSX }) => {\n    const children = nodesToJSX({\n      nodes: node.children,\n    })\n\n    const NodeTag = node.tag\n\n    return <NodeTag className={`list-${node?.listType}`}>{children}</NodeTag>\n  },\n  listitem: ({ node, nodesToJSX, parent }) => {\n    const hasSubLists = node.children.some((child) => child.type === 'list')\n\n    const children = nodesToJSX({\n      nodes: node.children,\n    })\n\n    if ('listType' in parent && parent?.listType === 'check') {\n      const uuid = uuidv4()\n\n      return (\n        <li\n          aria-checked={node.checked ? 'true' : 'false'}\n          className={`list-item-checkbox${node.checked ? ' list-item-checkbox-checked' : ' list-item-checkbox-unchecked'}${hasSubLists ? ' nestedListItem' : ''}`}\n          // eslint-disable-next-line jsx-a11y/no-noninteractive-element-to-interactive-role\n          role=\"checkbox\"\n          style={{ listStyleType: 'none' }}\n          tabIndex={-1}\n          value={node?.value}\n        >\n          {hasSubLists ? (\n            children\n          ) : (\n            <>\n              <input checked={node.checked} id={uuid} readOnly={true} type=\"checkbox\" />\n              <label htmlFor={uuid}>{children}</label>\n              <br />\n            </>\n          )}\n        </li>\n      )\n    } else {\n      return (\n        <li\n          className={`${hasSubLists ? 'nestedListItem' : ''}`}\n          style={hasSubLists ? { listStyleType: 'none' } : undefined}\n          value={node?.value}\n        >\n          {children}\n        </li>\n      )\n    }\n  },\n}\n","import type { SerializedParagraphNode } from '../../../../../nodeTypes.js'\nimport type { JSXConverters } from '../types.js'\n\nexport const ParagraphJSXConverter: JSXConverters<SerializedParagraphNode> = {\n  paragraph: ({ node, nodesToJSX }) => {\n    const children = nodesToJSX({\n      nodes: node.children,\n    })\n\n    if (!children?.length) {\n      return (\n        <p>\n          <br />\n        </p>\n      )\n    }\n\n    return <p>{children}</p>\n  },\n}\n","import type { SerializedTabNode } from '../../../../../nodeTypes.js'\nimport type { JSXConverters } from '../types.js'\n\nexport const TabJSXConverter: JSXConverters<SerializedTabNode> = {\n  tab: '\\t',\n}\n","import type {\n  SerializedTableCellNode,\n  SerializedTableNode,\n  SerializedTableRowNode,\n} from '../../../../../nodeTypes.js'\nimport type { JSXConverters } from '../types.js'\n\nexport const TableJSXConverter: JSXConverters<\n  SerializedTableCellNode | SerializedTableNode | SerializedTableRowNode\n> = {\n  table: ({ node, nodesToJSX }) => {\n    const children = nodesToJSX({\n      nodes: node.children,\n    })\n    return (\n      <div className=\"lexical-table-container\">\n        <table className=\"lexical-table\" style={{ borderCollapse: 'collapse' }}>\n          <tbody>{children}</tbody>\n        </table>\n      </div>\n    )\n  },\n  tablecell: ({ node, nodesToJSX }) => {\n    const children = nodesToJSX({\n      nodes: node.children,\n    })\n\n    const TagName = node.headerState > 0 ? 'th' : 'td' // Use capital letter to denote a component\n    const headerStateClass = `lexical-table-cell-header-${node.headerState}`\n    const style = {\n      backgroundColor: node.backgroundColor || undefined, // Use undefined to avoid setting the style property if not needed\n      border: '1px solid #ccc',\n      padding: '8px',\n    }\n\n    // Note: JSX does not support setting attributes directly as strings, so you must convert the colSpan and rowSpan to numbers\n    const colSpan = node.colSpan && node.colSpan > 1 ? node.colSpan : undefined\n    const rowSpan = node.rowSpan && node.rowSpan > 1 ? node.rowSpan : undefined\n\n    return (\n      <TagName\n        className={`lexical-table-cell ${headerStateClass}`}\n        colSpan={colSpan} // colSpan and rowSpan will only be added if they are not null\n        rowSpan={rowSpan}\n        style={style}\n      >\n        {children}\n      </TagName>\n    )\n  },\n  tablerow: ({ node, nodesToJSX }) => {\n    const children = nodesToJSX({\n      nodes: node.children,\n    })\n    return <tr className=\"lexical-table-row\">{children}</tr>\n  },\n}\n","import React from 'react'\n\nimport type { SerializedTextNode } from '../../../../../nodeTypes.js'\nimport type { JSXConverters } from '../types.js'\n\nimport { NodeFormat } from '../../../../../lexical/utils/nodeFormat.js'\n\nexport const TextJSXConverter: JSXConverters<SerializedTextNode> = {\n  text: ({ node }) => {\n    let text: React.ReactNode = node.text\n\n    if (node.format & NodeFormat.IS_BOLD) {\n      text = <strong>{text}</strong>\n    }\n    if (node.format & NodeFormat.IS_ITALIC) {\n      text = <em>{text}</em>\n    }\n    if (node.format & NodeFormat.IS_STRIKETHROUGH) {\n      text = <span style={{ textDecoration: 'line-through' }}>{text}</span>\n    }\n    if (node.format & NodeFormat.IS_UNDERLINE) {\n      text = <span style={{ textDecoration: 'underline' }}>{text}</span>\n    }\n    if (node.format & NodeFormat.IS_CODE) {\n      text = <code>{text}</code>\n    }\n    if (node.format & NodeFormat.IS_SUBSCRIPT) {\n      text = <sub>{text}</sub>\n    }\n    if (node.format & NodeFormat.IS_SUPERSCRIPT) {\n      text = <sup>{text}</sup>\n    }\n\n    return text\n  },\n}\n","/* eslint-disable perfectionist/sort-objects */\n/* eslint-disable regexp/no-obscure-range */\n/* eslint-disable @typescript-eslint/no-redundant-type-constituents */\n/* eslint-disable regexp/no-misleading-unicode-character */\n//This copy-and-pasted from lexical here: https://github.com/facebook/lexical/blob/c2ceee223f46543d12c574e62155e619f9a18a5d/packages/lexical/src/LexicalConstants.ts\n\nimport type { ElementFormatType, TextFormatType, TextModeType } from 'lexical'\nexport type TextDetailType = 'directionless' | 'unmergable'\n\n// DOM\nexport const NodeFormat = {\n  DOM_ELEMENT_TYPE: 1,\n  DOM_TEXT_TYPE: 3,\n  // Reconciling\n  NO_DIRTY_NODES: 0,\n  HAS_DIRTY_NODES: 1,\n  FULL_RECONCILE: 2,\n  // Text node modes\n  IS_NORMAL: 0,\n  IS_TOKEN: 1,\n  IS_SEGMENTED: 2,\n  IS_INERT: 3,\n  // Text node formatting\n  IS_BOLD: 1,\n  IS_ITALIC: 1 << 1,\n  IS_STRIKETHROUGH: 1 << 2,\n  IS_UNDERLINE: 1 << 3,\n  IS_CODE: 1 << 4,\n  IS_SUBSCRIPT: 1 << 5,\n  IS_SUPERSCRIPT: 1 << 6,\n  IS_HIGHLIGHT: 1 << 7,\n  // Text node details\n  IS_DIRECTIONLESS: 1,\n  IS_UNMERGEABLE: 1 << 1,\n  // Element node formatting\n  IS_ALIGN_LEFT: 1,\n  IS_ALIGN_CENTER: 2,\n  IS_ALIGN_RIGHT: 3,\n  IS_ALIGN_JUSTIFY: 4,\n  IS_ALIGN_START: 5,\n  IS_ALIGN_END: 6,\n} as const\n\nexport const IS_ALL_FORMATTING =\n  NodeFormat.IS_BOLD |\n  NodeFormat.IS_ITALIC |\n  NodeFormat.IS_STRIKETHROUGH |\n  NodeFormat.IS_UNDERLINE |\n  NodeFormat.IS_CODE |\n  NodeFormat.IS_SUBSCRIPT |\n  NodeFormat.IS_SUPERSCRIPT |\n  NodeFormat.IS_HIGHLIGHT\n\n// Reconciliation\nexport const NON_BREAKING_SPACE = '\\u00A0'\n\nexport const DOUBLE_LINE_BREAK = '\\n\\n'\n\n// For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\n\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC'\nconst LTR =\n  'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' +\n  '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' +\n  '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF'\n\n// eslint-disable-next-line no-misleading-character-class\nexport const RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']')\n// eslint-disable-next-line no-misleading-character-class\nexport const LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']')\n\nexport const TEXT_TYPE_TO_FORMAT: Record<string | TextFormatType, number> = {\n  bold: NodeFormat.IS_BOLD,\n  code: NodeFormat.IS_CODE,\n  highlight: NodeFormat.IS_HIGHLIGHT,\n  italic: NodeFormat.IS_ITALIC,\n  strikethrough: NodeFormat.IS_STRIKETHROUGH,\n  subscript: NodeFormat.IS_SUBSCRIPT,\n  superscript: NodeFormat.IS_SUPERSCRIPT,\n  underline: NodeFormat.IS_UNDERLINE,\n}\n\nexport const DETAIL_TYPE_TO_DETAIL: Record<string | TextDetailType, number> = {\n  directionless: NodeFormat.IS_DIRECTIONLESS,\n  unmergeable: NodeFormat.IS_UNMERGEABLE,\n}\n\nexport const ELEMENT_TYPE_TO_FORMAT: Record<Exclude<ElementFormatType, ''>, number> = {\n  center: NodeFormat.IS_ALIGN_CENTER,\n  end: NodeFormat.IS_ALIGN_END,\n  justify: NodeFormat.IS_ALIGN_JUSTIFY,\n  left: NodeFormat.IS_ALIGN_LEFT,\n  right: NodeFormat.IS_ALIGN_RIGHT,\n  start: NodeFormat.IS_ALIGN_START,\n}\n\nexport const ELEMENT_FORMAT_TO_TYPE: Record<number, ElementFormatType> = {\n  [NodeFormat.IS_ALIGN_CENTER]: 'center',\n  [NodeFormat.IS_ALIGN_END]: 'end',\n  [NodeFormat.IS_ALIGN_JUSTIFY]: 'justify',\n  [NodeFormat.IS_ALIGN_LEFT]: 'left',\n  [NodeFormat.IS_ALIGN_RIGHT]: 'right',\n  [NodeFormat.IS_ALIGN_START]: 'start',\n}\n\nexport const TEXT_MODE_TO_TYPE: Record<TextModeType, 0 | 1 | 2> = {\n  normal: NodeFormat.IS_NORMAL,\n  segmented: NodeFormat.IS_SEGMENTED,\n  token: NodeFormat.IS_TOKEN,\n}\n\nexport const TEXT_TYPE_TO_MODE: Record<number, TextModeType> = {\n  [NodeFormat.IS_NORMAL]: 'normal',\n  [NodeFormat.IS_SEGMENTED]: 'segmented',\n  [NodeFormat.IS_TOKEN]: 'token',\n}\n","import type { FileData, FileSizeImproved, TypeWithID } from 'payload'\n\nimport type { SerializedUploadNode } from '../../../../../nodeTypes.js'\nimport type { UploadDataImproved } from '../../../../upload/server/nodes/UploadNode.js'\nimport type { JSXConverters } from '../types.js'\n\nexport const UploadJSXConverter: JSXConverters<SerializedUploadNode> = {\n  upload: ({ node }) => {\n    // TO-DO (v4): SerializedUploadNode should use UploadData_P4\n    const uploadNode = node as UploadDataImproved\n    if (typeof uploadNode.value !== 'object') {\n      return null\n    }\n\n    const uploadDoc = uploadNode.value as FileData & TypeWithID\n\n    const url = uploadDoc.url\n\n    /**\n     * If the upload is not an image, return a link to the upload\n     */\n    if (!uploadDoc.mimeType.startsWith('image')) {\n      return (\n        <a href={url} rel=\"noopener noreferrer\">\n          {uploadDoc.filename}\n        </a>\n      )\n    }\n\n    /**\n     * If the upload is a simple image with no different sizes, return a simple img tag\n     */\n    if (!uploadDoc.sizes || !Object.keys(uploadDoc.sizes).length) {\n      return (\n        <img alt={uploadDoc.filename} height={uploadDoc.height} src={url} width={uploadDoc.width} />\n      )\n    }\n\n    /**\n     * If the upload is an image with different sizes, return a picture element\n     */\n    const pictureJSX: React.ReactNode[] = []\n\n    // Iterate through each size in the data.sizes object\n    for (const size in uploadDoc.sizes) {\n      const imageSize = uploadDoc.sizes[size] as FileSizeImproved\n\n      // Skip if any property of the size object is null\n      if (\n        !imageSize ||\n        !imageSize.width ||\n        !imageSize.height ||\n        !imageSize.mimeType ||\n        !imageSize.filesize ||\n        !imageSize.filename ||\n        !imageSize.url\n      ) {\n        continue\n      }\n      const imageSizeURL = imageSize?.url\n\n      pictureJSX.push(\n        <source\n          key={size}\n          media={`(max-width: ${imageSize.width}px)`}\n          srcSet={imageSizeURL}\n          type={imageSize.mimeType}\n        />,\n      )\n    }\n\n    // Add the default img tag\n    pictureJSX.push(\n      <img\n        alt={uploadDoc?.filename}\n        height={uploadDoc?.height}\n        key={'image'}\n        src={url}\n        width={uploadDoc?.width}\n      />,\n    )\n    return <picture>{pictureJSX}</picture>\n  },\n}\n","import type { DefaultNodeTypes } from '../../../../nodeTypes.js'\nimport type { JSXConverters } from './types.js'\n\nimport { BlockquoteJSXConverter } from './converters/blockquote.js'\nimport { HeadingJSXConverter } from './converters/heading.js'\nimport { HorizontalRuleJSXConverter } from './converters/horizontalRule.js'\nimport { LinebreakJSXConverter } from './converters/linebreak.js'\nimport { LinkJSXConverter } from './converters/link.js'\nimport { ListJSXConverter } from './converters/list.js'\nimport { ParagraphJSXConverter } from './converters/paragraph.js'\nimport { TabJSXConverter } from './converters/tab.js'\nimport { TableJSXConverter } from './converters/table.js'\nimport { TextJSXConverter } from './converters/text.js'\nimport { UploadJSXConverter } from './converters/upload.js'\n\nexport const defaultJSXConverters: JSXConverters<DefaultNodeTypes> = {\n  ...ParagraphJSXConverter,\n  ...TextJSXConverter,\n  ...LinebreakJSXConverter,\n  ...BlockquoteJSXConverter,\n  ...TableJSXConverter,\n  ...HeadingJSXConverter,\n  ...HorizontalRuleJSXConverter,\n  ...ListJSXConverter,\n  ...LinkJSXConverter({}),\n  ...UploadJSXConverter,\n  ...TabJSXConverter,\n}\n","/* eslint-disable no-console */\nimport type { SerializedEditorState, SerializedLexicalNode } from 'lexical'\n\nimport React from 'react'\n\nimport type { SerializedBlockNode, SerializedInlineBlockNode } from '../../../../nodeTypes.js'\nimport type { JSXConverter, JSXConverters, SerializedLexicalNodeWithParent } from './types.js'\n\nimport { hasText } from '../../../../validate/hasText.js'\n\nexport type ConvertLexicalToJSXArgs = {\n  converters: JSXConverters\n  data: SerializedEditorState\n  disableIndent?: boolean | string[]\n  disableTextAlign?: boolean | string[]\n}\n\nexport function convertLexicalToJSX({\n  converters,\n  data,\n  disableIndent,\n  disableTextAlign,\n}: ConvertLexicalToJSXArgs): React.ReactNode {\n  if (hasText(data)) {\n    return convertLexicalNodesToJSX({\n      converters,\n      disableIndent,\n      disableTextAlign,\n      nodes: data?.root?.children,\n      parent: data?.root,\n    })\n  }\n  return <></>\n}\n\nexport function convertLexicalNodesToJSX({\n  converters,\n  disableIndent,\n  disableTextAlign,\n  nodes,\n  parent,\n}: {\n  converters: JSXConverters\n  disableIndent?: boolean | string[]\n  disableTextAlign?: boolean | string[]\n  nodes: SerializedLexicalNode[]\n  parent: SerializedLexicalNodeWithParent\n}): React.ReactNode[] {\n  const unknownConverter: JSXConverter<any> = converters.unknown as JSXConverter<any>\n\n  const jsxArray: React.ReactNode[] = nodes.map((node, i) => {\n    let converterForNode: JSXConverter<any> | undefined\n    if (node.type === 'block') {\n      converterForNode = converters?.blocks?.[(node as SerializedBlockNode)?.fields?.blockType]\n      if (!converterForNode && !unknownConverter) {\n        console.error(\n          `Lexical => JSX converter: Blocks converter: found ${(node as SerializedBlockNode)?.fields?.blockType} block, but no converter is provided`,\n        )\n      }\n    } else if (node.type === 'inlineBlock') {\n      converterForNode =\n        converters?.inlineBlocks?.[(node as SerializedInlineBlockNode)?.fields?.blockType]\n      if (!converterForNode && !unknownConverter) {\n        console.error(\n          `Lexical => JSX converter: Inline Blocks converter: found ${(node as SerializedInlineBlockNode)?.fields?.blockType} inline block, but no converter is provided`,\n        )\n      }\n    } else {\n      converterForNode = converters[node.type] as JSXConverter<any>\n    }\n\n    try {\n      if (!converterForNode && unknownConverter) {\n        converterForNode = unknownConverter\n      }\n\n      let reactNode: React.ReactNode\n      if (converterForNode) {\n        const converted =\n          typeof converterForNode === 'function'\n            ? converterForNode({\n                childIndex: i,\n                converters,\n                node,\n                nodesToJSX: (args) => {\n                  return convertLexicalNodesToJSX({\n                    converters: args.converters ?? converters,\n                    disableIndent: args.disableIndent ?? disableIndent,\n                    disableTextAlign: args.disableTextAlign ?? disableTextAlign,\n                    nodes: args.nodes,\n                    parent: args.parent ?? {\n                      ...node,\n                      parent,\n                    },\n                  })\n                },\n                parent,\n              })\n            : converterForNode\n        reactNode = converted\n      } else {\n        reactNode = <span key={i}>unknown node</span>\n      }\n\n      const style: React.CSSProperties = {}\n\n      // Check if disableTextAlign is not true and does not include node type\n      if (\n        !disableTextAlign &&\n        (!Array.isArray(disableTextAlign) || !disableTextAlign?.includes(node.type))\n      ) {\n        if ('format' in node && node.format) {\n          switch (node.format) {\n            case 'center':\n              style.textAlign = 'center'\n              break\n            case 'end':\n              style.textAlign = 'right'\n              break\n            case 'justify':\n              style.textAlign = 'justify'\n              break\n            case 'left':\n              //style.textAlign = 'left'\n              // Do nothing, as left is the default\n              break\n            case 'right':\n              style.textAlign = 'right'\n              break\n            case 'start':\n              style.textAlign = 'left'\n              break\n          }\n        }\n      }\n\n      if (\n        !disableIndent &&\n        (!Array.isArray(disableIndent) || !disableIndent?.includes(node.type))\n      ) {\n        if ('indent' in node && node.indent && node.type !== 'listitem') {\n          // the unit should be px. Do not change it to rem, em, or something else.\n          // The quantity should be 40px. Do not change it either.\n          // See rationale in\n          // https://github.com/payloadcms/payload/issues/13130#issuecomment-3058348085\n          style.paddingInlineStart = `${Number(node.indent) * 40}px`\n        }\n      }\n\n      if (React.isValidElement(reactNode)) {\n        // Inject style into reactNode\n        if (style.textAlign || style.paddingInlineStart) {\n          const newStyle = {\n            ...style,\n            // @ts-expect-error type better later\n            ...(reactNode?.props?.style ?? {}),\n            // reactNode style comes after, thus a textAlign specified in the converter has priority over the one we inject here\n          }\n\n          return React.cloneElement(reactNode, {\n            key: i,\n            // @ts-expect-error type better later\n            style: newStyle,\n          })\n        }\n        return React.cloneElement(reactNode, {\n          key: i,\n        })\n      }\n\n      return reactNode\n    } catch (error) {\n      console.error('Error converting lexical node to JSX:', error, 'node:', node)\n      return null\n    }\n  })\n\n  return jsxArray.filter(Boolean)\n}\n","import type {\n  SerializedEditorState,\n  SerializedLexicalNode,\n  SerializedParagraphNode,\n  SerializedTextNode,\n} from 'lexical'\n\nexport function hasText(\n  value: null | SerializedEditorState<SerializedLexicalNode> | undefined,\n): boolean {\n  const hasChildren = !!value?.root?.children?.length\n\n  let hasOnlyEmptyParagraph = false\n  if (value?.root?.children?.length === 1) {\n    if (value?.root?.children[0]?.type === 'paragraph') {\n      const paragraphNode = value?.root?.children[0] as SerializedParagraphNode\n\n      if (!paragraphNode?.children || paragraphNode?.children?.length === 0) {\n        hasOnlyEmptyParagraph = true\n      } else if (paragraphNode?.children?.length === 1) {\n        const paragraphNodeChild = paragraphNode?.children[0]\n        if (paragraphNodeChild?.type === 'text') {\n          if (!(paragraphNodeChild as SerializedTextNode | undefined)?.['text']?.length) {\n            hasOnlyEmptyParagraph = true\n          }\n        }\n      }\n    }\n  }\n\n  if (!hasChildren || hasOnlyEmptyParagraph) {\n    return false\n  } else {\n    return true\n  }\n}\n","'use client'\n\nimport { createClientFeature } from '../../../../utilities/createClientFeature.js'\nimport { RichTextPlugin } from './plugin/index.js'\n\nexport const DebugJsxConverterFeatureClient = createClientFeature({\n  plugins: [\n    {\n      Component: RichTextPlugin,\n      position: 'bottom',\n    },\n  ],\n})\n","import type { StateValues } from './feature.server.js'\n\nconst tailwindColors = {\n  amber: {\n    '50': 'oklch(0.987 0.022 95.277)',\n    '100': 'oklch(0.962 0.059 95.617)',\n    '200': 'oklch(0.924 0.12 95.746)',\n    '300': 'oklch(0.879 0.169 91.605)',\n    '400': 'oklch(0.828 0.189 84.429)',\n    '500': 'oklch(0.769 0.188 70.08)',\n    '600': 'oklch(0.666 0.179 58.318)',\n    '700': 'oklch(0.555 0.163 48.998)',\n    '800': 'oklch(0.473 0.137 46.201)',\n    '900': 'oklch(0.414 0.112 45.904)',\n    '950': 'oklch(0.279 0.077 45.635)',\n  },\n  black: '#000',\n  blue: {\n    '50': 'oklch(0.97 0.014 254.604)',\n    '100': 'oklch(0.932 0.032 255.585)',\n    '200': 'oklch(0.882 0.059 254.128)',\n    '300': 'oklch(0.809 0.105 251.813)',\n    '400': 'oklch(0.707 0.165 254.624)',\n    '500': 'oklch(0.623 0.214 259.815)',\n    '600': 'oklch(0.546 0.245 262.881)',\n    '700': 'oklch(0.488 0.243 264.376)',\n    '800': 'oklch(0.424 0.199 265.638)',\n    '900': 'oklch(0.379 0.146 265.522)',\n    '950': 'oklch(0.282 0.091 267.935)',\n  },\n  current: 'currentColor',\n  cyan: {\n    '50': 'oklch(0.984 0.019 200.873)',\n    '100': 'oklch(0.956 0.045 203.388)',\n    '200': 'oklch(0.917 0.08 205.041)',\n    '300': 'oklch(0.865 0.127 207.078)',\n    '400': 'oklch(0.789 0.154 211.53)',\n    '500': 'oklch(0.715 0.143 215.221)',\n    '600': 'oklch(0.609 0.126 221.723)',\n    '700': 'oklch(0.52 0.105 223.128)',\n    '800': 'oklch(0.45 0.085 224.283)',\n    '900': 'oklch(0.398 0.07 227.392)',\n    '950': 'oklch(0.302 0.056 229.695)',\n  },\n  emerald: {\n    '50': 'oklch(0.979 0.021 166.113)',\n    '100': 'oklch(0.95 0.052 163.051)',\n    '200': 'oklch(0.905 0.093 164.15)',\n    '300': 'oklch(0.845 0.143 164.978)',\n    '400': 'oklch(0.765 0.177 163.223)',\n    '500': 'oklch(0.696 0.17 162.48)',\n    '600': 'oklch(0.596 0.145 163.225)',\n    '700': 'oklch(0.508 0.118 165.612)',\n    '800': 'oklch(0.432 0.095 166.913)',\n    '900': 'oklch(0.378 0.077 168.94)',\n    '950': 'oklch(0.262 0.051 172.552)',\n  },\n  fuchsia: {\n    '50': 'oklch(0.977 0.017 320.058)',\n    '100': 'oklch(0.952 0.037 318.852)',\n    '200': 'oklch(0.903 0.076 319.62)',\n    '300': 'oklch(0.833 0.145 321.434)',\n    '400': 'oklch(0.74 0.238 322.16)',\n    '500': 'oklch(0.667 0.295 322.15)',\n    '600': 'oklch(0.591 0.293 322.896)',\n    '700': 'oklch(0.518 0.253 323.949)',\n    '800': 'oklch(0.452 0.211 324.591)',\n    '900': 'oklch(0.401 0.17 325.612)',\n    '950': 'oklch(0.293 0.136 325.661)',\n  },\n  gray: {\n    '50': 'oklch(0.985 0.002 247.839)',\n    '100': 'oklch(0.967 0.003 264.542)',\n    '200': 'oklch(0.928 0.006 264.531)',\n    '300': 'oklch(0.872 0.01 258.338)',\n    '400': 'oklch(0.707 0.022 261.325)',\n    '500': 'oklch(0.551 0.027 264.364)',\n    '600': 'oklch(0.446 0.03 256.802)',\n    '700': 'oklch(0.373 0.034 259.733)',\n    '800': 'oklch(0.278 0.033 256.848)',\n    '900': 'oklch(0.21 0.034 264.665)',\n    '950': 'oklch(0.13 0.028 261.692)',\n  },\n  green: {\n    '50': 'oklch(0.982 0.018 155.826)',\n    '100': 'oklch(0.962 0.044 156.743)',\n    '200': 'oklch(0.925 0.084 155.995)',\n    '300': 'oklch(0.871 0.15 154.449)',\n    '400': 'oklch(0.792 0.209 151.711)',\n    '500': 'oklch(0.723 0.219 149.579)',\n    '600': 'oklch(0.627 0.194 149.214)',\n    '700': 'oklch(0.527 0.154 150.069)',\n    '800': 'oklch(0.448 0.119 151.328)',\n    '900': 'oklch(0.393 0.095 152.535)',\n    '950': 'oklch(0.266 0.065 152.934)',\n  },\n  indigo: {\n    '50': 'oklch(0.962 0.018 272.314)',\n    '100': 'oklch(0.93 0.034 272.788)',\n    '200': 'oklch(0.87 0.065 274.039)',\n    '300': 'oklch(0.785 0.115 274.713)',\n    '400': 'oklch(0.673 0.182 276.935)',\n    '500': 'oklch(0.585 0.233 277.117)',\n    '600': 'oklch(0.511 0.262 276.966)',\n    '700': 'oklch(0.457 0.24 277.023)',\n    '800': 'oklch(0.398 0.195 277.366)',\n    '900': 'oklch(0.359 0.144 278.697)',\n    '950': 'oklch(0.257 0.09 281.288)',\n  },\n  inherit: 'inherit',\n  lime: {\n    '50': 'oklch(0.986 0.031 120.757)',\n    '100': 'oklch(0.967 0.067 122.328)',\n    '200': 'oklch(0.938 0.127 124.321)',\n    '300': 'oklch(0.897 0.196 126.665)',\n    '400': 'oklch(0.841 0.238 128.85)',\n    '500': 'oklch(0.768 0.233 130.85)',\n    '600': 'oklch(0.648 0.2 131.684)',\n    '700': 'oklch(0.532 0.157 131.589)',\n    '800': 'oklch(0.453 0.124 130.933)',\n    '900': 'oklch(0.405 0.101 131.063)',\n    '950': 'oklch(0.274 0.072 132.109)',\n  },\n  neutral: {\n    '50': 'oklch(0.985 0 0)',\n    '100': 'oklch(0.97 0 0)',\n    '200': 'oklch(0.922 0 0)',\n    '300': 'oklch(0.87 0 0)',\n    '400': 'oklch(0.708 0 0)',\n    '500': 'oklch(0.556 0 0)',\n    '600': 'oklch(0.439 0 0)',\n    '700': 'oklch(0.371 0 0)',\n    '800': 'oklch(0.269 0 0)',\n    '900': 'oklch(0.205 0 0)',\n    '950': 'oklch(0.145 0 0)',\n  },\n  orange: {\n    '50': 'oklch(0.98 0.016 73.684)',\n    '100': 'oklch(0.954 0.038 75.164)',\n    '200': 'oklch(0.901 0.076 70.697)',\n    '300': 'oklch(0.837 0.128 66.29)',\n    '400': 'oklch(0.75 0.183 55.934)',\n    '500': 'oklch(0.705 0.213 47.604)',\n    '600': 'oklch(0.646 0.222 41.116)',\n    '700': 'oklch(0.553 0.195 38.402)',\n    '800': 'oklch(0.47 0.157 37.304)',\n    '900': 'oklch(0.408 0.123 38.172)',\n    '950': 'oklch(0.266 0.079 36.259)',\n  },\n  pink: {\n    '50': 'oklch(0.971 0.014 343.198)',\n    '100': 'oklch(0.948 0.028 342.258)',\n    '200': 'oklch(0.899 0.061 343.231)',\n    '300': 'oklch(0.823 0.12 346.018)',\n    '400': 'oklch(0.718 0.202 349.761)',\n    '500': 'oklch(0.656 0.241 354.308)',\n    '600': 'oklch(0.592 0.249 0.584)',\n    '700': 'oklch(0.525 0.223 3.958)',\n    '800': 'oklch(0.459 0.187 3.815)',\n    '900': 'oklch(0.408 0.153 2.432)',\n    '950': 'oklch(0.284 0.109 3.907)',\n  },\n  purple: {\n    '50': 'oklch(0.977 0.014 308.299)',\n    '100': 'oklch(0.946 0.033 307.174)',\n    '200': 'oklch(0.902 0.063 306.703)',\n    '300': 'oklch(0.827 0.119 306.383)',\n    '400': 'oklch(0.714 0.203 305.504)',\n    '500': 'oklch(0.627 0.265 303.9)',\n    '600': 'oklch(0.558 0.288 302.321)',\n    '700': 'oklch(0.496 0.265 301.924)',\n    '800': 'oklch(0.438 0.218 303.724)',\n    '900': 'oklch(0.381 0.176 304.987)',\n    '950': 'oklch(0.291 0.149 302.717)',\n  },\n  red: {\n    '50': 'oklch(0.971 0.013 17.38)',\n    '100': 'oklch(0.936 0.032 17.717)',\n    '200': 'oklch(0.885 0.062 18.334)',\n    '300': 'oklch(0.808 0.114 19.571)',\n    '400': 'oklch(0.704 0.191 22.216)',\n    '500': 'oklch(0.637 0.237 25.331)',\n    '600': 'oklch(0.577 0.245 27.325)',\n    '700': 'oklch(0.505 0.213 27.518)',\n    '800': 'oklch(0.444 0.177 26.899)',\n    '900': 'oklch(0.396 0.141 25.723)',\n    '950': 'oklch(0.258 0.092 26.042)',\n  },\n  rose: {\n    '50': 'oklch(0.969 0.015 12.422)',\n    '100': 'oklch(0.941 0.03 12.58)',\n    '200': 'oklch(0.892 0.058 10.001)',\n    '300': 'oklch(0.81 0.117 11.638)',\n    '400': 'oklch(0.712 0.194 13.428)',\n    '500': 'oklch(0.645 0.246 16.439)',\n    '600': 'oklch(0.586 0.253 17.585)',\n    '700': 'oklch(0.514 0.222 16.935)',\n    '800': 'oklch(0.455 0.188 13.697)',\n    '900': 'oklch(0.41 0.159 10.272)',\n    '950': 'oklch(0.271 0.105 12.094)',\n  },\n  sky: {\n    '50': 'oklch(0.977 0.013 236.62)',\n    '100': 'oklch(0.951 0.026 236.824)',\n    '200': 'oklch(0.901 0.058 230.902)',\n    '300': 'oklch(0.828 0.111 230.318)',\n    '400': 'oklch(0.746 0.16 232.661)',\n    '500': 'oklch(0.685 0.169 237.323)',\n    '600': 'oklch(0.588 0.158 241.966)',\n    '700': 'oklch(0.5 0.134 242.749)',\n    '800': 'oklch(0.443 0.11 240.79)',\n    '900': 'oklch(0.391 0.09 240.876)',\n    '950': 'oklch(0.293 0.066 243.157)',\n  },\n  slate: {\n    '50': 'oklch(0.984 0.003 247.858)',\n    '100': 'oklch(0.968 0.007 247.896)',\n    '200': 'oklch(0.929 0.013 255.508)',\n    '300': 'oklch(0.869 0.022 252.894)',\n    '400': 'oklch(0.704 0.04 256.788)',\n    '500': 'oklch(0.554 0.046 257.417)',\n    '600': 'oklch(0.446 0.043 257.281)',\n    '700': 'oklch(0.372 0.044 257.287)',\n    '800': 'oklch(0.279 0.041 260.031)',\n    '900': 'oklch(0.208 0.042 265.755)',\n    '950': 'oklch(0.129 0.042 264.695)',\n  },\n  stone: {\n    '50': 'oklch(0.985 0.001 106.423)',\n    '100': 'oklch(0.97 0.001 106.424)',\n    '200': 'oklch(0.923 0.003 48.717)',\n    '300': 'oklch(0.869 0.005 56.366)',\n    '400': 'oklch(0.709 0.01 56.259)',\n    '500': 'oklch(0.553 0.013 58.071)',\n    '600': 'oklch(0.444 0.011 73.639)',\n    '700': 'oklch(0.374 0.01 67.558)',\n    '800': 'oklch(0.268 0.007 34.298)',\n    '900': 'oklch(0.216 0.006 56.043)',\n    '950': 'oklch(0.147 0.004 49.25)',\n  },\n  teal: {\n    '50': 'oklch(0.984 0.014 180.72)',\n    '100': 'oklch(0.953 0.051 180.801)',\n    '200': 'oklch(0.91 0.096 180.426)',\n    '300': 'oklch(0.855 0.138 181.071)',\n    '400': 'oklch(0.777 0.152 181.912)',\n    '500': 'oklch(0.704 0.14 182.503)',\n    '600': 'oklch(0.6 0.118 184.704)',\n    '700': 'oklch(0.511 0.096 186.391)',\n    '800': 'oklch(0.437 0.078 188.216)',\n    '900': 'oklch(0.386 0.063 188.416)',\n    '950': 'oklch(0.277 0.046 192.524)',\n  },\n  transparent: 'transparent',\n  violet: {\n    '50': 'oklch(0.969 0.016 293.756)',\n    '100': 'oklch(0.943 0.029 294.588)',\n    '200': 'oklch(0.894 0.057 293.283)',\n    '300': 'oklch(0.811 0.111 293.571)',\n    '400': 'oklch(0.702 0.183 293.541)',\n    '500': 'oklch(0.606 0.25 292.717)',\n    '600': 'oklch(0.541 0.281 293.009)',\n    '700': 'oklch(0.491 0.27 292.581)',\n    '800': 'oklch(0.432 0.232 292.759)',\n    '900': 'oklch(0.38 0.189 293.745)',\n    '950': 'oklch(0.283 0.141 291.089)',\n  },\n  white: '#fff',\n  yellow: {\n    '50': 'oklch(0.987 0.026 102.212)',\n    '100': 'oklch(0.973 0.071 103.193)',\n    '200': 'oklch(0.945 0.129 101.54)',\n    '300': 'oklch(0.905 0.182 98.111)',\n    '400': 'oklch(0.852 0.199 91.936)',\n    '500': 'oklch(0.795 0.184 86.047)',\n    '600': 'oklch(0.681 0.162 75.834)',\n    '700': 'oklch(0.554 0.135 66.442)',\n    '800': 'oklch(0.476 0.114 61.907)',\n    '900': 'oklch(0.421 0.095 57.708)',\n    '950': 'oklch(0.286 0.066 53.813)',\n  },\n  zinc: {\n    '50': 'oklch(0.985 0 0)',\n    '100': 'oklch(0.967 0.001 286.375)',\n    '200': 'oklch(0.92 0.004 286.32)',\n    '300': 'oklch(0.871 0.006 286.286)',\n    '400': 'oklch(0.705 0.015 286.067)',\n    '500': 'oklch(0.552 0.016 285.938)',\n    '600': 'oklch(0.442 0.017 285.786)',\n    '700': 'oklch(0.37 0.013 285.805)',\n    '800': 'oklch(0.274 0.006 286.033)',\n    '900': 'oklch(0.21 0.006 285.885)',\n    '950': 'oklch(0.141 0.005 285.823)',\n  },\n}\n\n// prettier-ignore\n/* eslint-disable perfectionist/sort-objects */\nexport const defaultColors = {\n    text: {\n      'text-red': { css: { 'color': `light-dark(${tailwindColors.red[600]}, ${tailwindColors.red[400]})`, }, label: 'Red' },\n      'text-orange': { css: { 'color': `light-dark(${tailwindColors.orange[600]}, ${tailwindColors.orange[400]})`, }, label: 'Orange' },\n      'text-yellow': { css: { 'color': `light-dark(${tailwindColors.yellow[700]}, ${tailwindColors.yellow[300]})`, }, label: 'Yellow' },\n      'text-green': { css: { 'color': `light-dark(${tailwindColors.green[700]}, ${tailwindColors.green[400]})`, }, label: 'Green' },\n      'text-blue': { css: { 'color': `light-dark(${tailwindColors.blue[600]}, ${tailwindColors.blue[400]})`, }, label: 'Blue' },\n      'text-purple': { css: { 'color': `light-dark(${tailwindColors.purple[600]}, ${tailwindColors.purple[400]})`, }, label: 'Purple' },\n      'text-pink': { css: { 'color': `light-dark(${tailwindColors.pink[600]}, ${tailwindColors.pink[400]})`, }, label: 'Pink' },\n    } satisfies StateValues,\n    background: {\n      'bg-red': { css: { 'background-color': `light-dark(${tailwindColors.red[400]}, ${tailwindColors.red[600]})`, }, label: 'Red' },\n      'bg-orange': { css: { 'background-color': `light-dark(${tailwindColors.orange[400]}, ${tailwindColors.orange[600]})`, }, label: 'Orange' },\n      'bg-yellow': { css: { 'background-color': `light-dark(${tailwindColors.yellow[300]}, ${tailwindColors.yellow[700]})`, }, label: 'Yellow' },\n      'bg-green': { css: { 'background-color': `light-dark(${tailwindColors.green[400]}, ${tailwindColors.green[700]})`, }, label: 'Green' },\n      'bg-blue': { css: { 'background-color': `light-dark(${tailwindColors.blue[400]}, ${tailwindColors.blue[600]})`, }, label: 'Blue' },\n      'bg-purple': { css: { 'background-color': `light-dark(${tailwindColors.purple[400]}, ${tailwindColors.purple[600]})`, }, label: 'Purple' },\n      'bg-pink': { css: { 'background-color': `light-dark(${tailwindColors.pink[400]}, ${tailwindColors.pink[600]})`, }, label: 'Pink' },\n    } satisfies StateValues\n  }\n","'use client'\n\nimport { $isNodeSelection } from 'lexical'\n\nimport type { RelationshipFeatureProps } from '../server/index.js'\n\nimport { RelationshipIcon } from '../../../lexical/ui/icons/Relationship/index.js'\nimport { createClientFeature } from '../../../utilities/createClientFeature.js'\nimport { slashMenuBasicGroupWithItems } from '../../shared/slashMenu/basicGroup.js'\nimport { toolbarAddDropdownGroupWithItems } from '../../shared/toolbar/addDropdownGroup.js'\nimport { INSERT_RELATIONSHIP_WITH_DRAWER_COMMAND } from './drawer/commands.js'\nimport { $isRelationshipNode, RelationshipNode } from './nodes/RelationshipNode.js'\nimport { RelationshipPlugin } from './plugins/index.js'\n\nexport const RelationshipFeatureClient = createClientFeature<RelationshipFeatureProps>({\n  nodes: [RelationshipNode],\n  plugins: [\n    {\n      Component: RelationshipPlugin,\n      position: 'normal',\n    },\n  ],\n  slashMenu: {\n    groups: [\n      slashMenuBasicGroupWithItems([\n        {\n          Icon: RelationshipIcon,\n          key: 'relationship',\n          keywords: ['relationship', 'relation', 'rel'],\n          label: ({ i18n }) => {\n            return i18n.t('lexical:relationship:label')\n          },\n          onSelect: ({ editor }) => {\n            // dispatch INSERT_RELATIONSHIP_WITH_DRAWER_COMMAND\n            editor.dispatchCommand(INSERT_RELATIONSHIP_WITH_DRAWER_COMMAND, {\n              replace: false,\n            })\n          },\n        },\n      ]),\n    ],\n  },\n  toolbarFixed: {\n    groups: [\n      toolbarAddDropdownGroupWithItems([\n        {\n          ChildComponent: RelationshipIcon,\n          isActive: ({ selection }) => {\n            if (!$isNodeSelection(selection) || !selection.getNodes().length) {\n              return false\n            }\n\n            const firstNode = selection.getNodes()[0]\n            return $isRelationshipNode(firstNode)\n          },\n          key: 'relationship',\n          label: ({ i18n }) => {\n            return i18n.t('lexical:relationship:label')\n          },\n          onSelect: ({ editor }) => {\n            // dispatch INSERT_RELATIONSHIP_WITH_DRAWER_COMMAND\n            editor.dispatchCommand(INSERT_RELATIONSHIP_WITH_DRAWER_COMMAND, {\n              replace: false,\n            })\n          },\n        },\n      ]),\n    ],\n  },\n})\n","'use client'\nimport React from 'react'\n\nexport const RelationshipIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <g clipPath=\"url(#clip0_4397_10817)\">\n      <path\n        d=\"M7.75 12.25L15.25 4.75M15.25 4.75H11.5M15.25 4.75V8.5M13 11.5V13.75C13 14.5784 12.3284 15.25 11.5 15.25H6.25C5.42157 15.25 4.75 14.5784 4.75 13.75V8.5C4.75 7.67157 5.42157 7 6.25 7H8.5\"\n        stroke=\"currentColor\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n    </g>\n    <defs>\n      <clipPath id=\"clip0_4397_10817\">\n        <rect fill=\"currentColor\" height=\"12\" transform=\"translate(4 4)\" width=\"12\" />\n      </clipPath>\n    </defs>\n  </svg>\n)\n","'use client'\nimport type { JSX } from 'react'\n\nimport {\n  $applyNodeReplacement,\n  type DOMConversionMap,\n  type DOMConversionOutput,\n  type EditorConfig,\n  type LexicalEditor,\n  type LexicalNode,\n} from 'lexical'\nimport * as React from 'react'\n\nimport type {\n  RelationshipData,\n  SerializedRelationshipNode,\n} from '../../server/nodes/RelationshipNode.js'\n\nimport { RelationshipServerNode } from '../../server/nodes/RelationshipNode.js'\n\nconst RelationshipComponent = React.lazy(() =>\n  import('../components/RelationshipComponent.js').then((module) => ({\n    default: module.RelationshipComponent,\n  })),\n)\n\nfunction $relationshipElementToNode(domNode: HTMLDivElement): DOMConversionOutput | null {\n  const id = domNode.getAttribute('data-lexical-relationship-id')\n  const relationTo = domNode.getAttribute('data-lexical-relationship-relationTo')\n\n  if (id != null && relationTo != null) {\n    const node = $createRelationshipNode({\n      relationTo,\n      value: id,\n    })\n    return { node }\n  }\n  return null\n}\n\nexport class RelationshipNode extends RelationshipServerNode {\n  static override clone(node: RelationshipServerNode): RelationshipServerNode {\n    return super.clone(node)\n  }\n\n  static override getType(): string {\n    return super.getType()\n  }\n\n  static override importDOM(): DOMConversionMap<HTMLDivElement> | null {\n    return {\n      div: (domNode: HTMLDivElement) => {\n        if (\n          !domNode.hasAttribute('data-lexical-relationship-relationTo') ||\n          !domNode.hasAttribute('data-lexical-relationship-id')\n        ) {\n          return null\n        }\n        return {\n          conversion: $relationshipElementToNode,\n          priority: 2,\n        }\n      },\n    }\n  }\n\n  static override importJSON(serializedNode: SerializedRelationshipNode): RelationshipNode {\n    if (serializedNode.version === 1 && (serializedNode?.value as unknown as { id: string })?.id) {\n      serializedNode.value = (serializedNode.value as unknown as { id: string }).id\n    }\n\n    const importedData: RelationshipData = {\n      relationTo: serializedNode.relationTo,\n      value: serializedNode.value,\n    }\n    const node = $createRelationshipNode(importedData)\n    node.setFormat(serializedNode.format)\n    return node\n  }\n\n  override decorate(editor: LexicalEditor, config: EditorConfig): JSX.Element {\n    return (\n      <RelationshipComponent\n        className={config.theme.relationship ?? 'LexicalEditorTheme__relationship'}\n        data={this.__data}\n        format={this.__format}\n        nodeKey={this.getKey()}\n      />\n    )\n  }\n\n  override exportJSON(): SerializedRelationshipNode {\n    return super.exportJSON()\n  }\n}\n\nexport function $createRelationshipNode(data: RelationshipData): RelationshipNode {\n  return $applyNodeReplacement(\n    new RelationshipNode({\n      data,\n    }),\n  )\n}\n\nexport function $isRelationshipNode(\n  node: LexicalNode | null | RelationshipNode | undefined,\n): node is RelationshipNode {\n  return node instanceof RelationshipNode\n}\n","import type { SerializedDecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport type { CollectionSlug, DataFromCollectionSlug } from 'payload'\nimport type { JSX } from 'react'\n\nimport { DecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport { addClassNamesToElement } from '@lexical/utils'\nimport {\n  $applyNodeReplacement,\n  type DOMConversionMap,\n  type DOMConversionOutput,\n  type DOMExportOutput,\n  type EditorConfig,\n  type ElementFormatType,\n  type LexicalEditor,\n  type LexicalNode,\n  type NodeKey,\n} from 'lexical'\n\nimport type { StronglyTypedLeafNode } from '../../../../nodeTypes.js'\n\nexport type RelationshipData = {\n  [TCollectionSlug in CollectionSlug]: {\n    relationTo: TCollectionSlug\n    value: DataFromCollectionSlug<TCollectionSlug> | number | string\n  }\n}[CollectionSlug]\n\nexport type SerializedRelationshipNode = RelationshipData &\n  StronglyTypedLeafNode<SerializedDecoratorBlockNode, 'relationship'>\n\nfunction $relationshipElementToServerNode(domNode: HTMLDivElement): DOMConversionOutput | null {\n  const id = domNode.getAttribute('data-lexical-relationship-id')\n  const relationTo = domNode.getAttribute('data-lexical-relationship-relationTo')\n\n  if (id != null && relationTo != null) {\n    const node = $createServerRelationshipNode({\n      relationTo,\n      value: id,\n    })\n    return { node }\n  }\n  return null\n}\n\nexport class RelationshipServerNode extends DecoratorBlockNode {\n  __data: RelationshipData\n\n  constructor({\n    data,\n    format,\n    key,\n  }: {\n    data: RelationshipData\n    format?: ElementFormatType\n    key?: NodeKey\n  }) {\n    super(format, key)\n    this.__data = data\n  }\n\n  static override clone(node: RelationshipServerNode): RelationshipServerNode {\n    return new this({\n      data: node.__data,\n      format: node.__format,\n      key: node.__key,\n    })\n  }\n\n  static override getType(): string {\n    return 'relationship'\n  }\n\n  static override importDOM(): DOMConversionMap<HTMLDivElement> | null {\n    return {\n      div: (domNode: HTMLDivElement) => {\n        if (\n          !domNode.hasAttribute('data-lexical-relationship-relationTo') ||\n          !domNode.hasAttribute('data-lexical-relationship-id')\n        ) {\n          return null\n        }\n        return {\n          conversion: $relationshipElementToServerNode,\n          priority: 2,\n        }\n      },\n    }\n  }\n\n  static override importJSON(serializedNode: SerializedRelationshipNode): RelationshipServerNode {\n    if (serializedNode.version === 1 && (serializedNode?.value as unknown as { id: string })?.id) {\n      serializedNode.value = (serializedNode.value as unknown as { id: string }).id\n    }\n\n    const importedData: RelationshipData = {\n      relationTo: serializedNode.relationTo,\n      value: serializedNode.value,\n    }\n    const node = $createServerRelationshipNode(importedData)\n    node.setFormat(serializedNode.format)\n    return node\n  }\n\n  static isInline(): false {\n    return false\n  }\n\n  override createDOM(config?: EditorConfig): HTMLElement {\n    const element = document.createElement('div')\n    addClassNamesToElement(element, config?.theme?.relationship)\n    return element\n  }\n\n  override decorate(_editor: LexicalEditor, _config: EditorConfig): JSX.Element {\n    return null as unknown as JSX.Element\n  }\n\n  override exportDOM(): DOMExportOutput {\n    const element = document.createElement('div')\n    element.setAttribute(\n      'data-lexical-relationship-id',\n      String(typeof this.__data?.value === 'object' ? this.__data?.value?.id : this.__data?.value),\n    )\n    element.setAttribute('data-lexical-relationship-relationTo', this.__data?.relationTo)\n\n    const text = document.createTextNode(this.getTextContent())\n    element.append(text)\n    return { element }\n  }\n\n  override exportJSON(): SerializedRelationshipNode {\n    return {\n      ...super.exportJSON(),\n      ...this.getData(),\n      type: 'relationship',\n      version: 2,\n    }\n  }\n\n  getData(): RelationshipData {\n    return this.getLatest().__data\n  }\n\n  override getTextContent(): string {\n    return `${this.__data?.relationTo} relation to ${typeof this.__data?.value === 'object' ? this.__data?.value?.id : this.__data?.value}`\n  }\n\n  setData(data: RelationshipData): void {\n    const writable = this.getWritable()\n    writable.__data = data\n  }\n}\n\nexport function $createServerRelationshipNode(data: RelationshipData): RelationshipServerNode {\n  return $applyNodeReplacement(\n    new RelationshipServerNode({\n      data,\n    }),\n  )\n}\n\nexport function $isServerRelationshipNode(\n  node: LexicalNode | null | RelationshipServerNode | undefined,\n): node is RelationshipServerNode {\n  return node instanceof RelationshipServerNode\n}\n","'use client'\nimport type { LexicalCommand } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { $insertNodeToNearestRoot } from '@lexical/utils'\nimport {\n  $getPreviousSelection,\n  $getSelection,\n  $isParagraphNode,\n  $isRangeSelection,\n  COMMAND_PRIORITY_EDITOR,\n  createCommand,\n} from 'lexical'\nimport { useEffect } from 'react'\n\nimport type { PluginComponent } from '../../../typesClient.js'\nimport type { RelationshipFeatureProps } from '../../server/index.js'\nimport type { RelationshipData } from '../../server/nodes/RelationshipNode.js'\n\nimport { RelationshipDrawer } from '../drawer/index.js'\nimport { $createRelationshipNode, RelationshipNode } from '../nodes/RelationshipNode.js'\nimport { useEnabledRelationships } from '../utils/useEnabledRelationships.js'\n\nexport const INSERT_RELATIONSHIP_COMMAND: LexicalCommand<RelationshipData> = createCommand(\n  'INSERT_RELATIONSHIP_COMMAND',\n)\n\nexport const RelationshipPlugin: PluginComponent<RelationshipFeatureProps> = ({ clientProps }) => {\n  const [editor] = useLexicalComposerContext()\n\n  const { enabledCollectionSlugs } = useEnabledRelationships({\n    collectionSlugsBlacklist: clientProps?.disabledCollections,\n    collectionSlugsWhitelist: clientProps?.enabledCollections,\n  })\n\n  useEffect(() => {\n    if (!editor.hasNodes([RelationshipNode])) {\n      throw new Error('RelationshipPlugin: RelationshipNode not registered on editor')\n    }\n\n    return editor.registerCommand<RelationshipData>(\n      INSERT_RELATIONSHIP_COMMAND,\n      (payload) => {\n        const selection = $getSelection() || $getPreviousSelection()\n\n        if ($isRangeSelection(selection)) {\n          const relationshipNode = $createRelationshipNode(payload)\n          // we need to get the focus node before inserting the block node, as $insertNodeToNearestRoot can change the focus node\n          const { focus } = selection\n          const focusNode = focus.getNode()\n          // Insert relationship node BEFORE potentially removing focusNode, as $insertNodeToNearestRoot errors if the focusNode doesn't exist\n          $insertNodeToNearestRoot(relationshipNode)\n\n          // Delete the node it it's an empty paragraph\n          if ($isParagraphNode(focusNode) && !focusNode.__first) {\n            focusNode.remove()\n          }\n        }\n\n        return true\n      },\n      COMMAND_PRIORITY_EDITOR,\n    )\n  }, [editor])\n\n  return <RelationshipDrawer enabledCollectionSlugs={enabledCollectionSlugs} />\n}\n","'use client'\nimport type { LexicalEditor } from 'lexical'\nimport type { CollectionSlug } from 'payload'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { type ListDrawerProps, toast } from '@payloadcms/ui'\nimport { $getNodeByKey, COMMAND_PRIORITY_EDITOR } from 'lexical'\nimport React, { useCallback, useEffect, useState } from 'react'\n\nimport { useLexicalListDrawer } from '../../../../utilities/fieldsDrawer/useLexicalListDrawer.js'\nimport { $createRelationshipNode } from '../nodes/RelationshipNode.js'\nimport { INSERT_RELATIONSHIP_COMMAND } from '../plugins/index.js'\nimport { INSERT_RELATIONSHIP_WITH_DRAWER_COMMAND } from './commands.js'\n\nconst insertRelationship = ({\n  editor,\n  relationTo,\n  replaceNodeKey,\n  value,\n}: {\n  editor: LexicalEditor\n  relationTo: string\n  replaceNodeKey: null | string\n  value: number | string\n}) => {\n  if (!replaceNodeKey) {\n    editor.dispatchCommand(INSERT_RELATIONSHIP_COMMAND, {\n      relationTo,\n      value,\n    })\n  } else {\n    editor.update(() => {\n      const node = $getNodeByKey(replaceNodeKey)\n      if (node) {\n        node.replace($createRelationshipNode({ relationTo, value }))\n      }\n    })\n  }\n}\n\ntype Props = {\n  enabledCollectionSlugs: CollectionSlug[]\n}\n\nconst RelationshipDrawerComponent: React.FC<Props> = ({ enabledCollectionSlugs }) => {\n  const [editor] = useLexicalComposerContext()\n\n  const [replaceNodeKey, setReplaceNodeKey] = useState<null | string>(null)\n\n  const { closeListDrawer, ListDrawer, openListDrawer } = useLexicalListDrawer({\n    collectionSlugs: enabledCollectionSlugs,\n    selectedCollection: enabledCollectionSlugs?.[0],\n  })\n\n  useEffect(() => {\n    return editor.registerCommand<{\n      replace: { nodeKey: string } | false\n    }>(\n      INSERT_RELATIONSHIP_WITH_DRAWER_COMMAND,\n      (payload) => {\n        setReplaceNodeKey(payload?.replace ? payload?.replace.nodeKey : null)\n        openListDrawer()\n        return true\n      },\n      COMMAND_PRIORITY_EDITOR,\n    )\n  }, [editor, openListDrawer])\n\n  const onSelect = useCallback<NonNullable<ListDrawerProps['onSelect']>>(\n    ({ collectionSlug, doc }) => {\n      insertRelationship({\n        editor,\n        relationTo: collectionSlug,\n        replaceNodeKey,\n        value: doc.id,\n      })\n      closeListDrawer()\n    },\n    [editor, closeListDrawer, replaceNodeKey],\n  )\n\n  return <ListDrawer onSelect={onSelect} />\n}\n\nconst RelationshipDrawerComponentFallback: React.FC = () => {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    return editor.registerCommand<{\n      replace: { nodeKey: string } | false\n    }>(\n      INSERT_RELATIONSHIP_WITH_DRAWER_COMMAND,\n      () => {\n        toast.error('No relationship collections enabled')\n        return true\n      },\n      COMMAND_PRIORITY_EDITOR,\n    )\n  }, [editor])\n\n  return null\n}\n\nexport const RelationshipDrawer = ({ enabledCollectionSlugs }: Props): React.ReactNode => {\n  if (!enabledCollectionSlugs?.length) {\n    return <RelationshipDrawerComponentFallback />\n  }\n\n  return <RelationshipDrawerComponent enabledCollectionSlugs={enabledCollectionSlugs} />\n}\n","'use client'\nimport type { UseListDrawer } from '@payloadcms/ui'\nimport type { BaseSelection } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { useListDrawer, useModal } from '@payloadcms/ui'\nimport {\n  $getNodeByKey,\n  $getPreviousSelection,\n  $getRoot,\n  $getSelection,\n  $isRangeSelection,\n  $setSelection,\n} from 'lexical'\nimport { useCallback, useEffect, useState } from 'react'\n\n/**\n *\n * Wrapper around useListDrawer that restores and saves selection state (cursor position) when opening and closing the drawer.\n * By default, the lexical cursor position may be lost when opening a drawer and clicking somewhere on that drawer.\n */\nexport const useLexicalListDrawer = (\n  args: Parameters<UseListDrawer>[0],\n): {\n  closeListDrawer: () => void\n  isListDrawerOpen: boolean\n  ListDrawer: ReturnType<UseListDrawer>[0]\n  listDrawerSlug: string\n  ListDrawerToggler: ReturnType<UseListDrawer>[1]\n  openListDrawer: (selection?: BaseSelection) => void\n} => {\n  const [editor] = useLexicalComposerContext()\n  const [selectionState, setSelectionState] = useState<BaseSelection | null>(null)\n  const [wasOpen, setWasOpen] = useState<boolean>(false)\n\n  const [\n    BaseListDrawer,\n    BaseListDrawerToggler,\n    {\n      closeDrawer: baseCloseDrawer,\n      drawerSlug: listDrawerSlug,\n      isDrawerOpen,\n      openDrawer: baseOpenDrawer,\n    },\n  ] = useListDrawer(args)\n  const { modalState } = useModal()\n\n  const $storeSelection = useCallback(() => {\n    // editor.read() causes an error here when creating a new upload node from the slash menu. It seems like we can omit it here though, as all\n    // invocations of that functions are wrapped in editor.read() or editor.update() somewhere in the call stack.\n    const selection = $getSelection() ?? $getPreviousSelection()\n    setSelectionState(selection)\n  }, [])\n\n  const restoreSelection = useCallback(() => {\n    if (selectionState) {\n      editor.update(\n        () => {\n          if ($isRangeSelection(selectionState)) {\n            const { anchor, focus } = selectionState\n            if ($getNodeByKey(anchor.key) && $getNodeByKey(focus.key)) {\n              $setSelection(selectionState.clone())\n            }\n          } else {\n            // not ideal, but better than losing the selection. Try to set the selection\n            // in a valid place if you remove selected nodes!\n            $getRoot().selectEnd()\n          }\n        },\n        { discrete: true, skipTransforms: true },\n      )\n    }\n  }, [editor, selectionState])\n\n  const closeListDrawer = () => {\n    //restoreSelection() // Should already be stored by the useEffect below\n    baseCloseDrawer()\n  }\n\n  // We need to handle drawer closing via a useEffect, as toggleDrawer / closeDrawer will not be triggered if the drawer\n  // is closed by clicking outside of the drawer. This useEffect will handle everything.\n  useEffect(() => {\n    if (!wasOpen) {\n      return\n    }\n\n    const thisModalState = modalState[listDrawerSlug]\n    // Exists in modalState (thus has opened at least once before) and is closed\n    if (thisModalState && !thisModalState?.isOpen) {\n      setWasOpen(false)\n      setTimeout(() => {\n        restoreSelection()\n      }, 1)\n    }\n  }, [modalState, listDrawerSlug, restoreSelection, wasOpen])\n\n  return {\n    closeListDrawer,\n    isListDrawerOpen: isDrawerOpen,\n    ListDrawer: BaseListDrawer,\n    listDrawerSlug,\n    ListDrawerToggler: (props) => (\n      <BaseListDrawerToggler\n        {...props}\n        onClick={() => {\n          $storeSelection()\n        }}\n      />\n    ),\n    openListDrawer: () => {\n      $storeSelection()\n      baseOpenDrawer()\n      setWasOpen(true)\n    },\n  }\n}\n","'use client'\nimport type { ClientCollectionConfig, CollectionSlug } from 'payload'\n\nimport { useConfig, useEntityVisibility } from '@payloadcms/ui'\nimport * as React from 'react'\n\ntype UseEnabledRelationshipsOptions = {\n  collectionSlugsBlacklist?: string[]\n  collectionSlugsWhitelist?: string[]\n  uploads?: boolean\n}\n\ntype UseEnabledRelationshipsResult = {\n  enabledCollections: ClientCollectionConfig[]\n  enabledCollectionSlugs: CollectionSlug[]\n}\n\nexport const useEnabledRelationships = (\n  options?: UseEnabledRelationshipsOptions,\n): UseEnabledRelationshipsResult => {\n  const { collectionSlugsBlacklist, collectionSlugsWhitelist, uploads = false } = options || {}\n  const {\n    config: { collections },\n  } = useConfig()\n  const { visibleEntities } = useEntityVisibility()\n\n  const result = React.useMemo(() => {\n    const enabledCollectionSlugs: string[] = []\n    const enabledCollections: ClientCollectionConfig[] = []\n    const whitelistSet = collectionSlugsWhitelist ? new Set(collectionSlugsWhitelist) : null\n    const blacklistSet = collectionSlugsBlacklist ? new Set(collectionSlugsBlacklist) : null\n\n    for (const collection of collections) {\n      const {\n        slug,\n        admin: { enableRichTextRelationship },\n        upload,\n      } = collection\n\n      // Check visibility\n      if (!visibleEntities?.collections.includes(slug)) {\n        continue\n      }\n\n      // Check rich text relationship and upload settings\n      if (uploads) {\n        if (!enableRichTextRelationship || !upload) {\n          continue\n        }\n      } else {\n        if (upload || !enableRichTextRelationship) {\n          continue\n        }\n      }\n\n      // Check whitelist (if provided, only include slugs in the whitelist)\n      if (whitelistSet && !whitelistSet.has(slug)) {\n        continue\n      }\n\n      // Check blacklist (if provided, exclude slugs in the blacklist)\n      if (blacklistSet && blacklistSet.has(slug)) {\n        continue\n      }\n\n      enabledCollectionSlugs.push(slug)\n      enabledCollections.push(collection)\n    }\n\n    return { enabledCollections, enabledCollectionSlugs }\n  }, [collections, visibleEntities, uploads, collectionSlugsWhitelist, collectionSlugsBlacklist])\n\n  return result\n}\n","'use client'\nimport type { LexicalEditor } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { useLexicalEditable } from '@lexical/react/useLexicalEditable'\nimport { useScrollInfo, useThrottledEffect, useTranslation } from '@payloadcms/ui'\nimport * as React from 'react'\nimport { useMemo } from 'react'\n\nimport type { EditorConfigContextType } from '../../../../../lexical/config/client/EditorConfigProvider.js'\nimport type { SanitizedClientEditorConfig } from '../../../../../lexical/config/types.js'\nimport type { PluginComponent } from '../../../../typesClient.js'\nimport type { ToolbarGroup, ToolbarGroupItem } from '../../../types.js'\nimport type { FixedToolbarFeatureProps } from '../../server/index.js'\n\nimport { useEditorConfigContext } from '../../../../../lexical/config/client/EditorConfigProvider.js'\nimport { ToolbarButton } from '../../../shared/ToolbarButton/index.js'\nimport './index.scss'\nimport { ToolbarDropdown } from '../../../shared/ToolbarDropdown/index.js'\n\nfunction ButtonGroupItem({\n  anchorElem,\n  editor,\n  item,\n}: {\n  anchorElem: HTMLElement\n  editor: LexicalEditor\n  item: ToolbarGroupItem\n}): React.ReactNode {\n  if (item.Component) {\n    return (\n      item?.Component && (\n        <item.Component anchorElem={anchorElem} editor={editor} item={item} key={item.key} />\n      )\n    )\n  }\n\n  if (!item.ChildComponent) {\n    return null\n  }\n\n  return (\n    <ToolbarButton editor={editor} item={item} key={item.key}>\n      <item.ChildComponent />\n    </ToolbarButton>\n  )\n}\n\nfunction ToolbarGroupComponent({\n  anchorElem,\n  editor,\n  editorConfig,\n  group,\n  index,\n}: {\n  anchorElem: HTMLElement\n  editor: LexicalEditor\n  editorConfig: SanitizedClientEditorConfig\n  group: ToolbarGroup\n  index: number\n}): React.ReactNode {\n  const { i18n } = useTranslation<{}, string>()\n  const {\n    fieldProps: { featureClientSchemaMap, schemaPath },\n  } = useEditorConfigContext()\n\n  const [dropdownLabel, setDropdownLabel] = React.useState<string | undefined>(undefined)\n  const [DropdownIcon, setDropdownIcon] = React.useState<React.FC | undefined>(undefined)\n\n  React.useEffect(() => {\n    if (group?.type === 'dropdown' && group.items.length && group.ChildComponent) {\n      setDropdownIcon(() => group.ChildComponent!)\n    } else {\n      setDropdownIcon(undefined)\n    }\n  }, [group])\n\n  const onActiveChange = React.useCallback(\n    ({ activeItems }: { activeItems: ToolbarGroupItem[] }) => {\n      if (!activeItems.length) {\n        if (group?.type === 'dropdown' && group.items.length && group.ChildComponent) {\n          setDropdownIcon(() => group.ChildComponent!)\n          setDropdownLabel(undefined)\n        } else {\n          setDropdownIcon(undefined)\n          setDropdownLabel(undefined)\n        }\n        return\n      }\n      const item = activeItems[0]!\n\n      let label = item.key\n      if (item.label) {\n        label =\n          typeof item.label === 'function'\n            ? item.label({ featureClientSchemaMap, i18n, schemaPath })\n            : item.label\n      }\n      // Crop title to max. 25 characters\n      if (label.length > 25) {\n        label = label.substring(0, 25) + '...'\n      }\n      if (activeItems.length === 1) {\n        setDropdownLabel(label)\n        setDropdownIcon(() => item.ChildComponent)\n      } else {\n        setDropdownLabel(\n          i18n.t('lexical:general:toolbarItemsActive', { count: activeItems.length }),\n        )\n        if (group?.type === 'dropdown' && group.items.length && group.ChildComponent) {\n          setDropdownIcon(() => group.ChildComponent!)\n        } else {\n          setDropdownIcon(undefined)\n        }\n      }\n    },\n    [group, i18n, featureClientSchemaMap, schemaPath],\n  )\n\n  return (\n    <div\n      className={`fixed-toolbar__group fixed-toolbar__group-${group.key}`}\n      data-toolbar-group-key={group.key}\n      key={group.key}\n    >\n      {group.type === 'dropdown' && group.items.length ? (\n        DropdownIcon ? (\n          <ToolbarDropdown\n            anchorElem={anchorElem}\n            editor={editor}\n            group={group}\n            Icon={DropdownIcon}\n            itemsContainerClassNames={['fixed-toolbar__dropdown-items']}\n            label={dropdownLabel}\n            maxActiveItems={group.maxActiveItems ?? 1}\n            onActiveChange={onActiveChange}\n          />\n        ) : (\n          <ToolbarDropdown\n            anchorElem={anchorElem}\n            editor={editor}\n            group={group}\n            itemsContainerClassNames={['fixed-toolbar__dropdown-items']}\n            label={dropdownLabel}\n            maxActiveItems={group.maxActiveItems ?? 1}\n            onActiveChange={onActiveChange}\n          />\n        )\n      ) : null}\n      {group.type === 'buttons' && group.items.length\n        ? group.items.map((item) => {\n            return (\n              <ButtonGroupItem anchorElem={anchorElem} editor={editor} item={item} key={item.key} />\n            )\n          })\n        : null}\n      {index < editorConfig.features.toolbarFixed?.groups.length - 1 && <div className=\"divider\" />}\n    </div>\n  )\n}\n\nfunction FixedToolbar({\n  anchorElem,\n  clientProps,\n  editor,\n  editorConfig,\n  parentWithFixedToolbar,\n}: {\n  anchorElem: HTMLElement\n  clientProps?: FixedToolbarFeatureProps\n  editor: LexicalEditor\n  editorConfig: SanitizedClientEditorConfig\n  parentWithFixedToolbar: EditorConfigContextType | false\n}): React.ReactNode {\n  const currentToolbarRef = React.useRef<HTMLDivElement>(null)\n  const isEditable = useLexicalEditable()\n\n  const { y } = useScrollInfo()\n\n  // Memoize the parent toolbar element\n  const parentToolbarElem = useMemo(() => {\n    if (!parentWithFixedToolbar || clientProps?.disableIfParentHasFixedToolbar) {\n      return null\n    }\n\n    const parentEditorElem = parentWithFixedToolbar.editorContainerRef.current\n    let sibling = parentEditorElem.previousElementSibling\n    while (sibling) {\n      if (sibling.classList.contains('fixed-toolbar')) {\n        return sibling\n      }\n      sibling = sibling.previousElementSibling\n    }\n    return null\n  }, [clientProps?.disableIfParentHasFixedToolbar, parentWithFixedToolbar])\n\n  useThrottledEffect(\n    () => {\n      if (!parentToolbarElem) {\n        // this also checks for clientProps?.disableIfParentHasFixedToolbar indirectly, see the parentToolbarElem useMemo\n        return\n      }\n      const currentToolbarElem = currentToolbarRef.current\n      if (!currentToolbarElem) {\n        return\n      }\n\n      const currentRect = currentToolbarElem.getBoundingClientRect()\n      const parentRect = parentToolbarElem.getBoundingClientRect()\n\n      // we only need to check for vertical overlap\n      const overlapping = !(\n        currentRect.bottom < parentRect.top || currentRect.top > parentRect.bottom\n      )\n\n      if (overlapping) {\n        currentToolbarElem.classList.remove('fixed-toolbar')\n        currentToolbarElem.classList.add('fixed-toolbar', 'fixed-toolbar--overlapping')\n        parentToolbarElem.classList.remove('fixed-toolbar')\n        parentToolbarElem.classList.add('fixed-toolbar', 'fixed-toolbar--hide')\n      } else {\n        if (!currentToolbarElem.classList.contains('fixed-toolbar--overlapping')) {\n          return\n        }\n        currentToolbarElem.classList.remove('fixed-toolbar--overlapping')\n        currentToolbarElem.classList.add('fixed-toolbar')\n        parentToolbarElem.classList.remove('fixed-toolbar--hide')\n        parentToolbarElem.classList.add('fixed-toolbar')\n      }\n    },\n    50,\n    [currentToolbarRef, parentToolbarElem, y],\n  )\n\n  return (\n    <div\n      className=\"fixed-toolbar\"\n      onFocus={(event) => {\n        // Prevent other focus events being triggered. Otherwise, if this was to be clicked while in a child editor,\n        // the parent editor will be focused, and the child editor will lose focus.\n        event.stopPropagation()\n      }}\n      ref={currentToolbarRef}\n    >\n      {isEditable && (\n        <React.Fragment>\n          {editorConfig?.features &&\n            editorConfig.features?.toolbarFixed?.groups.map((group, i) => {\n              return (\n                <ToolbarGroupComponent\n                  anchorElem={anchorElem}\n                  editor={editor}\n                  editorConfig={editorConfig}\n                  group={group}\n                  index={i}\n                  key={group.key}\n                />\n              )\n            })}\n        </React.Fragment>\n      )}\n    </div>\n  )\n}\n\nconst getParentEditorWithFixedToolbar = (\n  editorConfigContext: EditorConfigContextType,\n): EditorConfigContextType | false => {\n  if (editorConfigContext.parentEditor?.editorConfig) {\n    if (editorConfigContext.parentEditor?.editorConfig.resolvedFeatureMap.has('toolbarFixed')) {\n      return editorConfigContext.parentEditor\n    } else {\n      if (editorConfigContext.parentEditor) {\n        return getParentEditorWithFixedToolbar(editorConfigContext.parentEditor)\n      }\n    }\n  }\n  return false\n}\n\nexport const FixedToolbarPlugin: PluginComponent<FixedToolbarFeatureProps> = ({ clientProps }) => {\n  const [currentEditor] = useLexicalComposerContext()\n  const editorConfigContext = useEditorConfigContext()\n  const isEditable = useLexicalEditable()\n  if (!isEditable) {\n    return null\n  }\n\n  const { editorConfig: currentEditorConfig } = editorConfigContext\n\n  const editor = clientProps.applyToFocusedEditor\n    ? editorConfigContext.focusedEditor?.editor || currentEditor\n    : currentEditor\n\n  const editorConfig = clientProps.applyToFocusedEditor\n    ? editorConfigContext.focusedEditor?.editorConfig || currentEditorConfig\n    : currentEditorConfig\n\n  const parentWithFixedToolbar = getParentEditorWithFixedToolbar(editorConfigContext)\n\n  if (clientProps?.disableIfParentHasFixedToolbar) {\n    if (parentWithFixedToolbar) {\n      return null\n    }\n  }\n\n  if (!editorConfig?.features?.toolbarFixed?.groups?.length) {\n    return null\n  }\n\n  return (\n    <FixedToolbar\n      anchorElem={document.body}\n      editor={editor}\n      editorConfig={editorConfig}\n      parentWithFixedToolbar={parentWithFixedToolbar}\n    />\n  )\n}\n","'use client'\nimport type { LexicalEditor } from 'lexical'\n\nimport { mergeRegister } from '@lexical/utils'\nimport { $addUpdateTag, $getSelection } from 'lexical'\nimport React, { useCallback, useDeferredValue, useEffect, useMemo, useState } from 'react'\n\nimport type { ToolbarGroupItem } from '../../types.js'\n\nimport { useEditorConfigContext } from '../../../../lexical/config/client/EditorConfigProvider.js'\nimport './index.scss'\nimport { useRunDeprioritized } from '../../../../utilities/useRunDeprioritized.js'\n\nconst baseClass = 'toolbar-popup__button'\n\nexport const ToolbarButton = ({\n  children,\n  editor,\n  item,\n}: {\n  children: React.JSX.Element\n  editor: LexicalEditor\n  item: ToolbarGroupItem\n}) => {\n  const [_state, setState] = useState({ active: false, enabled: true })\n  const deferredState = useDeferredValue(_state)\n\n  const editorConfigContext = useEditorConfigContext()\n\n  const className = useMemo(() => {\n    return [\n      baseClass,\n      !deferredState.enabled ? 'disabled' : '',\n      deferredState.active ? 'active' : '',\n      item.key ? `${baseClass}-${item.key}` : '',\n    ]\n      .filter(Boolean)\n      .join(' ')\n  }, [deferredState, item.key])\n  const updateStates = useCallback(() => {\n    editor.getEditorState().read(() => {\n      const selection = $getSelection()\n      if (!selection) {\n        return\n      }\n      const newActive = item.isActive\n        ? item.isActive({ editor, editorConfigContext, selection })\n        : false\n\n      const newEnabled = item.isEnabled\n        ? item.isEnabled({ editor, editorConfigContext, selection })\n        : true\n\n      setState((prev) => {\n        if (prev.active === newActive && prev.enabled === newEnabled) {\n          return prev\n        }\n        return { active: newActive, enabled: newEnabled }\n      })\n    })\n  }, [editor, editorConfigContext, item])\n\n  const runDeprioritized = useRunDeprioritized()\n\n  useEffect(() => {\n    // Run on mount\n    void runDeprioritized(updateStates)\n\n    const listener = () => runDeprioritized(updateStates)\n\n    const cleanup = mergeRegister(editor.registerUpdateListener(listener))\n    document.addEventListener('mouseup', listener)\n\n    return () => {\n      cleanup()\n      document.removeEventListener('mouseup', listener)\n    }\n  }, [editor, runDeprioritized, updateStates])\n\n  const handleClick = useCallback(() => {\n    if (!_state.enabled) {\n      return\n    }\n\n    editor.focus(() => {\n      editor.update(() => {\n        $addUpdateTag('toolbar')\n      })\n      // We need to wrap the onSelect in the callback, so the editor is properly focused before the onSelect is called.\n      item.onSelect?.({\n        editor,\n        isActive: _state.active,\n      })\n    })\n  }, [editor, item, _state])\n\n  const handleMouseDown = useCallback((e: React.MouseEvent) => {\n    // This fixes a bug where you are unable to click the button if you are in a NESTED editor (editor in blocks field in editor).\n    // Thus only happens if you click on the SVG of the button. Clicking on the outside works. Related issue: https://github.com/payloadcms/payload/issues/4025\n    // TODO: Find out why exactly it happens and why e.preventDefault() on the mouseDown fixes it. Write that down here, or potentially fix a root cause, if there is any.\n    e.preventDefault()\n  }, [])\n\n  return (\n    <button\n      className={className}\n      data-button-key={item.key}\n      onClick={handleClick}\n      onMouseDown={handleMouseDown}\n      type=\"button\"\n    >\n      {children}\n    </button>\n  )\n}\n","'use client'\nimport React, { useCallback, useDeferredValue, useEffect, useMemo } from 'react'\n\nconst baseClass = 'toolbar-popup__dropdown'\n\nimport type { LexicalEditor } from 'lexical'\n\nimport { mergeRegister } from '@lexical/utils'\nimport { useTranslation } from '@payloadcms/ui'\nimport { $getSelection } from 'lexical'\n\nimport type { ToolbarDropdownGroup, ToolbarGroupItem } from '../../types.js'\n\nimport { useEditorConfigContext } from '../../../../lexical/config/client/EditorConfigProvider.js'\nimport { useRunDeprioritized } from '../../../../utilities/useRunDeprioritized.js'\nimport './index.scss'\nimport { DropDown, DropDownItem } from './DropDown.js'\n\nconst ToolbarItem = ({\n  active,\n  anchorElem,\n  editor,\n  enabled,\n  item,\n}: {\n  active?: boolean\n  anchorElem: HTMLElement\n  editor: LexicalEditor\n  enabled?: boolean\n  item: ToolbarGroupItem\n}) => {\n  const { i18n } = useTranslation<{}, string>()\n  const {\n    fieldProps: { featureClientSchemaMap, schemaPath },\n  } = useEditorConfigContext()\n\n  if (item.Component) {\n    return (\n      item?.Component && (\n        <item.Component\n          active={active}\n          anchorElem={anchorElem}\n          editor={editor}\n          enabled={enabled}\n          item={item}\n          key={item.key}\n        />\n      )\n    )\n  }\n\n  let title = item.key\n  let croppedTitle = item.key\n  if (item.label) {\n    title =\n      typeof item.label === 'function'\n        ? item.label({ featureClientSchemaMap, i18n, schemaPath })\n        : item.label\n  }\n  // Crop title to max. 25 characters\n  if (title.length > 25) {\n    croppedTitle = title.substring(0, 25) + '...'\n  } else {\n    croppedTitle = title\n  }\n\n  return (\n    <DropDownItem\n      active={active}\n      editor={editor}\n      enabled={enabled}\n      Icon={item?.ChildComponent ? <item.ChildComponent /> : undefined}\n      item={item}\n      itemKey={item.key}\n      key={item.key}\n      tooltip={title}\n    >\n      <span className=\"text\">{croppedTitle}</span>\n    </DropDownItem>\n  )\n}\n\nconst MemoToolbarItem = React.memo(ToolbarItem)\n\nexport const ToolbarDropdown = ({\n  anchorElem,\n  classNames,\n  editor,\n  group,\n  Icon,\n  itemsContainerClassNames,\n  label,\n  maxActiveItems,\n  onActiveChange,\n}: {\n  anchorElem: HTMLElement\n  classNames?: string[]\n  editor: LexicalEditor\n  group: ToolbarDropdownGroup\n  Icon?: React.FC\n  itemsContainerClassNames?: string[]\n  label?: string\n  /**\n   * Maximum number of active items allowed. This is a performance optimization to prevent\n   * unnecessary item active checks when the maximum number of active items is reached.\n   */\n  maxActiveItems?: number\n  onActiveChange?: ({ activeItems }: { activeItems: ToolbarGroupItem[] }) => void\n}) => {\n  const [toolbarState, setToolbarState] = React.useState<{\n    activeItemKeys: string[]\n    enabledGroup: boolean\n    enabledItemKeys: string[]\n  }>({\n    activeItemKeys: [],\n    enabledGroup: true,\n    enabledItemKeys: [],\n  })\n  const deferredToolbarState = useDeferredValue(toolbarState)\n\n  const editorConfigContext = useEditorConfigContext()\n  const { items, key: groupKey } = group\n\n  const runDeprioritized = useRunDeprioritized()\n\n  const updateStates = useCallback(() => {\n    editor.getEditorState().read(() => {\n      const selection = $getSelection()\n      if (!selection) {\n        return\n      }\n\n      const _activeItemKeys: string[] = []\n      const _activeItems: ToolbarGroupItem[] = []\n      const _enabledItemKeys: string[] = []\n\n      for (const item of items) {\n        if (item.isActive && (!maxActiveItems || _activeItemKeys.length < maxActiveItems)) {\n          const isActive = item.isActive({ editor, editorConfigContext, selection })\n          if (isActive) {\n            _activeItemKeys.push(item.key)\n            _activeItems.push(item)\n          }\n        }\n        if (item.isEnabled) {\n          const isEnabled = item.isEnabled({ editor, editorConfigContext, selection })\n          if (isEnabled) {\n            _enabledItemKeys.push(item.key)\n          }\n        } else {\n          _enabledItemKeys.push(item.key)\n        }\n      }\n\n      setToolbarState({\n        activeItemKeys: _activeItemKeys,\n        enabledGroup: group.isEnabled\n          ? group.isEnabled({ editor, editorConfigContext, selection })\n          : true,\n        enabledItemKeys: _enabledItemKeys,\n      })\n\n      if (onActiveChange) {\n        onActiveChange({ activeItems: _activeItems })\n      }\n    })\n  }, [editor, editorConfigContext, group, items, maxActiveItems, onActiveChange])\n\n  useEffect(() => {\n    // Run on mount in order to update states when dropdown is opened\n    void runDeprioritized(updateStates)\n\n    return mergeRegister(\n      editor.registerUpdateListener(async () => {\n        await runDeprioritized(updateStates)\n      }),\n    )\n  }, [editor, runDeprioritized, updateStates])\n\n  const renderedItems = useMemo(() => {\n    return items?.length\n      ? items.map((item) => (\n          <MemoToolbarItem\n            active={deferredToolbarState.activeItemKeys.includes(item.key)}\n            anchorElem={anchorElem}\n            editor={editor}\n            enabled={deferredToolbarState.enabledItemKeys.includes(item.key)}\n            item={item}\n            key={item.key}\n          />\n        ))\n      : null\n  }, [items, deferredToolbarState, anchorElem, editor])\n\n  return (\n    <DropDown\n      buttonAriaLabel={`${groupKey} dropdown`}\n      buttonClassName={[baseClass, `${baseClass}-${groupKey}`, ...(classNames || [])]\n        .filter(Boolean)\n        .join(' ')}\n      disabled={!deferredToolbarState.enabledGroup}\n      dropdownKey={groupKey}\n      Icon={Icon}\n      itemsContainerClassNames={[`${baseClass}-items`, ...(itemsContainerClassNames || [])]}\n      key={groupKey}\n      label={label}\n    >\n      {renderedItems}\n    </DropDown>\n  )\n}\n","'use client'\nimport { Button } from '@payloadcms/ui'\nimport { $addUpdateTag, isDOMNode, type LexicalEditor } from 'lexical'\nimport React, { type ReactNode, useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\n\nimport type { ToolbarGroupItem } from '../../types.js'\n\nconst baseClass = 'toolbar-popup__dropdown-item'\n\ninterface DropDownContextType {\n  registerItem: (ref: React.RefObject<HTMLButtonElement | null>) => void\n}\n\nconst DropDownContext = React.createContext<DropDownContextType | null>(null)\n\nexport function DropDownItem({\n  active,\n  children,\n  editor,\n  enabled,\n  Icon,\n  item,\n  itemKey,\n  tooltip,\n}: {\n  active?: boolean\n  children: React.ReactNode\n  editor: LexicalEditor\n  enabled?: boolean\n  Icon: React.ReactNode\n  item: ToolbarGroupItem\n  itemKey: string\n  tooltip?: string\n}): React.ReactNode {\n  const className = useMemo(() => {\n    return [\n      baseClass,\n      enabled === false ? 'disabled' : '',\n      active ? 'active' : '',\n      item?.key ? `${baseClass}-${item.key}` : '',\n    ]\n      .filter(Boolean)\n      .join(' ')\n  }, [enabled, active, item.key])\n\n  const ref = useRef<HTMLButtonElement>(null)\n\n  const dropDownContext = React.use(DropDownContext)\n\n  if (dropDownContext === null) {\n    throw new Error('DropDownItem must be used within a DropDown')\n  }\n\n  const { registerItem } = dropDownContext\n\n  useEffect(() => {\n    if (ref?.current != null) {\n      registerItem(ref)\n    }\n  }, [ref, registerItem])\n\n  return (\n    <Button\n      aria-label={tooltip}\n      buttonStyle=\"none\"\n      className={className}\n      disabled={enabled === false}\n      extraButtonProps={{\n        'data-item-key': itemKey,\n      }}\n      icon={Icon}\n      iconPosition=\"left\"\n      iconStyle=\"none\"\n      onClick={() => {\n        if (enabled !== false) {\n          editor.focus(() => {\n            editor.update(() => {\n              $addUpdateTag('toolbar')\n            })\n            // We need to wrap the onSelect in the callback, so the editor is properly focused before the onSelect is called.\n            item.onSelect?.({\n              editor,\n              isActive: active!,\n            })\n          })\n        }\n      }}\n      onMouseDown={(e) => {\n        // This is required for Firefox compatibility. Without it, the dropdown will disappear without the onClick being called.\n        // This only happens in Firefox. Must be something about how Firefox handles focus events differently.\n        e.preventDefault()\n      }}\n      ref={ref}\n      tooltip={tooltip}\n      type=\"button\"\n    >\n      {children}\n    </Button>\n  )\n}\n\nfunction DropDownItems({\n  children,\n  dropDownRef,\n  itemsContainerClassNames,\n  onClose,\n}: {\n  children: React.ReactNode\n  dropDownRef: React.Ref<HTMLDivElement>\n  itemsContainerClassNames?: string[]\n  onClose: () => void\n}): React.ReactElement {\n  const [items, setItems] = useState<Array<React.RefObject<HTMLButtonElement | null>>>()\n  const [highlightedItem, setHighlightedItem] =\n    useState<React.RefObject<HTMLButtonElement | null>>()\n\n  const registerItem = useCallback(\n    (itemRef: React.RefObject<HTMLButtonElement | null>) => {\n      setItems((prev) => (prev != null ? [...prev, itemRef] : [itemRef]))\n    },\n    [setItems],\n  )\n\n  const handleKeyDown = (event: React.KeyboardEvent<HTMLDivElement>): void => {\n    if (items == null) {\n      return\n    }\n\n    const { key } = event\n\n    if (['ArrowDown', 'ArrowUp', 'Escape', 'Tab'].includes(key)) {\n      event.preventDefault()\n    }\n\n    if (key === 'Escape' || key === 'Tab') {\n      onClose()\n    } else if (key === 'ArrowUp') {\n      setHighlightedItem((prev) => {\n        if (prev == null) {\n          return items[0]\n        }\n        const index = items.indexOf(prev) - 1\n        return items[index === -1 ? items.length - 1 : index]\n      })\n    } else if (key === 'ArrowDown') {\n      setHighlightedItem((prev) => {\n        if (prev == null) {\n          return items[0]\n        }\n        return items[items.indexOf(prev) + 1]\n      })\n    }\n  }\n\n  const contextValue = useMemo(\n    () => ({\n      registerItem,\n    }),\n    [registerItem],\n  )\n\n  useEffect(() => {\n    if (items != null && highlightedItem == null) {\n      setHighlightedItem(items[0])\n    }\n\n    if (highlightedItem != null && highlightedItem?.current != null) {\n      highlightedItem.current.focus()\n    }\n  }, [items, highlightedItem])\n\n  return (\n    <DropDownContext value={contextValue}>\n      <div\n        className={(itemsContainerClassNames ?? ['toolbar-popup__dropdown-items']).join(' ')}\n        onKeyDown={handleKeyDown}\n        ref={dropDownRef}\n      >\n        {children}\n      </div>\n    </DropDownContext>\n  )\n}\n\nexport function DropDown({\n  buttonAriaLabel,\n  buttonClassName,\n  children,\n  disabled = false,\n  dropdownKey,\n  Icon,\n  itemsContainerClassNames,\n  label,\n  stopCloseOnClickSelf,\n}: {\n  buttonAriaLabel?: string\n  buttonClassName: string\n  children: ReactNode\n  disabled?: boolean\n  dropdownKey: string\n  Icon?: React.FC\n  itemsContainerClassNames?: string[]\n  label?: string\n  stopCloseOnClickSelf?: boolean\n}): React.ReactNode {\n  const dropDownRef = useRef<HTMLDivElement>(null)\n  const buttonRef = useRef<HTMLButtonElement>(null)\n  const [showDropDown, setShowDropDown] = useState(false)\n\n  const handleClose = (): void => {\n    setShowDropDown(false)\n    if (buttonRef?.current != null) {\n      buttonRef.current.focus()\n    }\n  }\n\n  useEffect(() => {\n    const button = buttonRef.current\n    const dropDown = dropDownRef.current\n\n    if (showDropDown && button !== null && dropDown !== null) {\n      const { left, top } = button.getBoundingClientRect()\n      const scrollTopOffset = window.scrollY || document.documentElement.scrollTop\n      dropDown.style.top = `${top + scrollTopOffset + button.offsetHeight + 5}px`\n      dropDown.style.left = `${Math.min(left - 5, window.innerWidth - dropDown.offsetWidth - 20)}px`\n    }\n  }, [dropDownRef, buttonRef, showDropDown])\n\n  useEffect(() => {\n    const button = buttonRef.current\n\n    if (button !== null && showDropDown) {\n      const handle = (event: MouseEvent): void => {\n        const target = event.target\n        if (!isDOMNode(target)) {\n          return\n        }\n        if (stopCloseOnClickSelf) {\n          if (dropDownRef.current && dropDownRef.current.contains(target)) {\n            return\n          }\n        }\n        if (!button.contains(target)) {\n          setShowDropDown(false)\n        }\n      }\n      document.addEventListener('click', handle)\n\n      return () => {\n        document.removeEventListener('click', handle)\n      }\n    }\n  }, [dropDownRef, buttonRef, showDropDown, stopCloseOnClickSelf])\n\n  const portal = createPortal(\n    <DropDownItems\n      dropDownRef={dropDownRef}\n      itemsContainerClassNames={itemsContainerClassNames}\n      onClose={handleClose}\n    >\n      {children}\n    </DropDownItems>,\n    document.body,\n  )\n\n  return (\n    <React.Fragment>\n      <button\n        aria-label={buttonAriaLabel}\n        className={buttonClassName + (showDropDown ? ' active' : '')}\n        data-dropdown-key={dropdownKey}\n        disabled={disabled}\n        onClick={(event) => {\n          event.preventDefault()\n          setShowDropDown(!showDropDown)\n        }}\n        onMouseDown={(e) => {\n          // This fixes a bug where you are unable to click the button if you are in a NESTED editor (editor in blocks field in editor).\n          // Thus only happens if you click on the SVG of the button. Clicking on the outside works. Related issue: https://github.com/payloadcms/payload/issues/4025\n          // TODO: Find out why exactly it happens and why e.preventDefault() on the mouseDown fixes it. Write that down here, or potentially fix a root cause, if there is any.\n          e.preventDefault()\n        }}\n        ref={buttonRef}\n        type=\"button\"\n      >\n        {Icon && <Icon />}\n        {label && <span className=\"toolbar-popup__dropdown-label\">{label}</span>}\n        <i className=\"toolbar-popup__dropdown-caret\" />\n      </button>\n\n      {showDropDown && <React.Fragment>{portal}</React.Fragment>}\n    </React.Fragment>\n  )\n}\n","'use client'\n\nimport type { FixedToolbarFeatureProps } from '../server/index.js'\n\nimport { createClientFeature } from '../../../../utilities/createClientFeature.js'\nimport { FixedToolbarPlugin } from './Toolbar/index.js'\n\nexport const FixedToolbarFeatureClient = createClientFeature<FixedToolbarFeatureProps>({\n  plugins: [\n    {\n      Component: FixedToolbarPlugin,\n      position: 'aboveContainer',\n    },\n  ],\n})\n","'use client'\nimport type { LexicalEditor } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { useLexicalEditable } from '@lexical/react/useLexicalEditable'\nimport { mergeRegister } from '@lexical/utils'\nimport {\n  $getSelection,\n  $isRangeSelection,\n  $isTextNode,\n  COMMAND_PRIORITY_LOW,\n  getDOMSelection,\n  SELECTION_CHANGE_COMMAND,\n} from 'lexical'\nimport { useCallback, useEffect, useRef, useState } from 'react'\nimport * as React from 'react'\nimport { createPortal } from 'react-dom'\n\nimport type { PluginComponentWithAnchor } from '../../../../typesClient.js'\nimport type { ToolbarGroup, ToolbarGroupItem } from '../../../types.js'\n\nimport { useEditorConfigContext } from '../../../../../lexical/config/client/EditorConfigProvider.js'\nimport { getDOMRangeRect } from '../../../../../lexical/utils/getDOMRangeRect.js'\nimport { setFloatingElemPosition } from '../../../../../lexical/utils/setFloatingElemPosition.js'\nimport { ToolbarButton } from '../../../shared/ToolbarButton/index.js'\nimport './index.scss'\nimport { ToolbarDropdown } from '../../../shared/ToolbarDropdown/index.js'\n\nfunction ButtonGroupItem({\n  anchorElem,\n  editor,\n  item,\n}: {\n  anchorElem: HTMLElement\n  editor: LexicalEditor\n  item: ToolbarGroupItem\n}): React.ReactNode {\n  if (item.Component) {\n    return (\n      item?.Component && (\n        <item.Component anchorElem={anchorElem} editor={editor} item={item} key={item.key} />\n      )\n    )\n  }\n  if (!item.ChildComponent) {\n    return null\n  }\n\n  return (\n    <ToolbarButton editor={editor} item={item} key={item.key}>\n      <item.ChildComponent />\n    </ToolbarButton>\n  )\n}\n\nfunction ToolbarGroupComponent({\n  anchorElem,\n  editor,\n  group,\n  index,\n}: {\n  anchorElem: HTMLElement\n  editor: LexicalEditor\n  group: ToolbarGroup\n  index: number\n}): React.ReactNode {\n  const { editorConfig } = useEditorConfigContext()\n\n  const [DropdownIcon, setDropdownIcon] = React.useState<React.FC | undefined>()\n\n  React.useEffect(() => {\n    if (group?.type === 'dropdown' && group.items.length && group.ChildComponent) {\n      setDropdownIcon(() => group.ChildComponent)\n    } else {\n      setDropdownIcon(undefined)\n    }\n  }, [group])\n\n  const onActiveChange = useCallback(\n    ({ activeItems }: { activeItems: ToolbarGroupItem[] }) => {\n      if (!activeItems.length) {\n        if (group?.type === 'dropdown' && group.items.length && group.ChildComponent) {\n          setDropdownIcon(() => group.ChildComponent)\n        } else {\n          setDropdownIcon(undefined)\n        }\n        return\n      }\n      const item = activeItems[0]\n      setDropdownIcon(() => item?.ChildComponent)\n    },\n    [group],\n  )\n\n  return (\n    <div\n      className={`inline-toolbar-popup__group inline-toolbar-popup__group-${group.key}`}\n      data-toolbar-group-key={group.key}\n      key={group.key}\n    >\n      {group.type === 'dropdown' && group.items.length ? (\n        DropdownIcon ? (\n          <ToolbarDropdown\n            anchorElem={anchorElem}\n            editor={editor}\n            group={group}\n            Icon={DropdownIcon}\n            maxActiveItems={group.maxActiveItems ?? 1}\n            onActiveChange={onActiveChange}\n          />\n        ) : (\n          <ToolbarDropdown\n            anchorElem={anchorElem}\n            editor={editor}\n            group={group}\n            maxActiveItems={group.maxActiveItems ?? 1}\n            onActiveChange={onActiveChange}\n          />\n        )\n      ) : null}\n      {group.type === 'buttons' && group.items.length\n        ? group.items.map((item) => {\n            return (\n              <ButtonGroupItem anchorElem={anchorElem} editor={editor} item={item} key={item.key} />\n            )\n          })\n        : null}\n      {index < editorConfig.features.toolbarInline?.groups.length - 1 && (\n        <div className=\"divider\" />\n      )}\n    </div>\n  )\n}\n\nfunction InlineToolbar({\n  anchorElem,\n  editor,\n}: {\n  anchorElem: HTMLElement\n  editor: LexicalEditor\n}): React.ReactNode {\n  const floatingToolbarRef = useRef<HTMLDivElement | null>(null)\n  const caretRef = useRef<HTMLDivElement | null>(null)\n\n  const { editorConfig } = useEditorConfigContext()\n\n  const closeFloatingToolbar = useCallback(() => {\n    if (floatingToolbarRef?.current) {\n      const isOpacityZero = floatingToolbarRef.current.style.opacity === '0'\n      const isPointerEventsNone = floatingToolbarRef.current.style.pointerEvents === 'none'\n\n      if (!isOpacityZero) {\n        floatingToolbarRef.current.style.opacity = '0'\n      }\n      if (!isPointerEventsNone) {\n        floatingToolbarRef.current.style.pointerEvents = 'none'\n      }\n    }\n  }, [floatingToolbarRef])\n\n  const mouseMoveListener = useCallback(\n    (e: MouseEvent) => {\n      if (floatingToolbarRef?.current && (e.buttons === 1 || e.buttons === 3)) {\n        const isOpacityZero = floatingToolbarRef.current.style.opacity === '0'\n        const isPointerEventsNone = floatingToolbarRef.current.style.pointerEvents === 'none'\n        if (!isOpacityZero || !isPointerEventsNone) {\n          // Check if the mouse is not over the popup\n          const x = e.clientX\n          const y = e.clientY\n          const elementUnderMouse = document.elementFromPoint(x, y)\n          if (!floatingToolbarRef.current.contains(elementUnderMouse)) {\n            // Mouse is not over the target element => not a normal click, but probably a drag\n            closeFloatingToolbar()\n          }\n        }\n      }\n    },\n    [closeFloatingToolbar],\n  )\n\n  const mouseUpListener = useCallback(() => {\n    if (floatingToolbarRef?.current) {\n      if (floatingToolbarRef.current.style.opacity !== '1') {\n        floatingToolbarRef.current.style.opacity = '1'\n      }\n      if (floatingToolbarRef.current.style.pointerEvents !== 'auto') {\n        floatingToolbarRef.current.style.pointerEvents = 'auto'\n      }\n    }\n  }, [])\n\n  useEffect(() => {\n    document.addEventListener('mousemove', mouseMoveListener)\n    document.addEventListener('mouseup', mouseUpListener)\n\n    return () => {\n      document.removeEventListener('mousemove', mouseMoveListener)\n      document.removeEventListener('mouseup', mouseUpListener)\n    }\n  }, [floatingToolbarRef, mouseMoveListener, mouseUpListener])\n\n  const $updateTextFormatFloatingToolbar = useCallback(() => {\n    const selection = $getSelection()\n\n    const nativeSelection = getDOMSelection(editor._window)\n\n    if (floatingToolbarRef.current === null) {\n      return\n    }\n\n    const possibleLinkEditor = anchorElem.querySelector(':scope > .link-editor')\n    const isLinkEditorVisible =\n      possibleLinkEditor !== null &&\n      'style' in possibleLinkEditor &&\n      possibleLinkEditor?.style?.['opacity' as keyof typeof possibleLinkEditor.style] === '1'\n\n    const rootElement = editor.getRootElement()\n    if (\n      selection !== null &&\n      nativeSelection !== null &&\n      !nativeSelection.isCollapsed &&\n      rootElement !== null &&\n      rootElement.contains(nativeSelection.anchorNode)\n    ) {\n      const rangeRect = getDOMRangeRect(nativeSelection, rootElement)\n\n      // Position floating toolbar\n      const offsetIfFlipped = setFloatingElemPosition({\n        alwaysDisplayOnTop: isLinkEditorVisible,\n        anchorElem,\n        floatingElem: floatingToolbarRef.current,\n        horizontalPosition: 'center',\n        targetRect: rangeRect,\n      })\n\n      // Position caret\n      if (caretRef.current) {\n        setFloatingElemPosition({\n          anchorElem: floatingToolbarRef.current,\n          anchorFlippedOffset: offsetIfFlipped,\n          floatingElem: caretRef.current,\n          horizontalOffset: 5,\n          horizontalPosition: 'center',\n          specialHandlingForCaret: true,\n          targetRect: rangeRect,\n          verticalGap: 8,\n        })\n      }\n    } else {\n      closeFloatingToolbar()\n    }\n  }, [editor, closeFloatingToolbar, anchorElem])\n\n  useEffect(() => {\n    const scrollerElem = anchorElem.parentElement\n\n    const update = () => {\n      editor.getEditorState().read(() => {\n        $updateTextFormatFloatingToolbar()\n      })\n    }\n\n    window.addEventListener('resize', update)\n    if (scrollerElem) {\n      scrollerElem.addEventListener('scroll', update)\n    }\n\n    return () => {\n      window.removeEventListener('resize', update)\n      if (scrollerElem) {\n        scrollerElem.removeEventListener('scroll', update)\n      }\n    }\n  }, [editor, $updateTextFormatFloatingToolbar, anchorElem])\n\n  useEffect(() => {\n    editor.getEditorState().read(() => {\n      $updateTextFormatFloatingToolbar()\n    })\n    return mergeRegister(\n      editor.registerUpdateListener(({ editorState }) => {\n        editorState.read(() => {\n          $updateTextFormatFloatingToolbar()\n        })\n      }),\n\n      editor.registerCommand(\n        SELECTION_CHANGE_COMMAND,\n        () => {\n          $updateTextFormatFloatingToolbar()\n          return false\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n    )\n  }, [editor, $updateTextFormatFloatingToolbar])\n\n  return (\n    <div className=\"inline-toolbar-popup\" ref={floatingToolbarRef}>\n      <div className=\"caret\" ref={caretRef} />\n      {editorConfig?.features &&\n        editorConfig.features?.toolbarInline?.groups.map((group, i) => {\n          return (\n            <ToolbarGroupComponent\n              anchorElem={anchorElem}\n              editor={editor}\n              group={group}\n              index={i}\n              key={group.key}\n            />\n          )\n        })}\n    </div>\n  )\n}\n\nfunction useInlineToolbar(\n  editor: LexicalEditor,\n  anchorElem: HTMLElement,\n): null | React.ReactElement {\n  const [isText, setIsText] = useState(false)\n  const isEditable = useLexicalEditable()\n\n  const updatePopup = useCallback(() => {\n    editor.getEditorState().read(() => {\n      // Should not to pop up the floating toolbar when using IME input\n      if (editor.isComposing()) {\n        return\n      }\n      const selection = $getSelection()\n      const nativeSelection = getDOMSelection(editor._window)\n      const rootElement = editor.getRootElement()\n\n      if (\n        nativeSelection !== null &&\n        (!$isRangeSelection(selection) ||\n          rootElement === null ||\n          !rootElement.contains(nativeSelection.anchorNode))\n      ) {\n        setIsText(false)\n        return\n      }\n\n      if (!$isRangeSelection(selection)) {\n        return\n      }\n\n      if (selection.getTextContent() !== '') {\n        const nodes = selection.getNodes()\n        let foundNodeWithText = false\n        for (const node of nodes) {\n          if ($isTextNode(node)) {\n            setIsText(true)\n            foundNodeWithText = true\n            break\n          }\n        }\n        if (!foundNodeWithText) {\n          setIsText(false)\n        }\n      } else {\n        setIsText(false)\n      }\n\n      const rawTextContent = selection.getTextContent().replace(/\\n/g, '')\n      if (!selection.isCollapsed() && rawTextContent === '') {\n        setIsText(false)\n        return\n      }\n    })\n  }, [editor])\n\n  useEffect(() => {\n    document.addEventListener('selectionchange', updatePopup)\n    document.addEventListener('mouseup', updatePopup)\n    return () => {\n      document.removeEventListener('selectionchange', updatePopup)\n      document.removeEventListener('mouseup', updatePopup)\n    }\n  }, [updatePopup])\n\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerUpdateListener(() => {\n        updatePopup()\n      }),\n      editor.registerRootListener(() => {\n        if (editor.getRootElement() === null) {\n          setIsText(false)\n        }\n      }),\n    )\n  }, [editor, updatePopup])\n\n  if (!isText || !isEditable) {\n    return null\n  }\n\n  return createPortal(<InlineToolbar anchorElem={anchorElem} editor={editor} />, anchorElem)\n}\n\nexport const InlineToolbarPlugin: PluginComponentWithAnchor<undefined> = ({ anchorElem }) => {\n  const [editor] = useLexicalComposerContext()\n\n  return useInlineToolbar(editor, anchorElem)\n}\n","'use client'\nexport function getDOMRangeRect(nativeSelection: Selection, rootElement: HTMLElement): DOMRect {\n  const domRange = nativeSelection.getRangeAt(0)\n\n  let rect\n\n  if (nativeSelection.anchorNode === rootElement) {\n    let inner = rootElement\n    while (inner.firstElementChild != null) {\n      inner = inner.firstElementChild as HTMLElement\n    }\n    rect = inner.getBoundingClientRect()\n  } else {\n    rect = domRange.getBoundingClientRect()\n  }\n\n  return rect\n}\n","'use client'\nconst VERTICAL_GAP = 10\nconst HORIZONTAL_OFFSET = 32\n\n// TODO: needs refactoring\n// This is supposed to position the floatingElem based on the parent (anchorElem) and the target (targetRect) which is usually the selected text.\n// So basically, it positions the floatingElem either below or above the target (targetRect) and aligns it to the left or center of the target (targetRect).\n// This is used for positioning the floating toolbar (anchor: richtext editor) and its caret (anchor: floating toolbar)\nexport function setFloatingElemPosition(args: {\n  alwaysDisplayOnTop?: boolean\n  anchorElem: HTMLElement\n  anchorFlippedOffset?: number // Offset which was added to the anchor (for caret, floating toolbar) if it was flipped\n  floatingElem: HTMLElement\n  horizontalOffset?: number\n  horizontalPosition?: 'center' | 'left'\n  specialHandlingForCaret?: boolean\n  targetRect: ClientRect | null\n  verticalGap?: number\n}): number | undefined {\n  const {\n    alwaysDisplayOnTop = false,\n    anchorElem,\n    anchorFlippedOffset = 0, // Offset which was added to the anchor (for caret, floating toolbar) if it was flipped\n    floatingElem,\n    horizontalOffset = HORIZONTAL_OFFSET,\n    horizontalPosition = 'left',\n    specialHandlingForCaret = false,\n    targetRect,\n    verticalGap = VERTICAL_GAP,\n  } = args\n  // Returns the top offset if the target was flipped\n  const scrollerElem = anchorElem.parentElement\n\n  if (targetRect === null || scrollerElem == null) {\n    floatingElem.style.opacity = '0'\n    floatingElem.style.transform = 'translate(-10000px, -10000px)'\n    return\n  }\n\n  const floatingElemRect = floatingElem.getBoundingClientRect()\n  const anchorElementRect = anchorElem.getBoundingClientRect()\n  const editorScrollerRect = scrollerElem.getBoundingClientRect()\n\n  let top = targetRect.top - floatingElemRect.height - verticalGap\n  let left = targetRect.left - horizontalOffset\n\n  if (horizontalPosition === 'center') {\n    // Calculate left to position floatingElem to the horizontal middle of targetRect\n    left = targetRect.left + targetRect.width / 2 - floatingElemRect.width / 2\n  }\n\n  let addedToTop = 0\n  if (!alwaysDisplayOnTop && top < editorScrollerRect.top && !specialHandlingForCaret) {\n    addedToTop = floatingElemRect.height + targetRect.height + verticalGap * 2\n\n    top += addedToTop\n  }\n\n  if (horizontalPosition === 'center') {\n    if (left + floatingElemRect.width > editorScrollerRect.right) {\n      left = editorScrollerRect.right - floatingElemRect.width - horizontalOffset\n    } else if (left < editorScrollerRect.left) {\n      left = editorScrollerRect.left + horizontalOffset\n    }\n  } else {\n    if (left + floatingElemRect.width > editorScrollerRect.right) {\n      left = editorScrollerRect.right - floatingElemRect.width - horizontalOffset\n    }\n  }\n\n  left -= anchorElementRect.left\n\n  floatingElem.style.opacity = '1'\n\n  if (specialHandlingForCaret && anchorFlippedOffset !== 0) {\n    // Floating select toolbar was flipped (positioned below text rather than above). Thus, the caret now needs to be positioned\n    // on the other side and rotated.\n    top -= anchorElementRect.bottom - anchorFlippedOffset + floatingElemRect.height - 3\n    // top += anchorFlippedOffset - anchorElementRect.height - floatingElemRect.height + 2\n    floatingElem.style.transform = `translate(${left}px, ${top}px) rotate(180deg)`\n  } else {\n    top -= anchorElementRect.top\n\n    floatingElem.style.transform = `translate(${left}px, ${top}px)`\n  }\n\n  return addedToTop\n}\n","'use client'\n\nimport { createClientFeature } from '../../../../utilities/createClientFeature.js'\nimport { InlineToolbarPlugin } from './Toolbar/index.js'\n\nexport const InlineToolbarFeatureClient = createClientFeature({\n  plugins: [\n    {\n      Component: InlineToolbarPlugin,\n      position: 'floatingAnchorElem',\n    },\n  ],\n})\n","'use client'\n\nimport { TableCellNode, TableNode, TableRowNode } from '@lexical/table'\n\nimport { TableIcon } from '../../../lexical/ui/icons/Table/index.js'\nimport { createClientFeature } from '../../../utilities/createClientFeature.js'\nimport { slashMenuBasicGroupWithItems } from '../../shared/slashMenu/basicGroup.js'\nimport { toolbarAddDropdownGroupWithItems } from '../../shared/toolbar/addDropdownGroup.js'\nimport { TableMarkdownTransformer } from '../markdownTransformer.js'\nimport { TableActionMenuPlugin } from './plugins/TableActionMenuPlugin/index.js'\nimport { TableCellResizerPlugin } from './plugins/TableCellResizerPlugin/index.js'\nimport { TableHoverActionsPlugin } from './plugins/TableHoverActionsPlugin/index.js'\nimport {\n  OPEN_TABLE_DRAWER_COMMAND,\n  TableContext,\n  TablePlugin,\n} from './plugins/TablePlugin/index.js'\n\nexport const TableFeatureClient = createClientFeature({\n  markdownTransformers: [TableMarkdownTransformer],\n  nodes: [TableNode, TableCellNode, TableRowNode],\n  plugins: [\n    {\n      Component: TablePlugin,\n      position: 'normal',\n    },\n    {\n      Component: TableCellResizerPlugin,\n      position: 'normal',\n    },\n    {\n      Component: TableActionMenuPlugin,\n      position: 'floatingAnchorElem',\n    },\n    {\n      Component: TableHoverActionsPlugin,\n      position: 'floatingAnchorElem',\n    },\n  ],\n  providers: [TableContext],\n  slashMenu: {\n    groups: [\n      slashMenuBasicGroupWithItems([\n        {\n          Icon: TableIcon,\n          key: 'table',\n          keywords: ['table'],\n          label: 'Table',\n          onSelect: ({ editor }) => {\n            editor.dispatchCommand(OPEN_TABLE_DRAWER_COMMAND, {})\n          },\n        },\n      ]),\n    ],\n  },\n  toolbarFixed: {\n    groups: [\n      toolbarAddDropdownGroupWithItems([\n        {\n          ChildComponent: TableIcon,\n          key: 'table',\n          label: 'Table',\n          onSelect: ({ editor }) => {\n            editor.dispatchCommand(OPEN_TABLE_DRAWER_COMMAND, {})\n          },\n        },\n      ]),\n    ],\n  },\n})\n","'use client'\nimport React from 'react'\n\nexport const TableIcon: React.FC = () => {\n  return (\n    <svg\n      className=\"icon\"\n      fill=\"none\"\n      height=\"20\"\n      viewBox=\"0 0 20 20\"\n      width=\"20\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n    >\n      <path\n        clipRule=\"evenodd\"\n        d=\"M5.33333 4.5C4.8731 4.5 4.5 4.8731 4.5 5.33333V7.5H9.5V4.5H5.33333ZM5.33333 3.5C4.32081 3.5 3.5 4.32081 3.5 5.33333V14.6667C3.5 15.6792 4.32081 16.5 5.33333 16.5H14.6667C15.6792 16.5 16.5 15.6792 16.5 14.6667V5.33333C16.5 4.32081 15.6792 3.5 14.6667 3.5H5.33333ZM10.5 4.5V7.5H15.5V5.33333C15.5 4.8731 15.1269 4.5 14.6667 4.5H10.5ZM15.5 8.5H10.5V11.5H15.5V8.5ZM15.5 12.5H10.5V15.5H14.6667C15.1269 15.5 15.5 15.1269 15.5 14.6667V12.5ZM9.5 15.5V12.5H4.5V14.6667C4.5 15.1269 4.8731 15.5 5.33333 15.5H9.5ZM4.5 11.5H9.5V8.5H4.5V11.5Z\"\n        fill=\"currentColor\"\n        fillRule=\"evenodd\"\n      />\n    </svg>\n  )\n}\n","import type { LexicalNode } from 'lexical'\n\nimport {\n  $createTableCellNode,\n  $createTableNode,\n  $createTableRowNode,\n  $isTableCellNode,\n  $isTableNode,\n  $isTableRowNode,\n  TableCellHeaderStates,\n  TableCellNode,\n  TableNode,\n  TableRowNode,\n} from '@lexical/table'\nimport { $isParagraphNode, $isTextNode } from 'lexical'\n\nimport {\n  $convertFromMarkdownString,\n  $convertToMarkdownString,\n  type ElementTransformer,\n  type Transformer,\n} from '../../packages/@lexical/markdown/index.js'\n\n// Very primitive table setup\nconst TABLE_ROW_REG_EXP = /^\\|(.+)\\|\\s?$/\n// eslint-disable-next-line regexp/no-unused-capturing-group\nconst TABLE_ROW_DIVIDER_REG_EXP = /^(\\| ?:?-*:? ?)+\\|\\s?$/\n\nexport const TableMarkdownTransformer: (props: {\n  allTransformers: Transformer[]\n}) => ElementTransformer = ({ allTransformers }) => ({\n  type: 'element',\n  dependencies: [TableNode, TableRowNode, TableCellNode],\n  export: (node: LexicalNode) => {\n    if (!$isTableNode(node)) {\n      return null\n    }\n\n    const output: string[] = []\n\n    for (const row of node.getChildren()) {\n      const rowOutput: string[] = []\n      if (!$isTableRowNode(row)) {\n        continue\n      }\n\n      let isHeaderRow = false\n      for (const cell of row.getChildren()) {\n        // It's TableCellNode, so it's just to make flow happy\n        if ($isTableCellNode(cell)) {\n          rowOutput.push(\n            $convertToMarkdownString(allTransformers, cell).replace(/\\n/g, '\\\\n').trim(),\n          )\n\n          if (cell.__headerState === TableCellHeaderStates.ROW) {\n            isHeaderRow = true\n          }\n        }\n      }\n\n      output.push(`| ${rowOutput.join(' | ')} |`)\n      if (isHeaderRow) {\n        output.push(`| ${rowOutput.map((_) => '---').join(' | ')} |`)\n      }\n    }\n\n    return output.join('\\n')\n  },\n  regExp: TABLE_ROW_REG_EXP,\n  replace: (parentNode, _1, match) => {\n    const match0 = match[0]\n    if (!match0) {\n      return\n    }\n    // Header row\n    if (TABLE_ROW_DIVIDER_REG_EXP.test(match0)) {\n      const table = parentNode.getPreviousSibling()\n      if (!table || !$isTableNode(table)) {\n        return\n      }\n\n      const rows = table.getChildren()\n      const lastRow = rows[rows.length - 1]\n      if (!lastRow || !$isTableRowNode(lastRow)) {\n        return\n      }\n\n      // Add header state to row cells\n      lastRow.getChildren().forEach((cell) => {\n        if (!$isTableCellNode(cell)) {\n          return\n        }\n        cell.setHeaderStyles(TableCellHeaderStates.ROW, TableCellHeaderStates.ROW)\n      })\n\n      // Remove line\n      parentNode.remove()\n      return\n    }\n\n    const matchCells = mapToTableCells(match0, allTransformers)\n\n    if (matchCells == null) {\n      return\n    }\n\n    const rows = [matchCells]\n    let sibling = parentNode.getPreviousSibling()\n    let maxCells = matchCells.length\n\n    while (sibling) {\n      if (!$isParagraphNode(sibling)) {\n        break\n      }\n\n      if (sibling.getChildrenSize() !== 1) {\n        break\n      }\n\n      const firstChild = sibling.getFirstChild()\n\n      if (!$isTextNode(firstChild)) {\n        break\n      }\n\n      const cells = mapToTableCells(firstChild.getTextContent(), allTransformers)\n\n      if (cells == null) {\n        break\n      }\n\n      maxCells = Math.max(maxCells, cells.length)\n      rows.unshift(cells)\n      const previousSibling = sibling.getPreviousSibling()\n      sibling.remove()\n      sibling = previousSibling\n    }\n\n    const table = $createTableNode()\n\n    for (const cells of rows) {\n      const tableRow = $createTableRowNode()\n      table.append(tableRow)\n\n      for (let i = 0; i < maxCells; i++) {\n        tableRow.append(i < cells.length ? cells[i]! : $createTableCell('', allTransformers))\n      }\n    }\n\n    const previousSibling = parentNode.getPreviousSibling()\n    if ($isTableNode(previousSibling) && getTableColumnsSize(previousSibling) === maxCells) {\n      previousSibling.append(...table.getChildren())\n      parentNode.remove()\n    } else {\n      parentNode.replace(table)\n    }\n\n    table.selectEnd()\n  },\n})\n\nfunction getTableColumnsSize(table: TableNode) {\n  const row = table.getFirstChild()\n  return $isTableRowNode(row) ? row.getChildrenSize() : 0\n}\n\nconst $createTableCell = (textContent: string, allTransformers: Transformer[]): TableCellNode => {\n  textContent = textContent.replace(/\\\\n/g, '\\n')\n  const cell = $createTableCellNode(TableCellHeaderStates.NO_STATUS)\n  $convertFromMarkdownString(textContent, allTransformers, cell)\n  return cell\n}\n\nconst mapToTableCells = (\n  textContent: string,\n  allTransformers: Transformer[],\n): Array<TableCellNode> | null => {\n  const match = textContent.match(TABLE_ROW_REG_EXP)\n  if (!match || !match[1]) {\n    return null\n  }\n  return match[1].split('|').map((text) => $createTableCell(text, allTransformers))\n}\n","'use client'\n\nimport type { TableObserver, TableSelection } from '@lexical/table'\nimport type { ElementNode } from 'lexical'\nimport type { JSX } from 'react'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { useLexicalEditable } from '@lexical/react/useLexicalEditable'\nimport {\n  $computeTableMapSkipCellCheck,\n  $deleteTableColumnAtSelection,\n  $deleteTableRowAtSelection,\n  $getNodeTriplet,\n  $getTableCellNodeFromLexicalNode,\n  $getTableColumnIndexFromTableCellNode,\n  $getTableNodeFromLexicalNodeOrThrow,\n  $getTableRowIndexFromTableCellNode,\n  $insertTableColumnAtSelection,\n  $insertTableRowAtSelection,\n  $isTableCellNode,\n  $isTableSelection,\n  $mergeCells,\n  $unmergeCell,\n  getTableElement,\n  getTableObserverFromTableElement,\n  TableCellHeaderStates,\n  TableCellNode,\n} from '@lexical/table'\nimport { mergeRegister } from '@lexical/utils'\nimport { useScrollInfo } from '@payloadcms/ui'\nimport {\n  $getSelection,\n  $isElementNode,\n  $isRangeSelection,\n  $isTextNode,\n  $setSelection,\n  COMMAND_PRIORITY_CRITICAL,\n  getDOMSelection,\n  isDOMNode,\n  SELECTION_CHANGE_COMMAND,\n} from 'lexical'\nimport * as React from 'react'\nimport { useCallback, useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\n\nimport type { PluginComponentWithAnchor } from '../../../../typesClient.js'\n\nimport './index.scss'\nimport { MeatballsIcon } from '../../../../../lexical/ui/icons/Meatballs/index.js'\n\nfunction computeSelectionCount(selection: TableSelection): {\n  columns: number\n  rows: number\n} {\n  const selectionShape = selection.getShape()\n  return {\n    columns: selectionShape.toX - selectionShape.fromX + 1,\n    rows: selectionShape.toY - selectionShape.fromY + 1,\n  }\n}\n\nfunction $canUnmerge(): boolean {\n  const selection = $getSelection()\n  if (\n    ($isRangeSelection(selection) && !selection.isCollapsed()) ||\n    ($isTableSelection(selection) && !selection.anchor.is(selection.focus)) ||\n    (!$isRangeSelection(selection) && !$isTableSelection(selection))\n  ) {\n    return false\n  }\n  const [cell] = $getNodeTriplet(selection.anchor)\n  return cell.__colSpan > 1 || cell.__rowSpan > 1\n}\n\nfunction $selectLastDescendant(node: ElementNode): void {\n  const lastDescendant = node.getLastDescendant()\n  if ($isTextNode(lastDescendant)) {\n    lastDescendant.select()\n  } else if ($isElementNode(lastDescendant)) {\n    lastDescendant.selectEnd()\n  } else if (lastDescendant !== null) {\n    lastDescendant.selectNext()\n  }\n}\n\ntype TableCellActionMenuProps = Readonly<{\n  cellMerge: boolean\n  contextRef: { current: HTMLElement | null }\n  onClose: () => void\n  setIsMenuOpen: (isOpen: boolean) => void\n  tableCellNode: TableCellNode\n}>\n\nfunction TableActionMenu({\n  cellMerge,\n  contextRef,\n  onClose,\n  setIsMenuOpen,\n  tableCellNode: _tableCellNode,\n}: TableCellActionMenuProps) {\n  const [editor] = useLexicalComposerContext()\n  const dropDownRef = useRef<HTMLDivElement | null>(null)\n  const [tableCellNode, updateTableCellNode] = useState(_tableCellNode)\n  const [selectionCounts, updateSelectionCounts] = useState({\n    columns: 1,\n    rows: 1,\n  })\n  const [canMergeCells, setCanMergeCells] = useState(false)\n  const [canUnmergeCell, setCanUnmergeCell] = useState(false)\n  const { y } = useScrollInfo()\n\n  useEffect(() => {\n    return editor.registerMutationListener(\n      TableCellNode,\n      (nodeMutations) => {\n        const nodeUpdated = nodeMutations.get(tableCellNode.getKey()) === 'updated'\n\n        if (nodeUpdated) {\n          editor.getEditorState().read(() => {\n            updateTableCellNode(tableCellNode.getLatest())\n          })\n        }\n      },\n      { skipInitialization: true },\n    )\n  }, [editor, tableCellNode])\n\n  useEffect(() => {\n    editor.getEditorState().read(() => {\n      const selection = $getSelection()\n      // Merge cells\n      if ($isTableSelection(selection)) {\n        const currentSelectionCounts = computeSelectionCount(selection)\n        updateSelectionCounts(computeSelectionCount(selection))\n\n        setCanMergeCells(currentSelectionCounts.columns > 1 || currentSelectionCounts.rows > 1)\n      }\n      // Unmerge cell\n      setCanUnmergeCell($canUnmerge())\n    })\n  }, [editor])\n\n  useEffect(() => {\n    const menuButtonElement = contextRef.current\n    const dropDownElement = dropDownRef.current\n    const rootElement = editor.getRootElement()\n\n    if (menuButtonElement != null && dropDownElement != null && rootElement != null) {\n      const rootEleRect = rootElement.getBoundingClientRect()\n      const menuButtonRect = menuButtonElement.getBoundingClientRect()\n      dropDownElement.style.opacity = '1'\n      const dropDownElementRect = dropDownElement.getBoundingClientRect()\n      const margin = 5\n      let leftPosition = menuButtonRect.right + margin\n      if (\n        leftPosition + dropDownElementRect.width > window.innerWidth ||\n        leftPosition + dropDownElementRect.width > rootEleRect.right\n      ) {\n        const position = menuButtonRect.left - dropDownElementRect.width - margin\n        leftPosition = (position < 0 ? margin : position) + window.pageXOffset\n      }\n      dropDownElement.style.left = `${leftPosition + window.pageXOffset}px`\n\n      let topPosition = menuButtonRect.top\n      if (topPosition + dropDownElementRect.height > window.innerHeight) {\n        const position = menuButtonRect.bottom - dropDownElementRect.height\n        topPosition = position < 0 ? margin : position\n      }\n      dropDownElement.style.top = `${topPosition}px`\n    }\n  }, [contextRef, dropDownRef, editor, y])\n\n  useEffect(() => {\n    function handleClickOutside(event: MouseEvent) {\n      if (\n        dropDownRef.current != null &&\n        contextRef.current != null &&\n        isDOMNode(event.target) &&\n        !dropDownRef.current.contains(event.target) &&\n        !contextRef.current.contains(event.target)\n      ) {\n        setIsMenuOpen(false)\n      }\n    }\n\n    window.addEventListener('click', handleClickOutside)\n\n    return () => window.removeEventListener('click', handleClickOutside)\n  }, [setIsMenuOpen, contextRef])\n\n  const clearTableSelection = useCallback(() => {\n    editor.update(() => {\n      if (tableCellNode.isAttached()) {\n        const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n        const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNode.getKey()))\n\n        if (tableElement === null) {\n          throw new Error('Expected to find tableElement in DOM')\n        }\n\n        const tableObserver = getTableObserverFromTableElement(tableElement)\n        if (tableObserver !== null) {\n          tableObserver.$clearHighlight()\n        }\n\n        tableNode.markDirty()\n        updateTableCellNode(tableCellNode.getLatest())\n      }\n\n      $setSelection(null)\n    })\n  }, [editor, tableCellNode])\n\n  const mergeTableCellsAtSelection = () => {\n    editor.update(() => {\n      const selection = $getSelection()\n      if (!$isTableSelection(selection)) {\n        return\n      }\n      const nodes = selection.getNodes()\n      const tableCells = nodes.filter($isTableCellNode)\n      const targetCell = $mergeCells(tableCells)\n\n      if (targetCell) {\n        $selectLastDescendant(targetCell)\n        onClose()\n      }\n    })\n  }\n\n  const unmergeTableCellsAtSelection = () => {\n    editor.update(() => {\n      $unmergeCell()\n    })\n  }\n\n  const insertTableRowAtSelection = useCallback(\n    (shouldInsertAfter: boolean) => {\n      editor.update(() => {\n        for (let i = 0; i < selectionCounts.rows; i++) {\n          $insertTableRowAtSelection(shouldInsertAfter)\n        }\n        onClose()\n      })\n    },\n    [editor, onClose, selectionCounts.rows],\n  )\n\n  const insertTableColumnAtSelection = useCallback(\n    (shouldInsertAfter: boolean) => {\n      editor.update(() => {\n        for (let i = 0; i < selectionCounts.columns; i++) {\n          $insertTableColumnAtSelection(shouldInsertAfter)\n        }\n        onClose()\n      })\n    },\n    [editor, onClose, selectionCounts.columns],\n  )\n\n  const deleteTableRowAtSelection = useCallback(() => {\n    editor.update(() => {\n      $deleteTableRowAtSelection()\n      onClose()\n    })\n  }, [editor, onClose])\n\n  const deleteTableAtSelection = useCallback(() => {\n    editor.update(() => {\n      const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n      tableNode.remove()\n\n      clearTableSelection()\n      onClose()\n    })\n  }, [editor, tableCellNode, clearTableSelection, onClose])\n\n  const deleteTableColumnAtSelection = useCallback(() => {\n    editor.update(() => {\n      $deleteTableColumnAtSelection()\n      onClose()\n    })\n  }, [editor, onClose])\n\n  const toggleTableRowIsHeader = useCallback(() => {\n    editor.update(() => {\n      const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n\n      const tableRowIndex = $getTableRowIndexFromTableCellNode(tableCellNode)\n\n      const [gridMap] = $computeTableMapSkipCellCheck(tableNode, null, null)\n\n      const rowCells = new Set<TableCellNode>()\n\n      const newStyle = tableCellNode.getHeaderStyles() ^ TableCellHeaderStates.ROW\n      if (gridMap[tableRowIndex]) {\n        for (let col = 0; col < gridMap[tableRowIndex].length; col++) {\n          const mapCell = gridMap[tableRowIndex][col]\n\n          if (!mapCell?.cell) {\n            continue\n          }\n\n          if (!rowCells.has(mapCell.cell)) {\n            rowCells.add(mapCell.cell)\n            mapCell.cell.setHeaderStyles(newStyle, TableCellHeaderStates.ROW)\n          }\n        }\n      }\n\n      clearTableSelection()\n      onClose()\n    })\n  }, [editor, tableCellNode, clearTableSelection, onClose])\n\n  const toggleTableColumnIsHeader = useCallback(() => {\n    editor.update(() => {\n      const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n\n      const tableColumnIndex = $getTableColumnIndexFromTableCellNode(tableCellNode)\n\n      const [gridMap] = $computeTableMapSkipCellCheck(tableNode, null, null)\n\n      const columnCells = new Set<TableCellNode>()\n\n      const newStyle = tableCellNode.getHeaderStyles() ^ TableCellHeaderStates.COLUMN\n      if (gridMap) {\n        for (let row = 0; row < gridMap.length; row++) {\n          const mapCell = gridMap?.[row]?.[tableColumnIndex]\n\n          if (!mapCell?.cell) {\n            continue\n          }\n\n          if (!columnCells.has(mapCell.cell)) {\n            columnCells.add(mapCell.cell)\n            mapCell.cell.setHeaderStyles(newStyle, TableCellHeaderStates.COLUMN)\n          }\n        }\n      }\n\n      clearTableSelection()\n      onClose()\n    })\n  }, [editor, tableCellNode, clearTableSelection, onClose])\n\n  const toggleRowStriping = useCallback(() => {\n    editor.update(() => {\n      if (tableCellNode.isAttached()) {\n        const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n        if (tableNode) {\n          tableNode.setRowStriping(!tableNode.getRowStriping())\n        }\n      }\n\n      clearTableSelection()\n      onClose()\n    })\n  }, [editor, tableCellNode, clearTableSelection, onClose])\n\n  const toggleFirstColumnFreeze = useCallback(() => {\n    editor.update(() => {\n      if (tableCellNode.isAttached()) {\n        const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n        if (tableNode) {\n          tableNode.setFrozenColumns(tableNode.getFrozenColumns() === 0 ? 1 : 0)\n        }\n      }\n      clearTableSelection()\n      onClose()\n    })\n  }, [editor, tableCellNode, clearTableSelection, onClose])\n\n  let mergeCellButton: JSX.Element | null = null\n  if (cellMerge) {\n    if (canMergeCells) {\n      mergeCellButton = (\n        <button\n          className=\"item\"\n          data-test-id=\"table-merge-cells\"\n          onClick={() => mergeTableCellsAtSelection()}\n          type=\"button\"\n        >\n          <span className=\"text\">Merge cells</span>\n        </button>\n      )\n    } else if (canUnmergeCell) {\n      mergeCellButton = (\n        <button\n          className=\"item\"\n          data-test-id=\"table-unmerge-cells\"\n          onClick={() => unmergeTableCellsAtSelection()}\n          type=\"button\"\n        >\n          <span className=\"text\">Unmerge cells</span>\n        </button>\n      )\n    }\n  }\n\n  return createPortal(\n    // eslint-disable-next-line jsx-a11y/no-static-element-interactions,jsx-a11y/click-events-have-key-events\n    <div\n      className=\"table-action-menu-dropdown\"\n      onClick={(e) => {\n        e.stopPropagation()\n      }}\n      ref={dropDownRef}\n    >\n      {mergeCellButton ? (\n        <React.Fragment>\n          {mergeCellButton}\n          <hr />\n        </React.Fragment>\n      ) : null}\n\n      <button\n        className=\"item\"\n        data-test-id=\"table-row-striping\"\n        onClick={() => toggleRowStriping()}\n        type=\"button\"\n      >\n        <span className=\"text\">Toggle Row Striping</span>\n      </button>\n      <button\n        className=\"item\"\n        data-test-id=\"table-freeze-first-column\"\n        onClick={() => toggleFirstColumnFreeze()}\n        type=\"button\"\n      >\n        <span className=\"text\">Toggle First Column Freeze</span>\n      </button>\n      <button\n        className=\"item\"\n        data-test-id=\"table-insert-row-above\"\n        onClick={() => insertTableRowAtSelection(false)}\n        type=\"button\"\n      >\n        <span className=\"text\">\n          Insert {selectionCounts.rows === 1 ? 'row' : `${selectionCounts.rows} rows`} above\n        </span>\n      </button>\n      <button\n        className=\"item\"\n        data-test-id=\"table-insert-row-below\"\n        onClick={() => insertTableRowAtSelection(true)}\n        type=\"button\"\n      >\n        <span className=\"text\">\n          Insert {selectionCounts.rows === 1 ? 'row' : `${selectionCounts.rows} rows`} below\n        </span>\n      </button>\n      <hr />\n      <button\n        className=\"item\"\n        data-test-id=\"table-insert-column-before\"\n        onClick={() => insertTableColumnAtSelection(false)}\n        type=\"button\"\n      >\n        <span className=\"text\">\n          Insert {selectionCounts.columns === 1 ? 'column' : `${selectionCounts.columns} columns`}{' '}\n          left\n        </span>\n      </button>\n      <button\n        className=\"item\"\n        data-test-id=\"table-insert-column-after\"\n        onClick={() => insertTableColumnAtSelection(true)}\n        type=\"button\"\n      >\n        <span className=\"text\">\n          Insert {selectionCounts.columns === 1 ? 'column' : `${selectionCounts.columns} columns`}{' '}\n          right\n        </span>\n      </button>\n      <hr />\n      <button\n        className=\"item\"\n        data-test-id=\"table-delete-columns\"\n        onClick={() => deleteTableColumnAtSelection()}\n        type=\"button\"\n      >\n        <span className=\"text\">Delete column</span>\n      </button>\n      <button\n        className=\"item\"\n        data-test-id=\"table-delete-rows\"\n        onClick={() => deleteTableRowAtSelection()}\n        type=\"button\"\n      >\n        <span className=\"text\">Delete row</span>\n      </button>\n      <button\n        className=\"item\"\n        data-test-id=\"table-delete\"\n        onClick={() => deleteTableAtSelection()}\n        type=\"button\"\n      >\n        <span className=\"text\">Delete table</span>\n      </button>\n      <hr />\n      <button\n        className=\"item\"\n        data-test-id=\"table-row-header\"\n        onClick={() => toggleTableRowIsHeader()}\n        type=\"button\"\n      >\n        <span className=\"text\">\n          {(tableCellNode.__headerState & TableCellHeaderStates.ROW) === TableCellHeaderStates.ROW\n            ? 'Remove'\n            : 'Add'}{' '}\n          row header\n        </span>\n      </button>\n      <button\n        className=\"item\"\n        data-test-id=\"table-column-header\"\n        onClick={() => toggleTableColumnIsHeader()}\n        type=\"button\"\n      >\n        <span className=\"text\">\n          {(tableCellNode.__headerState & TableCellHeaderStates.COLUMN) ===\n          TableCellHeaderStates.COLUMN\n            ? 'Remove'\n            : 'Add'}{' '}\n          column header\n        </span>\n      </button>\n    </div>,\n    document.body,\n  )\n}\n\nfunction TableCellActionMenuContainer({\n  anchorElem,\n  cellMerge,\n}: {\n  anchorElem: HTMLElement\n  cellMerge: boolean\n}): JSX.Element {\n  const [editor] = useLexicalComposerContext()\n\n  const menuButtonRef = useRef<HTMLDivElement | null>(null)\n  const menuRootRef = useRef<HTMLButtonElement | null>(null)\n  const [isMenuOpen, setIsMenuOpen] = useState(false)\n\n  const [tableCellNode, setTableMenuCellNode] = useState<null | TableCellNode>(null)\n\n  const $moveMenu = useCallback(() => {\n    const menu = menuButtonRef.current\n    const selection = $getSelection()\n    const nativeSelection = getDOMSelection(editor._window)\n    const activeElement = document.activeElement\n    function disable() {\n      if (menu) {\n        menu.classList.remove('table-cell-action-button-container--active')\n        menu.classList.add('table-cell-action-button-container--inactive')\n      }\n      setTableMenuCellNode(null)\n    }\n\n    if (selection == null || menu == null) {\n      return disable()\n    }\n\n    const rootElement = editor.getRootElement()\n    let tableObserver: null | TableObserver = null\n    let tableCellParentNodeDOM: HTMLElement | null = null\n\n    if (\n      $isRangeSelection(selection) &&\n      rootElement !== null &&\n      nativeSelection !== null &&\n      rootElement.contains(nativeSelection.anchorNode)\n    ) {\n      const tableCellNodeFromSelection = $getTableCellNodeFromLexicalNode(\n        selection.anchor.getNode(),\n      )\n\n      if (tableCellNodeFromSelection == null) {\n        return disable()\n      }\n\n      tableCellParentNodeDOM = editor.getElementByKey(tableCellNodeFromSelection.getKey())\n\n      if (tableCellParentNodeDOM == null || !tableCellNodeFromSelection.isAttached()) {\n        return disable()\n      }\n\n      const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNodeFromSelection)\n      const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNode.getKey()))\n\n      if (tableElement === null) {\n        throw new Error('TableActionMenu: Expected to find tableElement in DOM')\n      }\n\n      tableObserver = getTableObserverFromTableElement(tableElement)\n      setTableMenuCellNode(tableCellNodeFromSelection)\n    } else if ($isTableSelection(selection)) {\n      const anchorNode = $getTableCellNodeFromLexicalNode(selection.anchor.getNode())\n      if (!$isTableCellNode(anchorNode)) {\n        throw new Error('TableSelection anchorNode must be a TableCellNode')\n      }\n      const tableNode = $getTableNodeFromLexicalNodeOrThrow(anchorNode)\n      const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNode.getKey()))\n\n      if (tableElement === null) {\n        throw new Error('TableActionMenu: Expected to find tableElement in DOM')\n      }\n\n      tableObserver = getTableObserverFromTableElement(tableElement)\n      tableCellParentNodeDOM = editor.getElementByKey(anchorNode.getKey())\n    } else if (!activeElement) {\n      return disable()\n    }\n    if (tableObserver === null || tableCellParentNodeDOM === null) {\n      return disable()\n    }\n    const enabled = !tableObserver || !tableObserver.isSelecting\n    menu.classList.toggle('table-cell-action-button-container--active', enabled)\n    menu.classList.toggle('table-cell-action-button-container--inactive', !enabled)\n    if (enabled) {\n      const tableCellRect = tableCellParentNodeDOM.getBoundingClientRect()\n      const anchorRect = anchorElem.getBoundingClientRect()\n      const top = tableCellRect.top - anchorRect.top\n      const left = tableCellRect.right - anchorRect.left\n      menu.style.transform = `translate(${left}px, ${top}px)`\n    }\n  }, [editor, anchorElem])\n\n  useEffect(() => {\n    // We call the $moveMenu callback every time the selection changes,\n    // once up front, and once after each pointerup\n    let timeoutId: ReturnType<typeof setTimeout> | undefined = undefined\n    const callback = () => {\n      timeoutId = undefined\n      editor.getEditorState().read($moveMenu)\n    }\n    const delayedCallback = () => {\n      if (timeoutId === undefined) {\n        timeoutId = setTimeout(callback, 0)\n      }\n      return false\n    }\n    return mergeRegister(\n      editor.registerUpdateListener(delayedCallback),\n      editor.registerCommand(SELECTION_CHANGE_COMMAND, delayedCallback, COMMAND_PRIORITY_CRITICAL),\n      editor.registerRootListener((rootElement, prevRootElement) => {\n        if (prevRootElement) {\n          prevRootElement.removeEventListener('pointerup', delayedCallback)\n        }\n        if (rootElement) {\n          rootElement.addEventListener('pointerup', delayedCallback)\n          delayedCallback()\n        }\n      }),\n      () => clearTimeout(timeoutId),\n    )\n  })\n\n  const prevTableCellDOM = useRef(tableCellNode)\n\n  useEffect(() => {\n    if (prevTableCellDOM.current !== tableCellNode) {\n      setIsMenuOpen(false)\n    }\n\n    prevTableCellDOM.current = tableCellNode\n  }, [prevTableCellDOM, tableCellNode])\n\n  return (\n    <div className=\"table-cell-action-button-container\" ref={menuButtonRef}>\n      {tableCellNode != null && (\n        <React.Fragment>\n          <button\n            className=\"table-cell-action-button\"\n            onClick={(e) => {\n              e.stopPropagation()\n              setIsMenuOpen(!isMenuOpen)\n            }}\n            ref={menuRootRef}\n            type=\"button\"\n          >\n            <MeatballsIcon />\n          </button>\n          {isMenuOpen && (\n            <TableActionMenu\n              cellMerge={cellMerge}\n              contextRef={menuRootRef}\n              onClose={() => setIsMenuOpen(false)}\n              setIsMenuOpen={setIsMenuOpen}\n              tableCellNode={tableCellNode}\n            />\n          )}\n        </React.Fragment>\n      )}\n    </div>\n  )\n}\n\nexport const TableActionMenuPlugin: PluginComponentWithAnchor = ({ anchorElem }) => {\n  const isEditable = useLexicalEditable()\n  return createPortal(\n    isEditable ? (\n      <TableCellActionMenuContainer anchorElem={anchorElem ?? document.body} cellMerge />\n    ) : null,\n    anchorElem ?? document.body,\n  )\n}\n","'use client'\nimport React from 'react'\n\nexport const MeatballsIcon: React.FC = () => (\n  <svg fill=\"none\" height=\"18\" viewBox=\"0 0 20 20\" width=\"18\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path\n      d=\"M5 11C5.55228 11 6 10.5523 6 10C6 9.44772 5.55228 9 5 9C4.44772 9 4 9.44772 4 10C4 10.5523 4.44772 11 5 11Z\"\n      fill=\"currentColor\"\n    />\n    <path\n      d=\"M10 11C10.5523 11 11 10.5523 11 10C11 9.44772 10.5523 9 10 9C9.44772 9 9 9.44772 9 10C9 10.5523 9.44772 11 10 11Z\"\n      fill=\"currentColor\"\n    />\n    <path\n      d=\"M15 11C15.5523 11 16 10.5523 16 10C16 9.44772 15.5523 9 15 9C14.4477 9 14 9.44772 14 10C14 10.5523 14.4477 11 15 11Z\"\n      fill=\"currentColor\"\n    />\n  </svg>\n)\n","'use client'\n\nimport type { TableCellNode, TableDOMCell, TableMapType } from '@lexical/table'\nimport type { LexicalEditor, NodeKey } from 'lexical'\nimport type { JSX, MouseEventHandler } from 'react'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { useLexicalEditable } from '@lexical/react/useLexicalEditable'\nimport {\n  $computeTableMapSkipCellCheck,\n  $getTableNodeFromLexicalNodeOrThrow,\n  $getTableRowIndexFromTableCellNode,\n  $isTableCellNode,\n  $isTableRowNode,\n  getDOMCellFromTarget,\n  getTableElement,\n  TableNode,\n} from '@lexical/table'\nimport { calculateZoomLevel, mergeRegister } from '@lexical/utils'\nimport { $getNearestNodeFromDOMNode, isHTMLElement, SKIP_SCROLL_INTO_VIEW_TAG } from 'lexical'\nimport * as React from 'react'\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\n\nimport type { PluginComponent } from '../../../../typesClient.js'\n\nimport './index.scss'\nimport { useEditorConfigContext } from '../../../../../lexical/config/client/EditorConfigProvider.js'\n\ntype MousePosition = {\n  x: number\n  y: number\n}\n\ntype MouseDraggingDirection = 'bottom' | 'right'\n\nconst MIN_ROW_HEIGHT = 33\nconst MIN_COLUMN_WIDTH = 92\n\nfunction TableCellResizer({ editor }: { editor: LexicalEditor }): JSX.Element {\n  const targetRef = useRef<HTMLElement | null>(null)\n  const resizerRef = useRef<HTMLDivElement | null>(null)\n  const tableRectRef = useRef<ClientRect | null>(null)\n  const [hasTable, setHasTable] = useState(false)\n  const editorConfig = useEditorConfigContext()\n\n  const mouseStartPosRef = useRef<MousePosition | null>(null)\n  const [mouseCurrentPos, updateMouseCurrentPos] = useState<MousePosition | null>(null)\n\n  const [activeCell, updateActiveCell] = useState<null | TableDOMCell>(null)\n  const [isMouseDown, updateIsMouseDown] = useState<boolean>(false)\n  const [draggingDirection, updateDraggingDirection] = useState<MouseDraggingDirection | null>(null)\n\n  const resetState = useCallback(() => {\n    updateActiveCell(null)\n    targetRef.current = null\n    updateDraggingDirection(null)\n    mouseStartPosRef.current = null\n    tableRectRef.current = null\n  }, [])\n\n  const isMouseDownOnEvent = (event: MouseEvent) => {\n    return (event.buttons & 1) === 1\n  }\n\n  useEffect(() => {\n    const tableKeys = new Set<NodeKey>()\n    return mergeRegister(\n      editor.registerMutationListener(TableNode, (nodeMutations) => {\n        for (const [nodeKey, mutation] of nodeMutations) {\n          if (mutation === 'destroyed') {\n            tableKeys.delete(nodeKey)\n          } else {\n            tableKeys.add(nodeKey)\n          }\n        }\n        setHasTable(tableKeys.size > 0)\n      }),\n      editor.registerNodeTransform(TableNode, (tableNode) => {\n        if (tableNode.getColWidths()) {\n          return tableNode\n        }\n\n        const numColumns = tableNode.getColumnCount()\n        const columnWidth = MIN_COLUMN_WIDTH\n\n        tableNode.setColWidths(Array(numColumns).fill(columnWidth))\n        return tableNode\n      }),\n    )\n  }, [editor])\n\n  useEffect(() => {\n    if (!hasTable) {\n      return\n    }\n\n    const onMouseMove = (event: MouseEvent) => {\n      const target = event.target\n      if (!isHTMLElement(target)) {\n        return\n      }\n\n      if (draggingDirection) {\n        updateMouseCurrentPos({\n          x: event.clientX,\n          y: event.clientY,\n        })\n        return\n      }\n      updateIsMouseDown(isMouseDownOnEvent(event))\n      if (resizerRef.current && resizerRef.current.contains(target)) {\n        return\n      }\n\n      if (targetRef.current !== target) {\n        targetRef.current = target\n        const cell = getDOMCellFromTarget(target)\n\n        if (cell && activeCell !== cell) {\n          editor.getEditorState().read(\n            () => {\n              const tableCellNode = $getNearestNodeFromDOMNode(cell.elem)\n\n              if (!tableCellNode) {\n                throw new Error('TableCellResizer: Table cell node not found.')\n              }\n\n              const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n              const tableElement = getTableElement(\n                tableNode,\n                editor.getElementByKey(tableNode.getKey()),\n              )\n              if (!tableElement) {\n                throw new Error('TableCellResizer: Table element not found.')\n              }\n\n              targetRef.current = target\n              tableRectRef.current = tableElement.getBoundingClientRect()\n              updateActiveCell(cell)\n            },\n            { editor },\n          )\n        } else if (cell == null) {\n          resetState()\n        }\n      }\n    }\n\n    const onMouseDown = (event: MouseEvent) => {\n      updateIsMouseDown(true)\n    }\n\n    const onMouseUp = (event: MouseEvent) => {\n      updateIsMouseDown(false)\n    }\n\n    const removeRootListener = editor.registerRootListener((rootElement, prevRootElement) => {\n      prevRootElement?.removeEventListener('mousemove', onMouseMove)\n      prevRootElement?.removeEventListener('mousedown', onMouseDown)\n      prevRootElement?.removeEventListener('mouseup', onMouseUp)\n      rootElement?.addEventListener('mousemove', onMouseMove)\n      rootElement?.addEventListener('mousedown', onMouseDown)\n      rootElement?.addEventListener('mouseup', onMouseUp)\n    })\n\n    return () => {\n      removeRootListener()\n    }\n  }, [activeCell, draggingDirection, editor, hasTable, resetState])\n\n  const isHeightChanging = (direction: MouseDraggingDirection) => {\n    if (direction === 'bottom') {\n      return true\n    }\n    return false\n  }\n\n  const updateRowHeight = useCallback(\n    (heightChange: number) => {\n      if (!activeCell) {\n        throw new Error('TableCellResizer: Expected active cell.')\n      }\n\n      editor.update(\n        () => {\n          const tableCellNode = $getNearestNodeFromDOMNode(activeCell.elem)\n          if (!$isTableCellNode(tableCellNode)) {\n            throw new Error('TableCellResizer: Table cell node not found.')\n          }\n\n          const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n\n          const baseRowIndex = $getTableRowIndexFromTableCellNode(tableCellNode)\n          const tableRows = tableNode.getChildren()\n\n          // Determine if this is a full row merge by checking colspan\n          const isFullRowMerge = tableCellNode.getColSpan() === tableNode.getColumnCount()\n\n          // For full row merges, apply to first row. For partial merges, apply to last row\n          const tableRowIndex = isFullRowMerge\n            ? baseRowIndex\n            : baseRowIndex + tableCellNode.getRowSpan() - 1\n\n          if (tableRowIndex >= tableRows.length || tableRowIndex < 0) {\n            throw new Error('Expected table cell to be inside of table row.')\n          }\n\n          const tableRow = tableRows[tableRowIndex]\n\n          if (!$isTableRowNode(tableRow)) {\n            throw new Error('Expected table row')\n          }\n\n          let height = tableRow.getHeight()\n          if (height === undefined) {\n            const rowCells = tableRow.getChildren<TableCellNode>()\n            height = Math.min(\n              ...rowCells.map((cell) => getCellNodeHeight(cell, editor) ?? Infinity),\n            )\n          }\n\n          const newHeight = Math.max(height + heightChange, MIN_ROW_HEIGHT)\n          tableRow.setHeight(newHeight)\n        },\n        { tag: SKIP_SCROLL_INTO_VIEW_TAG },\n      )\n    },\n    [activeCell, editor],\n  )\n\n  const getCellNodeHeight = (\n    cell: TableCellNode,\n    activeEditor: LexicalEditor,\n  ): number | undefined => {\n    const domCellNode = activeEditor.getElementByKey(cell.getKey())\n    return domCellNode?.clientHeight\n  }\n\n  const getCellColumnIndex = (tableCellNode: TableCellNode, tableMap: TableMapType) => {\n    let columnIndex: number | undefined\n    tableMap.forEach((row) => {\n      row.forEach((cell, columnIndexInner) => {\n        if (cell.cell === tableCellNode) {\n          columnIndex = columnIndexInner\n        }\n      })\n    })\n    return columnIndex\n  }\n\n  const updateColumnWidth = useCallback(\n    (widthChange: number) => {\n      if (!activeCell) {\n        throw new Error('TableCellResizer: Expected active cell.')\n      }\n      editor.update(\n        () => {\n          const tableCellNode = $getNearestNodeFromDOMNode(activeCell.elem)\n          if (!$isTableCellNode(tableCellNode)) {\n            throw new Error('TableCellResizer: Table cell node not found.')\n          }\n\n          const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n          const [tableMap] = $computeTableMapSkipCellCheck(tableNode, null, null)\n          const columnIndex = getCellColumnIndex(tableCellNode, tableMap)\n          if (columnIndex === undefined) {\n            throw new Error('TableCellResizer: Table column not found.')\n          }\n\n          const colWidths = tableNode.getColWidths()\n          if (!colWidths) {\n            return\n          }\n          const width = colWidths[columnIndex]\n          if (width === undefined) {\n            return\n          }\n          const newColWidths = [...colWidths]\n          const newWidth = Math.max(width + widthChange, MIN_COLUMN_WIDTH)\n          newColWidths[columnIndex] = newWidth\n          tableNode.setColWidths(newColWidths)\n        },\n        { tag: SKIP_SCROLL_INTO_VIEW_TAG },\n      )\n    },\n    [activeCell, editor],\n  )\n\n  const mouseUpHandler = useCallback(\n    (direction: MouseDraggingDirection) => {\n      const handler = (event: MouseEvent) => {\n        event.preventDefault()\n        event.stopPropagation()\n\n        if (!activeCell) {\n          throw new Error('TableCellResizer: Expected active cell.')\n        }\n\n        if (mouseStartPosRef.current) {\n          const { x, y } = mouseStartPosRef.current\n\n          if (activeCell === null) {\n            return\n          }\n          const zoom = calculateZoomLevel(event.target as Element)\n\n          if (isHeightChanging(direction)) {\n            const heightChange = (event.clientY - y) / zoom\n            updateRowHeight(heightChange)\n          } else {\n            const widthChange = (event.clientX - x) / zoom\n            updateColumnWidth(widthChange)\n          }\n\n          resetState()\n          document.removeEventListener('mouseup', handler)\n        }\n      }\n      return handler\n    },\n    [activeCell, resetState, updateColumnWidth, updateRowHeight],\n  )\n\n  const toggleResize = useCallback(\n    (direction: MouseDraggingDirection): MouseEventHandler<HTMLDivElement> =>\n      (event) => {\n        event.preventDefault()\n        event.stopPropagation()\n\n        if (!activeCell) {\n          throw new Error('TableCellResizer: Expected active cell.')\n        }\n\n        mouseStartPosRef.current = {\n          x: event.clientX,\n          y: event.clientY,\n        }\n        updateMouseCurrentPos(mouseStartPosRef.current)\n        updateDraggingDirection(direction)\n\n        document.addEventListener('mouseup', mouseUpHandler(direction))\n      },\n    [activeCell, mouseUpHandler],\n  )\n\n  const [resizerStyles, setResizerStyles] = useState<{\n    bottom?: null | React.CSSProperties\n    left?: null | React.CSSProperties\n    right?: null | React.CSSProperties\n    top?: null | React.CSSProperties\n  }>({\n    bottom: null,\n    left: null,\n    right: null,\n    top: null,\n  })\n\n  useEffect(() => {\n    if (activeCell) {\n      const { height, left, top, width } = activeCell.elem.getBoundingClientRect()\n      const zoom = calculateZoomLevel(activeCell.elem)\n      const zoneWidth = 10 // Pixel width of the zone where you can drag the edge\n      const styles = {\n        bottom: {\n          backgroundColor: 'none',\n          cursor: 'row-resize',\n          height: `${zoneWidth}px`,\n          left: `${window.scrollX + left}px`,\n          top: `${window.scrollY + top + height - zoneWidth / 2}px`,\n          width: `${width}px`,\n        },\n        right: {\n          backgroundColor: 'none',\n          cursor: 'col-resize',\n          height: `${height}px`,\n          left: `${window.scrollX + left + width - zoneWidth / 2}px`,\n          top: `${window.scrollY + top}px`,\n          width: `${zoneWidth}px`,\n        },\n      }\n\n      const tableRect = tableRectRef.current\n\n      if (draggingDirection && mouseCurrentPos && tableRect) {\n        if (isHeightChanging(draggingDirection)) {\n          styles[draggingDirection].left = `${window.scrollX + tableRect.left}px`\n          styles[draggingDirection].top = `${window.scrollY + mouseCurrentPos.y / zoom}px`\n          styles[draggingDirection].height = '3px'\n          styles[draggingDirection].width = `${tableRect.width}px`\n        } else {\n          styles[draggingDirection].top = `${window.scrollY + tableRect.top}px`\n          styles[draggingDirection].left = `${window.scrollX + mouseCurrentPos.x / zoom}px`\n          styles[draggingDirection].width = '3px'\n          styles[draggingDirection].height = `${tableRect.height}px`\n        }\n\n        styles[draggingDirection].backgroundColor = '#adf'\n      }\n\n      setResizerStyles(styles)\n    } else {\n      setResizerStyles({\n        bottom: null,\n        left: null,\n        right: null,\n        top: null,\n      })\n    }\n  }, [activeCell, draggingDirection, mouseCurrentPos])\n\n  return (\n    <div ref={resizerRef}>\n      {activeCell != null && !isMouseDown && (\n        <React.Fragment>\n          <div\n            className={`${editorConfig.editorConfig.lexical.theme.tableCellResizer} TableCellResizer__ui`}\n            onMouseDown={toggleResize('right')}\n            style={resizerStyles.right || undefined}\n          />\n          <div\n            className={`${editorConfig.editorConfig.lexical.theme.tableCellResizer} TableCellResizer__ui`}\n            onMouseDown={toggleResize('bottom')}\n            style={resizerStyles.bottom || undefined}\n          />\n        </React.Fragment>\n      )}\n    </div>\n  )\n}\n\nexport const TableCellResizerPlugin: PluginComponent = () => {\n  const [editor] = useLexicalComposerContext()\n  const isEditable = useLexicalEditable()\n\n  return useMemo(\n    () => (isEditable ? createPortal(<TableCellResizer editor={editor} />, document.body) : null),\n    [editor, isEditable],\n  )\n}\n","'use client'\n\nimport type { TableCellNode, TableRowNode } from '@lexical/table'\nimport type { EditorConfig, NodeKey } from 'lexical'\nimport type { JSX } from 'react'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { useLexicalEditable } from '@lexical/react/useLexicalEditable'\nimport {\n  $getTableAndElementByKey,\n  $getTableColumnIndexFromTableCellNode,\n  $getTableRowIndexFromTableCellNode,\n  $insertTableColumnAtSelection,\n  $insertTableRowAtSelection,\n  $isTableCellNode,\n  $isTableNode,\n  getTableElement,\n  TableNode,\n} from '@lexical/table'\nimport { $findMatchingParent, mergeRegister } from '@lexical/utils'\nimport { $getNearestNodeFromDOMNode, isHTMLElement } from 'lexical'\nimport { useEffect, useMemo, useRef, useState } from 'react'\nimport * as React from 'react'\nimport { createPortal } from 'react-dom'\n\nimport { useEditorConfigContext } from '../../../../../lexical/config/client/EditorConfigProvider.js'\nimport { useDebounce } from '../../utils/useDebounce.js'\n\nconst BUTTON_WIDTH_PX = 20\n\nfunction TableHoverActionsContainer({\n  anchorElem,\n}: {\n  anchorElem: HTMLElement\n}): JSX.Element | null {\n  const [editor] = useLexicalComposerContext()\n  const isEditable = useLexicalEditable()\n\n  const editorConfig = useEditorConfigContext()\n  const [isShownRow, setShownRow] = useState<boolean>(false)\n  const [isShownColumn, setShownColumn] = useState<boolean>(false)\n  const [shouldListenMouseMove, setShouldListenMouseMove] = useState<boolean>(false)\n  const [position, setPosition] = useState({})\n  const tableSetRef = useRef<Set<NodeKey>>(new Set())\n  const tableCellDOMNodeRef = useRef<HTMLElement | null>(null)\n\n  const debouncedOnMouseMove = useDebounce(\n    (event: MouseEvent) => {\n      const { isOutside, tableDOMNode } = getMouseInfo(event, editorConfig.editorConfig?.lexical)\n\n      if (isOutside) {\n        setShownRow(false)\n        setShownColumn(false)\n        return\n      }\n\n      if (!tableDOMNode) {\n        return\n      }\n\n      tableCellDOMNodeRef.current = tableDOMNode\n\n      let hoveredRowNode: null | TableCellNode = null\n      let hoveredColumnNode: null | TableCellNode = null\n      let tableDOMElement: HTMLElement | null = null\n\n      editor.getEditorState().read(\n        () => {\n          const maybeTableCell = $getNearestNodeFromDOMNode(tableDOMNode)\n\n          if ($isTableCellNode(maybeTableCell)) {\n            const table = $findMatchingParent(maybeTableCell, (node) => $isTableNode(node))\n            if (!$isTableNode(table)) {\n              return\n            }\n\n            tableDOMElement = getTableElement(table, editor.getElementByKey(table.getKey()))\n\n            if (tableDOMElement) {\n              const rowCount = table.getChildrenSize()\n              const colCount = (table.getChildAtIndex(0) as TableRowNode)?.getChildrenSize()\n\n              const rowIndex = $getTableRowIndexFromTableCellNode(maybeTableCell)\n              const colIndex = $getTableColumnIndexFromTableCellNode(maybeTableCell)\n\n              if (rowIndex === rowCount - 1) {\n                hoveredRowNode = maybeTableCell\n              } else if (colIndex === colCount - 1) {\n                hoveredColumnNode = maybeTableCell\n              }\n            }\n          }\n        },\n        { editor },\n      )\n\n      if (!tableDOMElement) {\n        return\n      }\n\n      // this is the scrollable div container of the table (in case of overflow)\n      const tableContainerElement = (tableDOMElement as HTMLTableElement).parentElement\n\n      if (!tableContainerElement) {\n        return\n      }\n\n      const {\n        bottom: tableElemBottom,\n        height: tableElemHeight,\n        left: tableElemLeft,\n        right: tableElemRight,\n        width: tableElemWidth,\n        y: tableElemY,\n      } = (tableDOMElement as HTMLTableElement).getBoundingClientRect()\n\n      let tableHasScroll = false\n      if (\n        tableContainerElement &&\n        tableContainerElement.classList.contains('LexicalEditorTheme__tableScrollableWrapper')\n      ) {\n        tableHasScroll = tableContainerElement.scrollWidth > tableContainerElement.clientWidth\n      }\n\n      const { left: editorElemLeft, y: editorElemY } = anchorElem.getBoundingClientRect()\n\n      if (hoveredRowNode) {\n        setShownColumn(false)\n        setShownRow(true)\n        setPosition({\n          height: BUTTON_WIDTH_PX,\n          left:\n            tableHasScroll && tableContainerElement\n              ? tableContainerElement.offsetLeft\n              : tableElemLeft - editorElemLeft,\n          top: tableElemBottom - editorElemY + 5,\n          width:\n            tableHasScroll && tableContainerElement\n              ? tableContainerElement.offsetWidth\n              : tableElemWidth,\n        })\n      } else if (hoveredColumnNode) {\n        setShownColumn(true)\n        setShownRow(false)\n        setPosition({\n          height: tableElemHeight,\n          left: tableElemRight - editorElemLeft + 5,\n          top: tableElemY - editorElemY,\n          width: BUTTON_WIDTH_PX,\n        })\n      }\n    },\n    50,\n    250,\n  )\n\n  // Hide the buttons on any table dimensions change to prevent last row cells\n  // overlap behind the 'Add Row' button when text entry changes cell height\n  const tableResizeObserver = useMemo(() => {\n    return new ResizeObserver(() => {\n      setShownRow(false)\n      setShownColumn(false)\n    })\n  }, [])\n\n  useEffect(() => {\n    if (!shouldListenMouseMove) {\n      return\n    }\n\n    document.addEventListener('mousemove', debouncedOnMouseMove)\n\n    return () => {\n      setShownRow(false)\n      setShownColumn(false)\n\n      document.removeEventListener('mousemove', debouncedOnMouseMove)\n    }\n  }, [shouldListenMouseMove, debouncedOnMouseMove])\n\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerMutationListener(\n        TableNode,\n        (mutations) => {\n          editor.getEditorState().read(\n            () => {\n              let resetObserver = false\n              for (const [key, type] of mutations) {\n                switch (type) {\n                  case 'created': {\n                    tableSetRef.current.add(key)\n                    resetObserver = true\n                    break\n                  }\n                  case 'destroyed': {\n                    tableSetRef.current.delete(key)\n                    resetObserver = true\n                    break\n                  }\n                  default:\n                    break\n                }\n              }\n              if (resetObserver) {\n                // Reset resize observers\n                tableResizeObserver.disconnect()\n                for (const tableKey of tableSetRef.current) {\n                  const { tableElement } = $getTableAndElementByKey(tableKey)\n                  tableResizeObserver.observe(tableElement)\n                }\n                setShouldListenMouseMove(tableSetRef.current.size > 0)\n              }\n            },\n            { editor },\n          )\n        },\n        { skipInitialization: false },\n      ),\n    )\n  }, [editor, tableResizeObserver])\n\n  const insertAction = (insertRow: boolean) => {\n    editor.update(() => {\n      if (tableCellDOMNodeRef.current) {\n        const maybeTableNode = $getNearestNodeFromDOMNode(tableCellDOMNodeRef.current)\n        maybeTableNode?.selectEnd()\n        if (insertRow) {\n          $insertTableRowAtSelection()\n          setShownRow(false)\n        } else {\n          $insertTableColumnAtSelection()\n          setShownColumn(false)\n        }\n      }\n    })\n  }\n\n  if (!isEditable) {\n    return null\n  }\n\n  return (\n    <>\n      {isShownRow && (\n        <button\n          aria-label=\"Add Row\"\n          className={editorConfig.editorConfig.lexical.theme.tableAddRows}\n          onClick={() => insertAction(true)}\n          style={{ ...position }}\n          type=\"button\"\n        />\n      )}\n      {isShownColumn && (\n        <button\n          aria-label=\"Add Column\"\n          className={editorConfig.editorConfig.lexical.theme.tableAddColumns}\n          onClick={() => insertAction(false)}\n          style={{ ...position }}\n          type=\"button\"\n        />\n      )}\n    </>\n  )\n}\n\nfunction getMouseInfo(\n  event: MouseEvent,\n  editorConfig: EditorConfig,\n): {\n  isOutside: boolean\n  tableDOMNode: HTMLElement | null\n} {\n  const target = event.target\n\n  if (isHTMLElement(target)) {\n    const tableDOMNode = target.closest<HTMLElement>(\n      `td.${editorConfig.theme.tableCell}, th.${editorConfig.theme.tableCell}`,\n    )\n\n    const isOutside = !(\n      tableDOMNode ||\n      target.closest<HTMLElement>(`button.${editorConfig.theme.tableAddRows}`) ||\n      target.closest<HTMLElement>(`button.${editorConfig.theme.tableAddColumns}`) ||\n      target.closest<HTMLElement>(`div.${editorConfig.theme.tableCellResizer}`)\n    )\n\n    return { isOutside, tableDOMNode }\n  } else {\n    return { isOutside: true, tableDOMNode: null }\n  }\n}\n\nexport function TableHoverActionsPlugin({\n  anchorElem = document.body,\n}: {\n  anchorElem?: HTMLElement\n}): null | React.ReactPortal {\n  const isEditable = useLexicalEditable()\n\n  if (!isEditable) {\n    return null\n  }\n\n  return createPortal(<TableHoverActionsContainer anchorElem={anchorElem} />, anchorElem)\n}\n","'use client'\nimport { useCallback, useEffect, useRef } from 'react'\n\nimport debounce from './debounce.js'\n\n// Define the type for debounced function that includes cancel method\ninterface DebouncedFunction<T extends (...args: any[]) => any> {\n  (...args: Parameters<T>): ReturnType<T>\n  cancel: () => void\n}\n\nexport function useDebounce<T extends (...args: never[]) => void>(\n  fn: T,\n  ms: number,\n  maxWait?: number,\n) {\n  // Update the ref type to include cancel method\n  const debouncedRef = useRef<DebouncedFunction<T> | null>(null)\n\n  useEffect(() => {\n    debouncedRef.current = debounce(fn, ms, { maxWait }) as DebouncedFunction<T>\n\n    return () => {\n      debouncedRef.current?.cancel()\n    }\n  }, [fn, ms, maxWait])\n\n  const callback = useCallback((...args: Parameters<T>) => {\n    if (debouncedRef.current) {\n      debouncedRef.current(...args)\n    }\n  }, [])\n\n  return callback\n}\n","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck - not worth it migrate jsdoc to tsdoc\n'use client'\n// Copied & modified from https://github.com/lodash/lodash/blob/main/src/debounce.ts\n/*\nThe MIT License\n\nCopyright JS Foundation and other contributors <https://js.foundation/>\n\nBased on Underscore.js, copyright Jeremy Ashkenas,\nDocumentCloud and Investigative Reporters & Editors <http://underscorejs.org/>\n\nThis software consists of voluntary contributions made by many\nindividuals. For exact contribution history, see the revision history\navailable at https://github.com/lodash/lodash\n\nThe following license applies to all parts of this software except as\ndocumented below:\n\n====\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n====\n\nCopyright and related rights for sample code are waived via CC0. Sample\ncode is defined as all source code displayed within the prose of the\ndocumentation.\n\nCC0: http://creativecommons.org/publicdomain/zero/1.0/\n\n====\n\nFiles located in the node_modules and vendor directories are externally\nmaintained libraries used by this software which have their own\nlicenses; we recommend you read them, as their terms may differ from the\nterms above.\n */\n\n/** Error message constants. */\nconst FUNC_ERROR_TEXT = 'Expected a function'\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nconst nativeMax = Math.max,\n  nativeMin = Math.min\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [sortOnOptions={}] The options object.\n * @param {boolean} [sortOnOptions.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [sortOnOptions.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [sortOnOptions.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  let lastArgs,\n    lastCallTime,\n    lastInvokeTime = 0,\n    lastThis,\n    leading = false,\n    maxing = false,\n    maxWait,\n    result,\n    timerID,\n    trailing = true\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT)\n  }\n  wait = wait || 0\n  if (typeof options === 'object') {\n    leading = !!options.leading\n    maxing = 'maxWait' in options\n    maxWait = maxing ? nativeMax(options.maxWait || 0, wait) : maxWait\n    trailing = 'trailing' in options ? !!options.trailing : trailing\n  }\n\n  function invokeFunc(time) {\n    const args = lastArgs,\n      thisArg = lastThis\n\n    lastArgs = lastThis = undefined\n    lastInvokeTime = time\n    result = func.apply(thisArg, args)\n    return result\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time\n    // Start the timer for the trailing edge.\n    timerID = setTimeout(timerExpired, wait)\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result\n  }\n\n  function remainingWait(time) {\n    const timeSinceLastCall = time - lastCallTime,\n      timeSinceLastInvoke = time - lastInvokeTime,\n      timeWaiting = wait - timeSinceLastCall\n\n    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting\n  }\n\n  function shouldInvoke(time) {\n    const timeSinceLastCall = time - lastCallTime,\n      timeSinceLastInvoke = time - lastInvokeTime\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (\n      lastCallTime === undefined ||\n      timeSinceLastCall >= wait ||\n      timeSinceLastCall < 0 ||\n      (maxing && timeSinceLastInvoke >= maxWait)\n    )\n  }\n\n  function timerExpired() {\n    const time = Date.now()\n    if (shouldInvoke(time)) {\n      return trailingEdge(time)\n    }\n    // Restart the timer.\n    timerID = setTimeout(timerExpired, remainingWait(time))\n  }\n\n  function trailingEdge(time) {\n    timerID = undefined\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time)\n    }\n    lastArgs = lastThis = undefined\n    return result\n  }\n\n  function cancel() {\n    if (timerID !== undefined) {\n      clearTimeout(timerID)\n    }\n    lastInvokeTime = 0\n    lastArgs = lastCallTime = lastThis = timerID = undefined\n  }\n\n  function flush() {\n    return timerID === undefined ? result : trailingEdge(Date.now())\n  }\n\n  function debounced() {\n    const time = Date.now(),\n      isInvoking = shouldInvoke(time)\n\n    // eslint-disable-next-line prefer-rest-params\n    lastArgs = arguments\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    lastThis = this\n    lastCallTime = time\n\n    if (isInvoking) {\n      if (timerID === undefined) {\n        return leadingEdge(lastCallTime)\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerID)\n        timerID = setTimeout(timerExpired, wait)\n        return invokeFunc(lastCallTime)\n      }\n    }\n    if (timerID === undefined) {\n      timerID = setTimeout(timerExpired, wait)\n    }\n    return result\n  }\n  debounced.cancel = cancel\n  debounced.flush = flush\n  return debounced\n}\n\n// eslint-disable-next-line no-restricted-exports\nexport default debounce\n","'use client'\n\nimport type {\n  EditorThemeClasses,\n  Klass,\n  LexicalCommand,\n  LexicalEditor,\n  LexicalNode,\n  RangeSelection,\n} from 'lexical'\nimport type { JSX } from 'react'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { TablePlugin as LexicalReactTablePlugin } from '@lexical/react/LexicalTablePlugin'\nimport { INSERT_TABLE_COMMAND, TableCellNode, TableNode, TableRowNode } from '@lexical/table'\nimport { mergeRegister } from '@lexical/utils'\nimport { formatDrawerSlug, useEditDepth } from '@payloadcms/ui'\nimport { $getSelection, $isRangeSelection, COMMAND_PRIORITY_EDITOR, createCommand } from 'lexical'\nimport { createContext, use, useEffect, useMemo, useState } from 'react'\nimport * as React from 'react'\n\nimport type { PluginComponent } from '../../../../typesClient.js'\n\nimport { useEditorConfigContext } from '../../../../../lexical/config/client/EditorConfigProvider.js'\nimport { FieldsDrawer } from '../../../../../utilities/fieldsDrawer/Drawer.js'\nimport { useLexicalDrawer } from '../../../../../utilities/fieldsDrawer/useLexicalDrawer.js'\nimport './index.scss'\n\nexport type CellContextShape = {\n  cellEditorConfig: CellEditorConfig | null\n  cellEditorPlugins: Array<JSX.Element> | JSX.Element | null\n  set: (\n    cellEditorConfig: CellEditorConfig | null,\n    cellEditorPlugins: Array<JSX.Element> | JSX.Element | null,\n  ) => void\n}\n\nexport type CellEditorConfig = Readonly<{\n  namespace: string\n  nodes?: ReadonlyArray<Klass<LexicalNode>>\n  onError: (error: Error, editor: LexicalEditor) => void\n  readOnly?: boolean\n  theme?: EditorThemeClasses\n}>\n\nexport const OPEN_TABLE_DRAWER_COMMAND: LexicalCommand<{}> = createCommand(\n  'OPEN_EMBED_DRAWER_COMMAND',\n)\n\nexport const CellContext = createContext<CellContextShape>({\n  cellEditorConfig: null,\n  cellEditorPlugins: null,\n  set: () => {\n    // Empty\n  },\n})\n\nexport function TableContext({ children }: { children: JSX.Element }) {\n  const [contextValue, setContextValue] = useState<{\n    cellEditorConfig: CellEditorConfig | null\n    cellEditorPlugins: Array<JSX.Element> | JSX.Element | null\n  }>({\n    cellEditorConfig: null,\n    cellEditorPlugins: null,\n  })\n  return (\n    <CellContext\n      value={useMemo(\n        () => ({\n          cellEditorConfig: contextValue.cellEditorConfig,\n          cellEditorPlugins: contextValue.cellEditorPlugins,\n          set: (cellEditorConfig, cellEditorPlugins) => {\n            setContextValue({ cellEditorConfig, cellEditorPlugins })\n          },\n        }),\n        [contextValue.cellEditorConfig, contextValue.cellEditorPlugins],\n      )}\n    >\n      {children}\n    </CellContext>\n  )\n}\n\nexport const TablePlugin: PluginComponent = () => {\n  const [editor] = useLexicalComposerContext()\n  const cellContext = use(CellContext)\n  const editDepth = useEditDepth()\n  const {\n    fieldProps: { schemaPath },\n    uuid,\n  } = useEditorConfigContext()\n\n  const drawerSlug = formatDrawerSlug({\n    slug: 'lexical-table-create-' + uuid,\n    depth: editDepth,\n  })\n  const { toggleDrawer } = useLexicalDrawer(drawerSlug, true)\n\n  useEffect(() => {\n    if (!editor.hasNodes([TableNode, TableRowNode, TableCellNode])) {\n      throw new Error(\n        'TablePlugin: TableNode, TableRowNode, or TableCellNode is not registered on editor',\n      )\n    }\n\n    return mergeRegister(\n      editor.registerCommand(\n        OPEN_TABLE_DRAWER_COMMAND,\n        () => {\n          let rangeSelection: null | RangeSelection = null\n\n          editor.getEditorState().read(() => {\n            const selection = $getSelection()\n            if ($isRangeSelection(selection)) {\n              rangeSelection = selection\n            }\n          })\n\n          if (rangeSelection) {\n            toggleDrawer()\n          }\n          return true\n        },\n        COMMAND_PRIORITY_EDITOR,\n      ),\n    )\n  }, [cellContext, editor, toggleDrawer])\n\n  return (\n    <React.Fragment>\n      <FieldsDrawer\n        drawerSlug={drawerSlug}\n        drawerTitle=\"Create Table\"\n        featureKey=\"experimental_table\"\n        handleDrawerSubmit={(_fields, data) => {\n          if (!data.columns || !data.rows) {\n            return\n          }\n\n          editor.dispatchCommand(INSERT_TABLE_COMMAND, {\n            columns: String(data.columns),\n            rows: String(data.rows),\n          })\n        }}\n        schemaPath={schemaPath}\n        schemaPathSuffix=\"fields\"\n      />\n      <LexicalReactTablePlugin\n        hasCellBackgroundColor={false}\n        hasCellMerge\n        hasHorizontalScroll={true}\n      />\n    </React.Fragment>\n  )\n}\n","'use client'\n\nimport { $isNodeSelection } from 'lexical'\n\nimport type { ExclusiveUploadFeatureProps } from '../server/index.js'\n\nimport { UploadIcon } from '../../../lexical/ui/icons/Upload/index.js'\nimport { createClientFeature } from '../../../utilities/createClientFeature.js'\nimport { slashMenuBasicGroupWithItems } from '../../shared/slashMenu/basicGroup.js'\nimport { toolbarAddDropdownGroupWithItems } from '../../shared/toolbar/addDropdownGroup.js'\nimport { INSERT_UPLOAD_WITH_DRAWER_COMMAND } from './drawer/commands.js'\nimport { $isUploadNode, UploadNode } from './nodes/UploadNode.js'\nimport { UploadPlugin } from './plugin/index.js'\n\nexport type UploadFeaturePropsClient = {\n  collections: {\n    [collection: string]: {\n      hasExtraFields: boolean\n    }\n  }\n} & ExclusiveUploadFeatureProps\n\nexport const UploadFeatureClient = createClientFeature<UploadFeaturePropsClient>({\n  nodes: [UploadNode],\n  plugins: [\n    {\n      Component: UploadPlugin,\n      position: 'normal',\n    },\n  ],\n  slashMenu: {\n    groups: [\n      slashMenuBasicGroupWithItems([\n        {\n          Icon: UploadIcon,\n          key: 'upload',\n          keywords: ['upload', 'image', 'file', 'img', 'picture', 'photo', 'media'],\n          label: ({ i18n }) => {\n            return i18n.t('lexical:upload:label')\n          },\n          onSelect: ({ editor }) => {\n            editor.dispatchCommand(INSERT_UPLOAD_WITH_DRAWER_COMMAND, {\n              replace: false,\n            })\n          },\n        },\n      ]),\n    ],\n  },\n  toolbarFixed: {\n    groups: [\n      toolbarAddDropdownGroupWithItems([\n        {\n          ChildComponent: UploadIcon,\n          isActive: ({ selection }) => {\n            if (!$isNodeSelection(selection) || !selection.getNodes().length) {\n              return false\n            }\n\n            const firstNode = selection.getNodes()[0]\n            return $isUploadNode(firstNode)\n          },\n          key: 'upload',\n          label: ({ i18n }) => {\n            return i18n.t('lexical:upload:label')\n          },\n          onSelect: ({ editor }) => {\n            editor.dispatchCommand(INSERT_UPLOAD_WITH_DRAWER_COMMAND, {\n              replace: false,\n            })\n          },\n        },\n      ]),\n    ],\n  },\n})\n","'use client'\nimport React from 'react'\n\nexport const UploadIcon: React.FC = () => (\n  <svg\n    aria-hidden=\"true\"\n    className=\"icon\"\n    fill=\"none\"\n    focusable=\"false\"\n    height=\"20\"\n    viewBox=\"0 0 20 20\"\n    width=\"20\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path\n      d=\"M14.6667 4H5.33333C4.59695 4 4 4.59695 4 5.33333V14.6667C4 15.403 4.59695 16 5.33333 16H14.6667C15.403 16 16 15.403 16 14.6667V5.33333C16 4.59695 15.403 4 14.6667 4Z\"\n      stroke=\"currentColor\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    />\n    <path\n      d=\"M7.99984 9.33366C8.73622 9.33366 9.33317 8.73671 9.33317 8.00033C9.33317 7.26395 8.73622 6.66699 7.99984 6.66699C7.26346 6.66699 6.6665 7.26395 6.6665 8.00033C6.6665 8.73671 7.26346 9.33366 7.99984 9.33366Z\"\n      stroke=\"currentColor\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    />\n    <path\n      d=\"M16 11.9995L13.9427 9.94214C13.6926 9.69218 13.3536 9.55176 13 9.55176C12.6464 9.55176 12.3074 9.69218 12.0573 9.94214L6 15.9995\"\n      stroke=\"currentColor\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    />\n  </svg>\n)\n","'use client'\nimport type { DOMConversionMap, EditorConfig, LexicalEditor, LexicalNode } from 'lexical'\nimport type { JSX } from 'react'\n\nimport ObjectID from 'bson-objectid'\nimport { $applyNodeReplacement } from 'lexical'\nimport * as React from 'react'\n\nimport type {\n  Internal_UploadData,\n  SerializedUploadNode,\n  UploadData,\n} from '../../server/nodes/UploadNode.js'\n\nimport { $convertUploadElement } from '../../server/nodes/conversions.js'\nimport { UploadServerNode } from '../../server/nodes/UploadNode.js'\nimport { PendingUploadComponent } from '../component/pending/index.js'\n\nconst RawUploadComponent = React.lazy(() =>\n  import('../../client/component/index.js').then((module) => ({ default: module.UploadComponent })),\n)\n\nexport class UploadNode extends UploadServerNode {\n  static override clone(node: UploadServerNode): UploadServerNode {\n    return super.clone(node)\n  }\n\n  static override getType(): string {\n    return super.getType()\n  }\n\n  static override importDOM(): DOMConversionMap<HTMLImageElement> {\n    return {\n      img: (node) => ({\n        conversion: (domNode) => $convertUploadElement(domNode, $createUploadNode),\n        priority: 0,\n      }),\n    }\n  }\n\n  static override importJSON(serializedNode: SerializedUploadNode): UploadNode {\n    if (serializedNode.version === 1 && (serializedNode?.value as unknown as { id: string })?.id) {\n      serializedNode.value = (serializedNode.value as unknown as { id: string }).id\n    }\n    if (serializedNode.version === 2 && !serializedNode?.id) {\n      serializedNode.id = new ObjectID.default().toHexString()\n      serializedNode.version = 3\n    }\n\n    const importedData: Internal_UploadData = {\n      id: serializedNode.id,\n      fields: serializedNode.fields,\n      pending: (serializedNode as Internal_UploadData).pending,\n      relationTo: serializedNode.relationTo,\n      value: serializedNode.value,\n    }\n\n    const node = $createUploadNode({ data: importedData })\n    node.setFormat(serializedNode.format)\n\n    return node\n  }\n\n  override decorate(editor?: LexicalEditor, config?: EditorConfig): JSX.Element {\n    if ((this.__data as Internal_UploadData).pending) {\n      return <PendingUploadComponent />\n    }\n    return (\n      <RawUploadComponent\n        className={config?.theme?.upload ?? 'LexicalEditorTheme__upload'}\n        data={this.__data}\n        format={this.__format}\n        nodeKey={this.getKey()}\n      />\n    )\n  }\n\n  override exportJSON(): SerializedUploadNode {\n    return super.exportJSON()\n  }\n}\n\nexport function $createUploadNode({\n  data,\n}: {\n  data: Omit<UploadData, 'id'> & Partial<Pick<UploadData, 'id'>>\n}): UploadNode {\n  if (!data?.id) {\n    data.id = new ObjectID.default().toHexString()\n  }\n\n  return $applyNodeReplacement(new UploadNode({ data: data as UploadData }))\n}\n\nexport function $isUploadNode(node: LexicalNode | null | undefined): node is UploadNode {\n  return node instanceof UploadNode\n}\n","// This file contains functions used to convert dom elements to upload or pending upload lexical nodes. It requires the actual node\n// creation functions to be passed in to stay compatible with both client and server code.\nimport type { DOMConversionOutput } from 'lexical'\n\nimport ObjectID from 'bson-objectid'\n\nimport type { $createUploadNode } from '../../client/nodes/UploadNode.js'\nimport type { $createUploadServerNode, Internal_UploadData } from './UploadNode.js'\n\nexport function isGoogleDocCheckboxImg(img: HTMLImageElement): boolean {\n  return (\n    img.parentElement != null &&\n    img.parentElement.tagName === 'LI' &&\n    img.previousSibling === null &&\n    img.getAttribute('aria-roledescription') === 'checkbox'\n  )\n}\n\nexport function $convertUploadElement(\n  domNode: HTMLImageElement,\n  $createNode: typeof $createUploadNode | typeof $createUploadServerNode,\n): DOMConversionOutput | null {\n  if (domNode.hasAttribute('data-lexical-pending-upload-form-id')) {\n    const formID = domNode.getAttribute('data-lexical-pending-upload-form-id')\n\n    if (formID != null) {\n      const node = $createNode({\n        data: {\n          pending: {\n            formID,\n            src: domNode.getAttribute('src') || '',\n          },\n        } as Internal_UploadData,\n      })\n      return { node }\n    }\n  }\n  if (\n    domNode.hasAttribute('data-lexical-upload-relation-to') &&\n    domNode.hasAttribute('data-lexical-upload-id')\n  ) {\n    const id = domNode.getAttribute('data-lexical-upload-id')\n    const relationTo = domNode.getAttribute('data-lexical-upload-relation-to')\n\n    if (id != null && relationTo != null) {\n      const node = $createNode({\n        data: {\n          fields: {},\n          relationTo,\n          value: id,\n        },\n      })\n      return { node }\n    }\n  }\n\n  // Create pending UploadNode. Auto-Upload functionality will then be handled by the node transform\n  const node = $createNode({\n    data: {\n      pending: {\n        formID: new ObjectID.default().toHexString(),\n        src: domNode.getAttribute('src') || '',\n      },\n    } as Internal_UploadData,\n  })\n\n  return { node }\n}\n","import type { SerializedDecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport type {\n  DOMConversionMap,\n  DOMExportOutput,\n  EditorConfig,\n  ElementFormatType,\n  LexicalNode,\n  NodeKey,\n} from 'lexical'\nimport type {\n  CollectionSlug,\n  DataFromCollectionSlug,\n  JsonObject,\n  TypedUploadCollection,\n  UploadCollectionSlug,\n} from 'payload'\nimport type { JSX } from 'react'\n\nimport { DecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport { addClassNamesToElement } from '@lexical/utils'\nimport ObjectID from 'bson-objectid'\nimport { $applyNodeReplacement } from 'lexical'\n\nimport type { StronglyTypedLeafNode } from '../../../../nodeTypes.js'\n\nimport { $convertUploadElement } from './conversions.js'\n\nexport type UploadData<TUploadExtraFieldsData extends JsonObject = JsonObject> = {\n  [TCollectionSlug in CollectionSlug]: {\n    fields: TUploadExtraFieldsData\n    /**\n     * Every lexical node that has sub-fields needs to have a unique ID. This is the ID of this upload node, not the ID of the linked upload document\n     */\n    id: string\n    relationTo: TCollectionSlug\n    /**\n     * Value can be just the document ID, or the full, populated document\n     */\n    value: DataFromCollectionSlug<TCollectionSlug> | number | string\n  }\n}[CollectionSlug]\n\n/**\n * Internal use only - UploadData type that can contain a pending state\n * @internal\n */\nexport type Internal_UploadData<TUploadExtraFieldsData extends JsonObject = JsonObject> = {\n  pending?: {\n    /**\n     * ID that corresponds to the bulk upload form ID\n     */\n    formID: string\n    /**\n     * src value of the image dom element\n     */\n    src: string\n  }\n} & UploadData<TUploadExtraFieldsData>\n\n/**\n * UploadDataImproved is a more precise type, and will replace UploadData in Payload v4.\n * This type is for internal use only as it will be deprecated in the future.\n * @internal\n *\n * @todo Replace UploadData with UploadDataImproved in 4.0\n */\nexport type UploadDataImproved<TUploadExtraFieldsData extends JsonObject = JsonObject> = {\n  [TCollectionSlug in UploadCollectionSlug]: {\n    fields: TUploadExtraFieldsData\n    /**\n     * Every lexical node that has sub-fields needs to have a unique ID. This is the ID of this upload node, not the ID of the linked upload document\n     */\n    id: string\n    relationTo: TCollectionSlug\n    /**\n     * Value can be just the document ID, or the full, populated document\n     */\n    value: number | string | TypedUploadCollection[TCollectionSlug]\n  }\n}[UploadCollectionSlug]\n\nexport type SerializedUploadNode = StronglyTypedLeafNode<SerializedDecoratorBlockNode, 'upload'> &\n  UploadData\n\nexport class UploadServerNode extends DecoratorBlockNode {\n  __data: UploadData\n\n  constructor({\n    data,\n    format,\n    key,\n  }: {\n    data: UploadData\n    format?: ElementFormatType\n    key?: NodeKey\n  }) {\n    super(format, key)\n    this.__data = data\n  }\n\n  static override clone(node: UploadServerNode): UploadServerNode {\n    return new this({\n      data: node.__data,\n      format: node.__format,\n      key: node.__key,\n    })\n  }\n\n  static override getType(): string {\n    return 'upload'\n  }\n\n  static override importDOM(): DOMConversionMap<HTMLImageElement> {\n    return {\n      img: (node) => ({\n        conversion: (domNode) => $convertUploadElement(domNode, $createUploadServerNode),\n        priority: 0,\n      }),\n    }\n  }\n\n  static override importJSON(serializedNode: SerializedUploadNode): UploadServerNode {\n    if (serializedNode.version === 1 && (serializedNode?.value as unknown as { id: string })?.id) {\n      serializedNode.value = (serializedNode.value as unknown as { id: string }).id\n    }\n    if (serializedNode.version === 2 && !serializedNode?.id) {\n      serializedNode.id = new ObjectID.default().toHexString()\n      serializedNode.version = 3\n    }\n\n    const importedData: Internal_UploadData = {\n      id: serializedNode.id,\n      fields: serializedNode.fields,\n      pending: (serializedNode as Internal_UploadData).pending,\n      relationTo: serializedNode.relationTo,\n      value: serializedNode.value,\n    }\n\n    const node = $createUploadServerNode({ data: importedData })\n    node.setFormat(serializedNode.format)\n\n    return node\n  }\n\n  static isInline(): false {\n    return false\n  }\n\n  override createDOM(config?: EditorConfig): HTMLElement {\n    const element = document.createElement('div')\n    addClassNamesToElement(element, config?.theme?.upload)\n    return element\n  }\n\n  override decorate(): JSX.Element {\n    return null as unknown as JSX.Element\n  }\n\n  override exportDOM(): DOMExportOutput {\n    const element = document.createElement('img')\n    const data = this.__data as Internal_UploadData\n    if (data.pending) {\n      element.setAttribute('data-lexical-pending-upload-form-id', String(data?.pending?.formID))\n      element.setAttribute('src', data?.pending?.src || '')\n    } else {\n      element.setAttribute('data-lexical-upload-id', String(data?.value))\n      element.setAttribute('data-lexical-upload-relation-to', data?.relationTo)\n    }\n\n    return { element }\n  }\n\n  override exportJSON(): SerializedUploadNode {\n    return {\n      ...super.exportJSON(),\n      ...this.getData(),\n      type: 'upload',\n      version: 3,\n    }\n  }\n\n  getData(): UploadData {\n    return this.getLatest().__data\n  }\n\n  setData(data: UploadData): void {\n    const writable = this.getWritable()\n    writable.__data = data\n  }\n\n  override updateDOM(): false {\n    return false\n  }\n}\n\nexport function $createUploadServerNode({\n  data,\n}: {\n  data: Omit<UploadData, 'id'> & Partial<Pick<UploadData, 'id'>>\n}): UploadServerNode {\n  if (!data?.id) {\n    data.id = new ObjectID.default().toHexString()\n  }\n  return $applyNodeReplacement(new UploadServerNode({ data: data as UploadData }))\n}\n\nexport function $isUploadServerNode(\n  node: LexicalNode | null | undefined,\n): node is UploadServerNode {\n  return node instanceof UploadServerNode\n}\n","'use client'\n\nimport { ShimmerEffect } from '@payloadcms/ui'\n\nimport '../index.scss'\n\nexport const PendingUploadComponent = (): React.ReactNode => {\n  return (\n    <div className={'lexical-upload'}>\n      <ShimmerEffect height={'95px'} width={'203px'} />\n    </div>\n  )\n}\n","'use client'\nimport type { LexicalCommand } from 'lexical'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { $dfsIterator, $insertNodeToNearestRoot, mergeRegister } from '@lexical/utils'\nimport { useBulkUpload, useEffectEvent, useModal } from '@payloadcms/ui'\nimport ObjectID from 'bson-objectid'\nimport {\n  $createRangeSelection,\n  $getPreviousSelection,\n  $getSelection,\n  $isParagraphNode,\n  $isRangeSelection,\n  $setSelection,\n  COMMAND_PRIORITY_EDITOR,\n  COMMAND_PRIORITY_LOW,\n  createCommand,\n  DROP_COMMAND,\n  getDOMSelectionFromTarget,\n  isHTMLElement,\n  PASTE_COMMAND,\n} from 'lexical'\nimport React, { useEffect } from 'react'\n\nimport type { PluginComponent } from '../../../typesClient.js'\nimport type { Internal_UploadData, UploadData } from '../../server/nodes/UploadNode.js'\nimport type { UploadFeaturePropsClient } from '../index.js'\n\nimport { useEnabledRelationships } from '../../../relationship/client/utils/useEnabledRelationships.js'\nimport { UploadDrawer } from '../drawer/index.js'\nimport { $createUploadNode, $isUploadNode, UploadNode } from '../nodes/UploadNode.js'\n\nexport type InsertUploadPayload = Readonly<Omit<UploadData, 'id'> & Partial<Pick<UploadData, 'id'>>>\n\ndeclare global {\n  interface DragEvent {\n    rangeOffset?: number\n    rangeParent?: Node\n  }\n}\n\nfunction canDropImage(event: DragEvent): boolean {\n  const target = event.target\n  return !!(\n    isHTMLElement(target) &&\n    !target.closest('code, span.editor-image') &&\n    isHTMLElement(target.parentElement) &&\n    target.parentElement.closest('div.ContentEditable__root')\n  )\n}\n\nfunction getDragSelection(event: DragEvent): null | Range | undefined {\n  // Source: https://github.com/AlessioGr/lexical/blob/main/packages/lexical-playground/src/plugins/ImagesPlugin/index.tsx\n  let range\n  const domSelection = getDOMSelectionFromTarget(event.target)\n  if (document.caretRangeFromPoint) {\n    range = document.caretRangeFromPoint(event.clientX, event.clientY)\n  } else if (event.rangeParent && domSelection !== null) {\n    domSelection.collapse(event.rangeParent, event.rangeOffset || 0)\n    range = domSelection.getRangeAt(0)\n  } else {\n    throw Error(`Cannot get the selection when dragging`)\n  }\n\n  return range\n}\n\nexport const INSERT_UPLOAD_COMMAND: LexicalCommand<InsertUploadPayload> =\n  createCommand('INSERT_UPLOAD_COMMAND')\n\ntype FileToUpload = {\n  alt?: string\n  file: File\n  /**\n   * Bulk Upload Form ID that should be created, which can then be matched\n   * against the node formID if the upload is successful\n   */\n  formID: string\n}\n\nexport const UploadPlugin: PluginComponent<UploadFeaturePropsClient> = ({ clientProps }) => {\n  const [editor] = useLexicalComposerContext()\n\n  const { enabledCollectionSlugs } = useEnabledRelationships({\n    collectionSlugsBlacklist: clientProps?.disabledCollections,\n    collectionSlugsWhitelist: clientProps?.enabledCollections,\n    uploads: true,\n  })\n\n  const {\n    drawerSlug: bulkUploadDrawerSlug,\n    setCollectionSlug,\n    setInitialForms,\n    setOnCancel,\n    setOnSuccess,\n    setSelectableCollections,\n  } = useBulkUpload()\n\n  const { isModalOpen, openModal } = useModal()\n\n  const openBulkUpload = useEffectEvent(({ files }: { files: FileToUpload[] }) => {\n    if (files?.length === 0) {\n      return\n    }\n\n    setInitialForms((initialForms) => [\n      ...(initialForms ?? []),\n      ...files.map((file) => ({\n        file: file.file,\n        formID: file.formID,\n      })),\n    ])\n\n    if (!isModalOpen(bulkUploadDrawerSlug)) {\n      if (!enabledCollectionSlugs.length || !enabledCollectionSlugs[0]) {\n        return\n      }\n\n      setCollectionSlug(enabledCollectionSlugs[0])\n      setSelectableCollections(enabledCollectionSlugs)\n\n      setOnCancel(() => {\n        // Remove all the pending upload nodes that were added but not uploaded\n        editor.update(() => {\n          for (const dfsNode of $dfsIterator()) {\n            const node = dfsNode.node\n\n            if ($isUploadNode(node)) {\n              const nodeData = node.getData()\n              if ((nodeData as Internal_UploadData)?.pending) {\n                node.remove()\n              }\n            }\n          }\n        })\n      })\n\n      setOnSuccess((newDocs) => {\n        const newDocsMap = new Map(newDocs.map((doc) => [doc.formID, doc]))\n        editor.update(() => {\n          for (const dfsNode of $dfsIterator()) {\n            const node = dfsNode.node\n            if ($isUploadNode(node)) {\n              const nodeData: Internal_UploadData = node.getData()\n\n              if (nodeData?.pending) {\n                const newDoc = newDocsMap.get(nodeData.pending?.formID)\n                if (newDoc) {\n                  node.replace(\n                    $createUploadNode({\n                      data: {\n                        id: new ObjectID.default().toHexString(),\n                        fields: {},\n                        relationTo: newDoc.collectionSlug,\n                        value: newDoc.doc.id,\n                      } as UploadData,\n                    }),\n                  )\n                }\n              }\n            }\n          }\n        })\n      })\n\n      openModal(bulkUploadDrawerSlug)\n    }\n  })\n\n  useEffect(() => {\n    if (!editor.hasNodes([UploadNode])) {\n      throw new Error('UploadPlugin: UploadNode not registered on editor')\n    }\n\n    return mergeRegister(\n      /**\n       * Handle auto-uploading files if you copy & paste an image dom element from the clipboard\n       */\n      editor.registerNodeTransform(UploadNode, (node) => {\n        const nodeData: Internal_UploadData = node.getData()\n        if (!nodeData?.pending) {\n          return\n        }\n\n        async function upload() {\n          let transformedImage: FileToUpload | null = null\n\n          const src = nodeData?.pending?.src\n          const formID = nodeData?.pending?.formID as string\n\n          if (src?.startsWith('data:')) {\n            // It's a base64-encoded image\n            const mimeMatch = src.match(/data:(image\\/[a-zA-Z]+);base64,/)\n            const mimeType = mimeMatch ? mimeMatch[1] : 'image/png' // Default to PNG if MIME type not found\n            const base64Data = src.replace(/^data:image\\/[a-zA-Z]+;base64,/, '')\n            const byteCharacters = atob(base64Data)\n            const byteNumbers = new Array(byteCharacters.length)\n            for (let i = 0; i < byteCharacters.length; i++) {\n              byteNumbers[i] = byteCharacters.charCodeAt(i)\n            }\n            const byteArray = new Uint8Array(byteNumbers)\n            const file = new File([byteArray], 'pasted-image.' + mimeType?.split('/', 2)[1], {\n              type: mimeType,\n            })\n            transformedImage = { alt: undefined, file, formID }\n          } else if (src?.startsWith('http') || src?.startsWith('https')) {\n            // It's an image URL\n            const res = await fetch(src)\n            const blob = await res.blob()\n            const inferredFileName =\n              src.split('/').pop() || 'pasted-image' + blob.type.split('/', 2)[1]\n            const file = new File([blob], inferredFileName, {\n              type: blob.type,\n            })\n\n            transformedImage = { alt: undefined, file, formID }\n          }\n\n          if (!transformedImage) {\n            return\n          }\n\n          openBulkUpload({ files: [transformedImage] })\n        }\n        void upload()\n      }),\n      editor.registerCommand<InsertUploadPayload>(\n        INSERT_UPLOAD_COMMAND,\n        (payload: InsertUploadPayload) => {\n          editor.update(() => {\n            const selection = $getSelection() || $getPreviousSelection()\n\n            if ($isRangeSelection(selection)) {\n              const uploadNode = $createUploadNode({\n                data: {\n                  id: payload.id,\n                  fields: payload.fields,\n                  relationTo: payload.relationTo,\n                  value: payload.value,\n                },\n              })\n              // we need to get the focus node before inserting the block node, as $insertNodeToNearestRoot can change the focus node\n              const { focus } = selection\n              const focusNode = focus.getNode()\n              // Insert upload node BEFORE potentially removing focusNode, as $insertNodeToNearestRoot errors if the focusNode doesn't exist\n              $insertNodeToNearestRoot(uploadNode)\n\n              // Delete the node it it's an empty paragraph\n              if ($isParagraphNode(focusNode) && !focusNode.__first) {\n                focusNode.remove()\n              }\n            }\n          })\n\n          return true\n        },\n        COMMAND_PRIORITY_EDITOR,\n      ),\n      editor.registerCommand(\n        PASTE_COMMAND,\n        (event) => {\n          // Pending UploadNodes are automatically created when importDOM is called. However, if you paste a file from your computer\n          // directly, importDOM won't be called, as it's not a HTML dom element. So we need to handle that case here.\n\n          if (!(event instanceof ClipboardEvent)) {\n            return false\n          }\n          const clipboardData = event.clipboardData\n\n          if (!clipboardData?.types?.length || clipboardData?.types?.includes('text/html')) {\n            // HTML is handled through importDOM => registerNodeTransform for pending UploadNode\n            return false\n          }\n\n          const files: FileToUpload[] = []\n          if (clipboardData?.files?.length) {\n            Array.from(clipboardData.files).forEach((file) => {\n              files.push({\n                alt: '',\n                file,\n                formID: new ObjectID.default().toHexString(),\n              })\n            })\n          }\n\n          if (files.length) {\n            // Insert a pending UploadNode for each image\n            editor.update(() => {\n              const selection = $getSelection() || $getPreviousSelection()\n\n              if ($isRangeSelection(selection)) {\n                for (const file of files) {\n                  const pendingUploadNode = $createUploadNode({\n                    data: {\n                      pending: {\n                        formID: file.formID,\n                        src: URL.createObjectURL(file.file),\n                      },\n                    } as Internal_UploadData,\n                  })\n                  // we need to get the focus node before inserting the upload node, as $insertNodeToNearestRoot can change the focus node\n                  const { focus } = selection\n                  const focusNode = focus.getNode()\n                  // Insert upload node BEFORE potentially removing focusNode, as $insertNodeToNearestRoot errors if the focusNode doesn't exist\n                  $insertNodeToNearestRoot(pendingUploadNode)\n\n                  // Delete the node it it's an empty paragraph\n                  if ($isParagraphNode(focusNode) && !focusNode.__first) {\n                    focusNode.remove()\n                  }\n                }\n              }\n            })\n\n            // Open the bulk drawer - the node transform will not open it for us, as it does not handle blob/file uploads\n            openBulkUpload({ files })\n\n            return true\n          }\n\n          return false\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n      // Handle drag & drop of files from the desktop into the editor\n      editor.registerCommand(\n        DROP_COMMAND,\n        (event) => {\n          if (!(event instanceof DragEvent)) {\n            return false\n          }\n\n          const dt = event.dataTransfer\n\n          if (!dt?.types?.length) {\n            return false\n          }\n\n          const files: FileToUpload[] = []\n          if (dt?.files?.length) {\n            Array.from(dt.files).forEach((file) => {\n              files.push({\n                alt: '',\n                file,\n                formID: new ObjectID.default().toHexString(),\n              })\n            })\n          }\n\n          if (files.length) {\n            // Prevent the default browser drop handling, which would open the file in the browser\n            event.preventDefault()\n            event.stopPropagation()\n\n            // Insert a PendingUploadNode for each image\n            editor.update(() => {\n              if (canDropImage(event)) {\n                const range = getDragSelection(event)\n                const selection = $createRangeSelection()\n                if (range !== null && range !== undefined) {\n                  selection.applyDOMRange(range)\n                }\n                $setSelection(selection)\n\n                for (const file of files) {\n                  const pendingUploadNode = $createUploadNode({\n                    data: {\n                      pending: {\n                        formID: file.formID,\n                        src: URL.createObjectURL(file.file),\n                      },\n                    } as Internal_UploadData,\n                  })\n                  // we need to get the focus node before inserting the upload node, as $insertNodeToNearestRoot can change the focus node\n                  const { focus } = selection\n                  const focusNode = focus.getNode()\n                  // Insert upload node BEFORE potentially removing focusNode, as $insertNodeToNearestRoot errors if the focusNode doesn't exist\n                  $insertNodeToNearestRoot(pendingUploadNode)\n\n                  // Delete the node it it's an empty paragraph\n                  if ($isParagraphNode(focusNode) && !focusNode.__first) {\n                    focusNode.remove()\n                  }\n                }\n              }\n            })\n\n            // Open the bulk drawer - the node transform will not open it for us, as it does not handle blob/file uploads\n            openBulkUpload({ files })\n\n            return true\n          }\n\n          return false\n        },\n        COMMAND_PRIORITY_LOW,\n      ),\n    )\n  }, [editor])\n\n  return <UploadDrawer enabledCollectionSlugs={enabledCollectionSlugs} />\n}\n","'use client'\nimport type { ListDrawerProps } from '@payloadcms/ui'\nimport type { LexicalEditor } from 'lexical'\nimport type { UploadCollectionSlug } from 'payload'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext.js'\nimport { toast } from '@payloadcms/ui'\nimport { $getNodeByKey, COMMAND_PRIORITY_EDITOR } from 'lexical'\nimport React, { useCallback, useEffect, useState } from 'react'\n\nimport { useLexicalListDrawer } from '../../../../utilities/fieldsDrawer/useLexicalListDrawer.js'\nimport { $createUploadNode } from '../nodes/UploadNode.js'\nimport { INSERT_UPLOAD_COMMAND } from '../plugin/index.js'\nimport { INSERT_UPLOAD_WITH_DRAWER_COMMAND } from './commands.js'\n\nconst insertUpload = ({\n  editor,\n  relationTo,\n  replaceNodeKey,\n  value,\n}: {\n  editor: LexicalEditor\n  relationTo: string\n  replaceNodeKey: null | string\n  value: number | string\n}) => {\n  if (!replaceNodeKey) {\n    editor.dispatchCommand(INSERT_UPLOAD_COMMAND, {\n      // @ts-expect-error - TODO: fix this\n      fields: null,\n      relationTo,\n      value,\n    })\n  } else {\n    editor.update(() => {\n      const node = $getNodeByKey(replaceNodeKey)\n      if (node) {\n        node.replace(\n          $createUploadNode({\n            data: {\n              // @ts-expect-error - TODO: fix this\n              fields: null,\n              relationTo,\n              value,\n            },\n          }),\n        )\n      }\n    })\n  }\n}\n\ntype Props = {\n  enabledCollectionSlugs: UploadCollectionSlug[]\n}\n\nconst UploadDrawerComponent: React.FC<Props> = ({ enabledCollectionSlugs }) => {\n  const [editor] = useLexicalComposerContext()\n\n  const [replaceNodeKey, setReplaceNodeKey] = useState<null | string>(null)\n\n  const { closeListDrawer, ListDrawer, openListDrawer } = useLexicalListDrawer({\n    collectionSlugs: enabledCollectionSlugs,\n    uploads: true,\n  })\n\n  useEffect(() => {\n    return editor.registerCommand<{\n      replace: { nodeKey: string } | false\n    }>(\n      INSERT_UPLOAD_WITH_DRAWER_COMMAND,\n      (payload) => {\n        setReplaceNodeKey(payload?.replace ? payload?.replace.nodeKey : null)\n        openListDrawer()\n        return true\n      },\n      COMMAND_PRIORITY_EDITOR,\n    )\n  }, [editor, openListDrawer])\n\n  const onSelect = useCallback<NonNullable<ListDrawerProps['onSelect']>>(\n    ({ collectionSlug, doc }) => {\n      closeListDrawer()\n      insertUpload({\n        editor,\n        relationTo: collectionSlug,\n        replaceNodeKey,\n        value: doc.id,\n      })\n    },\n    [editor, closeListDrawer, replaceNodeKey],\n  )\n\n  return <ListDrawer onSelect={onSelect} />\n}\n\nconst UploadDrawerComponentFallback: React.FC = () => {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    return editor.registerCommand<{\n      replace: { nodeKey: string } | false\n    }>(\n      INSERT_UPLOAD_WITH_DRAWER_COMMAND,\n      () => {\n        toast.error('No upload collections enabled')\n        return true\n      },\n      COMMAND_PRIORITY_EDITOR,\n    )\n  }, [editor])\n\n  return null\n}\n\nexport const UploadDrawer = ({ enabledCollectionSlugs }: Props): React.ReactNode => {\n  if (!enabledCollectionSlugs?.length) {\n    return <UploadDrawerComponentFallback />\n  }\n\n  return <UploadDrawerComponent enabledCollectionSlugs={enabledCollectionSlugs} />\n}\n","'use client'\n\nimport type { RichTextFieldClient } from 'payload'\n\nimport { ShimmerEffect, useConfig } from '@payloadcms/ui'\nimport React, { lazy, Suspense, useEffect, useState } from 'react'\n\nimport type { FeatureProviderClient } from '../features/typesClient.js'\nimport type { SanitizedClientEditorConfig } from '../lexical/config/types.js'\nimport type { LexicalRichTextFieldProps } from '../types.js'\n\nimport { defaultEditorLexicalConfig } from '../lexical/config/client/default.js'\nimport { loadClientFeatures } from '../lexical/config/client/loader.js'\nimport { sanitizeClientEditorConfig } from '../lexical/config/client/sanitize.js'\n\nconst RichTextEditor = lazy(() =>\n  import('./Field.js').then((module) => ({ default: module.RichText })),\n)\n\nexport const RichTextField: React.FC<LexicalRichTextFieldProps> = (props) => {\n  const {\n    admin = {},\n    clientFeatures,\n    featureClientImportMap = {},\n    featureClientSchemaMap,\n    field,\n    lexicalEditorConfig = defaultEditorLexicalConfig,\n    schemaPath,\n  } = props\n\n  const { config } = useConfig()\n\n  const [finalSanitizedEditorConfig, setFinalSanitizedEditorConfig] =\n    useState<null | SanitizedClientEditorConfig>(null)\n\n  useEffect(() => {\n    if (finalSanitizedEditorConfig) {\n      return\n    }\n\n    const featureProvidersLocal: FeatureProviderClient<any, any>[] = []\n    for (const clientFeature of Object.values(clientFeatures)) {\n      if (!clientFeature.clientFeatureProvider) {\n        continue\n      }\n      featureProvidersLocal.push(\n        clientFeature.clientFeatureProvider(clientFeature.clientFeatureProps),\n      ) // Execute the clientFeatureProvider function here, as the server cannot execute functions imported from use client files\n    }\n\n    const resolvedClientFeatures = loadClientFeatures({\n      config,\n      featureClientImportMap,\n      featureClientSchemaMap,\n      field: field as RichTextFieldClient,\n      schemaPath: schemaPath ?? field.name,\n      unSanitizedEditorConfig: {\n        features: featureProvidersLocal,\n        lexical: lexicalEditorConfig,\n      },\n    })\n\n    setFinalSanitizedEditorConfig(\n      sanitizeClientEditorConfig(resolvedClientFeatures, lexicalEditorConfig, admin),\n    )\n  }, [\n    admin,\n    clientFeatures,\n    config,\n    featureClientImportMap,\n    featureClientSchemaMap,\n    field,\n    finalSanitizedEditorConfig,\n    lexicalEditorConfig,\n    schemaPath,\n  ]) // TODO: Optimize this and use useMemo for this in the future. This might break sub-richtext-blocks from the blocks feature. Need to investigate\n\n  return (\n    <Suspense fallback={<ShimmerEffect height=\"35vh\" />}>\n      {finalSanitizedEditorConfig && (\n        <RichTextEditor {...props} editorConfig={finalSanitizedEditorConfig} />\n      )}\n    </Suspense>\n  )\n}\n","import type { EditorThemeClasses } from 'lexical'\n\nexport const LexicalEditorTheme: EditorThemeClasses = {\n  block: 'LexicalEditorTheme__block',\n  blockCursor: 'LexicalEditorTheme__blockCursor',\n  characterLimit: 'LexicalEditorTheme__characterLimit',\n  code: 'LexicalEditorTheme__code',\n  inlineBlock: 'LexicalEditorTheme__inlineBlock',\n\n  heading: {\n    h1: 'LexicalEditorTheme__h1',\n    h2: 'LexicalEditorTheme__h2',\n    h3: 'LexicalEditorTheme__h3',\n    h4: 'LexicalEditorTheme__h4',\n    h5: 'LexicalEditorTheme__h5',\n    h6: 'LexicalEditorTheme__h6',\n  },\n  hr: 'LexicalEditorTheme__hr',\n  hrSelected: 'LexicalEditorTheme__hrSelected',\n  indent: 'LexicalEditorTheme__indent',\n  link: 'LexicalEditorTheme__link',\n  list: {\n    checklist: 'LexicalEditorTheme__checklist',\n    listitem: 'LexicalEditorTheme__listItem',\n    listitemChecked: 'LexicalEditorTheme__listItemChecked',\n    listitemUnchecked: 'LexicalEditorTheme__listItemUnchecked',\n    nested: {\n      listitem: 'LexicalEditorTheme__nestedListItem',\n    },\n    olDepth: [\n      'LexicalEditorTheme__ol1',\n      'LexicalEditorTheme__ol2',\n      'LexicalEditorTheme__ol3',\n      'LexicalEditorTheme__ol4',\n      'LexicalEditorTheme__ol5',\n    ],\n    ul: 'LexicalEditorTheme__ul',\n  },\n  ltr: 'LexicalEditorTheme__ltr',\n  mark: 'LexicalEditorTheme__mark',\n  markOverlap: 'LexicalEditorTheme__markOverlap',\n  paragraph: 'LexicalEditorTheme__paragraph',\n  placeholder: 'LexicalEditorTheme__placeholder',\n  quote: 'LexicalEditorTheme__quote',\n  relationship: 'LexicalEditorTheme__relationship',\n  rtl: 'LexicalEditorTheme__rtl',\n  tab: 'LexicalEditorTheme__tabNode',\n  table: 'LexicalEditorTheme__table',\n  tableAddColumns: 'LexicalEditorTheme__tableAddColumns',\n  tableAddRows: 'LexicalEditorTheme__tableAddRows',\n  tableAlignment: {\n    center: 'LexicalEditorTheme__tableAlignmentCenter',\n    right: 'LexicalEditorTheme__tableAlignmentRight',\n  },\n  tableCell: 'LexicalEditorTheme__tableCell',\n  tableCellActionButton: 'LexicalEditorTheme__tableCellActionButton',\n  tableCellActionButtonContainer: 'LexicalEditorTheme__tableCellActionButtonContainer',\n  tableCellHeader: 'LexicalEditorTheme__tableCellHeader',\n  tableCellResizer: 'LexicalEditorTheme__tableCellResizer',\n  tableCellSelected: 'LexicalEditorTheme__tableCellSelected',\n  tableFrozenColumn: 'LexicalEditorTheme__tableFrozenColumn',\n  tableRowStriping: 'LexicalEditorTheme__tableRowStriping',\n  tableScrollableWrapper: 'LexicalEditorTheme__tableScrollableWrapper',\n  tableSelected: 'LexicalEditorTheme__tableSelected',\n  tableSelection: 'LexicalEditorTheme__tableSelection',\n  text: {\n    bold: 'LexicalEditorTheme__textBold',\n    code: 'LexicalEditorTheme__textCode',\n    italic: 'LexicalEditorTheme__textItalic',\n    strikethrough: 'LexicalEditorTheme__textStrikethrough',\n    subscript: 'LexicalEditorTheme__textSubscript',\n    superscript: 'LexicalEditorTheme__textSuperscript',\n    underline: 'LexicalEditorTheme__textUnderline',\n    underlineStrikethrough: 'LexicalEditorTheme__textUnderlineStrikethrough',\n  },\n  upload: 'LexicalEditorTheme__upload',\n}\n","'use client'\nimport type { EditorConfig as LexicalEditorConfig } from 'lexical'\n\nimport { LexicalEditorTheme } from '../../theme/EditorTheme.js'\n\nexport const defaultEditorLexicalConfig: LexicalEditorConfig = {\n  namespace: 'lexical',\n  theme: LexicalEditorTheme,\n}\n","'use client'\n\nimport type { ClientConfig, RichTextFieldClient } from 'payload'\n\nimport type {\n  ClientFeatureProviderMap,\n  ResolvedClientFeature,\n  ResolvedClientFeatureMap,\n} from '../../../features/typesClient.js'\nimport type { FeatureClientSchemaMap } from '../../../types.js'\nimport type { ClientEditorConfig } from '../types.js'\n\n/**\n * This function expects client functions to ALREADY be ordered & dependencies checked on the server\n * @param unSanitizedEditorConfig\n */\nexport function loadClientFeatures({\n  config,\n  featureClientImportMap,\n  featureClientSchemaMap,\n  field,\n  schemaPath,\n  unSanitizedEditorConfig,\n}: {\n  config: ClientConfig\n  featureClientImportMap: Record<string, any>\n  featureClientSchemaMap: FeatureClientSchemaMap\n  field?: RichTextFieldClient\n  schemaPath: string\n  unSanitizedEditorConfig: ClientEditorConfig\n}): ResolvedClientFeatureMap {\n  const featureProviderMap: ClientFeatureProviderMap = new Map()\n\n  for (const featureProvider of unSanitizedEditorConfig.features) {\n    if (\n      !featureProvider?.clientFeatureProps?.featureKey ||\n      featureProvider?.clientFeatureProps?.order === undefined ||\n      featureProvider?.clientFeatureProps?.order === null\n    ) {\n      throw new Error(\n        'A Feature you have installed does not return the client props as clientFeatureProps. Please make sure to always return those props, even if they are null, as other important props like order and featureKey are later on injected.',\n      )\n    }\n    featureProviderMap.set(featureProvider.clientFeatureProps.featureKey, featureProvider)\n  }\n\n  // sort unSanitizedEditorConfig.features by order\n  unSanitizedEditorConfig.features = unSanitizedEditorConfig.features.sort(\n    (a, b) => a.clientFeatureProps.order - b.clientFeatureProps.order,\n  )\n\n  const resolvedFeatures: ResolvedClientFeatureMap = new Map()\n\n  // Make sure all dependencies declared in the respective features exist\n  let loaded = 0\n  for (const featureProvider of unSanitizedEditorConfig.features) {\n    const feature: Partial<ResolvedClientFeature<any>> =\n      typeof featureProvider.feature === 'function'\n        ? featureProvider.feature({\n            config,\n            featureClientImportMap,\n            featureClientSchemaMap,\n            featureProviderMap,\n            field,\n            resolvedFeatures,\n            schemaPath,\n            unSanitizedEditorConfig,\n          })\n        : featureProvider.feature\n\n    feature.key = featureProvider.clientFeatureProps.featureKey\n    feature.order = loaded\n\n    resolvedFeatures.set(\n      featureProvider.clientFeatureProps.featureKey,\n      feature as ResolvedClientFeature<any>,\n    )\n\n    loaded++\n  }\n\n  return resolvedFeatures\n}\n","'use client'\n\nimport type { EditorConfig as LexicalEditorConfig } from 'lexical'\n\nimport { deepMerge } from 'payload/shared'\n\nimport type { ToolbarGroup } from '../../../features/toolbars/types.js'\nimport type {\n  ResolvedClientFeatureMap,\n  SanitizedClientFeatures,\n} from '../../../features/typesClient.js'\nimport type { LexicalFieldAdminClientProps } from '../../../types.js'\nimport type { SanitizedClientEditorConfig } from '../types.js'\n\nexport const sanitizeClientFeatures = (\n  features: ResolvedClientFeatureMap,\n): SanitizedClientFeatures => {\n  const sanitized: SanitizedClientFeatures = {\n    enabledFeatures: [],\n    enabledFormats: [],\n    markdownTransformers: [],\n    nodes: [],\n    plugins: [],\n    providers: [],\n    slashMenu: {\n      dynamicGroups: [],\n      groups: [],\n    },\n    toolbarFixed: {\n      groups: [],\n    },\n    toolbarInline: {\n      groups: [],\n    },\n  }\n\n  // Allow customization of groups for toolbarFixed\n  let customGroups: Record<string, Partial<ToolbarGroup>> = {}\n  features.forEach((feature) => {\n    if (feature.key === 'toolbarFixed' && feature.sanitizedClientFeatureProps?.customGroups) {\n      customGroups = {\n        ...customGroups,\n        ...feature.sanitizedClientFeatureProps.customGroups,\n      }\n    }\n  })\n\n  if (!features?.size) {\n    return sanitized\n  }\n\n  features.forEach((feature) => {\n    if (feature.providers?.length) {\n      sanitized.providers = sanitized.providers.concat(feature.providers)\n    }\n\n    if (feature.enableFormats?.length) {\n      sanitized.enabledFormats.push(...feature.enableFormats)\n    }\n\n    if (feature.nodes?.length) {\n      // Important: do not use concat\n      for (const node of feature.nodes) {\n        sanitized.nodes.push(node)\n      }\n    }\n    if (feature.plugins?.length) {\n      feature.plugins.forEach((plugin, i) => {\n        sanitized.plugins?.push({\n          clientProps: feature.sanitizedClientFeatureProps,\n          Component: plugin.Component as any, // Appeases strict: true\n          key: feature.key + i,\n          position: plugin.position,\n        })\n      })\n    }\n\n    if (feature.toolbarInline?.groups?.length) {\n      for (const group of feature.toolbarInline.groups) {\n        // 1. find the group with the same key or create new one\n        let foundGroup = sanitized.toolbarInline.groups.find(\n          (sanitizedGroup) => sanitizedGroup.key === group.key,\n        )\n        if (!foundGroup) {\n          foundGroup = {\n            ...group,\n            items: [],\n          }\n        } else {\n          sanitized.toolbarInline.groups = sanitized.toolbarInline.groups.filter(\n            (sanitizedGroup) => sanitizedGroup.key !== group.key,\n          )\n        }\n\n        // 2. Add options to group options array and add to sanitized.slashMenu.groupsWithOptions\n        if (group?.items?.length) {\n          foundGroup.items = foundGroup.items.concat(group.items)\n        }\n        sanitized.toolbarInline?.groups.push(foundGroup)\n      }\n    }\n\n    if (feature.toolbarFixed?.groups?.length) {\n      for (const group of feature.toolbarFixed.groups) {\n        // 1. find the group with the same key or create new one\n        let foundGroup = sanitized.toolbarFixed.groups.find(\n          (sanitizedGroup) => sanitizedGroup.key === group.key,\n        )\n        if (!foundGroup) {\n          foundGroup = {\n            ...group,\n            items: [],\n          }\n        } else {\n          sanitized.toolbarFixed.groups = sanitized.toolbarFixed.groups.filter(\n            (sanitizedGroup) => sanitizedGroup.key !== group.key,\n          )\n        }\n\n        // 2. Add options to group options array and add to sanitized.slashMenu.groupsWithOptions\n        if (group?.items?.length) {\n          foundGroup.items = foundGroup.items.concat(group.items)\n        }\n        sanitized.toolbarFixed?.groups.push(foundGroup)\n      }\n    }\n\n    if (feature.slashMenu?.groups) {\n      if (feature.slashMenu.dynamicGroups?.length) {\n        sanitized.slashMenu.dynamicGroups = sanitized.slashMenu.dynamicGroups.concat(\n          feature.slashMenu.dynamicGroups,\n        )\n      }\n\n      for (const optionGroup of feature.slashMenu.groups) {\n        // 1. find the group with the same name or create new one\n        let group = sanitized.slashMenu.groups.find((group) => group.key === optionGroup.key)\n        if (!group) {\n          group = {\n            ...optionGroup,\n            items: [],\n          }\n        } else {\n          sanitized.slashMenu.groups = sanitized.slashMenu.groups.filter(\n            (group) => group.key !== optionGroup.key,\n          )\n        }\n\n        // 2. Add options to group options array and add to sanitized.slashMenu.groupsWithOptions\n        if (optionGroup?.items?.length) {\n          group.items = group.items.concat(optionGroup.items)\n        }\n        sanitized.slashMenu.groups.push(group)\n      }\n    }\n\n    if (feature.markdownTransformers?.length) {\n      // Important: do not use concat\n      for (const transformer of feature.markdownTransformers) {\n        if (typeof transformer === 'function') {\n          sanitized.markdownTransformers.push(\n            transformer({\n              allNodes: sanitized.nodes,\n              allTransformers: sanitized.markdownTransformers,\n            }),\n          )\n        } else {\n          sanitized.markdownTransformers.push(transformer)\n        }\n      }\n    }\n    sanitized.enabledFeatures.push(feature.key)\n  })\n\n  // Apply custom group configurations to toolbarFixed groups\n  if (Object.keys(customGroups).length > 0) {\n    sanitized.toolbarFixed.groups = sanitized.toolbarFixed.groups.map((group) => {\n      const customConfig = customGroups[group.key]\n      if (customConfig) {\n        return deepMerge(group, customConfig)\n      }\n      return group\n    })\n  }\n\n  // Sort sanitized.toolbarInline.groups by order property\n  sanitized.toolbarInline.groups.sort((a, b) => {\n    if (a.order && b.order) {\n      return a.order - b.order\n    } else if (a.order) {\n      return -1\n    } else if (b.order) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  // Sort sanitized.toolbarFixed.groups by order property\n  sanitized.toolbarFixed.groups.sort((a, b) => {\n    if (a.order && b.order) {\n      return a.order - b.order\n    } else if (a.order) {\n      return -1\n    } else if (b.order) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n\n  // Sort sanitized.toolbarInline.groups.[group].entries by order property\n  for (const group of sanitized.toolbarInline.groups) {\n    group.items.sort((a, b) => {\n      if (a.order && b.order) {\n        return a.order - b.order\n      } else if (a.order) {\n        return -1\n      } else if (b.order) {\n        return 1\n      } else {\n        return 0\n      }\n    })\n  }\n\n  // Sort sanitized.toolbarFixed.groups.[group].entries by order property\n  for (const group of sanitized.toolbarFixed.groups) {\n    group.items.sort((a, b) => {\n      if (a.order && b.order) {\n        return a.order - b.order\n      } else if (a.order) {\n        return -1\n      } else if (b.order) {\n        return 1\n      } else {\n        return 0\n      }\n    })\n  }\n\n  return sanitized\n}\n\nexport function sanitizeClientEditorConfig(\n  resolvedClientFeatureMap: ResolvedClientFeatureMap,\n  lexical?: LexicalEditorConfig,\n  admin?: LexicalFieldAdminClientProps,\n): SanitizedClientEditorConfig {\n  return {\n    admin,\n    features: sanitizeClientFeatures(resolvedClientFeatureMap),\n    lexical: lexical!,\n    resolvedFeatureMap: resolvedClientFeatureMap,\n  }\n}\n","'use client'\n\n/**\n * @deprecated - remove in 4.0. lexical already exports an isHTMLElement utility\n */\nexport function isHTMLElement(x: unknown): x is HTMLElement {\n  return x instanceof HTMLElement\n}\n","'use client'\nexport function joinClasses(...args: Array<boolean | null | string | undefined>): string {\n  return args.filter(Boolean).join(' ')\n}\n","'use client'\ntype Force = [number, number]\ntype Listener = (force: Force, e: TouchEvent) => void\ninterface ElementValues {\n  handleTouchend: (e: TouchEvent) => void\n  handleTouchstart: (e: TouchEvent) => void\n  listeners: Set<Listener>\n  start: Force | null\n}\n\nconst elements = new WeakMap<HTMLElement, ElementValues>()\n\nfunction readTouch(e: TouchEvent): [number, number] | null {\n  const touch = e.changedTouches[0]\n  if (touch === undefined) {\n    return null\n  }\n  return [touch.clientX, touch.clientY]\n}\n\nfunction addListener(element: HTMLElement, cb: Listener): () => void {\n  let elementValues = elements.get(element)\n  if (elementValues === undefined) {\n    const listeners = new Set<Listener>()\n    const handleTouchstart = (e: TouchEvent): void => {\n      if (elementValues !== undefined) {\n        elementValues.start = readTouch(e)\n      }\n    }\n    const handleTouchend = (e: TouchEvent): void => {\n      if (elementValues === undefined) {\n        return\n      }\n      const { start } = elementValues\n      if (start === null) {\n        return\n      }\n      const end = readTouch(e)\n      for (const listener of listeners) {\n        if (end !== null) {\n          listener([end[0] - start[0], end[1] - start[1]], e)\n        }\n      }\n    }\n    element.addEventListener('touchstart', handleTouchstart)\n    element.addEventListener('touchend', handleTouchend)\n\n    elementValues = {\n      handleTouchend,\n      handleTouchstart,\n      listeners,\n      start: null,\n    }\n    elements.set(element, elementValues)\n  }\n  elementValues.listeners.add(cb)\n  return () => {\n    deleteListener(element, cb)\n  }\n}\n\nfunction deleteListener(element: HTMLElement, cb: Listener): void {\n  const elementValues = elements.get(element)\n  if (elementValues === undefined) {\n    return\n  }\n  const { listeners } = elementValues\n  listeners.delete(cb)\n  if (listeners.size === 0) {\n    elements.delete(element)\n    element.removeEventListener('touchstart', elementValues.handleTouchstart)\n    element.removeEventListener('touchend', elementValues.handleTouchend)\n  }\n}\n\nexport function addSwipeLeftListener(\n  element: HTMLElement,\n  cb: (_force: number, e: TouchEvent) => void,\n): () => void {\n  return addListener(element, (force, e) => {\n    const [x, y] = force\n    if (x < 0 && -x > Math.abs(y)) {\n      cb(x, e)\n    }\n  })\n}\n\nexport function addSwipeRightListener(\n  element: HTMLElement,\n  cb: (_force: number, e: TouchEvent) => void,\n): () => void {\n  return addListener(element, (force, e) => {\n    const [x, y] = force\n    if (x > 0 && x > Math.abs(y)) {\n      cb(x, e)\n    }\n  })\n}\n\nexport function addSwipeUpListener(\n  element: HTMLElement,\n  cb: (_force: number, e: TouchEvent) => void,\n): () => void {\n  return addListener(element, (force, e) => {\n    const [x, y] = force\n    if (y < 0 && -y > Math.abs(x)) {\n      cb(x, e)\n    }\n  })\n}\n\nexport function addSwipeDownListener(\n  element: HTMLElement,\n  cb: (_force: number, e: TouchEvent) => void,\n): () => void {\n  return addListener(element, (force, e) => {\n    const [x, y] = force\n    if (y > 0 && y > Math.abs(x)) {\n      cb(x, e)\n    }\n  })\n}\n","'use client'\nimport React from 'react'\n\nimport { useInlineBlockComponentContext } from '../index.js'\n\nexport const InlineBlockEditButton = () => {\n  const { EditButton } = useInlineBlockComponentContext()\n\n  return EditButton ? <EditButton /> : null\n}\n","'use client'\nimport React from 'react'\n\nimport { useInlineBlockComponentContext } from '../index.js'\n\nexport const InlineBlockRemoveButton = () => {\n  const { RemoveButton } = useInlineBlockComponentContext()\n\n  return RemoveButton ? <RemoveButton /> : null\n}\n","'use client'\nimport React from 'react'\n\nimport { useInlineBlockComponentContext } from '../index.js'\n\nexport const InlineBlockLabel = () => {\n  const { Label } = useInlineBlockComponentContext()\n\n  return Label ? <Label /> : null\n}\n","'use client'\nimport React from 'react'\n\nimport { useInlineBlockComponentContext } from '../index.js'\n\nexport const InlineBlockContainer = ({ children }: { children: React.ReactNode }) => {\n  const { InlineBlockContainer } = useInlineBlockComponentContext()\n\n  return InlineBlockContainer ? <InlineBlockContainer>{children}</InlineBlockContainer> : null\n}\n","'use client'\nimport React from 'react'\n\nimport { type BlockCollapsibleProps, useBlockComponentContext } from '../BlockContent.js'\n\nexport const BlockCollapsible: React.FC<BlockCollapsibleProps> = (props) => {\n  const { children, ...rest } = props\n  const { BlockCollapsible } = useBlockComponentContext()\n\n  return BlockCollapsible ? <BlockCollapsible {...rest}>{children}</BlockCollapsible> : null\n}\n","'use client'\nimport React from 'react'\n\nimport { useBlockComponentContext } from '../BlockContent.js'\n\nexport const BlockEditButton = () => {\n  const { EditButton } = useBlockComponentContext()\n\n  return EditButton ? <EditButton /> : null\n}\n","'use client'\nimport React from 'react'\n\nimport { useBlockComponentContext } from '../BlockContent.js'\n\nexport const BlockRemoveButton = () => {\n  const { RemoveButton } = useBlockComponentContext()\n\n  return RemoveButton ? <RemoveButton /> : null\n}\n","import { stringify } from 'qs-esm'\n\nimport type { HTMLPopulateFn } from '../lexicalToHtml/async/types.js'\n\nexport const getRestPopulateFn: (args: {\n  /**\n   * E.g. `http://localhost:3000/api`\n   */\n  apiURL: string\n  depth?: number\n  draft?: boolean\n  locale?: string\n}) => HTMLPopulateFn = ({ apiURL, depth, draft, locale }) => {\n  const populateFn: HTMLPopulateFn = async ({ id, collectionSlug, select }) => {\n    const query = stringify(\n      { depth: depth ?? 0, draft: draft ?? false, locale, select },\n      { addQueryPrefix: true },\n    )\n\n    const res = await fetch(`${apiURL}/${collectionSlug}/${id}${query}`, {\n      credentials: 'include',\n      headers: {\n        Accept: 'application/json',\n        'Content-Type': 'application/json',\n      },\n      method: 'GET',\n    }).then((res) => res.json())\n\n    return res\n  }\n\n  return populateFn\n}\n","import type { BlockJSX } from 'payload'\n\n/**\n * @internal\n * @experimental - API may change in minor releases\n */\nexport const codeConverter: BlockJSX = {\n  customEndRegex: {\n    optional: true,\n    regExp: /[ \\t]*```$/,\n  },\n  customStartRegex: /^[ \\t]*```(\\w+)?/,\n  doNotTrimChildren: true,\n  export: ({ fields }) => {\n    const isSingleLine = !fields.code.includes('\\n') && !fields.language?.length\n    if (isSingleLine) {\n      return '```' + fields.code + '```'\n    }\n\n    return '```' + (fields.language || '') + (fields.code ? '\\n' + fields.code : '') + '\\n' + '```'\n  },\n  import: ({ children, closeMatch, openMatch }) => {\n    const language = openMatch?.[1]\n\n    // Removed first and last \\n from children if present\n    if (children.startsWith('\\n')) {\n      children = children.slice(1)\n    }\n    if (children.endsWith('\\n')) {\n      children = children.slice(0, -1)\n    }\n\n    const isSingleLineAndComplete =\n      !!closeMatch && !children.includes('\\n') && openMatch?.input?.trim() !== '```' + language\n\n    if (isSingleLineAndComplete) {\n      return {\n        code: language + (children?.length ? children : ''), // No need to add space to children as they are not trimmed\n        language: '',\n      }\n    }\n\n    return {\n      code: children,\n      language,\n    }\n  },\n}\n","'use client'\n\nimport type { CodeFieldClient, CodeFieldClientProps } from 'payload'\n\nimport { CodeField, useFormFields } from '@payloadcms/ui'\nimport React, { useId, useMemo } from 'react'\n\nimport { defaultLanguages } from './defaultLanguages.js'\n\nexport type AdditionalCodeComponentProps = {\n  /**\n   * @default first key of the `languages` prop\n   */\n  defaultLanguage?: string\n  /**\n   * @default all languages supported by Monaco Editor\n   */\n  languages?: Record<string, string>\n  /**\n   * Override the name of the block.\n   *\n   * @default 'Code'\n   */\n  slug?: string\n  /**\n   * Configure typescript settings for the editor\n   */\n  typescript?: {\n    /**\n     * By default, the editor will not perform semantic validation. This means that\n     * while syntax errors will be highlighted, other issues like missing imports or incorrect\n     * types will not be.\n     *\n     * @default false\n     */\n    enableSemanticValidation?: boolean\n    /**\n     * Additional types to fetch and include in the editor for autocompletion.\n     *\n     * For example, to include types for payload, you would set this to\n     *\n     * [{ url: 'https://unpkg.com/payload@latest/dist/index.d.ts', filePath: 'file:///node_modules/payload/index.d.ts' }]\n     */\n    fetchTypes?: Array<{\n      filePath: string\n      url: string\n    }>\n    /**\n     * @default undefined\n     */\n    paths?: Record<string, string[]>\n    /**\n     * @default \"ESNext\"\n     */\n    target?: string\n    /**\n     * @default ['node_modules/@types']\n     */\n    typeRoots?: string[]\n  }\n}\n\nexport const CodeComponent: React.FC<AdditionalCodeComponentProps & CodeFieldClientProps> = ({\n  autoComplete,\n  field,\n  forceRender,\n  languages = defaultLanguages,\n  path,\n  permissions,\n  readOnly,\n  renderedBlocks,\n  schemaPath,\n  typescript,\n  validate,\n}) => {\n  const languageField = useFormFields(([fields]) => fields['language'])\n\n  const language: string =\n    (languageField?.value as string) || (languageField?.initialValue as string) || 'typescript'\n\n  // unique id per component instance to ensure Monaco creates a distinct model\n  // for each TypeScript code block. Using React's useId is SSR-safe and builtin.\n  const instanceId = useId()\n\n  const label = languages[language]\n\n  const props: CodeFieldClient = useMemo<CodeFieldClient>(\n    () => ({\n      ...field,\n      type: 'code',\n      admin: {\n        ...field.admin,\n        editorOptions: {},\n        editorProps: {\n          // If typescript is set, @monaco-editor/react needs to set the URI to a .ts or .tsx file when it calls createModel().\n          // Provide a unique defaultPath per instance so Monaco doesn't reuse the same model\n          // across multiple code block instances. We use field.name + instanceId for debugability.\n          defaultPath: language === 'ts' ? `file-${field.name}-${instanceId}.tsx` : undefined,\n        },\n        language,\n      },\n    }),\n    [field, language, instanceId],\n  )\n\n  const key = `${field.name}-${language}-${label}`\n\n  return (\n    props && (\n      <CodeField\n        autoComplete={autoComplete}\n        field={props}\n        forceRender={forceRender}\n        key={key}\n        onMount={(_editor, monaco) => {\n          monaco.editor.defineTheme('vs-dark', {\n            base: 'vs-dark',\n            colors: {\n              'editor.background': '#222222',\n            },\n            inherit: true,\n            rules: [],\n          })\n\n          monaco.editor.defineTheme('vs', {\n            base: 'vs',\n            colors: {\n              'editor.background': '#f5f5f5',\n            },\n            inherit: true,\n            rules: [],\n          })\n          monaco.languages.typescript.typescriptDefaults.setCompilerOptions({\n            allowNonTsExtensions: true,\n            // Set module resolution to NodeJs to enable autocompletion\n            allowJs: true,\n            allowSyntheticDefaultImports: true,\n            esModuleInterop: true,\n            jsx: monaco.languages.typescript.JsxEmit.React,\n            moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,\n            noEmit: true,\n            paths: typescript?.paths,\n            reactNamespace: 'React',\n            target: monaco.languages.typescript.ScriptTarget[\n              typescript?.target ?? ('ESNext' as any)\n            ] as any,\n            typeRoots: typescript?.typeRoots ?? ['node_modules/@types'],\n          })\n\n          monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({\n            noSemanticValidation: typescript?.enableSemanticValidation ? false : true,\n            noSyntaxValidation: false,\n          })\n\n          const run = async () => {\n            if (\n              typescript?.fetchTypes &&\n              Array.isArray(typescript.fetchTypes) &&\n              typescript.fetchTypes.length > 0\n            ) {\n              await Promise.all(\n                typescript.fetchTypes.map(async (type) => {\n                  const types = await fetch(type.url)\n                  const typesText = await types.text()\n                  monaco.languages.typescript.typescriptDefaults.addExtraLib(\n                    typesText,\n                    type.filePath,\n                  )\n                }),\n              )\n            }\n          }\n          void run()\n        }}\n        path={path}\n        permissions={permissions}\n        readOnly={readOnly}\n        renderedBlocks={renderedBlocks}\n        schemaPath={schemaPath}\n        validate={validate}\n      />\n    )\n  )\n}\n","/**\n * Source: https://github.com/microsoft/monaco-editor/tree/main/src/basic-languages\n */\nexport const defaultLanguages: Record<string, string> = {\n  abap: 'ABAP',\n  apex: 'Apex',\n  azcli: 'Azure CLI',\n  bat: 'Batch',\n  bicep: 'Bicep',\n  cameligo: 'CameLIGO',\n  clojure: 'Clojure',\n  coffee: 'CoffeeScript',\n  cpp: 'C++',\n  csharp: 'C#',\n  csp: 'CSP',\n  css: 'CSS',\n  cypher: 'Cypher',\n  dart: 'Dart',\n  dockerfile: 'Dockerfile',\n  ecl: 'ECL',\n  elixir: 'Elixir',\n  flow9: 'Flow9',\n  freemarker2: 'FreeMarker 2',\n  fsharp: 'F#',\n  go: 'Go',\n  graphql: 'GraphQL',\n  handlebars: 'Handlebars',\n  hcl: 'HCL',\n  html: 'HTML',\n  ini: 'INI',\n  java: 'Java',\n  javascript: 'JavaScript',\n  julia: 'Julia',\n  kotlin: 'Kotlin',\n  less: 'Less',\n  lexon: 'Lexon',\n  liquid: 'Liquid',\n  lua: 'Lua',\n  m3: 'M3',\n  markdown: 'Markdown',\n  mdx: 'MDX',\n  mips: 'MIPS',\n  msdax: 'DAX',\n  mysql: 'MySQL',\n  'objective-c': 'Objective-C',\n  pascal: 'Pascal',\n  pascaligo: 'PascaLIGO',\n  perl: 'Perl',\n  pgsql: 'PostgreSQL',\n  php: 'PHP',\n  pla: 'PLA',\n  plaintext: 'Plain Text',\n  postiats: 'Postiats',\n  powerquery: 'Power Query',\n  powershell: 'PowerShell',\n  protobuf: 'Protobuf',\n  pug: 'Pug',\n  python: 'Python',\n  qsharp: 'Q#',\n  r: 'R',\n  razor: 'Razor',\n  redis: 'Redis',\n  redshift: 'Amazon Redshift',\n  restructuredtext: 'reStructuredText',\n  ruby: 'Ruby',\n  rust: 'Rust',\n  sb: 'Small Basic',\n  scala: 'Scala',\n  scheme: 'Scheme',\n  scss: 'SCSS',\n  shell: 'Shell',\n  solidity: 'Solidity',\n  sophia: 'Sophia',\n  sparql: 'SPARQL',\n  sql: 'SQL',\n  st: 'Structured Text',\n  swift: 'Swift',\n  systemverilog: 'SystemVerilog',\n  tcl: 'Tcl',\n  twig: 'Twig',\n  typescript: 'TypeScript',\n  typespec: 'TypeSpec',\n  vb: 'Visual Basic',\n  wgsl: 'WGSL',\n  xml: 'XML',\n  yaml: 'YAML',\n}\n","'use client'\nimport type { ComboboxEntry } from '@payloadcms/ui'\nimport type {} from 'payload'\n\nimport './index.scss'\n\nimport { useLexicalEditable } from '@lexical/react/useLexicalEditable'\nimport {\n  ChevronIcon,\n  Combobox,\n  CopyToClipboard,\n  PopupList,\n  RenderFields,\n  useForm,\n  useFormFields,\n  useTranslation,\n} from '@payloadcms/ui'\nimport React from 'react'\n\nimport type { AdditionalCodeComponentProps } from './Code.js'\n\nimport { CodeBlockIcon } from '../../../../../lexical/ui/icons/CodeBlock/index.js'\nimport { useBlockComponentContext } from '../../../client/component/BlockContent.js'\nimport { Collapse } from './Collapse/index.js'\nimport { defaultLanguages } from './defaultLanguages.js'\nimport { FloatingCollapse } from './FloatingCollapse/index.js'\n\nconst baseClass = 'payload-richtext-code-block'\nexport const CodeBlockBlockComponent: React.FC<Pick<AdditionalCodeComponentProps, 'languages'>> = (\n  args,\n) => {\n  const { languages: languagesFromProps } = args\n  const languages = languagesFromProps || defaultLanguages\n\n  const { BlockCollapsible, formSchema, RemoveButton } = useBlockComponentContext()\n  const { setModified } = useForm()\n  const { t } = useTranslation()\n\n  const { codeField } = useFormFields(([fields]) => ({\n    codeField: fields?.code,\n  }))\n\n  const { selectedLanguageField, setSelectedLanguage } = useFormFields(([fields, dispatch]) => ({\n    selectedLanguageField: fields?.language,\n    setSelectedLanguage: (language: string) => {\n      dispatch({\n        type: 'UPDATE',\n        path: 'language',\n        value: language,\n      })\n      setModified(true)\n    },\n  }))\n\n  const selectedLanguageLabel = languages[selectedLanguageField?.value as keyof typeof languages]\n\n  const isEditable = useLexicalEditable()\n\n  const languageEntries = React.useMemo<ComboboxEntry[]>(() => {\n    return Object.entries(languages).map(([languageCode, languageLabel]) => ({\n      name: `${languageCode} ${languageLabel}`,\n      Component: (\n        <PopupList.Button\n          active={false}\n          disabled={false}\n          onClick={() => {\n            setSelectedLanguage(languageCode)\n          }}\n        >\n          <span className={`${baseClass}__language-code`} data-language={languageCode}>\n            {languageLabel}\n          </span>\n        </PopupList.Button>\n      ),\n    }))\n  }, [languages, setSelectedLanguage])\n\n  return (\n    <BlockCollapsible\n      Actions={\n        <div className={`${baseClass}__actions`}>\n          <Combobox\n            button={\n              <div\n                className={`${baseClass}__language-selector-button`}\n                data-selected-language={selectedLanguageField?.value}\n              >\n                <span>{selectedLanguageLabel}</span>\n                <ChevronIcon className={`${baseClass}__chevron`} />\n              </div>\n            }\n            buttonType=\"custom\"\n            className={`${baseClass}__language-selector`}\n            disabled={!isEditable}\n            entries={languageEntries}\n            horizontalAlign=\"right\"\n            minEntriesForSearch={8}\n            searchPlaceholder={t('fields:searchForLanguage')}\n            showScrollbar\n            size=\"large\"\n          />\n          <CopyToClipboard value={(codeField?.value as string) ?? ''} />\n\n          <Collapse />\n\n          {isEditable && <RemoveButton />}\n        </div>\n      }\n      className={baseClass}\n      collapsibleProps={{\n        AfterCollapsible: <FloatingCollapse />,\n        disableHeaderToggle: true,\n        disableToggleIndicator: true,\n      }}\n      Pill={\n        <div className={`${baseClass}__pill`}>\n          <CodeBlockIcon />\n        </div>\n      }\n    >\n      <RenderFields\n        fields={formSchema}\n        forceRender={true}\n        parentIndexPath=\"\"\n        parentPath={''}\n        parentSchemaPath=\"\"\n        permissions={true}\n        readOnly={!isEditable}\n      />\n    </BlockCollapsible>\n  )\n}\n","'use client'\nimport React from 'react'\n\nexport const CodeBlockIcon: React.FC = () => (\n  <svg fill=\"none\" height=\"12\" viewBox=\"0 0 15 12\" width=\"15\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path\n      d=\"M11.3738 8.62598L14.0404 5.95931L11.3738 3.29264M3.37376 3.29264L0.707092 5.95931L3.37376 8.62598M9.04043 0.625977L5.70709 11.2926\"\n      stroke=\"currentColor\"\n      strokeLinecap=\"square\"\n    />\n  </svg>\n)\n","import React from 'react'\n\nimport './index.scss'\n\nconst baseClass = 'code-block-collapse-button'\nimport { useCollapsible } from '@payloadcms/ui'\n\nimport { CollapseIcon } from '../../../../../../lexical/ui/icons/Collapse/index.js'\n\nexport const Collapse: React.FC = () => {\n  const { toggle } = useCollapsible()\n  return (\n    <button className={baseClass} onClick={toggle} type=\"button\">\n      <CollapseIcon />\n    </button>\n  )\n}\n","'use client'\nimport React from 'react'\n\nexport const CollapseIcon: React.FC = () => (\n  <svg fill=\"none\" height=\"15\" viewBox=\"0 0 15 15\" width=\"15\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path\n      d=\"M7.16667 13.8333V9.83333M7.16667 9.83333L9.16667 11.8333M7.16667 9.83333L5.16667 11.8333M7.16667 4.5V0.5M7.16667 4.5L9.16667 2.5M7.16667 4.5L5.16667 2.5M1.83333 7.16667H0.5M5.83333 7.16667H4.5M9.83333 7.16667H8.5M13.8333 7.16667H12.5\"\n      stroke=\"currentColor\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    />\n  </svg>\n)\n","import React from 'react'\n\nimport './index.scss'\n\nconst baseClass = 'code-block-floating-collapse-button'\nimport { useCollapsible, useTranslation } from '@payloadcms/ui'\n\nimport { CollapseIcon } from '../../../../../../lexical/ui/icons/Collapse/index.js'\n\nexport const FloatingCollapse: React.FC = () => {\n  const { isCollapsed, toggle } = useCollapsible()\n  const { t } = useTranslation()\n\n  if (!isCollapsed) {\n    return null\n  }\n\n  return (\n    <button className={baseClass} onClick={toggle} type=\"button\">\n      <span>{t('general:collapse')}</span>\n      <CollapseIcon />\n    </button>\n  )\n}\n","'use client'\nimport type { RichTextField } from 'payload'\n\nimport {\n  FieldContext,\n  FieldPathContext,\n  type FieldType,\n  type RenderFieldServerFnArgs,\n  ServerFunctionsContext,\n  type ServerFunctionsContextType,\n  ShimmerEffect,\n  useServerFunctions,\n} from '@payloadcms/ui'\nimport React, { useCallback, useEffect, useRef } from 'react'\n\nimport type { DefaultTypedEditorState } from '../../nodeTypes.js'\nimport type { LexicalRichTextField } from '../../types.js'\n\n/**\n * Utility to render a lexical editor on the client.\n *\n * @experimental - may break in minor releases\n * @todo - replace this with a general utility that works for all fields. Maybe merge with packages/ui/src/forms/RenderFields/RenderField.tsx\n */\nexport const RenderLexical: React.FC<\n  /**\n   * If value or setValue, or both, is provided, this component will manage its own value.\n   * If neither is passed, it will rely on the parent form to manage the value.\n   */\n  {\n    /**\n     * Override the loading state while the field component is being fetched and rendered.\n     */\n    Loading?: React.ReactElement\n\n    setValue?: FieldType<DefaultTypedEditorState | undefined>['setValue']\n    value?: FieldType<DefaultTypedEditorState | undefined>['value']\n  } & RenderFieldServerFnArgs<LexicalRichTextField>\n> = (args) => {\n  const { field, initialValue, Loading, path, schemaPath, setValue, value } = args\n  const [Component, setComponent] = React.useState<null | React.ReactNode>(null)\n  const serverFunctionContext = useServerFunctions()\n  const { _internal_renderField } = serverFunctionContext\n\n  const [entityType, entitySlug] = schemaPath.split('.', 2)\n\n  const fieldPath = path ?? (field && 'name' in field ? field?.name : '') ?? ''\n\n  const renderLexical = useCallback(() => {\n    async function render() {\n      const { Field } = await _internal_renderField({\n        field: {\n          ...((field as RichTextField) || {}),\n          type: 'richText',\n          admin: {\n            ...((field as RichTextField)?.admin || {}),\n            // When using \"fake\" anchor fields, hidden is often set to true. We need to override that here to ensure the field is rendered.\n            hidden: false,\n          },\n        },\n        initialValue: initialValue ?? undefined,\n        path,\n        schemaPath,\n      })\n\n      setComponent(Field)\n    }\n    void render()\n  }, [_internal_renderField, schemaPath, path, field, initialValue])\n\n  const mounted = useRef(false)\n\n  useEffect(() => {\n    if (mounted.current) {\n      return\n    }\n    mounted.current = true\n    void renderLexical()\n  }, [renderLexical])\n\n  if (!Component) {\n    return typeof Loading !== 'undefined' ? Loading : <ShimmerEffect />\n  }\n\n  /**\n   * By default, the lexical will make form state requests (e.g. to get drawer fields), passing in the arguments\n   * of the current field. However, we need to override those arguments to get it to make requests based on the\n   * *target* field. The server only knows the schema map of the target field.\n   */\n  const adjustedServerFunctionContext: ServerFunctionsContextType = {\n    ...serverFunctionContext,\n    getFormState: async (getFormStateArgs) => {\n      return serverFunctionContext.getFormState({\n        ...getFormStateArgs,\n        collectionSlug: entityType === 'collection' ? entitySlug : undefined,\n        globalSlug: entityType === 'global' ? entitySlug : undefined,\n      })\n    },\n  }\n\n  if (typeof value === 'undefined' && !setValue) {\n    return (\n      <ServerFunctionsContext value={{ ...adjustedServerFunctionContext }}>\n        <FieldPathContext key={fieldPath} value={fieldPath}>\n          {Component}\n        </FieldPathContext>\n      </ServerFunctionsContext>\n    )\n  }\n\n  const fieldValue: FieldType<DefaultTypedEditorState | undefined> = {\n    disabled: false,\n    formInitializing: false,\n    formProcessing: false,\n    formSubmitted: false,\n    initialValue: value,\n    path: fieldPath,\n    setValue: setValue ?? (() => undefined),\n    showError: false,\n    value,\n  }\n\n  return (\n    <ServerFunctionsContext value={{ ...adjustedServerFunctionContext }}>\n      <FieldPathContext key={fieldPath} value={fieldPath}>\n        <FieldContext value={fieldValue}>{Component}</FieldContext>\n      </FieldPathContext>\n    </ServerFunctionsContext>\n  )\n}\n","import type { SerializedLexicalNode } from 'lexical'\n\nimport type { DefaultNodeTypes, DefaultTypedEditorState, TypedEditorState } from '../nodeTypes.js'\n\n/**\n * Helper to build lexical editor state JSON from text and/or nodes.\n *\n * @param nodes - The nodes to include in the editor state. If you pass the `text` argument, this will append your nodes after the first paragraph node.\n * @param text - The text content to include in the editor state. This will create a paragraph node with a text node for you and set that as the first node.\n * @returns The constructed editor state JSON.\n *\n * @example\n *\n * just passing text:\n *\n * ```ts\n * const editorState = buildEditorState<DefaultNodeTypes>({ text: 'Hello world' }) // result typed as DefaultTypedEditorState\n * ```\n *\n * @example\n *\n * passing nodes:\n *\n * ```ts\n * const editorState = // result typed as TypedEditorState<DefaultNodeTypes | SerializedBlockNode> (or TypedEditorState<SerializedBlockNode>)\n * buildEditorState<DefaultNodeTypes | SerializedBlockNode>({ // or just buildEditorState<SerializedBlockNode> if you *only* want to allow block nodes\n *   nodes: [\n *     {\n *       type: 'block',\n *        fields: {\n *          id: 'id',\n *          blockName: 'Cool block',\n *          blockType: 'myBlock',\n *        },\n *        format: 'left',\n *        version: 1,\n *      }\n *   ],\n * })\n * ```\n */\nexport function buildEditorState<T extends SerializedLexicalNode>({\n  nodes,\n  text,\n}: {\n  nodes?: TypedEditorState<T>['root']['children']\n  text?: string\n}): TypedEditorState<T> {\n  const editorJSON: DefaultTypedEditorState = {\n    root: {\n      type: 'root',\n      children: [],\n      direction: 'ltr',\n      format: '',\n      indent: 0,\n      version: 1,\n    },\n  }\n\n  if (text) {\n    editorJSON.root.children.push({\n      type: 'paragraph',\n      children: [\n        {\n          type: 'text',\n          detail: 0,\n          format: 0,\n          mode: 'normal',\n          style: '',\n          text,\n          version: 1,\n        },\n      ],\n      direction: 'ltr',\n      format: '',\n      indent: 0,\n      textFormat: 0,\n      textStyle: '',\n      version: 1,\n    })\n  }\n\n  if (nodes?.length) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    editorJSON.root.children.push(...(nodes as any))\n  }\n\n  return editorJSON as TypedEditorState<T>\n}\n\n/**\n *\n * Alias for `buildEditorState<DefaultNodeTypes>`\n *\n * @experimental this API may change or be removed in a minor release\n * @internal\n */\nexport const buildDefaultEditorState: typeof buildEditorState<DefaultNodeTypes> =\n  buildEditorState<DefaultNodeTypes>\n"],"names":["slashMenuBasicGroupWithItems", "items", "key", "label", "i18n", "t", "$isElementNode", "$isRangeSelection", "FORMAT_ELEMENT_COMMAND", "AlignCenterIcon", "_jsxs", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "_jsx", "d", "stroke", "strokeWidth", "AlignJustifyIcon", "_jsxs", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "_jsx", "d", "stroke", "strokeWidth", "AlignLeftIcon", "_jsxs", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "_jsx", "d", "stroke", "strokeWidth", "AlignRightIcon", "_jsxs", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "_jsx", "d", "stroke", "strokeWidth", "createClientFeature", "feature", "props", "featureProviderClient", "clientFeatureProps", "config", "featureClientImportMap", "featureClientSchemaMap", "featureProviderMap", "field", "resolvedFeatures", "schemaPath", "unSanitizedEditorConfig", "toReturn", "sanitizedClientFeatureProps", "newFeature", "toolbarAlignGroupWithItems", "items", "type", "ChildComponent", "AlignLeftIcon", "key", "order", "toolbarGroups", "toolbarAlignGroupWithItems", "ChildComponent", "AlignLeftIcon", "isActive", "selection", "$isRangeSelection", "node", "getNodes", "$isElementNode", "getFormatType", "parent", "getParent", "key", "label", "i18n", "t", "onSelect", "editor", "dispatchCommand", "FORMAT_ELEMENT_COMMAND", "order", "AlignCenterIcon", "AlignRightIcon", "AlignJustifyIcon", "AlignFeatureClient", "createClientFeature", "toolbarFixed", "groups", "toolbarInline", "$createQuoteNode", "$isQuoteNode", "QuoteNode", "$setBlocksType", "$getSelection", "$isRangeSelection", "BlockquoteIcon", "_jsx", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "d", "TextIcon", "_jsx", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "d", "toolbarTextDropdownGroupWithItems", "items", "type", "ChildComponent", "TextIcon", "key", "order", "$createQuoteNode", "$isQuoteNode", "QuoteNode", "MarkdownTransformer", "type", "dependencies", "export", "node", "exportChildren", "lines", "split", "output", "line", "push", "join", "regExp", "replace", "parentNode", "children", "_match", "isImport", "previousNode", "getPreviousSibling", "splice", "getChildrenSize", "select", "remove", "append", "toolbarGroups", "toolbarTextDropdownGroupWithItems", "ChildComponent", "BlockquoteIcon", "isActive", "selection", "$isRangeSelection", "node", "getNodes", "$isQuoteNode", "getParent", "key", "label", "i18n", "t", "onSelect", "editor", "update", "$getSelection", "$setBlocksType", "$createQuoteNode", "order", "BlockquoteFeatureClient", "createClientFeature", "markdownTransformers", "MarkdownTransformer", "nodes", "QuoteNode", "slashMenu", "groups", "slashMenuBasicGroupWithItems", "Icon", "keywords", "toolbarFixed", "toolbarInline", "getTranslation", "BlockIcon", "_jsxs", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "_jsx", "rx", "stroke", "x", "y", "InlineBlocksIcon", "_jsx", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "clipRule", "d", "fillRule", "getBlockImageComponent", "imageURL", "imageAltText", "_jsx", "alt", "className", "src", "style", "maxHeight", "maxWidth", "BlockIcon", "$parseSerializedNode", "JSOX", "extractPropsFromJSXPropsString", "propsString", "props", "key", "collectingKey", "i", "length", "char", "result", "handleValue", "value", "newIndex", "startIndex", "handleQuotedString", "handleObject", "handleArray", "handleUnquotedString", "bracketCount", "parse", "isSingleQuoted", "parseObject", "objString", "replace", "propsToJSXString", "props", "propsArray", "key", "value", "Object", "entries", "push", "escapeQuotes", "Array", "isArray", "map", "v", "JSON", "stringify", "replacer", "join", "str", "replace", "linesFromStartToContentAndPropsString", "isEndOptional", "lines", "regexpEndRegex", "startLineIndex", "startMatch", "trimChildren", "propsString", "content", "linesCopy", "slice", "isWithinContent", "contentSubTagStartAmount", "bracketCount", "quoteChar", "isSelfClosing", "isWithinCodeBlockAmount", "beforeStartLine", "index", "endlineLastCharIndex", "endLineIndex", "mainLoop", "lineIndex", "lineCopy", "entries", "line", "trim", "amountOfBeginningSpacesRemoved", "i", "length", "charIndex", "char", "nextChar", "match", "undefined", "Error", "join", "JSON", "stringify", "afterEndLine", "ObjectID", "$applyNodeReplacement", "DecoratorBlockNode", "addClassNamesToElement", "ObjectID", "$applyNodeReplacement", "ServerBlockNode", "__cacheBuster", "__fields", "constructor", "cacheBuster", "fields", "format", "key", "clone", "node", "__format", "__key", "getType", "importDOM", "importJSON", "serializedNode", "version", "data", "$createServerBlockNode", "setFormat", "isInline", "createDOM", "config", "element", "document", "createElement", "theme", "block", "decorate", "editor", "exportDOM", "text", "createTextNode", "getTextContent", "append", "exportJSON", "type", "getFields", "getCacheBuster", "getLatest", "setFields", "preventFormStateUpdate", "writable", "getWritable", "id", "default", "toHexString", "useLexicalComposerContext", "useLexicalEditable", "getTranslation", "Button", "Collapsible", "Drawer", "EditDepthProvider", "ErrorPill", "Form", "formatDrawerSlug", "FormSubmit", "Pill", "RenderFields", "SectionTitle", "useConfig", "useDocumentForm", "useDocumentInfo", "useEditDepth", "useFormSubmitted", "useServerFunctions", "useTranslation", "abortAndIgnore", "$getNodeByKey", "deepCopyObjectSimpleWithoutReactComponents", "reduceFieldsToValues", "React", "useCallback", "useEffect", "useMemo", "useRef", "v4", "uuid", "c", "_c", "useLexicalEditable", "RenderFields", "useFormSubmitted", "React", "createContext", "BlockComponentContext", "baseClass", "BlockCollapsible", "BlockDrawer", "CustomBlock", "EditButton", "errorCount", "formSchema", "initialState", "nodeKey", "RemoveButton", "useBlockComponentContext", "use", "BlockContent", "props", "$", "Collapsible", "contextProps", "fieldHasErrors", "isEditable", "t0", "props_0", "children", "rest", "_jsx", "CollapsibleWithErrorProps", "_jsxs", "value", "fields", "forceRender", "parentIndexPath", "parentPath", "parentSchemaPath", "permissions", "readOnly", "removeEmptyArrayValues", "fields", "key", "field", "Array", "isArray", "rows", "disableFormData", "BlockComponent", "props", "cacheBuster", "className", "baseClass", "formData", "nodeKey", "submitted", "useFormSubmitted", "id", "collectionSlug", "globalSlug", "useDocumentInfo", "fieldProps", "featureClientSchemaMap", "field", "parentLexicalRichTextField", "initialLexicalFormState", "schemaPath", "uuid", "uuidFromContext", "useEditorConfigContext", "fields", "parentDocumentFields", "useDocumentForm", "onChangeAbortControllerRef", "useRef", "AbortController", "editDepth", "useEditDepth", "errorCount", "setErrorCount", "React", "useState", "config", "useConfig", "drawerSlug", "formatDrawerSlug", "slug", "depth", "toggleDrawer", "useLexicalDrawer", "getDocPreferences", "setDocFieldPreferences", "editor", "useLexicalComposerContext", "isEditable", "useLexicalEditable", "blockType", "getFormState", "useServerFunctions", "schemaFieldsPath", "initialState", "setInitialState", "cachedFormState", "formState", "Object", "fromEntries", "entries", "map", "fieldName", "fieldState", "initialValue", "value", "hasMounted", "prevCacheBuster", "useEffect", "current", "CustomLabel", "setCustomLabel", "customComponents", "BlockLabel", "undefined", "CustomBlock", "setCustomBlock", "Block", "abortController", "state", "data", "docPermissions", "docPreferences", "documentFormState", "deepCopyObjectSimpleWithoutReactComponents", "initialBlockData", "operation", "readOnly", "renderAllFields", "signal", "blockName", "passesCondition", "valid", "newFormStateData", "reduceFieldsToValues", "update", "node", "$getNodeByKey", "$isBlockNode", "newData", "setFields", "_components", "abortAndIgnore", "isCollapsed", "setIsCollapsed", "collapsed", "componentMapRenderedBlockPath", "blocksField", "clientBlock", "blockReferences", "blocksMap", "blocks", "i18n", "t", "useTranslation", "onChange", "useCallback", "prevFormState", "submit", "controller", "newFormState", "initialBlockFormState", "removeEmptyArrayValues", "setTimeout", "rowErrorCount", "formField", "values", "removeBlock", "remove", "blockDisplayName", "labels", "singular", "getTranslation", "onCollapsedChange", "changedCollapsed", "then", "currentDocPreferences", "collapsedArray", "name", "newCollapsed", "length", "includes", "push", "splice", "indexOf", "hello", "EditButton", "useMemo", "_jsx", "Button", "buttonStyle", "disabled", "el", "icon", "onClick", "e", "preventDefault", "stopPropagation", "onMouseDown", "round", "size", "tooltip", "label", "RemoveButton", "BlockCollapsible", "Actions", "children", "collapsibleProps", "disableBlockName", "editButton", "fieldHasErrors", "Label", "Pill", "CustomPill", "removeButton", "Collapsible", "filter", "Boolean", "join", "collapsibleStyle", "header", "_jsxs", "pillStyle", "admin", "SectionTitle", "path", "ErrorPill", "count", "withMessage", "_Fragment", "onToggle", "incomingCollapsedState", "blockID", "BlockDrawer", "EditDepthProvider", "Drawer", "title", "RenderFields", "forceRender", "parentIndexPath", "parentPath", "parentSchemaPath", "permissions", "FormSubmit", "programmaticSubmit", "Form", "beforeSubmit", "onSubmit", "BlockContent", "formSchema", "BlockNode", "ServerBlockNode", "clone", "node", "getType", "importJSON", "serializedNode", "version", "fields", "data", "$createBlockNode", "setFormat", "format", "decorate", "_editor", "config", "_jsx", "BlockComponent", "cacheBuster", "getCacheBuster", "className", "theme", "block", "formData", "getFields", "nodeKey", "getKey", "exportJSON", "$applyNodeReplacement", "id", "ObjectID", "default", "toHexString", "$isBlockNode", "createHeadlessEditor", "getLexicalToMarkdown", "allNodes", "allTransformers", "lexicalToMarkdown", "editorState", "headlessEditor", "createHeadlessEditor", "nodes", "setEditorState", "parseEditorState", "e", "console", "error", "markdown", "getEditorState", "read", "$convertToMarkdownString", "createHeadlessEditor", "getMarkdownToLexical", "allNodes", "allTransformers", "markdownToLexical", "markdown", "headlessEditor", "createHeadlessEditor", "nodes", "update", "$convertFromMarkdownString", "discrete", "getEditorState", "toJSON", "createTagRegexes", "tagName", "escapedTagName", "replace", "regExpEnd", "RegExp", "regExpStart", "getBlockMarkdownTransformers", "blocks", "inlineBlocks", "length", "transformers", "block", "transformer", "getMarkdownTransformerForBlock", "concat", "isInlineBlock", "jsx", "regex", "slug", "toReturn", "push", "allNodes", "allTransformers", "type", "dependencies", "InlineBlockNode", "export", "node", "$isInlineBlockNode", "getFields", "blockType", "toLowerCase", "nodeFields", "lexicalToMarkdown", "getLexicalToMarkdown", "exportResult", "fields", "hasProps", "props", "Object", "keys", "children", "propsToJSXString", "getEndIndex", "match", "endlineLastCharIndex", "linesFromStartToContentAndPropsString", "isEndOptional", "lines", "getTextContent", "regexpEndRegex", "startLineIndex", "startMatch", "trimChildren", "importRegExp", "customStartRegex", "regExp", "content", "propsString", "index", "import", "markdownToLexical", "getMarkdownToLexical", "blockFields", "closeMatch", "htmlToLexical", "openMatch", "extractPropsFromJSXPropsString", "inlineBlockNode", "$createInlineBlockNode", "BlockNode", "$isBlockNode", "sanitizedChildren", "includes", "child", "split", "sanitizedChild", "doNotTrimChildren", "handleImportAfterStartMatch", "customEndRegex", "undefined", "rootNode", "optional", "afterEndLine", "beforeStartLine", "unsanitizedContent", "endLineIndex", "endsWith", "slice", "startsWith", "$createBlockNode", "prevNodes", "nextNodes", "markdown", "root", "firstPrevNode", "append", "$parseSerializedNode", "lastChild", "getChildren", "linesInBetween", "line", "childrenString", "join", "trim", "createCommand", "INSERT_BLOCK_COMMAND", "INSERT_INLINE_BLOCK_COMMAND", "c", "_c", "useLexicalComposerContext", "$insertNodeToNearestRoot", "$wrapNodeInElement", "mergeRegister", "formatDrawerSlug", "useEditDepth", "$createParagraphNode", "$getNodeByKey", "$getPreviousSelection", "$getSelection", "$insertNodes", "$isParagraphNode", "$isRangeSelection", "$isRootOrShadowRoot", "COMMAND_PRIORITY_EDITOR", "useEffect", "useState", "BlocksPlugin", "$", "_c", "editor", "useLexicalComposerContext", "targetNodeKey", "setTargetNodeKey", "useState", "setCreatedInlineBlock", "uuid", "useEditorConfigContext", "editDepth", "useEditDepth", "t0", "t1", "formatDrawerSlug", "slug", "depth", "drawerSlug", "toggleDrawer", "useLexicalDrawer", "t2", "hasNodes", "BlockNode", "Error", "mergeRegister", "registerCommand", "INSERT_BLOCK_COMMAND", "payload", "update", "selection", "$getSelection", "$getPreviousSelection", "$isRangeSelection", "blockNode", "$createBlockNode", "focus", "focusNode", "getNode", "$insertNodeToNearestRoot", "$isParagraphNode", "__first", "remove", "COMMAND_PRIORITY_EDITOR", "INSERT_INLINE_BLOCK_COMMAND", "fields", "node", "$getNodeByKey", "$isInlineBlockNode", "setFields", "inlineBlockNode", "$createInlineBlockNode", "$insertNodes", "$isRootOrShadowRoot", "getParentOrThrow", "$wrapNodeInElement", "$createParagraphNode", "selectEnd", "t3", "useEffect", "BlocksFeatureClient", "createClientFeature", "config", "featureClientSchemaMap", "props", "schemaPath", "schemaMapRenderedBlockPathPrefix", "schemaMapRenderedInlineBlockPathPrefix", "clientSchema", "blocksFields", "Object", "entries", "filter", "key", "startsWith", "replace", "includes", "map", "value", "inlineBlocksFields", "clientBlocks", "field", "blockReferences", "blocksMap", "blocks", "block", "undefined", "clientInlineBlocks", "markdownTransformers", "getBlockMarkdownTransformers", "inlineBlocks", "nodes", "BlockNode", "InlineBlockNode", "plugins", "Component", "BlocksPlugin", "position", "sanitizedClientFeatureProps", "slashMenu", "groups", "length", "items", "Icon", "getBlockImageComponent", "imageURL", "imageAltText", "slug", "keywords", "label", "i18n", "labels", "singular", "getTranslation", "onSelect", "editor", "dispatchCommand", "INSERT_BLOCK_COMMAND", "blockName", "blockType", "t", "inlineBlock", "InlineBlocksIcon", "INSERT_INLINE_BLOCK_COMMAND", "Boolean", "toolbarFixed", "type", "ChildComponent", "BlockIcon", "index", "isActive", "order", "c", "_c", "useLexicalComposerContext", "$createParagraphNode", "$createTextNode", "$getRoot", "getDOMSelection", "React", "useCallback", "useEffect", "useLayoutEffect", "useRef", "useState", "documentMode", "CAN_USE_DOM", "document", "IS_APPLE", "test", "navigator", "platform", "IS_FIREFOX", "userAgent", "CAN_USE_BEFORE_INPUT", "window", "InputEvent", "IS_SAFARI", "IS_IOS", "MSStream", "IS_ANDROID", "IS_WINDOWS", "IS_CHROME", "IS_APPLE_WEBKIT", "copy", "text", "textArea", "document", "createElement", "value", "style", "position", "opacity", "body", "appendChild", "focus", "select", "result", "execCommand", "console", "log", "error", "removeChild", "download", "filename", "a", "setAttribute", "encodeURIComponent", "display", "click", "formatStep", "step", "formattedStep", "formatOneStep", "name", "x", "y", "anchorPath", "toString", "anchorOffset", "focusPath", "focusOffset", "count", "join", "isSelectAll", "event", "key", "toLowerCase", "IS_APPLE", "metaKey", "ctrlKey", "sanitizeSelection", "selection", "anchorNode", "focusNode", "getPathFromNodeToEditor", "node", "rootElement", "currentNode", "path", "unshift", "Array", "from", "parentNode", "childNodes", "indexOf", "keyPresses", "Set", "useTestRecorder", "editor", "steps", "setSteps", "useState", "isRecording", "setIsRecording", "setCurrentInnerHTML", "templatedTest", "setTemplatedTest", "previousSelectionRef", "useRef", "skipNextSelectionChangeRef", "preRef", "getCurrentEditor", "useCallback", "generateTestContent", "getRootElement", "browserSelection", "getDOMSelection", "_window", "contains", "map", "pushStep", "currentSteps", "currentIndex", "length", "lastStep", "slice", "useLayoutEffect", "onKeyDown", "has", "onKeyUp", "registerRootListener", "prevRootElement", "removeEventListener", "addEventListener", "current", "scrollTo", "scrollHeight", "useEffect", "testContent", "registerUpdateListener", "dirtyElements", "dirtyLeaves", "editorState", "currentSelection", "_selection", "previousSelection", "skipNextSelectionChange", "size", "innerHTML", "toggleEditorSelection", "currentEditor", "update", "root", "$getRoot", "clear", "$createTextNode", "append", "$createParagraphNode", "currentIsRecording", "onSnapshotClick", "onCopyClick", "onDownloadClick", "_jsx", "className", "id", "onClick", "e", "preventDefault", "title", "type", "_jsxs", "ref", "TestRecorderPlugin", "$", "_c", "useLexicalComposerContext", "testRecorderButton", "testRecorderOutput", "t0", "Fragment", "children", "TestRecorderFeatureClient", "createClientFeature", "plugins", "Component", "TestRecorderPlugin", "position", "c", "_c", "useLexicalComposerContext", "TreeView", "TreeViewPlugin", "$", "editor", "t0", "_jsx", "timeTravelButtonClassName", "timeTravelPanelButtonClassName", "timeTravelPanelClassName", "timeTravelPanelSliderClassName", "treeTypeButtonClassName", "viewClassName", "TreeViewFeatureClient", "createClientFeature", "plugins", "Component", "TreeViewPlugin", "position", "$isTableSelection", "$isRangeSelection", "FORMAT_TEXT_COMMAND", "BoldIcon", "_jsx", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "d", "toolbarFormatGroupWithItems", "items", "type", "key", "order", "BOLD_ITALIC_STAR", "type", "format", "tag", "BOLD_ITALIC_UNDERSCORE", "intraword", "BOLD_STAR", "BOLD_UNDERSCORE", "toolbarGroups", "toolbarFormatGroupWithItems", "ChildComponent", "BoldIcon", "isActive", "selection", "$isRangeSelection", "$isTableSelection", "hasFormat", "key", "onSelect", "editor", "dispatchCommand", "FORMAT_TEXT_COMMAND", "order", "BoldFeatureClient", "createClientFeature", "featureProviderMap", "markdownTransformers", "BOLD_STAR", "BOLD_UNDERSCORE", "get", "push", "BOLD_ITALIC_UNDERSCORE", "BOLD_ITALIC_STAR", "enableFormats", "toolbarFixed", "groups", "toolbarInline", "$isTableSelection", "$isRangeSelection", "FORMAT_TEXT_COMMAND", "CodeIcon", "_jsxs", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "_jsx", "d", "stroke", "INLINE_CODE", "type", "format", "tag", "toolbarGroups", "toolbarFormatGroupWithItems", "ChildComponent", "CodeIcon", "isActive", "selection", "$isRangeSelection", "$isTableSelection", "hasFormat", "key", "onSelect", "editor", "dispatchCommand", "FORMAT_TEXT_COMMAND", "order", "InlineCodeFeatureClient", "createClientFeature", "enableFormats", "markdownTransformers", "INLINE_CODE", "toolbarFixed", "groups", "toolbarInline", "$isTableSelection", "$isRangeSelection", "FORMAT_TEXT_COMMAND", "ItalicIcon", "_jsx", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "d", "ITALIC_STAR", "type", "format", "tag", "ITALIC_UNDERSCORE", "intraword", "toolbarGroups", "toolbarFormatGroupWithItems", "ChildComponent", "ItalicIcon", "isActive", "selection", "$isRangeSelection", "$isTableSelection", "hasFormat", "key", "onSelect", "editor", "dispatchCommand", "FORMAT_TEXT_COMMAND", "order", "ItalicFeatureClient", "createClientFeature", "enableFormats", "markdownTransformers", "ITALIC_STAR", "ITALIC_UNDERSCORE", "toolbarFixed", "groups", "toolbarInline", "$isTableSelection", "$isRangeSelection", "FORMAT_TEXT_COMMAND", "StrikethroughIcon", "_jsxs", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "_jsx", "d", "STRIKETHROUGH", "type", "format", "tag", "toolbarGroups", "toolbarFormatGroupWithItems", "ChildComponent", "StrikethroughIcon", "isActive", "selection", "$isRangeSelection", "$isTableSelection", "hasFormat", "key", "onSelect", "editor", "dispatchCommand", "FORMAT_TEXT_COMMAND", "order", "StrikethroughFeatureClient", "createClientFeature", "enableFormats", "markdownTransformers", "STRIKETHROUGH", "toolbarFixed", "groups", "toolbarInline", "$isTableSelection", "$isRangeSelection", "FORMAT_TEXT_COMMAND", "SubscriptIcon", "_jsx", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "d", "toolbarGroups", "toolbarFormatGroupWithItems", "ChildComponent", "SubscriptIcon", "isActive", "selection", "$isRangeSelection", "$isTableSelection", "hasFormat", "key", "onSelect", "editor", "dispatchCommand", "FORMAT_TEXT_COMMAND", "order", "SubscriptFeatureClient", "createClientFeature", "enableFormats", "toolbarFixed", "groups", "toolbarInline", "$isTableSelection", "$isRangeSelection", "FORMAT_TEXT_COMMAND", "SuperscriptIcon", "_jsx", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "d", "toolbarGroups", "toolbarFormatGroupWithItems", "ChildComponent", "SuperscriptIcon", "isActive", "selection", "$isRangeSelection", "$isTableSelection", "hasFormat", "key", "onSelect", "editor", "dispatchCommand", "FORMAT_TEXT_COMMAND", "order", "SuperscriptFeatureClient", "createClientFeature", "enableFormats", "toolbarFixed", "groups", "toolbarInline", "$isTableSelection", "$isRangeSelection", "FORMAT_TEXT_COMMAND", "UnderlineIcon", "_jsxs", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "_jsx", "d", "toolbarGroups", "toolbarFormatGroupWithItems", "ChildComponent", "UnderlineIcon", "isActive", "selection", "$isRangeSelection", "$isTableSelection", "hasFormat", "key", "onSelect", "editor", "dispatchCommand", "FORMAT_TEXT_COMMAND", "order", "UnderlineFeatureClient", "createClientFeature", "enableFormats", "toolbarFixed", "groups", "toolbarInline", "kebabToCamelCase", "str", "replace", "_", "letter", "toUpperCase", "TextStateIcon", "css", "convertedCss", "Object", "fromEntries", "entries", "map", "key", "value", "_jsx", "style", "alignItems", "borderRadius", "display", "fontSize", "height", "justifyContent", "width", "useLexicalComposerContext", "$forEachSelectedTextNode", "$getNodeByKey", "$getState", "$setState", "createState", "TextNode", "useEffect", "registerTextStates", "state", "stateMap", "Map", "stateKey", "stateValues", "stateConfig", "parse", "value", "Object", "keys", "includes", "undefined", "set", "setTextState", "editor", "update", "textNode", "stateMapEntry", "get", "Error", "StatePlugin", "registerMutationListener", "mutatedNodes", "getEditorState", "read", "nodeKey", "mutation", "node", "dom", "getElementByKey", "mergedStyles", "create", "forEach", "stateEntry", "stateValue", "dataset", "css", "assign", "style", "cssText", "toolbarGroups", "props", "stateMap", "items", "stateKey", "state", "key", "stateValue", "meta", "push", "ChildComponent", "_jsx", "TextStateIcon", "css", "label", "onSelect", "editor", "setTextState", "type", "color", "i18n", "t", "undefined", "order", "TextStateFeatureClient", "createClientFeature", "registerTextStates", "plugins", "Component", "StatePlugin", "position", "toolbarFixed", "groups", "toolbarInline", "c", "_c", "useLexicalComposerContext", "$createHeadingNode", "$isHeadingNode", "HeadingNode", "$setBlocksType", "$getSelection", "$isRangeSelection", "useEffect", "H1Icon", "_jsx", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "d", "H2Icon", "_jsx", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "d", "H3Icon", "_jsx", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "d", "H4Icon", "_jsx", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "d", "H5Icon", "_jsx", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "d", "H6Icon", "_jsx", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "d", "$createHeadingNode", "$isHeadingNode", "HeadingNode", "createBlockNode", "createNode", "parentNode", "children", "match", "node", "append", "replace", "select", "MarkdownTransformer", "enabledHeadingSizes", "pattern", "map", "tag", "Number", "slice", "size", "join", "regExp", "RegExp", "type", "dependencies", "HeadingNode", "export", "node", "exportChildren", "$isHeadingNode", "level", "getTag", "repeat", "replace", "createBlockNode", "match", "length", "$createHeadingNode", "$setHeading", "headingSize", "selection", "$getSelection", "$setBlocksType", "$createHeadingNode", "iconImports", "h1", "H1Icon", "h2", "H2Icon", "h3", "H3Icon", "h4", "H4Icon", "h5", "H5Icon", "h6", "H6Icon", "HeadingFeatureClient", "createClientFeature", "props", "enabledHeadingSizes", "toolbarGroups", "toolbarTextDropdownGroupWithItems", "map", "i", "ChildComponent", "isActive", "$isRangeSelection", "node", "getNodes", "$isHeadingNode", "getTag", "parent", "getParent", "key", "label", "i18n", "t", "headingLevel", "charAt", "onSelect", "editor", "update", "order", "markdownTransformers", "MarkdownTransformer", "nodes", "HeadingNode", "plugins", "Component", "HeadingPlugin", "position", "sanitizedClientFeatureProps", "slashMenu", "groups", "length", "slashMenuBasicGroupWithItems", "Icon", "keywords", "toolbarFixed", "toolbarInline", "t0", "$", "_c", "clientProps", "t1", "t2", "undefined", "t3", "at", "lowestAllowed", "useLexicalComposerContext", "t4", "t5", "registerNodeTransform", "includes", "setTag", "useEffect", "$isNodeSelection", "HorizontalRuleIcon", "_jsx", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "x", "y", "AddIcon", "_jsxs", "fill", "height", "viewBox", "width", "xmlns", "_jsx", "d", "stroke", "toolbarAddDropdownGroupWithItems", "items", "type", "ChildComponent", "AddIcon", "key", "order", "addClassNamesToElement", "$applyNodeReplacement", "createCommand", "DecoratorNode", "INSERT_HORIZONTAL_RULE_COMMAND", "HorizontalRuleServerNode", "clone", "node", "__key", "getType", "importDOM", "hr", "conversion", "$convertHorizontalRuleElement", "priority", "importJSON", "serializedNode", "$createHorizontalRuleServerNode", "createDOM", "config", "element", "document", "createElement", "theme", "decorate", "exportDOM", "exportJSON", "type", "version", "getTextContent", "isInline", "updateDOM", "$applyNodeReplacement", "HorizontalRuleNode", "HorizontalRuleServerNode", "clone", "node", "getType", "importJSON", "serializedNode", "$createHorizontalRuleNode", "decorate", "exportJSON", "$createHorizontalRuleNode", "$applyNodeReplacement", "HorizontalRuleNode", "$isHorizontalRuleNode", "node", "MarkdownTransformer", "type", "dependencies", "HorizontalRuleNode", "export", "node", "exportChildren", "$isHorizontalRuleNode", "regExp", "replace", "parentNode", "$createHorizontalRuleNode", "c", "_c", "useLexicalComposerContext", "$insertNodeToNearestRoot", "$getSelection", "$isRangeSelection", "COMMAND_PRIORITY_EDITOR", "useEffect", "HorizontalRulePlugin", "$", "_c", "editor", "useLexicalComposerContext", "t0", "t1", "registerCommand", "INSERT_HORIZONTAL_RULE_COMMAND", "_temp", "COMMAND_PRIORITY_EDITOR", "useEffect", "type", "selection", "$getSelection", "$isRangeSelection", "focus", "getNode", "horizontalRuleNode", "$createHorizontalRuleNode", "$insertNodeToNearestRoot", "HorizontalRuleFeatureClient", "createClientFeature", "markdownTransformers", "MarkdownTransformer", "nodes", "HorizontalRuleNode", "plugins", "Component", "HorizontalRulePlugin", "position", "slashMenu", "groups", "slashMenuBasicGroupWithItems", "Icon", "HorizontalRuleIcon", "key", "keywords", "label", "i18n", "t", "onSelect", "editor", "dispatchCommand", "INSERT_HORIZONTAL_RULE_COMMAND", "undefined", "toolbarFixed", "toolbarAddDropdownGroupWithItems", "ChildComponent", "isActive", "selection", "$isNodeSelection", "getNodes", "length", "firstNode", "$isHorizontalRuleNode", "$findMatchingParent", "$isElementNode", "INDENT_CONTENT_COMMAND", "OUTDENT_CONTENT_COMMAND", "IndentDecreaseIcon", "_jsxs", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "_jsx", "d", "stroke", "strokeWidth", "IndentIncreaseIcon", "_jsxs", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "_jsx", "d", "stroke", "strokeWidth", "useLexicalComposerContext", "TabIndentationPlugin", "$findMatchingParent", "mergeRegister", "$getSelection", "$isElementNode", "$isRangeSelection", "COMMAND_PRIORITY_LOW", "INDENT_CONTENT_COMMAND", "KEY_TAB_COMMAND", "OUTDENT_CONTENT_COMMAND", "TabNode", "useEffect", "IndentPlugin", "clientProps", "editor", "disabledNodes", "disableTabNode", "length", "registerCommand", "$handleIndentAndOutdent", "block", "includes", "getType", "indent", "getIndent", "setIndent", "registerUpdateListener", "dirtyElements", "editorState", "update", "nodeKey", "node", "_nodeMap", "get", "event", "preventDefault", "dispatchCommand", "shiftKey", "undefined", "registerNodeTransform", "remove", "_jsx", "indentOrOutdent", "selection", "alreadyHandled", "Set", "nodes", "getNodes", "i", "key", "getKey", "has", "parentBlock", "parentNode", "isInline", "parentKey", "canIndent", "add", "size", "toolbarIndentGroupWithItems", "items", "type", "key", "order", "toolbarGroups", "disabledNodes", "toolbarIndentGroupWithItems", "ChildComponent", "IndentDecreaseIcon", "isActive", "isEnabled", "selection", "nodes", "getNodes", "isOutdentable", "node", "isIndentable", "getIndent", "some", "Boolean", "$findMatchingParent", "key", "label", "i18n", "t", "onSelect", "editor", "dispatchCommand", "OUTDENT_CONTENT_COMMAND", "undefined", "order", "IndentIncreaseIcon", "isIndentableAndNotDisabled", "includes", "getType", "INDENT_CONTENT_COMMAND", "IndentFeatureClient", "createClientFeature", "props", "plugins", "Component", "IndentPlugin", "position", "sanitizedClientFeatureProps", "toolbarFixed", "groups", "toolbarInline", "$isElementNode", "canIndent", "$findMatchingParent", "$getSelection", "$isRangeSelection", "LinkIcon", "_jsx", "className", "fill", "height", "viewBox", "width", "xmlns", "d", "stroke", "strokeLinecap", "strokeLinejoin", "$isAtNodeEnd", "getSelectedNode", "selection", "anchor", "focus", "anchorNode", "getNode", "focusNode", "isBackward", "toolbarFeatureButtonsGroupWithItems", "items", "type", "key", "order", "$createTextNode", "addClassNamesToElement", "isHTMLAnchorElement", "ObjectID", "$applyNodeReplacement", "$createTextNode", "$getSelection", "$isElementNode", "$isRangeSelection", "createCommand", "ElementNode", "SUPPORTED_URL_PROTOCOLS", "Set", "LinkNode", "__fields", "__id", "constructor", "id", "fields", "linkType", "newTab", "key", "clone", "node", "__key", "getType", "importDOM", "a", "conversion", "$convertAnchorElement", "priority", "importJSON", "serializedNode", "$createLinkNode", "updateFromJSON", "version", "doc", "value", "default", "toHexString", "canBeEmpty", "canInsertTextAfter", "canInsertTextBefore", "createDOM", "config", "element", "document", "createElement", "href", "sanitizeUrl", "url", "target", "rel", "manageRel", "theme", "link", "exportJSON", "getFields", "returnObject", "type", "getID", "extractWithChild", "child", "selection", "destination", "anchorNode", "anchor", "getNode", "focusNode", "focus", "isParentOf", "getTextContent", "length", "getLatest", "insertNewAfter", "restoreSelection", "getParentOrThrow", "linkNode", "append", "isInline", "parsedUrl", "URL", "has", "protocol", "setFields", "writable", "getWritable", "setID", "updateDOM", "prevNode", "removeAttribute", "domNode", "content", "textContent", "getAttribute", "$isLinkNode", "TOGGLE_LINK_COMMAND", "$toggleLink", "payload", "selectedNodes", "nodes", "extract", "forEach", "parent", "getParent", "getChildren", "insertBefore", "remove", "firstNode", "$getLinkAncestor", "text", "getLastChild", "prevParent", "is", "getPreviousSibling", "insertAfter", "children", "$getAncestor", "ancestor", "predicate", "input", "action", "result", "mutableInput", "includes", "re", "RegExp", "replace", "trim", "LinkMarkdownTransformer", "type", "dependencies", "LinkNode", "export", "_node", "exportChildren", "$isLinkNode", "node", "url", "getFields", "importRegExp", "regExp", "replace", "textNode", "match", "linkText", "linkUrl", "linkNode", "$createLinkNode", "fields", "doc", "linkType", "newTab", "linkTextNode", "$createTextNode", "setFormat", "getFormat", "append", "trigger", "$applyNodeReplacement", "$isElementNode", "AutoLinkNode", "LinkNode", "clone", "node", "id", "fields", "__fields", "key", "__key", "getType", "importDOM", "importJSON", "serializedNode", "$createAutoLinkNode", "updateFromJSON", "version", "doc", "value", "exportJSON", "serialized", "type", "children", "direction", "format", "indent", "insertNewAfter", "selection", "restoreSelection", "element", "getParentOrThrow", "$isElementNode", "linkNode", "append", "setFields", "$applyNodeReplacement", "$isAutoLinkNode", "c", "_c", "useLexicalComposerContext", "mergeRegister", "$createTextNode", "$getSelection", "$isElementNode", "$isLineBreakNode", "$isNodeSelection", "$isRangeSelection", "$isTextNode", "TextNode", "TextNodeValue", "useEffect", "createLinkMatcherWithRegExp", "regExp", "urlTransformer", "text", "match", "exec", "index", "length", "url", "findFirstMatch", "matchers", "matcher", "PUNCTUATION_OR_SPACE", "isSeparator", "char", "undefined", "test", "endsWithSeparator", "textContent", "startsWithSeparator", "startsWithTLD", "isEmail", "isPreviousNodeValid", "node", "previousNode", "getPreviousSibling", "$isElementNode", "getLastDescendant", "$isLineBreakNode", "$isTextNode", "getTextContent", "isNextNodeValid", "nextNode", "getNextSibling", "getFirstDescendant", "isContentAroundIsValid", "matchStart", "matchEnd", "nodes", "extractMatchingNodes", "startIndex", "endIndex", "unmodifiedBeforeNodes", "matchingNodes", "unmodifiedAfterNodes", "matchingOffset", "currentOffset", "currentNodes", "currentNode", "currentNodeLength", "currentNodeStart", "push", "shift", "$createAutoLinkNode_", "fields", "linkType", "linkNode", "$createAutoLinkNode", "remainingTextNode", "linkTextNode", "splitText", "textNode", "$createTextNode", "setFormat", "getFormat", "setDetail", "getDetail", "setStyle", "getStyle", "append", "replace", "firstTextNode", "offset", "firstLinkTextNode", "linkNodes", "forEach", "currentNodeEnd", "endNode", "selection", "$getSelection", "selectedTextNode", "getNodes", "find", "$isRangeSelection", "select", "anchor", "focus", "$isNodeSelection", "$handleLinkCreation", "onChange", "initialText", "map", "join", "invalidMatchEnd", "matchLength", "actualMatchStart", "actualMatchEnd", "substring", "handleLinkEdit", "children", "getChildren", "childrenLength", "i", "child", "isSimpleText", "replaceWithChildren", "getFields", "flds", "setFields", "handleBadNeighbors", "previousSibling", "nextSibling", "$isAutoLinkNode", "isEmailURI", "startsWith", "j", "insertAfter", "remove", "getLatest", "getTextNodesToMatch", "textNodesToMatch", "useAutoLink", "editor", "$", "_c", "t0", "t1", "hasNodes", "AutoLinkNode", "Error", "onChangeWrapped", "prevUrl", "mergeRegister", "registerNodeTransform", "TextNodeValue", "parent", "getParentOrThrow", "previous", "$isLinkNode", "useEffect", "URL_REGEX", "EMAIL_REGEX", "MATCHERS", "AutoLinkPlugin", "useLexicalComposerContext", "ClickableLinkPlugin", "LexicalClickableLinkPlugin", "_jsx", "createPortal", "useLexicalComposerContext", "useLexicalEditable", "$findMatchingParent", "mergeRegister", "getTranslation", "CloseMenuIcon", "EditIcon", "ExternalLinkIcon", "formatDrawerSlug", "useConfig", "useEditDepth", "useLocale", "useTranslation", "requests", "$getSelection", "$isLineBreakNode", "$isRangeSelection", "COMMAND_PRIORITY_HIGH", "COMMAND_PRIORITY_LOW", "getDOMSelection", "KEY_ESCAPE_COMMAND", "SELECTION_CHANGE_COMMAND", "React", "useCallback", "useEffect", "useRef", "useState", "setFloatingElemPositionForLinkEditor", "targetRect", "floatingElem", "anchorElem", "verticalGap", "VERTICAL_GAP", "horizontalOffset", "HORIZONTAL_OFFSET", "scrollerElem", "parentElement", "style", "opacity", "transform", "floatingElemRect", "getBoundingClientRect", "anchorElementRect", "editorScrollerRect", "top", "left", "height", "width", "right", "createCommand", "TOGGLE_LINK_WITH_MODAL_COMMAND", "preventDefault", "event", "LinkEditor", "anchorElem", "editor", "useLexicalComposerContext", "linkNode", "setLinkNode", "useState", "editorRef", "useRef", "linkUrl", "setLinkUrl", "linkLabel", "setLinkLabel", "fieldProps", "schemaPath", "uuid", "useEditorConfigContext", "isEditable", "useLexicalEditable", "config", "getEntityConfig", "useConfig", "i18n", "t", "useTranslation", "stateData", "setStateData", "editDepth", "useEditDepth", "isLink", "setIsLink", "selectedNodes", "setSelectedNodes", "locale", "useLocale", "isAutoLink", "setIsAutoLink", "drawerSlug", "formatDrawerSlug", "slug", "depth", "toggleDrawer", "useLexicalDrawer", "setNotLink", "useCallback", "current", "style", "opacity", "transform", "undefined", "$updateLinkEditor", "selection", "$getSelection", "selectedNodeDomRect", "$isRangeSelection", "focusNode", "getSelectedNode", "getElementByKey", "getKey", "getBoundingClientRect", "focusLinkParent", "$findMatchingParent", "$isLinkNode", "badNode", "getNodes", "filter", "node", "$isLineBreakNode", "find", "is", "fields", "getFields", "data", "id", "getID", "text", "getTextContent", "linkType", "url", "routes", "admin", "doc", "relationTo", "value", "relatedField", "collectionSlug", "label", "String", "collection", "Error", "loadingLabel", "getTranslation", "labels", "singular", "replace", "requests", "get", "serverURL", "api", "headers", "language", "params", "code", "then", "res", "ok", "status", "json", "useAsTitle", "title", "catch", "$isAutoLinkNode", "editorElem", "nativeSelection", "getDOMSelection", "_window", "activeElement", "document", "rootElement", "getRootElement", "contains", "anchorNode", "getRangeAt", "y", "setFloatingElemPositionForLinkEditor", "className", "useEffect", "mergeRegister", "registerCommand", "TOGGLE_LINK_WITH_MODAL_COMMAND", "payload", "dispatchCommand", "TOGGLE_LINK_COMMAND", "COMMAND_PRIORITY_LOW", "scrollerElem", "parentElement", "update", "getEditorState", "read", "window", "addEventListener", "removeEventListener", "registerUpdateListener", "editorState", "SELECTION_CHANGE_COMMAND", "KEY_ESCAPE_COMMAND", "COMMAND_PRIORITY_HIGH", "_jsxs", "React", "Fragment", "_jsx", "ref", "length", "href", "rel", "target", "__fields", "newTab", "ExternalLinkIcon", "_Fragment", "onClick", "onMouseDown", "tabIndex", "type", "EditIcon", "CloseMenuIcon", "FieldsDrawer", "drawerTitle", "featureKey", "handleDrawerSubmit", "newLinkPayload", "bareLinkFields", "linkParent", "getParent", "$createLinkNode", "schemaPathSuffix", "FloatingLinkEditorPlugin", "props", "anchorElem", "document", "body", "createPortal", "_jsx", "LinkEditor", "c", "_c", "useLexicalComposerContext", "mergeRegister", "$getSelection", "$isElementNode", "$isRangeSelection", "COMMAND_PRIORITY_LOW", "PASTE_COMMAND", "useEffect", "absoluteRegExp", "relativeOrAnchorRegExp", "validateUrl", "url", "includes", "test", "absoluteRegExp", "relativeOrAnchorRegExp", "urlObj", "URL", "protocol", "hostname", "LinkPlugin", "t0", "$", "_c", "clientProps", "editor", "useLexicalComposerContext", "t1", "t2", "defaultLinkType", "defaultLinkURL", "hasNodes", "LinkNode", "Error", "mergeRegister", "registerCommand", "TOGGLE_LINK_COMMAND", "payload", "$toggleLink", "fields", "linkType", "url", "COMMAND_PRIORITY_LOW", "PASTE_COMMAND", "event", "selection", "$getSelection", "$isRangeSelection", "isCollapsed", "ClipboardEvent", "clipboardData", "clipboardText", "getData", "validateUrl", "getNodes", "some", "_temp", "linkFields", "doc", "newTab", "dispatchCommand", "text", "preventDefault", "useEffect", "node", "$isElementNode", "toolbarGroups", "toolbarFeatureButtonsGroupWithItems", "ChildComponent", "LinkIcon", "isActive", "selection", "$isRangeSelection", "selectedNode", "getSelectedNode", "$findMatchingParent", "$isLinkNode", "isEnabled", "$getSelection", "getTextContent", "length", "key", "label", "i18n", "t", "onSelect", "editor", "dispatchCommand", "TOGGLE_LINK_COMMAND", "selectedText", "selectedNodes", "getEditorState", "read", "getNodes", "linkFields", "doc", "TOGGLE_LINK_WITH_MODAL_COMMAND", "fields", "text", "order", "LinkFeatureClient", "createClientFeature", "props", "markdownTransformers", "LinkMarkdownTransformer", "nodes", "LinkNode", "disableAutoLinks", "AutoLinkNode", "filter", "Boolean", "plugins", "Component", "LinkPlugin", "position", "AutoLinkPlugin", "ClickableLinkPlugin", "FloatingLinkEditorPlugin", "sanitizedClientFeatureProps", "toolbarFixed", "groups", "toolbarInline", "$isListNode", "INSERT_CHECK_LIST_COMMAND", "ListItemNode", "ListNode", "$isRangeSelection", "ChecklistIcon", "_jsxs", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "_jsx", "rx", "stroke", "x", "y", "d", "strokeWidth", "ListPlugin", "LexicalListPlugin", "_jsx", "shouldRegisterListBaseNodes", "type", "featureProviderMap", "has", "slashMenuListGroupWithItems", "items", "key", "label", "i18n", "t", "$isListNode", "ListItemNode", "ListNode", "$createListItemNode", "$createListNode", "$isListItemNode", "$isListNode", "LIST_INDENT_SIZE", "listReplace", "listType", "parentNode", "children", "match", "previousNode", "getPreviousSibling", "nextNode", "getNextSibling", "listItem", "undefined", "getListType", "firstChild", "getFirstChild", "insertBefore", "append", "remove", "list", "Number", "replace", "select", "indent", "Math", "floor", "length", "setIndent", "listExport", "listNode", "exportChildren", "depth", "output", "getChildren", "index", "listItemNode", "getChildrenSize", "push", "repeat", "prefix", "getStart", "getChecked", "join", "CHECK_LIST", "type", "dependencies", "ListNode", "ListItemNode", "export", "node", "exportChildren", "$isListNode", "listExport", "regExp", "replace", "listReplace", "CheckListPlugin", "LexicalCheckListPlugin", "_jsx", "toolbarGroups", "toolbarTextDropdownGroupWithItems", "ChildComponent", "ChecklistIcon", "isActive", "selection", "$isRangeSelection", "node", "getNodes", "$isListNode", "getListType", "parent", "getParent", "parentParent", "key", "label", "i18n", "t", "onSelect", "editor", "dispatchCommand", "INSERT_CHECK_LIST_COMMAND", "undefined", "order", "ChecklistFeatureClient", "createClientFeature", "featureProviderMap", "plugins", "Component", "LexicalCheckListPlugin", "position", "shouldRegister", "shouldRegisterListBaseNodes", "push", "LexicalListPlugin", "markdownTransformers", "CHECK_LIST", "nodes", "ListNode", "ListItemNode", "slashMenu", "groups", "slashMenuListGroupWithItems", "Icon", "keywords", "toolbarFixed", "toolbarInline", "$isListNode", "INSERT_ORDERED_LIST_COMMAND", "ListItemNode", "ListNode", "$isRangeSelection", "OrderedListIcon", "_jsxs", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "_jsx", "d", "stroke", "strokeWidth", "$isListNode", "ListItemNode", "ListNode", "ORDERED_LIST", "type", "dependencies", "ListNode", "ListItemNode", "export", "node", "exportChildren", "$isListNode", "listExport", "regExp", "replace", "listReplace", "toolbarGroups", "toolbarTextDropdownGroupWithItems", "ChildComponent", "OrderedListIcon", "isActive", "selection", "$isRangeSelection", "node", "getNodes", "$isListNode", "getListType", "parent", "getParent", "parentParent", "key", "label", "i18n", "t", "onSelect", "editor", "dispatchCommand", "INSERT_ORDERED_LIST_COMMAND", "undefined", "order", "OrderedListFeatureClient", "createClientFeature", "featureProviderMap", "shouldRegister", "shouldRegisterListBaseNodes", "markdownTransformers", "ORDERED_LIST", "nodes", "ListNode", "ListItemNode", "plugins", "Component", "LexicalListPlugin", "position", "slashMenu", "groups", "slashMenuListGroupWithItems", "Icon", "keywords", "toolbarFixed", "toolbarInline", "$isListNode", "INSERT_UNORDERED_LIST_COMMAND", "ListItemNode", "ListNode", "$isRangeSelection", "UnorderedListIcon", "_jsxs", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "_jsx", "cx", "cy", "r", "stroke", "strokeWidth", "d", "$isListNode", "ListItemNode", "ListNode", "UNORDERED_LIST", "type", "dependencies", "ListNode", "ListItemNode", "export", "node", "exportChildren", "$isListNode", "listExport", "regExp", "replace", "listReplace", "toolbarGroups", "toolbarTextDropdownGroupWithItems", "ChildComponent", "UnorderedListIcon", "isActive", "selection", "$isRangeSelection", "node", "getNodes", "$isListNode", "getListType", "parent", "getParent", "parentParent", "key", "label", "i18n", "t", "onSelect", "editor", "dispatchCommand", "INSERT_UNORDERED_LIST_COMMAND", "undefined", "order", "UnorderedListFeatureClient", "createClientFeature", "markdownTransformers", "UNORDERED_LIST", "nodes", "ListNode", "ListItemNode", "plugins", "Component", "LexicalListPlugin", "position", "slashMenu", "groups", "slashMenuListGroupWithItems", "Icon", "keywords", "toolbarFixed", "toolbarInline", "addClassNamesToElement", "$applyNodeReplacement", "DecoratorNode", "React", "Component", "lazy", "then", "module", "default", "UnknownConvertedNodeComponent", "UnknownConvertedNode", "__data", "constructor", "data", "key", "clone", "node", "__key", "getType", "importJSON", "serializedNode", "$createUnknownConvertedNode", "canInsertTextAfter", "canInsertTextBefore", "createDOM", "config", "element", "document", "createElement", "decorate", "_jsx", "exportJSON", "type", "version", "isInline", "updateDOM", "prevNode", "dom", "LexicalPluginToLexicalFeatureClient", "createClientFeature", "nodes", "UnknownConvertedNode", "addClassNamesToElement", "$applyNodeReplacement", "DecoratorNode", "React", "Component", "lazy", "then", "module", "default", "UnknownConvertedNodeComponent", "UnknownConvertedNode", "__data", "constructor", "data", "key", "clone", "node", "__key", "getType", "importJSON", "serializedNode", "$createUnknownConvertedNode", "canInsertTextAfter", "canInsertTextBefore", "createDOM", "config", "element", "document", "createElement", "decorate", "_jsx", "exportJSON", "type", "version", "isInline", "updateDOM", "prevNode", "dom", "SlateToLexicalFeatureClient", "createClientFeature", "nodes", "UnknownConvertedNode", "$setBlocksType", "$createParagraphNode", "$getSelection", "$isParagraphNode", "$isRangeSelection", "toolbarGroups", "toolbarTextDropdownGroupWithItems", "ChildComponent", "TextIcon", "isActive", "selection", "$isRangeSelection", "node", "getNodes", "$isParagraphNode", "getParent", "key", "label", "i18n", "t", "onSelect", "editor", "update", "$getSelection", "$setBlocksType", "$createParagraphNode", "order", "ParagraphFeatureClient", "createClientFeature", "slashMenu", "groups", "slashMenuBasicGroupWithItems", "Icon", "keywords", "toolbarFixed", "toolbarInline", "c", "_c", "useLexicalComposerContext", "useEffect", "useState", "BlockquoteJSXConverter", "quote", "node", "nodesToJSX", "children", "nodes", "_jsx", "HeadingJSXConverter", "heading", "node", "nodesToJSX", "children", "nodes", "NodeTag", "tag", "_jsx", "HorizontalRuleJSXConverter", "horizontalrule", "_jsx", "LinebreakJSXConverter", "linebreak", "_jsx", "LinkJSXConverter", "internalDocToHref", "autolink", "node", "nodesToJSX", "children", "nodes", "rel", "fields", "newTab", "undefined", "target", "_jsx", "href", "url", "link", "linkType", "linkNode", "console", "error", "v4", "uuidv4", "ListJSXConverter", "list", "node", "nodesToJSX", "children", "nodes", "NodeTag", "tag", "_jsx", "className", "listType", "listitem", "parent", "hasSubLists", "some", "child", "type", "uuid", "checked", "role", "style", "listStyleType", "tabIndex", "value", "_jsxs", "_Fragment", "id", "readOnly", "htmlFor", "undefined", "ParagraphJSXConverter", "paragraph", "node", "nodesToJSX", "children", "nodes", "length", "_jsx", "TabJSXConverter", "tab", "TableJSXConverter", "table", "node", "nodesToJSX", "children", "nodes", "_jsx", "className", "style", "borderCollapse", "tablecell", "TagName", "headerState", "headerStateClass", "backgroundColor", "undefined", "border", "padding", "colSpan", "rowSpan", "tablerow", "NodeFormat", "DOM_ELEMENT_TYPE", "DOM_TEXT_TYPE", "NO_DIRTY_NODES", "HAS_DIRTY_NODES", "FULL_RECONCILE", "IS_NORMAL", "IS_TOKEN", "IS_SEGMENTED", "IS_INERT", "IS_BOLD", "IS_ITALIC", "IS_STRIKETHROUGH", "IS_UNDERLINE", "IS_CODE", "IS_SUBSCRIPT", "IS_SUPERSCRIPT", "IS_HIGHLIGHT", "IS_DIRECTIONLESS", "IS_UNMERGEABLE", "IS_ALIGN_LEFT", "IS_ALIGN_CENTER", "IS_ALIGN_RIGHT", "IS_ALIGN_JUSTIFY", "IS_ALIGN_START", "IS_ALIGN_END", "IS_ALL_FORMATTING", "NON_BREAKING_SPACE", "DOUBLE_LINE_BREAK", "RTL", "LTR", "RTL_REGEX", "RegExp", "LTR_REGEX", "TEXT_TYPE_TO_FORMAT", "bold", "code", "highlight", "italic", "strikethrough", "subscript", "superscript", "underline", "DETAIL_TYPE_TO_DETAIL", "directionless", "unmergeable", "ELEMENT_TYPE_TO_FORMAT", "center", "end", "justify", "left", "right", "start", "ELEMENT_FORMAT_TO_TYPE", "TEXT_MODE_TO_TYPE", "normal", "segmented", "token", "TEXT_TYPE_TO_MODE", "TextJSXConverter", "text", "node", "format", "NodeFormat", "IS_BOLD", "_jsx", "IS_ITALIC", "IS_STRIKETHROUGH", "style", "textDecoration", "IS_UNDERLINE", "IS_CODE", "IS_SUBSCRIPT", "IS_SUPERSCRIPT", "UploadJSXConverter", "upload", "node", "uploadNode", "value", "uploadDoc", "url", "mimeType", "startsWith", "_jsx", "href", "rel", "filename", "sizes", "Object", "keys", "length", "alt", "height", "src", "width", "pictureJSX", "size", "imageSize", "filesize", "imageSizeURL", "push", "media", "srcSet", "type", "defaultJSXConverters", "ParagraphJSXConverter", "TextJSXConverter", "LinebreakJSXConverter", "BlockquoteJSXConverter", "TableJSXConverter", "HeadingJSXConverter", "HorizontalRuleJSXConverter", "ListJSXConverter", "LinkJSXConverter", "UploadJSXConverter", "TabJSXConverter", "jsx", "_jsx", "Fragment", "_Fragment", "React", "hasText", "value", "hasChildren", "root", "children", "length", "hasOnlyEmptyParagraph", "type", "paragraphNode", "paragraphNodeChild", "convertLexicalToJSX", "converters", "data", "disableIndent", "disableTextAlign", "hasText", "convertLexicalNodesToJSX", "nodes", "root", "children", "parent", "_jsx", "_Fragment", "unknownConverter", "unknown", "map", "node", "i", "converterForNode", "type", "blocks", "fields", "blockType", "console", "error", "inlineBlocks", "reactNode", "childIndex", "nodesToJSX", "args", "style", "Array", "isArray", "includes", "format", "textAlign", "indent", "paddingInlineStart", "Number", "React", "isValidElement", "newStyle", "props", "cloneElement", "key", "filter", "Boolean", "RichText", "className", "converters", "data", "editorState", "disableContainer", "disableIndent", "disableTextAlign", "finalConverters", "defaultConverters", "defaultJSXConverters", "content", "Array", "isArray", "convertLexicalToJSX", "_jsx", "_Fragment", "RichTextPlugin", "$", "_c", "editor", "useLexicalComposerContext", "t0", "getEditorState", "toJSON", "editorState", "setEditorState", "useState", "t1", "t2", "registerUpdateListener", "t3", "editorState_0", "useEffect", "_jsx", "className", "children", "RichText", "converters", "defaultJSXConverters", "data", "DebugJsxConverterFeatureClient", "createClientFeature", "plugins", "Component", "RichTextPlugin", "position", "tailwindColors", "amber", "black", "blue", "current", "cyan", "emerald", "fuchsia", "gray", "green", "indigo", "inherit", "lime", "neutral", "orange", "pink", "purple", "red", "rose", "sky", "slate", "stone", "teal", "transparent", "violet", "white", "yellow", "zinc", "defaultColors", "text", "css", "label", "background", "$isNodeSelection", "RelationshipIcon", "_jsxs", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "_jsx", "clipPath", "d", "stroke", "strokeLinecap", "strokeLinejoin", "id", "transform", "$applyNodeReplacement", "React", "DecoratorBlockNode", "addClassNamesToElement", "$applyNodeReplacement", "$relationshipElementToServerNode", "domNode", "id", "getAttribute", "relationTo", "node", "$createServerRelationshipNode", "value", "RelationshipServerNode", "__data", "constructor", "data", "format", "key", "clone", "__format", "__key", "getType", "importDOM", "div", "hasAttribute", "conversion", "priority", "importJSON", "serializedNode", "version", "importedData", "setFormat", "isInline", "createDOM", "config", "element", "document", "createElement", "theme", "relationship", "decorate", "_editor", "_config", "exportDOM", "setAttribute", "String", "text", "createTextNode", "getTextContent", "append", "exportJSON", "getData", "type", "getLatest", "setData", "writable", "getWritable", "RelationshipComponent", "lazy", "then", "module", "default", "$relationshipElementToNode", "domNode", "id", "getAttribute", "relationTo", "node", "$createRelationshipNode", "value", "RelationshipNode", "RelationshipServerNode", "clone", "getType", "importDOM", "div", "hasAttribute", "conversion", "priority", "importJSON", "serializedNode", "version", "importedData", "setFormat", "format", "decorate", "editor", "config", "_jsx", "className", "theme", "relationship", "data", "__data", "__format", "nodeKey", "getKey", "exportJSON", "$applyNodeReplacement", "$isRelationshipNode", "c", "_c", "useLexicalComposerContext", "$insertNodeToNearestRoot", "$getPreviousSelection", "$getSelection", "$isParagraphNode", "$isRangeSelection", "COMMAND_PRIORITY_EDITOR", "createCommand", "useEffect", "c", "_c", "useLexicalComposerContext", "toast", "$getNodeByKey", "COMMAND_PRIORITY_EDITOR", "useEffect", "useState", "c", "_c", "useLexicalComposerContext", "useListDrawer", "useModal", "$getNodeByKey", "$getPreviousSelection", "$getRoot", "$getSelection", "$isRangeSelection", "$setSelection", "useEffect", "useState", "useLexicalListDrawer", "args", "$", "editor", "selectionState", "setSelectionState", "wasOpen", "setWasOpen", "BaseListDrawer", "BaseListDrawerToggler", "t0", "closeDrawer", "baseCloseDrawer", "drawerSlug", "listDrawerSlug", "isDrawerOpen", "openDrawer", "baseOpenDrawer", "modalState", "t1", "Symbol", "for", "selection", "$storeSelection", "t2", "update", "anchor", "focus", "key", "clone", "selectEnd", "discrete", "skipTransforms", "restoreSelection", "t3", "closeListDrawer", "t4", "t5", "thisModalState", "isOpen", "setTimeout", "t6", "props", "_jsx", "onClick", "t7", "t8", "isListDrawerOpen", "ListDrawer", "ListDrawerToggler", "insertRelationship", "editor", "relationTo", "replaceNodeKey", "value", "update", "node", "$getNodeByKey", "replace", "$createRelationshipNode", "dispatchCommand", "INSERT_RELATIONSHIP_COMMAND", "RelationshipDrawerComponent", "t0", "$", "_c", "enabledCollectionSlugs", "useLexicalComposerContext", "setReplaceNodeKey", "useState", "t1", "t2", "collectionSlugs", "selectedCollection", "closeListDrawer", "ListDrawer", "openListDrawer", "useLexicalListDrawer", "t3", "t4", "registerCommand", "INSERT_RELATIONSHIP_WITH_DRAWER_COMMAND", "payload", "nodeKey", "COMMAND_PRIORITY_EDITOR", "useEffect", "t5", "t6", "collectionSlug", "doc", "id", "onSelect", "_jsx", "RelationshipDrawerComponentFallback", "_temp", "RelationshipDrawer", "length", "toast", "error", "useConfig", "useEntityVisibility", "React", "useEnabledRelationships", "options", "collectionSlugsBlacklist", "collectionSlugsWhitelist", "uploads", "config", "collections", "visibleEntities", "useMemo", "enabledCollectionSlugs", "enabledCollections", "whitelistSet", "Set", "blacklistSet", "collection", "slug", "admin", "enableRichTextRelationship", "upload", "includes", "has", "push", "INSERT_RELATIONSHIP_COMMAND", "createCommand", "RelationshipPlugin", "t0", "$", "_c", "clientProps", "editor", "useLexicalComposerContext", "t1", "disabledCollections", "t2", "enabledCollections", "t3", "collectionSlugsBlacklist", "collectionSlugsWhitelist", "enabledCollectionSlugs", "useEnabledRelationships", "t4", "t5", "hasNodes", "RelationshipNode", "Error", "registerCommand", "_temp", "COMMAND_PRIORITY_EDITOR", "useEffect", "t6", "_jsx", "RelationshipDrawer", "payload", "selection", "$getSelection", "$getPreviousSelection", "$isRangeSelection", "relationshipNode", "$createRelationshipNode", "focus", "focusNode", "getNode", "$insertNodeToNearestRoot", "$isParagraphNode", "__first", "remove", "RelationshipFeatureClient", "createClientFeature", "nodes", "RelationshipNode", "plugins", "Component", "RelationshipPlugin", "position", "slashMenu", "groups", "slashMenuBasicGroupWithItems", "Icon", "RelationshipIcon", "key", "keywords", "label", "i18n", "t", "onSelect", "editor", "dispatchCommand", "INSERT_RELATIONSHIP_WITH_DRAWER_COMMAND", "replace", "toolbarFixed", "toolbarAddDropdownGroupWithItems", "ChildComponent", "isActive", "selection", "$isNodeSelection", "getNodes", "length", "firstNode", "$isRelationshipNode", "c", "_c", "useLexicalComposerContext", "useLexicalEditable", "useScrollInfo", "useThrottledEffect", "useTranslation", "React", "useMemo", "c", "_c", "mergeRegister", "$addUpdateTag", "$getSelection", "useDeferredValue", "useEffect", "useState", "baseClass", "ToolbarButton", "t0", "$", "_c", "children", "editor", "item", "t1", "Symbol", "for", "active", "enabled", "_state", "setState", "useState", "deferredState", "useDeferredValue", "editorConfigContext", "useEditorConfigContext", "t2", "t3", "t4", "key", "t5", "filter", "Boolean", "className", "join", "t6", "getEditorState", "read", "selection", "$getSelection", "newActive", "isActive", "newEnabled", "isEnabled", "prev", "updateStates", "runDeprioritized", "useRunDeprioritized", "t7", "t8", "listener", "cleanup", "mergeRegister", "registerUpdateListener", "document", "addEventListener", "removeEventListener", "useEffect", "t9", "focus", "update", "_temp", "onSelect", "handleClick", "handleMouseDown", "_temp2", "t10", "_jsx", "onClick", "onMouseDown", "type", "$addUpdateTag", "e", "preventDefault", "c", "_c", "React", "useCallback", "useDeferredValue", "useEffect", "useMemo", "mergeRegister", "useTranslation", "$getSelection", "Button", "$addUpdateTag", "isDOMNode", "React", "useCallback", "useEffect", "useMemo", "useRef", "useState", "createPortal", "baseClass", "DropDownContext", "createContext", "DropDownItem", "active", "children", "editor", "enabled", "Icon", "item", "itemKey", "tooltip", "className", "key", "filter", "Boolean", "join", "ref", "dropDownContext", "use", "Error", "registerItem", "current", "_jsx", "buttonStyle", "disabled", "extraButtonProps", "icon", "iconPosition", "iconStyle", "onClick", "focus", "update", "onSelect", "isActive", "onMouseDown", "e", "preventDefault", "type", "DropDownItems", "dropDownRef", "itemsContainerClassNames", "onClose", "items", "setItems", "highlightedItem", "setHighlightedItem", "itemRef", "prev", "handleKeyDown", "event", "includes", "index", "indexOf", "length", "contextValue", "value", "onKeyDown", "DropDown", "buttonAriaLabel", "buttonClassName", "dropdownKey", "label", "stopCloseOnClickSelf", "buttonRef", "showDropDown", "setShowDropDown", "handleClose", "button", "dropDown", "left", "top", "getBoundingClientRect", "scrollTopOffset", "window", "scrollY", "document", "documentElement", "scrollTop", "style", "offsetHeight", "Math", "min", "innerWidth", "offsetWidth", "handle", "target", "contains", "addEventListener", "removeEventListener", "portal", "body", "_jsxs", "Fragment", "baseClass", "ToolbarItem", "t0", "$", "_c", "active", "anchorElem", "editor", "enabled", "item", "i18n", "useTranslation", "fieldProps", "t1", "useEditorConfigContext", "featureClientSchemaMap", "schemaPath", "Component", "t2", "_jsx", "key", "title", "croppedTitle", "label", "length", "substring", "DropDownItem", "Icon", "ChildComponent", "undefined", "itemKey", "tooltip", "children", "className", "MemoToolbarItem", "React", "memo", "ToolbarDropdown", "classNames", "group", "itemsContainerClassNames", "maxActiveItems", "onActiveChange", "toolbarState", "setToolbarState", "useState", "activeItemKeys", "enabledGroup", "enabledItemKeys", "deferredToolbarState", "useDeferredValue", "editorConfigContext", "items", "groupKey", "runDeprioritized", "useRunDeprioritized", "updateStates", "useCallback", "getEditorState", "read", "selection", "$getSelection", "_activeItemKeys", "_activeItems", "_enabledItemKeys", "isActive", "push", "isEnabled", "activeItems", "useEffect", "mergeRegister", "registerUpdateListener", "renderedItems", "useMemo", "map", "includes", "DropDown", "buttonAriaLabel", "buttonClassName", "filter", "Boolean", "join", "disabled", "dropdownKey", "ButtonGroupItem", "anchorElem", "editor", "item", "Component", "_jsx", "key", "ChildComponent", "ToolbarButton", "ToolbarGroupComponent", "t0", "$", "_c", "editorConfig", "group", "index", "i18n", "useTranslation", "fieldProps", "t1", "useEditorConfigContext", "featureClientSchemaMap", "schemaPath", "dropdownLabel", "setDropdownLabel", "useState", "undefined", "DropdownIcon", "setDropdownIcon", "t2", "items", "type", "length", "t3", "useEffect", "t4", "t5", "activeItems", "label", "substring", "t", "count", "onActiveChange", "t6", "features", "toolbarFixed", "groups", "_jsxs", "className", "children", "ToolbarDropdown", "Icon", "itemsContainerClassNames", "maxActiveItems", "map", "item_0", "FixedToolbar", "clientProps", "parentWithFixedToolbar", "currentToolbarRef", "useRef", "isEditable", "useLexicalEditable", "y", "useScrollInfo", "parentToolbarElem", "useMemo", "disableIfParentHasFixedToolbar", "sibling", "editorContainerRef", "current", "previousElementSibling", "classList", "contains", "useThrottledEffect", "currentToolbarElem", "currentRect", "getBoundingClientRect", "parentRect", "bottom", "top", "remove", "add", "onFocus", "event", "stopPropagation", "ref", "Fragment", "i", "getParentEditorWithFixedToolbar", "editorConfigContext", "parentEditor", "resolvedFeatureMap", "has", "FixedToolbarPlugin", "currentEditor", "useLexicalComposerContext", "currentEditorConfig", "applyToFocusedEditor", "focusedEditor", "Symbol", "for", "bb0", "document", "body", "FixedToolbarFeatureClient", "createClientFeature", "plugins", "Component", "FixedToolbarPlugin", "position", "c", "_c", "useLexicalComposerContext", "useLexicalEditable", "mergeRegister", "$getSelection", "$isRangeSelection", "$isTextNode", "COMMAND_PRIORITY_LOW", "getDOMSelection", "SELECTION_CHANGE_COMMAND", "useCallback", "useEffect", "useRef", "useState", "React", "createPortal", "getDOMRangeRect", "nativeSelection", "rootElement", "domRange", "getRangeAt", "rect", "anchorNode", "inner", "firstElementChild", "getBoundingClientRect", "setFloatingElemPosition", "args", "alwaysDisplayOnTop", "anchorElem", "anchorFlippedOffset", "floatingElem", "horizontalOffset", "HORIZONTAL_OFFSET", "horizontalPosition", "specialHandlingForCaret", "targetRect", "verticalGap", "VERTICAL_GAP", "scrollerElem", "parentElement", "style", "opacity", "transform", "floatingElemRect", "getBoundingClientRect", "anchorElementRect", "editorScrollerRect", "top", "height", "left", "width", "addedToTop", "right", "bottom", "ButtonGroupItem", "anchorElem", "editor", "item", "Component", "_jsx", "key", "ChildComponent", "ToolbarButton", "ToolbarGroupComponent", "t0", "$", "_c", "group", "index", "editorConfig", "useEditorConfigContext", "DropdownIcon", "setDropdownIcon", "useState", "t1", "items", "type", "length", "undefined", "t2", "useEffect", "t3", "t4", "activeItems", "onActiveChange", "t5", "features", "toolbarInline", "groups", "_jsxs", "className", "children", "ToolbarDropdown", "Icon", "maxActiveItems", "map", "item_0", "InlineToolbar", "floatingToolbarRef", "useRef", "caretRef", "closeFloatingToolbar", "useCallback", "current", "isOpacityZero", "style", "opacity", "isPointerEventsNone", "pointerEvents", "mouseMoveListener", "e", "buttons", "x", "clientX", "y", "clientY", "elementUnderMouse", "document", "elementFromPoint", "contains", "mouseUpListener", "addEventListener", "removeEventListener", "$updateTextFormatFloatingToolbar", "selection", "$getSelection", "nativeSelection", "getDOMSelection", "_window", "possibleLinkEditor", "querySelector", "isLinkEditorVisible", "rootElement", "getRootElement", "isCollapsed", "anchorNode", "rangeRect", "getDOMRangeRect", "offsetIfFlipped", "setFloatingElemPosition", "alwaysDisplayOnTop", "floatingElem", "horizontalPosition", "targetRect", "anchorFlippedOffset", "horizontalOffset", "specialHandlingForCaret", "verticalGap", "scrollerElem", "parentElement", "update", "getEditorState", "read", "window", "mergeRegister", "registerUpdateListener", "editorState", "registerCommand", "SELECTION_CHANGE_COMMAND", "COMMAND_PRIORITY_LOW", "ref", "i", "useInlineToolbar", "isText", "setIsText", "isEditable", "useLexicalEditable", "isComposing", "$isRangeSelection", "getTextContent", "nodes", "getNodes", "foundNodeWithText", "node", "$isTextNode", "rawTextContent", "replace", "updatePopup", "registerRootListener", "createPortal", "InlineToolbarPlugin", "useLexicalComposerContext", "InlineToolbarFeatureClient", "createClientFeature", "plugins", "Component", "InlineToolbarPlugin", "position", "TableCellNode", "TableNode", "TableRowNode", "TableIcon", "_jsx", "className", "fill", "height", "viewBox", "width", "xmlns", "clipRule", "d", "fillRule", "$createTableCellNode", "$createTableNode", "$createTableRowNode", "$isTableCellNode", "$isTableNode", "$isTableRowNode", "TableCellHeaderStates", "TableCellNode", "TableNode", "TableRowNode", "$isParagraphNode", "$isTextNode", "TABLE_ROW_REG_EXP", "TABLE_ROW_DIVIDER_REG_EXP", "TableMarkdownTransformer", "allTransformers", "type", "dependencies", "TableNode", "TableRowNode", "TableCellNode", "export", "node", "$isTableNode", "output", "row", "getChildren", "rowOutput", "$isTableRowNode", "isHeaderRow", "cell", "$isTableCellNode", "push", "$convertToMarkdownString", "replace", "trim", "__headerState", "TableCellHeaderStates", "ROW", "join", "map", "_", "regExp", "parentNode", "_1", "match", "match0", "test", "table", "getPreviousSibling", "rows", "lastRow", "length", "forEach", "setHeaderStyles", "remove", "matchCells", "mapToTableCells", "sibling", "maxCells", "$isParagraphNode", "getChildrenSize", "firstChild", "getFirstChild", "$isTextNode", "cells", "getTextContent", "Math", "max", "unshift", "previousSibling", "$createTableNode", "tableRow", "$createTableRowNode", "append", "i", "$createTableCell", "getTableColumnsSize", "selectEnd", "textContent", "$createTableCellNode", "NO_STATUS", "$convertFromMarkdownString", "split", "text", "c", "_c", "useLexicalComposerContext", "useLexicalEditable", "$computeTableMapSkipCellCheck", "$deleteTableColumnAtSelection", "$deleteTableRowAtSelection", "$getNodeTriplet", "$getTableCellNodeFromLexicalNode", "$getTableColumnIndexFromTableCellNode", "$getTableNodeFromLexicalNodeOrThrow", "$getTableRowIndexFromTableCellNode", "$insertTableColumnAtSelection", "$insertTableRowAtSelection", "$isTableCellNode", "$isTableSelection", "$mergeCells", "$unmergeCell", "getTableElement", "getTableObserverFromTableElement", "TableCellHeaderStates", "TableCellNode", "mergeRegister", "useScrollInfo", "$getSelection", "$isElementNode", "$isRangeSelection", "$isTextNode", "$setSelection", "COMMAND_PRIORITY_CRITICAL", "getDOMSelection", "isDOMNode", "SELECTION_CHANGE_COMMAND", "React", "useCallback", "useEffect", "useRef", "useState", "createPortal", "MeatballsIcon", "_jsxs", "fill", "height", "viewBox", "width", "xmlns", "_jsx", "d", "computeSelectionCount", "selection", "selectionShape", "getShape", "columns", "toX", "fromX", "rows", "toY", "fromY", "$canUnmerge", "$getSelection", "$isRangeSelection", "isCollapsed", "$isTableSelection", "anchor", "is", "focus", "cell", "$getNodeTriplet", "__colSpan", "__rowSpan", "$selectLastDescendant", "node", "lastDescendant", "getLastDescendant", "$isTextNode", "select", "$isElementNode", "selectEnd", "selectNext", "TableActionMenu", "cellMerge", "contextRef", "onClose", "setIsMenuOpen", "tableCellNode", "_tableCellNode", "editor", "useLexicalComposerContext", "dropDownRef", "useRef", "updateTableCellNode", "useState", "selectionCounts", "updateSelectionCounts", "canMergeCells", "setCanMergeCells", "canUnmergeCell", "setCanUnmergeCell", "y", "useScrollInfo", "useEffect", "registerMutationListener", "TableCellNode", "nodeMutations", "get", "getKey", "getEditorState", "read", "getLatest", "skipInitialization", "currentSelectionCounts", "menuButtonElement", "current", "dropDownElement", "rootElement", "getRootElement", "rootEleRect", "getBoundingClientRect", "menuButtonRect", "style", "opacity", "dropDownElementRect", "margin", "leftPosition", "right", "width", "window", "innerWidth", "position", "left", "pageXOffset", "topPosition", "top", "height", "innerHeight", "bottom", "handleClickOutside", "event", "isDOMNode", "target", "contains", "addEventListener", "removeEventListener", "clearTableSelection", "useCallback", "update", "isAttached", "tableNode", "$getTableNodeFromLexicalNodeOrThrow", "tableElement", "getTableElement", "getElementByKey", "Error", "tableObserver", "getTableObserverFromTableElement", "$clearHighlight", "markDirty", "$setSelection", "mergeTableCellsAtSelection", "tableCells", "getNodes", "filter", "$isTableCellNode", "targetCell", "$mergeCells", "unmergeTableCellsAtSelection", "$unmergeCell", "insertTableRowAtSelection", "shouldInsertAfter", "i", "$insertTableRowAtSelection", "insertTableColumnAtSelection", "$insertTableColumnAtSelection", "deleteTableRowAtSelection", "$deleteTableRowAtSelection", "deleteTableAtSelection", "remove", "deleteTableColumnAtSelection", "$deleteTableColumnAtSelection", "toggleTableRowIsHeader", "tableRowIndex", "$getTableRowIndexFromTableCellNode", "gridMap", "$computeTableMapSkipCellCheck", "rowCells", "Set", "newStyle", "getHeaderStyles", "TableCellHeaderStates", "ROW", "col", "length", "mapCell", "has", "add", "setHeaderStyles", "toggleTableColumnIsHeader", "tableColumnIndex", "$getTableColumnIndexFromTableCellNode", "columnCells", "COLUMN", "row", "toggleRowStriping", "setRowStriping", "getRowStriping", "toggleFirstColumnFreeze", "setFrozenColumns", "getFrozenColumns", "mergeCellButton", "_jsx", "className", "onClick", "type", "createPortal", "_jsxs", "e", "stopPropagation", "ref", "Fragment", "__headerState", "document", "body", "TableCellActionMenuContainer", "anchorElem", "menuButtonRef", "menuRootRef", "isMenuOpen", "setTableMenuCellNode", "$moveMenu", "menu", "nativeSelection", "getDOMSelection", "_window", "activeElement", "disable", "classList", "tableCellParentNodeDOM", "anchorNode", "tableCellNodeFromSelection", "$getTableCellNodeFromLexicalNode", "getNode", "enabled", "isSelecting", "toggle", "tableCellRect", "anchorRect", "transform", "timeoutId", "callback", "undefined", "delayedCallback", "setTimeout", "mergeRegister", "registerUpdateListener", "registerCommand", "SELECTION_CHANGE_COMMAND", "COMMAND_PRIORITY_CRITICAL", "registerRootListener", "prevRootElement", "clearTimeout", "prevTableCellDOM", "MeatballsIcon", "TableActionMenuPlugin", "t0", "$", "_c", "isEditable", "useLexicalEditable", "t1", "c", "_c", "useLexicalComposerContext", "useLexicalEditable", "$computeTableMapSkipCellCheck", "$getTableNodeFromLexicalNodeOrThrow", "$getTableRowIndexFromTableCellNode", "$isTableCellNode", "$isTableRowNode", "getDOMCellFromTarget", "getTableElement", "TableNode", "calculateZoomLevel", "mergeRegister", "$getNearestNodeFromDOMNode", "isHTMLElement", "SKIP_SCROLL_INTO_VIEW_TAG", "React", "useCallback", "useEffect", "useRef", "useState", "createPortal", "MIN_ROW_HEIGHT", "MIN_COLUMN_WIDTH", "TableCellResizer", "editor", "targetRef", "useRef", "resizerRef", "tableRectRef", "hasTable", "setHasTable", "useState", "editorConfig", "useEditorConfigContext", "mouseStartPosRef", "mouseCurrentPos", "updateMouseCurrentPos", "activeCell", "updateActiveCell", "isMouseDown", "updateIsMouseDown", "draggingDirection", "updateDraggingDirection", "resetState", "useCallback", "current", "isMouseDownOnEvent", "event", "buttons", "useEffect", "tableKeys", "Set", "mergeRegister", "registerMutationListener", "TableNode", "nodeMutations", "nodeKey", "mutation", "delete", "add", "size", "registerNodeTransform", "tableNode", "getColWidths", "numColumns", "getColumnCount", "columnWidth", "setColWidths", "Array", "fill", "onMouseMove", "target", "isHTMLElement", "x", "clientX", "y", "clientY", "contains", "cell", "getDOMCellFromTarget", "getEditorState", "read", "tableCellNode", "$getNearestNodeFromDOMNode", "elem", "Error", "$getTableNodeFromLexicalNodeOrThrow", "tableElement", "getTableElement", "getElementByKey", "getKey", "getBoundingClientRect", "onMouseDown", "onMouseUp", "removeRootListener", "registerRootListener", "rootElement", "prevRootElement", "removeEventListener", "addEventListener", "isHeightChanging", "direction", "updateRowHeight", "heightChange", "update", "$isTableCellNode", "baseRowIndex", "$getTableRowIndexFromTableCellNode", "tableRows", "getChildren", "tableRowIndex", "getColSpan", "getRowSpan", "length", "tableRow", "$isTableRowNode", "height", "getHeight", "undefined", "rowCells", "Math", "min", "map", "getCellNodeHeight", "Infinity", "newHeight", "max", "setHeight", "tag", "SKIP_SCROLL_INTO_VIEW_TAG", "activeEditor", "clientHeight", "getCellColumnIndex", "tableMap", "columnIndex", "forEach", "row", "columnIndexInner", "updateColumnWidth", "widthChange", "$computeTableMapSkipCellCheck", "colWidths", "width", "newColWidths", "newWidth", "mouseUpHandler", "handler", "preventDefault", "stopPropagation", "zoom", "calculateZoomLevel", "document", "toggleResize", "resizerStyles", "setResizerStyles", "bottom", "left", "right", "top", "zoneWidth", "styles", "backgroundColor", "cursor", "window", "scrollX", "scrollY", "tableRect", "_jsx", "ref", "_jsxs", "Fragment", "className", "lexical", "theme", "tableCellResizer", "style", "TableCellResizerPlugin", "$", "_c", "useLexicalComposerContext", "isEditable", "useLexicalEditable", "t0", "createPortal", "c", "_c", "useLexicalComposerContext", "useLexicalEditable", "$getTableAndElementByKey", "$getTableColumnIndexFromTableCellNode", "$getTableRowIndexFromTableCellNode", "$insertTableColumnAtSelection", "$insertTableRowAtSelection", "$isTableCellNode", "$isTableNode", "getTableElement", "TableNode", "$findMatchingParent", "mergeRegister", "$getNearestNodeFromDOMNode", "isHTMLElement", "useEffect", "useMemo", "useRef", "useState", "createPortal", "c", "_c", "useEffect", "useRef", "FUNC_ERROR_TEXT", "nativeMax", "Math", "max", "nativeMin", "min", "debounce", "func", "wait", "options", "lastArgs", "lastCallTime", "lastInvokeTime", "lastThis", "leading", "maxing", "maxWait", "result", "timerID", "trailing", "TypeError", "invokeFunc", "time", "args", "thisArg", "undefined", "apply", "leadingEdge", "setTimeout", "timerExpired", "remainingWait", "timeSinceLastCall", "timeSinceLastInvoke", "timeWaiting", "shouldInvoke", "Date", "now", "trailingEdge", "cancel", "clearTimeout", "flush", "debounced", "isInvoking", "arguments", "debounce_default", "useDebounce", "fn", "ms", "maxWait", "$", "_c", "debouncedRef", "useRef", "t0", "t1", "current", "debounce", "cancel", "useEffect", "t2", "Symbol", "for", "t3", "args", "BUTTON_WIDTH_PX", "TableHoverActionsContainer", "anchorElem", "editor", "useLexicalComposerContext", "isEditable", "useLexicalEditable", "editorConfig", "useEditorConfigContext", "isShownRow", "setShownRow", "useState", "isShownColumn", "setShownColumn", "shouldListenMouseMove", "setShouldListenMouseMove", "position", "setPosition", "tableSetRef", "useRef", "Set", "tableCellDOMNodeRef", "debouncedOnMouseMove", "useDebounce", "event", "isOutside", "tableDOMNode", "getMouseInfo", "lexical", "current", "hoveredRowNode", "hoveredColumnNode", "tableDOMElement", "getEditorState", "read", "maybeTableCell", "$getNearestNodeFromDOMNode", "$isTableCellNode", "table", "$findMatchingParent", "node", "$isTableNode", "getTableElement", "getElementByKey", "getKey", "rowCount", "getChildrenSize", "colCount", "getChildAtIndex", "rowIndex", "$getTableRowIndexFromTableCellNode", "colIndex", "$getTableColumnIndexFromTableCellNode", "tableContainerElement", "parentElement", "bottom", "tableElemBottom", "height", "tableElemHeight", "left", "tableElemLeft", "right", "tableElemRight", "width", "tableElemWidth", "y", "tableElemY", "getBoundingClientRect", "tableHasScroll", "classList", "contains", "scrollWidth", "clientWidth", "editorElemLeft", "editorElemY", "offsetLeft", "top", "offsetWidth", "tableResizeObserver", "useMemo", "ResizeObserver", "useEffect", "document", "addEventListener", "removeEventListener", "mergeRegister", "registerMutationListener", "TableNode", "mutations", "resetObserver", "key", "type", "add", "delete", "disconnect", "tableKey", "tableElement", "$getTableAndElementByKey", "observe", "size", "skipInitialization", "insertAction", "insertRow", "update", "selectEnd", "$insertTableRowAtSelection", "$insertTableColumnAtSelection", "_jsxs", "_Fragment", "_jsx", "className", "theme", "tableAddRows", "onClick", "style", "tableAddColumns", "target", "isHTMLElement", "closest", "tableCell", "tableCellResizer", "TableHoverActionsPlugin", "t0", "$", "_c", "t1", "undefined", "body", "t2", "createPortal", "c", "_c", "useLexicalComposerContext", "TablePlugin", "LexicalReactTablePlugin", "INSERT_TABLE_COMMAND", "TableCellNode", "TableNode", "TableRowNode", "mergeRegister", "formatDrawerSlug", "useEditDepth", "$getSelection", "$isRangeSelection", "COMMAND_PRIORITY_EDITOR", "createCommand", "createContext", "use", "useEffect", "useMemo", "useState", "React", "OPEN_TABLE_DRAWER_COMMAND", "createCommand", "CellContext", "createContext", "cellEditorConfig", "cellEditorPlugins", "set", "TableContext", "children", "contextValue", "setContextValue", "useState", "_jsx", "value", "useMemo", "TablePlugin", "$", "_c", "editor", "useLexicalComposerContext", "cellContext", "use", "editDepth", "useEditDepth", "fieldProps", "t0", "uuid", "useEditorConfigContext", "schemaPath", "t1", "t2", "formatDrawerSlug", "slug", "depth", "drawerSlug", "toggleDrawer", "useLexicalDrawer", "t3", "hasNodes", "TableNode", "TableRowNode", "TableCellNode", "Error", "mergeRegister", "registerCommand", "rangeSelection", "getEditorState", "read", "selection", "$getSelection", "$isRangeSelection", "COMMAND_PRIORITY_EDITOR", "t4", "useEffect", "t5", "_fields", "data", "columns", "rows", "dispatchCommand", "INSERT_TABLE_COMMAND", "String", "t6", "_jsxs", "Fragment", "FieldsDrawer", "drawerTitle", "featureKey", "handleDrawerSubmit", "schemaPathSuffix", "LexicalReactTablePlugin", "hasCellBackgroundColor", "hasCellMerge", "hasHorizontalScroll", "TableFeatureClient", "createClientFeature", "markdownTransformers", "TableMarkdownTransformer", "nodes", "TableNode", "TableCellNode", "TableRowNode", "plugins", "Component", "TablePlugin", "position", "TableCellResizerPlugin", "TableActionMenuPlugin", "TableHoverActionsPlugin", "providers", "TableContext", "slashMenu", "groups", "slashMenuBasicGroupWithItems", "Icon", "TableIcon", "key", "keywords", "label", "onSelect", "editor", "dispatchCommand", "OPEN_TABLE_DRAWER_COMMAND", "toolbarFixed", "toolbarAddDropdownGroupWithItems", "ChildComponent", "$isNodeSelection", "UploadIcon", "_jsxs", "className", "fill", "focusable", "height", "viewBox", "width", "xmlns", "_jsx", "d", "stroke", "strokeLinecap", "strokeLinejoin", "ObjectID", "$applyNodeReplacement", "React", "ObjectID", "$convertUploadElement", "domNode", "$createNode", "hasAttribute", "formID", "getAttribute", "node", "data", "pending", "src", "id", "relationTo", "fields", "value", "ObjectID", "default", "toHexString", "DecoratorBlockNode", "addClassNamesToElement", "ObjectID", "$applyNodeReplacement", "UploadServerNode", "DecoratorBlockNode", "__data", "constructor", "data", "format", "key", "clone", "node", "__format", "__key", "getType", "importDOM", "img", "conversion", "domNode", "$convertUploadElement", "$createUploadServerNode", "priority", "importJSON", "serializedNode", "version", "value", "id", "ObjectID", "default", "toHexString", "importedData", "fields", "pending", "relationTo", "setFormat", "isInline", "createDOM", "config", "element", "document", "createElement", "addClassNamesToElement", "theme", "upload", "decorate", "exportDOM", "setAttribute", "String", "formID", "src", "exportJSON", "getData", "type", "getLatest", "setData", "writable", "getWritable", "updateDOM", "$applyNodeReplacement", "ShimmerEffect", "PendingUploadComponent", "_jsx", "className", "height", "width", "RawUploadComponent", "lazy", "then", "module", "default", "UploadComponent", "UploadNode", "UploadServerNode", "clone", "node", "getType", "importDOM", "img", "conversion", "domNode", "$convertUploadElement", "$createUploadNode", "priority", "importJSON", "serializedNode", "version", "value", "id", "ObjectID", "toHexString", "importedData", "fields", "pending", "relationTo", "data", "setFormat", "format", "decorate", "editor", "config", "__data", "_jsx", "PendingUploadComponent", "className", "theme", "upload", "__format", "nodeKey", "getKey", "exportJSON", "$applyNodeReplacement", "$isUploadNode", "c", "_c", "useLexicalComposerContext", "$dfsIterator", "$insertNodeToNearestRoot", "mergeRegister", "useBulkUpload", "useEffectEvent", "useModal", "ObjectID", "$createRangeSelection", "$getPreviousSelection", "$getSelection", "$isParagraphNode", "$isRangeSelection", "$setSelection", "COMMAND_PRIORITY_EDITOR", "COMMAND_PRIORITY_LOW", "createCommand", "DROP_COMMAND", "getDOMSelectionFromTarget", "isHTMLElement", "PASTE_COMMAND", "useEffect", "c", "_c", "useLexicalComposerContext", "toast", "$getNodeByKey", "COMMAND_PRIORITY_EDITOR", "useEffect", "useState", "insertUpload", "editor", "relationTo", "replaceNodeKey", "value", "update", "node", "$getNodeByKey", "replace", "$createUploadNode", "data", "fields", "dispatchCommand", "INSERT_UPLOAD_COMMAND", "UploadDrawerComponent", "t0", "$", "_c", "enabledCollectionSlugs", "useLexicalComposerContext", "setReplaceNodeKey", "useState", "t1", "collectionSlugs", "uploads", "closeListDrawer", "ListDrawer", "openListDrawer", "useLexicalListDrawer", "t2", "t3", "registerCommand", "INSERT_UPLOAD_WITH_DRAWER_COMMAND", "payload", "nodeKey", "COMMAND_PRIORITY_EDITOR", "useEffect", "t4", "t5", "collectionSlug", "doc", "id", "onSelect", "_jsx", "UploadDrawerComponentFallback", "_temp", "UploadDrawer", "length", "toast", "error", "canDropImage", "event", "target", "isHTMLElement", "closest", "parentElement", "getDragSelection", "range", "domSelection", "getDOMSelectionFromTarget", "document", "caretRangeFromPoint", "clientX", "clientY", "rangeParent", "collapse", "rangeOffset", "getRangeAt", "Error", "INSERT_UPLOAD_COMMAND", "createCommand", "UploadPlugin", "t0", "$", "_c", "clientProps", "editor", "useLexicalComposerContext", "t1", "disabledCollections", "t2", "enabledCollections", "t3", "collectionSlugsBlacklist", "collectionSlugsWhitelist", "uploads", "enabledCollectionSlugs", "useEnabledRelationships", "drawerSlug", "bulkUploadDrawerSlug", "setCollectionSlug", "setInitialForms", "setOnCancel", "setOnSuccess", "setSelectableCollections", "useBulkUpload", "isModalOpen", "openModal", "useModal", "t4", "t5", "files", "length", "initialForms", "map", "_temp", "update", "_temp2", "newDocs", "newDocsMap", "Map", "_temp3", "dfsNode_0", "$dfsIterator", "node_0", "dfsNode", "node", "$isUploadNode", "nodeData_0", "getData", "nodeData", "pending", "newDoc", "get", "formID", "replace", "$createUploadNode", "data", "id", "ObjectID", "default", "toHexString", "fields", "relationTo", "collectionSlug", "value", "doc", "openBulkUpload", "useEffectEvent", "hasNodes", "UploadNode", "mergeRegister", "registerNodeTransform", "node_1", "nodeData_1", "transformedImage", "src", "startsWith", "mimeMatch", "match", "mimeType", "base64Data", "byteCharacters", "atob", "byteNumbers", "Array", "i", "charCodeAt", "byteArray", "Uint8Array", "File", "split", "type", "blob", "fetch", "inferredFileName", "pop", "registerCommand", "payload", "selection", "$getSelection", "$getPreviousSelection", "$isRangeSelection", "uploadNode", "focus", "focusNode", "getNode", "$insertNodeToNearestRoot", "$isParagraphNode", "__first", "remove", "COMMAND_PRIORITY_EDITOR", "PASTE_COMMAND", "ClipboardEvent", "clipboardData", "types", "includes", "files_0", "from", "forEach", "file_2", "push", "alt", "file", "selection_0", "file_3", "pendingUploadNode", "URL", "createObjectURL", "focus_0", "focusNode_0", "COMMAND_PRIORITY_LOW", "DROP_COMMAND", "event_0", "DragEvent", "dt", "dataTransfer", "files_1", "file_4", "preventDefault", "stopPropagation", "selection_1", "$createRangeSelection", "applyDOMRange", "$setSelection", "file_5", "pendingUploadNode_0", "focus_1", "focusNode_1", "t6", "useEffect", "t7", "_jsx", "UploadDrawer", "UploadFeatureClient", "createClientFeature", "nodes", "UploadNode", "plugins", "Component", "UploadPlugin", "position", "slashMenu", "groups", "slashMenuBasicGroupWithItems", "Icon", "UploadIcon", "key", "keywords", "label", "i18n", "t", "onSelect", "editor", "dispatchCommand", "INSERT_UPLOAD_WITH_DRAWER_COMMAND", "replace", "toolbarFixed", "toolbarAddDropdownGroupWithItems", "ChildComponent", "isActive", "selection", "$isNodeSelection", "getNodes", "length", "firstNode", "$isUploadNode", "c", "_c", "ShimmerEffect", "useConfig", "lazy", "Suspense", "useEffect", "useState", "LexicalEditorTheme", "block", "blockCursor", "characterLimit", "code", "inlineBlock", "heading", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "hrSelected", "indent", "link", "list", "checklist", "listitem", "listitemChecked", "listitemUnchecked", "nested", "olDepth", "ul", "ltr", "mark", "markOverlap", "paragraph", "placeholder", "quote", "relationship", "rtl", "tab", "table", "tableAddColumns", "tableAddRows", "tableAlignment", "center", "right", "tableCell", "tableCellActionButton", "tableCellActionButtonContainer", "tableCellHeader", "tableCellResizer", "tableCellSelected", "tableFrozenColumn", "tableRowStriping", "tableScrollableWrapper", "tableSelected", "tableSelection", "text", "bold", "italic", "strikethrough", "subscript", "superscript", "underline", "underlineStrikethrough", "upload", "defaultEditorLexicalConfig", "namespace", "theme", "LexicalEditorTheme", "loadClientFeatures", "config", "featureClientImportMap", "featureClientSchemaMap", "field", "schemaPath", "unSanitizedEditorConfig", "featureProviderMap", "Map", "featureProvider", "features", "clientFeatureProps", "featureKey", "order", "undefined", "Error", "set", "sort", "a", "b", "resolvedFeatures", "loaded", "feature", "key", "deepMerge", "sanitizeClientFeatures", "features", "sanitized", "enabledFeatures", "enabledFormats", "markdownTransformers", "nodes", "plugins", "providers", "slashMenu", "dynamicGroups", "groups", "toolbarFixed", "toolbarInline", "customGroups", "forEach", "feature", "key", "sanitizedClientFeatureProps", "size", "length", "concat", "enableFormats", "push", "node", "plugin", "i", "clientProps", "Component", "position", "group", "foundGroup", "find", "sanitizedGroup", "filter", "items", "optionGroup", "transformer", "allNodes", "allTransformers", "Object", "keys", "map", "customConfig", "sort", "a", "b", "order", "sanitizeClientEditorConfig", "resolvedClientFeatureMap", "lexical", "admin", "resolvedFeatureMap", "RichTextEditor", "lazy", "then", "module", "default", "RichText", "RichTextField", "props", "$", "_c", "admin", "t0", "clientFeatures", "featureClientImportMap", "t1", "featureClientSchemaMap", "field", "lexicalEditorConfig", "t2", "schemaPath", "t3", "undefined", "t4", "defaultEditorLexicalConfig", "config", "useConfig", "finalSanitizedEditorConfig", "setFinalSanitizedEditorConfig", "useState", "t5", "t6", "featureProvidersLocal", "clientFeature", "Object", "values", "clientFeatureProvider", "push", "clientFeatureProps", "resolvedClientFeatures", "loadClientFeatures", "name", "unSanitizedEditorConfig", "features", "lexical", "sanitizeClientEditorConfig", "useEffect", "t7", "_jsx", "Suspense", "fallback", "ShimmerEffect", "height", "editorConfig", "isHTMLElement", "x", "HTMLElement", "joinClasses", "args", "filter", "Boolean", "join", "elements", "WeakMap", "readTouch", "e", "touch", "changedTouches", "undefined", "clientX", "clientY", "addListener", "element", "cb", "elementValues", "get", "listeners", "Set", "handleTouchstart", "start", "handleTouchend", "end", "listener", "addEventListener", "set", "add", "deleteListener", "delete", "size", "removeEventListener", "addSwipeLeftListener", "force", "x", "y", "Math", "abs", "addSwipeRightListener", "addSwipeUpListener", "addSwipeDownListener", "c", "_c", "InlineBlockEditButton", "$", "_c", "EditButton", "useInlineBlockComponentContext", "t0", "_jsx", "c", "_c", "InlineBlockRemoveButton", "$", "_c", "RemoveButton", "useInlineBlockComponentContext", "t0", "_jsx", "c", "_c", "InlineBlockLabel", "$", "_c", "Label", "useInlineBlockComponentContext", "t0", "_jsx", "c", "_c", "InlineBlockContainer", "t0", "$", "_c", "children", "useInlineBlockComponentContext", "t1", "_jsx", "BlockCollapsible", "props", "children", "rest", "useBlockComponentContext", "_jsx", "c", "_c", "BlockEditButton", "$", "_c", "EditButton", "useBlockComponentContext", "t0", "_jsx", "c", "_c", "BlockRemoveButton", "$", "_c", "RemoveButton", "useBlockComponentContext", "t0", "_jsx", "stringify", "getRestPopulateFn", "apiURL", "depth", "draft", "locale", "id", "collectionSlug", "select", "query", "addQueryPrefix", "fetch", "credentials", "headers", "Accept", "method", "then", "res", "json", "codeConverter", "customEndRegex", "optional", "regExp", "customStartRegex", "doNotTrimChildren", "export", "fields", "code", "includes", "language", "length", "import", "children", "closeMatch", "openMatch", "startsWith", "slice", "endsWith", "input", "trim", "CodeField", "useFormFields", "useId", "useMemo", "defaultLanguages", "abap", "apex", "azcli", "bat", "bicep", "cameligo", "clojure", "coffee", "cpp", "csharp", "csp", "css", "cypher", "dart", "dockerfile", "ecl", "elixir", "flow9", "freemarker2", "fsharp", "go", "graphql", "handlebars", "hcl", "html", "ini", "java", "javascript", "julia", "kotlin", "less", "lexon", "liquid", "lua", "m3", "markdown", "mdx", "mips", "msdax", "mysql", "pascal", "pascaligo", "perl", "pgsql", "php", "pla", "plaintext", "postiats", "powerquery", "powershell", "protobuf", "pug", "python", "qsharp", "r", "razor", "redis", "redshift", "restructuredtext", "ruby", "rust", "sb", "scala", "scheme", "scss", "shell", "solidity", "sophia", "sparql", "sql", "st", "swift", "systemverilog", "tcl", "twig", "typescript", "typespec", "vb", "wgsl", "xml", "yaml", "CodeComponent", "autoComplete", "field", "forceRender", "languages", "defaultLanguages", "path", "permissions", "readOnly", "renderedBlocks", "schemaPath", "typescript", "validate", "languageField", "useFormFields", "fields", "language", "value", "initialValue", "instanceId", "useId", "label", "props", "useMemo", "type", "admin", "editorOptions", "editorProps", "defaultPath", "name", "undefined", "key", "_jsx", "CodeField", "onMount", "_editor", "monaco", "editor", "defineTheme", "base", "colors", "inherit", "rules", "typescriptDefaults", "setCompilerOptions", "allowNonTsExtensions", "allowJs", "allowSyntheticDefaultImports", "esModuleInterop", "jsx", "JsxEmit", "React", "moduleResolution", "ModuleResolutionKind", "NodeJs", "noEmit", "paths", "reactNamespace", "target", "ScriptTarget", "typeRoots", "setDiagnosticsOptions", "noSemanticValidation", "enableSemanticValidation", "noSyntaxValidation", "fetchTypes", "Array", "isArray", "length", "Promise", "all", "map", "typesText", "fetch", "url", "text", "addExtraLib", "filePath", "useLexicalEditable", "ChevronIcon", "Combobox", "CopyToClipboard", "PopupList", "RenderFields", "useForm", "useFormFields", "useTranslation", "React", "CodeBlockIcon", "_jsx", "fill", "height", "viewBox", "width", "xmlns", "d", "stroke", "strokeLinecap", "useCollapsible", "CollapseIcon", "_jsx", "fill", "height", "viewBox", "width", "xmlns", "d", "stroke", "strokeLinecap", "strokeLinejoin", "baseClass", "Collapse", "toggle", "useCollapsible", "_jsx", "className", "onClick", "type", "CollapseIcon", "useCollapsible", "useTranslation", "baseClass", "FloatingCollapse", "isCollapsed", "toggle", "useCollapsible", "t", "useTranslation", "_jsxs", "className", "onClick", "type", "_jsx", "CollapseIcon", "baseClass", "CodeBlockBlockComponent", "args", "languages", "languagesFromProps", "defaultLanguages", "BlockCollapsible", "formSchema", "RemoveButton", "useBlockComponentContext", "setModified", "useForm", "t", "useTranslation", "codeField", "useFormFields", "fields", "code", "selectedLanguageField", "setSelectedLanguage", "dispatch", "language", "type", "path", "value", "selectedLanguageLabel", "isEditable", "useLexicalEditable", "languageEntries", "React", "useMemo", "Object", "entries", "map", "languageCode", "languageLabel", "name", "Component", "_jsx", "PopupList", "Button", "active", "disabled", "onClick", "className", "Actions", "_jsxs", "Combobox", "button", "ChevronIcon", "buttonType", "horizontalAlign", "minEntriesForSearch", "searchPlaceholder", "showScrollbar", "size", "CopyToClipboard", "Collapse", "collapsibleProps", "AfterCollapsible", "FloatingCollapse", "disableHeaderToggle", "disableToggleIndicator", "Pill", "CodeBlockIcon", "RenderFields", "forceRender", "parentIndexPath", "parentPath", "parentSchemaPath", "permissions", "readOnly", "c", "_c", "FieldContext", "FieldPathContext", "ServerFunctionsContext", "ShimmerEffect", "useServerFunctions", "React", "useEffect", "useRef", "RenderLexical", "args", "$", "field", "initialValue", "Loading", "path", "schemaPath", "setValue", "value", "Component", "setComponent", "useState", "serverFunctionContext", "_internal_renderField", "entityType", "entitySlug", "split", "fieldPath", "name", "t0", "Field", "type", "admin", "hidden", "undefined", "renderLexical", "mounted", "t1", "t2", "current", "_jsx", "adjustedServerFunctionContext", "getFormState", "getFormStateArgs", "collectionSlug", "globalSlug", "children", "fieldValue", "disabled", "formInitializing", "formProcessing", "formSubmitted", "_temp", "showError", "buildEditorState", "nodes", "text", "editorJSON", "root", "type", "children", "direction", "format", "indent", "version", "push", "detail", "mode", "style", "textFormat", "textStyle", "length", "buildDefaultEditorState"],"mappings":""}},
    {"offset": {"line": 7847, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/utilities/buildInitialState.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/utilities/buildInitialState.ts"],"sourcesContent":["import type { SerializedLexicalNode } from 'lexical'\nimport type {\n  ClientFieldSchemaMap,\n  DocumentPreferences,\n  FieldSchemaMap,\n  FormState,\n  Operation,\n  PayloadRequest,\n  RichTextField,\n  SanitizedFieldPermissions,\n} from 'payload'\n\nimport { fieldSchemasToFormState } from '@payloadcms/ui/forms/fieldSchemasToFormState'\n\nimport type { SerializedBlockNode } from '../nodeTypes.js'\n\nexport type InitialLexicalFormState = {\n  [nodeID: string]: {\n    [key: string]: any\n    formState?: FormState\n  }\n}\n\ntype Props = {\n  context: {\n    clientFieldSchemaMap: ClientFieldSchemaMap\n    collectionSlug: string\n    disabled?: boolean\n    documentData?: any\n    field: RichTextField\n    fieldSchemaMap: FieldSchemaMap\n    id?: number | string\n    lexicalFieldSchemaPath: string\n    operation: Operation\n    permissions?: SanitizedFieldPermissions\n    preferences: DocumentPreferences\n    renderFieldFn: any\n    req: PayloadRequest\n  }\n  initialState?: InitialLexicalFormState\n  nodeData: SerializedLexicalNode[]\n}\n\nexport async function buildInitialState({\n  context,\n  initialState: initialStateFromArgs,\n  nodeData,\n}: Props): Promise<InitialLexicalFormState> {\n  let initialState: InitialLexicalFormState = initialStateFromArgs ?? {}\n  for (const node of nodeData) {\n    if ('children' in node) {\n      initialState = await buildInitialState({\n        context,\n        initialState,\n        nodeData: node.children as SerializedLexicalNode[],\n      })\n    }\n\n    if (node.type === 'block' || node.type === 'inlineBlock') {\n      const blockNode = node as SerializedBlockNode\n      const id = blockNode?.fields?.id\n      if (!id) {\n        continue\n      }\n\n      const schemaFieldsPath =\n        node.type === 'block'\n          ? `${context.lexicalFieldSchemaPath}.lexical_internal_feature.blocks.lexical_blocks.${blockNode.fields.blockType}.fields`\n          : `${context.lexicalFieldSchemaPath}.lexical_internal_feature.blocks.lexical_inline_blocks.${blockNode.fields.blockType}.fields`\n\n      // Build form state for the block\n\n      const formStateResult = await fieldSchemasToFormState({\n        id: context.id,\n        clientFieldSchemaMap: context.clientFieldSchemaMap,\n        collectionSlug: context.collectionSlug,\n        data: blockNode.fields,\n        documentData: context.documentData,\n        fields: (context.fieldSchemaMap.get(schemaFieldsPath) as any)?.fields,\n        fieldSchemaMap: context.fieldSchemaMap,\n        initialBlockData: blockNode.fields,\n        operation: context.operation as any, // TODO: Type\n        permissions: true,\n        preferences: context.preferences,\n        readOnly: context.disabled,\n        renderAllFields: true, // If this function runs, the parent lexical field is being re-rendered => thus we can assume all its sub-fields need to be re-rendered\n        renderFieldFn: context.renderFieldFn,\n        req: context.req,\n        schemaPath: schemaFieldsPath,\n      })\n\n      if (!initialState[id]) {\n        initialState[id] = {}\n      }\n\n      initialState[id].formState = formStateResult\n\n      if (node.type === 'block') {\n        const currentFieldPreferences = context.preferences?.fields?.[context.field.name]\n        const collapsedArray = currentFieldPreferences?.collapsed\n        if (Array.isArray(collapsedArray) && collapsedArray.includes(id)) {\n          initialState[id].collapsed = true\n        }\n      }\n    }\n  }\n  return initialState\n}\n"],"names":["fieldSchemasToFormState","buildInitialState","context","initialState","initialStateFromArgs","nodeData","node","children","type","blockNode","id","fields","schemaFieldsPath","lexicalFieldSchemaPath","blockType","formStateResult","clientFieldSchemaMap","collectionSlug","data","documentData","fieldSchemaMap","get","initialBlockData","operation","permissions","preferences","readOnly","disabled","renderAllFields","renderFieldFn","req","schemaPath","formState","currentFieldPreferences","field","name","collapsedArray","collapsed","Array","isArray","includes"],"mappings":";;;;AAYA,SAASA,uBAAuB,QAAQ;;AA+BjC,eAAeC,kBAAkB,EACtCC,OAAO,EACPC,YAAA,EAAcC,oBAAoB,EAClCC,QAAAA,EACM;IACN,IAAIF,YAAA,GAAwCC,oBAAA,IAAwB,CAAC;IACrE,KAAK,MAAME,IAAA,IAAQD,QAAA,CAAU;QAC3B,IAAI,cAAcC,IAAA,EAAM;YACtBH,YAAA,GAAe,MAAMF,iBAAA,CAAkB;gBACrCC,OAAA;gBACAC,YAAA;gBACAE,QAAA,EAAUC,IAAA,CAAKC,QAAAA;YACjB;QACF;QAEA,IAAID,IAAA,CAAKE,IAAI,KAAK,WAAWF,IAAA,CAAKE,IAAI,KAAK,eAAe;YACxD,MAAMC,SAAA,GAAYH,IAAA;YAClB,MAAMI,EAAA,GAAKD,SAAA,EAAWE,MAAA,EAAQD,EAAA;YAC9B,IAAI,CAACA,EAAA,EAAI;gBACP;YACF;YAEA,MAAME,gBAAA,GACJN,IAAA,CAAKE,IAAI,KAAK,UACV,GAAGN,OAAA,CAAQW,sBAAsB,CAAA,gDAAA,EAAmDJ,SAAA,CAAUE,MAAM,CAACG,SAAS,CAAA,OAAA,CAAS,GACvH,GAAGZ,OAAA,CAAQW,sBAAsB,CAAA,uDAAA,EAA0DJ,SAAA,CAAUE,MAAM,CAACG,SAAS,CAAA,OAAA,CAAS;YAEpI,iCAAA;YAEA,MAAMC,eAAA,GAAkB,UAAMf,+aAAA,EAAwB;gBACpDU,EAAA,EAAIR,OAAA,CAAQQ,EAAE;gBACdM,oBAAA,EAAsBd,OAAA,CAAQc,oBAAoB;gBAClDC,cAAA,EAAgBf,OAAA,CAAQe,cAAc;gBACtCC,IAAA,EAAMT,SAAA,CAAUE,MAAM;gBACtBQ,YAAA,EAAcjB,OAAA,CAAQiB,YAAY;gBAClCR,MAAA,EAAST,OAAA,CAAQkB,cAAc,CAACC,GAAG,CAACT,gBAAA,GAA2BD,MAAA;gBAC/DS,cAAA,EAAgBlB,OAAA,CAAQkB,cAAc;gBACtCE,gBAAA,EAAkBb,SAAA,CAAUE,MAAM;gBAClCY,SAAA,EAAWrB,OAAA,CAAQqB,SAAS;gBAC5BC,WAAA,EAAa;gBACbC,WAAA,EAAavB,OAAA,CAAQuB,WAAW;gBAChCC,QAAA,EAAUxB,OAAA,CAAQyB,QAAQ;gBAC1BC,eAAA,EAAiB;gBACjBC,aAAA,EAAe3B,OAAA,CAAQ2B,aAAa;gBACpCC,GAAA,EAAK5B,OAAA,CAAQ4B,GAAG;gBAChBC,UAAA,EAAYnB;YACd;YAEA,IAAI,CAACT,YAAY,CAACO,EAAA,CAAG,EAAE;gBACrBP,YAAY,CAACO,EAAA,CAAG,GAAG,CAAC;YACtB;YAEAP,YAAY,CAACO,EAAA,CAAG,CAACsB,SAAS,GAAGjB,eAAA;YAE7B,IAAIT,IAAA,CAAKE,IAAI,KAAK,SAAS;gBACzB,MAAMyB,uBAAA,GAA0B/B,OAAA,CAAQuB,WAAW,EAAEd,MAAA,EAAA,CAAST,OAAA,CAAQgC,KAAK,CAACC,IAAI,CAAC;gBACjF,MAAMC,cAAA,GAAiBH,uBAAA,EAAyBI,SAAA;gBAChD,IAAIC,KAAA,CAAMC,OAAO,CAACH,cAAA,KAAmBA,cAAA,CAAeI,QAAQ,CAAC9B,EAAA,GAAK;oBAChEP,YAAY,CAACO,EAAA,CAAG,CAAC2B,SAAS,GAAG;gBAC/B;YACF;QACF;IACF;IACA,OAAOlC,YAAA;AACT","ignoreList":[]}},
    {"offset": {"line": 7908, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/utilities/initLexicalFeatures.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/utilities/initLexicalFeatures.ts"],"sourcesContent":["import type { I18nClient } from '@payloadcms/translations'\n\nimport { type ClientFieldSchemaMap, type FieldSchemaMap, type Payload } from 'payload'\nimport { getFromImportMap } from 'payload/shared'\n\nimport type {\n  BaseClientFeatureProps,\n  FeatureProviderProviderClient,\n} from '../features/typesClient.js'\nimport type { SanitizedServerEditorConfig } from '../lexical/config/types.js'\nimport type { FeatureClientSchemaMap, LexicalRichTextFieldProps } from '../types.js'\ntype Args = {\n  clientFieldSchemaMap: ClientFieldSchemaMap\n  fieldSchemaMap: FieldSchemaMap\n  i18n: I18nClient\n  path: string\n  payload: Payload\n  sanitizedEditorConfig: SanitizedServerEditorConfig\n  schemaPath: string\n}\n\nexport function initLexicalFeatures(args: Args): {\n  clientFeatures: LexicalRichTextFieldProps['clientFeatures']\n  featureClientImportMap: Record<string, any>\n  featureClientSchemaMap: FeatureClientSchemaMap\n} {\n  const clientFeatures: LexicalRichTextFieldProps['clientFeatures'] = {}\n\n  // turn args.resolvedFeatureMap into an array of [key, value] pairs, ordered by value.order, lowest order first:\n  const resolvedFeatureMapArray = [...args.sanitizedEditorConfig.resolvedFeatureMap].sort(\n    (a, b) => a[1].order - b[1].order,\n  )\n\n  const featureClientSchemaMap: FeatureClientSchemaMap = {}\n\n  /**\n   * All modules added to the import map, keyed by the provided key, if feature.componentImports with type object is used\n   */\n  const featureClientImportMap: Record<string, any> | undefined = {}\n\n  for (const [featureKey, resolvedFeature] of resolvedFeatureMapArray) {\n    clientFeatures[featureKey] = {}\n\n    /**\n     * Handle client features\n     */\n    const ClientFeaturePayloadComponent = resolvedFeature.ClientFeature\n\n    if (ClientFeaturePayloadComponent) {\n      const clientFeatureProvider = getFromImportMap<FeatureProviderProviderClient>({\n        importMap: args.payload.importMap,\n        PayloadComponent: ClientFeaturePayloadComponent,\n        schemaPath: 'lexical-clientComponent',\n        silent: true,\n      })\n\n      if (!clientFeatureProvider) {\n        continue\n      }\n\n      const clientFeatureProps: BaseClientFeatureProps<Record<string, any>> =\n        resolvedFeature.clientFeatureProps ?? {}\n      clientFeatureProps.featureKey = resolvedFeature.key\n      clientFeatureProps.order = resolvedFeature.order\n      if (\n        typeof ClientFeaturePayloadComponent === 'object' &&\n        ClientFeaturePayloadComponent.clientProps\n      ) {\n        clientFeatureProps.clientProps = ClientFeaturePayloadComponent.clientProps\n      }\n      // As clientFeatureProvider is a client function, we cannot execute it on the server here. Thus, the client will have to execute clientFeatureProvider with its props\n      clientFeatures[featureKey] = { clientFeatureProps, clientFeatureProvider }\n    }\n\n    /**\n     * Handle sub-fields (formstate of those)\n     */\n    // The args.fieldSchemaMap generated before in buildFormState should contain all of lexical features' sub-field schemas\n    // as well, as it already called feature.generateSchemaMap for each feature.\n    // We will check for the existance resolvedFeature.generateSchemaMap to skip unnecessary loops for constructing featureSchemaMap, but we don't run it here\n    if (resolvedFeature.generateSchemaMap) {\n      const featureSchemaPath = `${args.schemaPath}.lexical_internal_feature.${featureKey}`\n\n      featureClientSchemaMap[featureKey] = {}\n\n      // Like args.fieldSchemaMap, we only want to include the sub-fields of the current feature\n      for (const [key, entry] of args.clientFieldSchemaMap.entries()) {\n        if (key.startsWith(featureSchemaPath)) {\n          featureClientSchemaMap[featureKey][key] = 'fields' in entry ? entry.fields : [entry]\n        }\n      }\n    }\n\n    if (\n      resolvedFeature.componentImports &&\n      typeof resolvedFeature.componentImports === 'object' &&\n      !Array.isArray(resolvedFeature.componentImports)\n    ) {\n      for (const [key, payloadComponent] of Object.entries(resolvedFeature.componentImports)) {\n        const resolvedComponent = getFromImportMap({\n          importMap: args.payload.importMap,\n          PayloadComponent: payloadComponent,\n          schemaPath: 'lexical-clientComponent',\n          silent: true,\n        })\n\n        featureClientImportMap[`${resolvedFeature.key}.${key}`] = resolvedComponent\n      }\n    }\n  }\n  return {\n    clientFeatures,\n    featureClientImportMap,\n    featureClientSchemaMap,\n  }\n}\n"],"names":["getFromImportMap","initLexicalFeatures","args","clientFeatures","resolvedFeatureMapArray","sanitizedEditorConfig","resolvedFeatureMap","sort","a","b","order","featureClientSchemaMap","featureClientImportMap","featureKey","resolvedFeature","ClientFeaturePayloadComponent","ClientFeature","clientFeatureProvider","importMap","payload","PayloadComponent","schemaPath","silent","clientFeatureProps","key","clientProps","generateSchemaMap","featureSchemaPath","entry","clientFieldSchemaMap","entries","startsWith","fields","componentImports","Array","isArray","payloadComponent","Object","resolvedComponent"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 7990, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/field/rscEntry.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/field/rscEntry.tsx"],"sourcesContent":["import type { SerializedLexicalNode } from 'lexical'\nimport type {\n  ClientComponentProps,\n  FieldPaths,\n  RichTextFieldClient,\n  RichTextField as RichTextFieldType,\n  ServerComponentProps,\n} from 'payload'\n\nimport { getTranslation } from '@payloadcms/translations'\nimport { renderField } from '@payloadcms/ui/forms/renderField'\nimport React from 'react'\n\nimport type { SanitizedServerEditorConfig } from '../lexical/config/types.js'\nimport type {\n  LexicalEditorProps,\n  LexicalFieldAdminClientProps,\n  LexicalRichTextFieldProps,\n} from '../types.js'\n\n// eslint-disable-next-line payload/no-imports-from-exports-dir\nimport { RichTextField } from '../exports/client/index.js'\nimport { buildInitialState } from '../utilities/buildInitialState.js'\nimport { initLexicalFeatures } from '../utilities/initLexicalFeatures.js'\n\nexport const RscEntryLexicalField: React.FC<\n  {\n    sanitizedEditorConfig: SanitizedServerEditorConfig\n  } & ClientComponentProps &\n    Pick<FieldPaths, 'path'> &\n    Pick<LexicalEditorProps, 'admin'> &\n    ServerComponentProps\n> = async (args) => {\n  const field: RichTextFieldType = args.field as RichTextFieldType\n  const path = args.path ?? (args.clientField as RichTextFieldClient).name\n  const schemaPath = args.schemaPath ?? path\n\n  const disabled = args?.readOnly || field?.admin?.readOnly\n\n  if (!(args?.clientField as RichTextFieldClient)?.name) {\n    throw new Error('Initialized lexical RSC field without a field name')\n  }\n\n  const { clientFeatures, featureClientImportMap, featureClientSchemaMap } = initLexicalFeatures({\n    clientFieldSchemaMap: args.clientFieldSchemaMap,\n    fieldSchemaMap: args.fieldSchemaMap,\n    i18n: args.i18n,\n    path,\n    payload: args.payload,\n    sanitizedEditorConfig: args.sanitizedEditorConfig,\n    schemaPath,\n  })\n\n  let initialLexicalFormState = {}\n  if (args.siblingData?.[field.name]?.root?.children?.length) {\n    initialLexicalFormState = await buildInitialState({\n      context: {\n        id: args.id,\n        clientFieldSchemaMap: args.clientFieldSchemaMap,\n        collectionSlug: args.collectionSlug,\n        disabled,\n        documentData: args.data,\n        field,\n        fieldSchemaMap: args.fieldSchemaMap,\n        lexicalFieldSchemaPath: schemaPath,\n        operation: args.operation,\n        permissions: args.permissions,\n        preferences: args.preferences,\n        renderFieldFn: renderField,\n        req: args.req,\n      },\n      nodeData: args.siblingData?.[field.name]?.root?.children as SerializedLexicalNode[],\n    })\n  }\n\n  const placeholderFromArgs = args.admin?.placeholder\n  const placeholder = placeholderFromArgs\n    ? getTranslation(placeholderFromArgs, args.i18n)\n    : undefined\n\n  const admin: LexicalFieldAdminClientProps = {}\n  if (placeholder) {\n    admin.placeholder = placeholder\n  }\n  if (args.admin?.hideGutter) {\n    admin.hideGutter = true\n  }\n  if (args.admin?.hideInsertParagraphAtEnd) {\n    admin.hideInsertParagraphAtEnd = true\n  }\n  if (args.admin?.hideAddBlockButton) {\n    admin.hideAddBlockButton = true\n  }\n  if (args.admin?.hideDraggableBlockElement) {\n    admin.hideDraggableBlockElement = true\n  }\n\n  const props: LexicalRichTextFieldProps = {\n    clientFeatures,\n    featureClientSchemaMap, // TODO: Does client need this? Why cant this just live in the server\n    field: args.clientField as RichTextFieldClient,\n    forceRender: args.forceRender,\n    initialLexicalFormState,\n    lexicalEditorConfig: args.sanitizedEditorConfig.lexical,\n    path,\n    permissions: args.permissions,\n    readOnly: args.readOnly,\n    renderedBlocks: args.renderedBlocks,\n    schemaPath,\n  }\n  if (Object.keys(admin).length) {\n    props.admin = admin\n  }\n  if (Object.keys(featureClientImportMap).length) {\n    props.featureClientImportMap = featureClientImportMap\n  }\n\n  for (const key in props) {\n    if (props[key as keyof LexicalRichTextFieldProps] === undefined) {\n      delete props[key as keyof LexicalRichTextFieldProps]\n    }\n  }\n\n  return <RichTextField {...props} />\n}\n"],"names":["getTranslation","renderField","React","RichTextField","buildInitialState","initLexicalFeatures","RscEntryLexicalField","args","field","path","clientField","name","schemaPath","disabled","readOnly","admin","Error","clientFeatures","featureClientImportMap","featureClientSchemaMap","clientFieldSchemaMap","fieldSchemaMap","i18n","payload","sanitizedEditorConfig","initialLexicalFormState","siblingData","root","children","length","context","id","collectionSlug","documentData","data","lexicalFieldSchemaPath","operation","permissions","preferences","renderFieldFn","req","nodeData","placeholderFromArgs","placeholder","undefined","hideGutter","hideInsertParagraphAtEnd","hideAddBlockButton","hideDraggableBlockElement","props","forceRender","lexicalEditorConfig","lexical","renderedBlocks","Object","keys","key","_jsx"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 8097, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/converters/lexicalToHtml/shared/findConverterForNode.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToHtml/shared/findConverterForNode.ts"],"sourcesContent":["/* eslint-disable no-console */\nimport type { SerializedLexicalNode } from 'lexical'\n\nimport type { SerializedBlockNode, SerializedInlineBlockNode } from '../../../../nodeTypes.js'\nimport type { HTMLConverterAsync, HTMLConvertersAsync } from '../async/types.js'\nimport type { HTMLConverter, HTMLConverters } from '../sync/types.js'\nimport type { ProvidedCSS } from './types.js'\n\nexport function findConverterForNode<\n  TConverters extends HTMLConverters | HTMLConvertersAsync,\n  TConverter extends HTMLConverter | HTMLConverterAsync,\n>({\n  converters,\n  disableIndent,\n  disableTextAlign,\n  node,\n  unknownConverter,\n}: {\n  converters: TConverters\n  disableIndent?: boolean | string[]\n  disableTextAlign?: boolean | string[]\n  node: SerializedLexicalNode\n  unknownConverter: TConverter\n}): {\n  converterForNode: TConverter | undefined\n  providedCSSString: string\n  providedStyleTag: string\n} {\n  let converterForNode: TConverter | undefined\n  if (node.type === 'block') {\n    converterForNode = converters?.blocks?.[\n      (node as SerializedBlockNode)?.fields?.blockType\n    ] as TConverter\n    if (!converterForNode && !unknownConverter) {\n      console.error(\n        `Lexical => HTML converter: Blocks converter: found ${(node as SerializedBlockNode)?.fields?.blockType} block, but no converter is provided`,\n      )\n    }\n  } else if (node.type === 'inlineBlock') {\n    converterForNode = converters?.inlineBlocks?.[\n      (node as SerializedInlineBlockNode)?.fields?.blockType\n    ] as TConverter\n    if (!converterForNode && !unknownConverter) {\n      console.error(\n        `Lexical => HTML converter: Inline Blocks converter: found ${(node as SerializedInlineBlockNode)?.fields?.blockType} inline block, but no converter is provided`,\n      )\n    }\n  } else {\n    converterForNode = converters[node.type] as TConverter\n  }\n\n  const style: ProvidedCSS = {}\n\n  // Check if disableTextAlign is not true and does not include node type\n  if (\n    !disableTextAlign &&\n    (!Array.isArray(disableTextAlign) || !disableTextAlign?.includes(node.type))\n  ) {\n    if ('format' in node && node.format) {\n      switch (node.format) {\n        case 'center':\n          style['text-align'] = 'center'\n          break\n        case 'end':\n          style['text-align'] = 'right'\n          break\n        case 'justify':\n          style['text-align'] = 'justify'\n          break\n        case 'left':\n          //style['text-align'] = 'left'\n          // Do nothing, as left is the default\n          break\n        case 'right':\n          style['text-align'] = 'right'\n          break\n        case 'start':\n          style['text-align'] = 'left'\n          break\n      }\n    }\n  }\n\n  if (!disableIndent && (!Array.isArray(disableIndent) || !disableIndent?.includes(node.type))) {\n    if ('indent' in node && node.indent && node.type !== 'listitem') {\n      // the unit should be px. Do not change it to rem, em, or something else.\n      // The quantity should be 40px. Do not change it either.\n      // See rationale in\n      // https://github.com/payloadcms/payload/issues/13130#issuecomment-3058348085\n      style['padding-inline-start'] = `${Number(node.indent) * 40}px`\n    }\n  }\n\n  let providedCSSString: string = ''\n  for (const key of Object.keys(style)) {\n    // @ts-expect-error we're iterating over the keys of the object\n    providedCSSString += `${key}: ${style[key]};`\n  }\n  const providedStyleTag = providedCSSString?.length ? ` style=\"${providedCSSString}\"` : ''\n\n  return {\n    converterForNode: converterForNode ?? unknownConverter,\n    providedCSSString,\n    providedStyleTag,\n  }\n}\n"],"names":["findConverterForNode","converters","disableIndent","disableTextAlign","node","unknownConverter","converterForNode","type","blocks","fields","blockType","console","error","inlineBlocks","style","Array","isArray","includes","format","indent","Number","providedCSSString","key","Object","keys","providedStyleTag","length"],"mappings":"AAAA,6BAAA,EAQA;;;;AAAO,SAASA,qBAGd,EACAC,UAAU,EACVC,aAAa,EACbC,gBAAgB,EAChBC,IAAI,EACJC,gBAAAA,EAOD;IAKC,IAAIC,gBAAA;IACJ,IAAIF,IAAA,CAAKG,IAAI,KAAK,SAAS;QACzBD,gBAAA,GAAmBL,UAAA,EAAYO,MAAA,EAAA,CAC5BJ,IAAA,EAA8BK,MAAA,EAAQC,SAAA,CACxC;QACD,IAAI,CAACJ,gBAAA,IAAoB,CAACD,gBAAA,EAAkB;YAC1CM,OAAA,CAAQC,KAAK,CACX,CAAA,mDAAA,EAAuDR,IAAA,EAA8BK,MAAA,EAAQC,SAAA,CAAA,oCAAA,CAA+C;QAEhJ;IACF,OAAO,IAAIN,IAAA,CAAKG,IAAI,KAAK,eAAe;QACtCD,gBAAA,GAAmBL,UAAA,EAAYY,YAAA,EAAA,CAC5BT,IAAA,EAAoCK,MAAA,EAAQC,SAAA,CAC9C;QACD,IAAI,CAACJ,gBAAA,IAAoB,CAACD,gBAAA,EAAkB;YAC1CM,OAAA,CAAQC,KAAK,CACX,CAAA,0DAAA,EAA8DR,IAAA,EAAoCK,MAAA,EAAQC,SAAA,CAAA,2CAAA,CAAsD;QAEpK;IACF,OAAO;QACLJ,gBAAA,GAAmBL,UAAU,CAACG,IAAA,CAAKG,IAAI,CAAC;IAC1C;IAEA,MAAMO,KAAA,GAAqB,CAAC;IAE5B,uEAAA;IACA,IACE,CAACX,gBAAA,IAAA,CACA,CAACY,KAAA,CAAMC,OAAO,CAACb,gBAAA,KAAqB,CAACA,gBAAA,EAAkBc,QAAA,CAASb,IAAA,CAAKG,IAAI,CAAA,GAC1E;QACA,IAAI,YAAYH,IAAA,IAAQA,IAAA,CAAKc,MAAM,EAAE;YACnC,OAAQd,IAAA,CAAKc,MAAM;gBACjB,KAAK;oBACHJ,KAAK,CAAC,aAAa,GAAG;oBACtB;gBACF,KAAK;oBACHA,KAAK,CAAC,aAAa,GAAG;oBACtB;gBACF,KAAK;oBACHA,KAAK,CAAC,aAAa,GAAG;oBACtB;gBACF,KAAK;oBAGH;gBACF,KAAK;oBACHA,KAAK,CAAC,aAAa,GAAG;oBACtB;gBACF,KAAK;oBACHA,KAAK,CAAC,aAAa,GAAG;oBACtB;YACJ;QACF;IACF;IAEA,IAAI,CAACZ,aAAA,IAAA,CAAkB,CAACa,KAAA,CAAMC,OAAO,CAACd,aAAA,KAAkB,CAACA,aAAA,EAAee,QAAA,CAASb,IAAA,CAAKG,IAAI,CAAA,GAAI;QAC5F,IAAI,YAAYH,IAAA,IAAQA,IAAA,CAAKe,MAAM,IAAIf,IAAA,CAAKG,IAAI,KAAK,YAAY;YAC/D,yEAAA;YACA,wDAAA;YACA,mBAAA;YACA,6EAAA;YACAO,KAAK,CAAC,uBAAuB,GAAG,GAAGM,MAAA,CAAOhB,IAAA,CAAKe,MAAM,IAAI,GAAA,EAAA,CAAM;QACjE;IACF;IAEA,IAAIE,iBAAA,GAA4B;IAChC,KAAK,MAAMC,GAAA,IAAOC,MAAA,CAAOC,IAAI,CAACV,KAAA,EAAQ;QACpC,+DAAA;QACAO,iBAAA,IAAqB,GAAGC,GAAA,CAAA,EAAA,EAAQR,KAAK,CAACQ,GAAA,CAAI,CAAA,CAAA,CAAG;IAC/C;IACA,MAAMG,gBAAA,GAAmBJ,iBAAA,EAAmBK,MAAA,GAAS,CAAA,QAAA,EAAWL,iBAAA,CAAA,CAAA,CAAoB,GAAG;IAEvF,OAAO;QACLf,gBAAA,EAAkBA,gBAAA,IAAoBD,gBAAA;QACtCgB,iBAAA;QACAI;IACF;AACF","ignoreList":[]}},
    {"offset": {"line": 8166, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/converters/lexicalToHtml/async/converters/blockquote.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToHtml/async/converters/blockquote.ts"],"sourcesContent":["import type { SerializedQuoteNode } from '../../../../../nodeTypes.js'\nimport type { HTMLConvertersAsync } from '../types.js'\n\nexport const BlockquoteHTMLConverterAsync: HTMLConvertersAsync<SerializedQuoteNode> = {\n  quote: async ({ node, nodesToHTML, providedStyleTag }) => {\n    const children = (\n      await nodesToHTML({\n        nodes: node.children,\n      })\n    ).join('')\n\n    return `<blockquote${providedStyleTag}>${children}</blockquote>`\n  },\n}\n"],"names":["BlockquoteHTMLConverterAsync","quote","node","nodesToHTML","providedStyleTag","children","nodes","join"],"mappings":";;;;AAGO,MAAMA,4BAAA,GAAyE;IACpFC,KAAA,EAAO,MAAAA,CAAO,EAAEC,IAAI,EAAEC,WAAW,EAAEC,gBAAAA,EAAkB;QACnD,MAAMC,QAAA,GAAW,CACf,MAAMF,WAAA,CAAY;YAChBG,KAAA,EAAOJ,IAAA,CAAKG,QAAAA;QACd,EAAC,EACDE,IAAI,CAAC;QAEP,OAAO,CAAA,WAAA,EAAcH,gBAAA,CAAA,CAAA,EAAoBC,QAAA,CAAA,aAAA,CAAuB;IAClE;AACF","ignoreList":[]}},
    {"offset": {"line": 8182, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/converters/lexicalToHtml/async/converters/heading.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToHtml/async/converters/heading.ts"],"sourcesContent":["import type { SerializedHeadingNode } from '../../../../../nodeTypes.js'\nimport type { HTMLConvertersAsync } from '../types.js'\n\nexport const HeadingHTMLConverterAsync: HTMLConvertersAsync<SerializedHeadingNode> = {\n  heading: async ({ node, nodesToHTML, providedStyleTag }) => {\n    const children = (\n      await nodesToHTML({\n        nodes: node.children,\n      })\n    ).join('')\n\n    return `<${node.tag}${providedStyleTag}>${children}</${node.tag}>`\n  },\n}\n"],"names":["HeadingHTMLConverterAsync","heading","node","nodesToHTML","providedStyleTag","children","nodes","join","tag"],"mappings":";;;;AAGO,MAAMA,yBAAA,GAAwE;IACnFC,OAAA,EAAS,MAAAA,CAAO,EAAEC,IAAI,EAAEC,WAAW,EAAEC,gBAAAA,EAAkB;QACrD,MAAMC,QAAA,GAAW,CACf,MAAMF,WAAA,CAAY;YAChBG,KAAA,EAAOJ,IAAA,CAAKG,QAAAA;QACd,EAAC,EACDE,IAAI,CAAC;QAEP,OAAO,CAAA,CAAA,EAAIL,IAAA,CAAKM,GAAG,GAAGJ,gBAAA,CAAA,CAAA,EAAoBC,QAAA,CAAA,EAAA,EAAaH,IAAA,CAAKM,GAAG,CAAA,CAAA,CAAG;IACpE;AACF","ignoreList":[]}},
    {"offset": {"line": 8198, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/converters/lexicalToHtml/async/converters/horizontalRule.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToHtml/async/converters/horizontalRule.ts"],"sourcesContent":["import type { SerializedHorizontalRuleNode } from '../../../../../nodeTypes.js'\nimport type { HTMLConvertersAsync } from '../types.js'\nexport const HorizontalRuleHTMLConverterAsync: HTMLConvertersAsync<SerializedHorizontalRuleNode> = {\n  horizontalrule: '<hr />',\n}\n"],"names":["HorizontalRuleHTMLConverterAsync","horizontalrule"],"mappings":";;;;AAEO,MAAMA,gCAAA,GAAsF;IACjGC,cAAA,EAAgB;AAClB","ignoreList":[]}},
    {"offset": {"line": 8209, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/converters/lexicalToHtml/async/converters/linebreak.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToHtml/async/converters/linebreak.ts"],"sourcesContent":["import type { SerializedLineBreakNode } from '../../../../../nodeTypes.js'\nimport type { HTMLConvertersAsync } from '../types.js'\n\nexport const LinebreakHTMLConverterAsync: HTMLConvertersAsync<SerializedLineBreakNode> = {\n  linebreak: '<br />',\n}\n"],"names":["LinebreakHTMLConverterAsync","linebreak"],"mappings":";;;;AAGO,MAAMA,2BAAA,GAA4E;IACvFC,SAAA,EAAW;AACb","ignoreList":[]}},
    {"offset": {"line": 8220, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/converters/lexicalToHtml/async/converters/link.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToHtml/async/converters/link.ts"],"sourcesContent":["import type { SerializedAutoLinkNode, SerializedLinkNode } from '../../../../../nodeTypes.js'\nimport type { HTMLConvertersAsync, HTMLPopulateFn } from '../types.js'\n\nexport const LinkHTMLConverterAsync: (args: {\n  internalDocToHref?: (args: {\n    linkNode: SerializedLinkNode\n    populate?: HTMLPopulateFn\n  }) => Promise<string> | string\n}) => HTMLConvertersAsync<SerializedAutoLinkNode | SerializedLinkNode> = ({\n  internalDocToHref,\n}) => ({\n  autolink: async ({ node, nodesToHTML, providedStyleTag }) => {\n    const children = (\n      await nodesToHTML({\n        nodes: node.children,\n      })\n    ).join('')\n\n    return `<a${providedStyleTag} href=\"${node.fields.url}\"${node.fields.newTab ? ' rel=\"noopener noreferrer\" target=\"_blank\"' : ''}>${children}</a>`\n  },\n  link: async ({ node, nodesToHTML, populate, providedStyleTag }) => {\n    const children = (\n      await nodesToHTML({\n        nodes: node.children,\n      })\n    ).join('')\n\n    let href: string = node.fields.url ?? ''\n    if (node.fields.linkType === 'internal') {\n      if (internalDocToHref) {\n        href = await internalDocToHref({ linkNode: node, populate })\n      } else {\n        console.error(\n          'Lexical => HTML converter: Link converter: found internal link, but internalDocToHref is not provided',\n        )\n        href = '#' // fallback\n      }\n    }\n\n    return `<a${providedStyleTag} href=\"${href}\"${node.fields.newTab ? ' rel=\"noopener noreferrer\" target=\"_blank\"' : ''}>${children}</a>`\n  },\n})\n"],"names":["LinkHTMLConverterAsync","internalDocToHref","autolink","node","nodesToHTML","providedStyleTag","children","nodes","join","fields","url","newTab","link","populate","href","linkType","linkNode","console","error"],"mappings":";;;;AAGO,MAAMA,sBAAA,GAK4DA,CAAC,EACxEC,iBAAAA,EACD,GAAA,CAAM;QACLC,QAAA,EAAU,MAAAA,CAAO,EAAEC,IAAI,EAAEC,WAAW,EAAEC,gBAAAA,EAAkB;YACtD,MAAMC,QAAA,GAAW,CACf,MAAMF,WAAA,CAAY;gBAChBG,KAAA,EAAOJ,IAAA,CAAKG,QAAAA;YACd,EAAC,EACDE,IAAI,CAAC;YAEP,OAAO,CAAA,EAAA,EAAKH,gBAAA,CAAA,OAAA,EAA0BF,IAAA,CAAKM,MAAM,CAACC,GAAG,CAAA,CAAA,EAAIP,IAAA,CAAKM,MAAM,CAACE,MAAM,GAAG,+CAA+C,GAAA,CAAA,EAAML,QAAA,CAAA,IAAA,CAAc;QACnJ;QACAM,IAAA,EAAM,MAAAA,CAAO,EAAET,IAAI,EAAEC,WAAW,EAAES,QAAQ,EAAER,gBAAAA,EAAkB;YAC5D,MAAMC,QAAA,GAAW,CACf,MAAMF,WAAA,CAAY;gBAChBG,KAAA,EAAOJ,IAAA,CAAKG,QAAAA;YACd,EAAC,EACDE,IAAI,CAAC;YAEP,IAAIM,IAAA,GAAeX,IAAA,CAAKM,MAAM,CAACC,GAAG,IAAI;YACtC,IAAIP,IAAA,CAAKM,MAAM,CAACM,QAAQ,KAAK,YAAY;gBACvC,IAAId,iBAAA,EAAmB;oBACrBa,IAAA,GAAO,MAAMb,iBAAA,CAAkB;wBAAEe,QAAA,EAAUb,IAAA;wBAAMU;oBAAS;gBAC5D,OAAO;oBACLI,OAAA,CAAQC,KAAK,CACX;oBAEFJ,IAAA,GAAO,IAAI,WAAA;;gBACb;YACF;YAEA,OAAO,CAAA,EAAA,EAAKT,gBAAA,CAAA,OAAA,EAA0BS,IAAA,CAAA,CAAA,EAAQX,IAAA,CAAKM,MAAM,CAACE,MAAM,GAAG,+CAA+C,GAAA,CAAA,EAAML,QAAA,CAAA,IAAA,CAAc;QACxI;IACF,CAAA","ignoreList":[]}},
    {"offset": {"line": 8255, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/converters/lexicalToHtml/async/converters/list.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToHtml/async/converters/list.ts"],"sourcesContent":["import { v4 as uuidv4 } from 'uuid'\n\nimport type { SerializedListItemNode, SerializedListNode } from '../../../../../nodeTypes.js'\nimport type { HTMLConvertersAsync } from '../types.js'\n\nexport const ListHTMLConverterAsync: HTMLConvertersAsync<\n  SerializedListItemNode | SerializedListNode\n> = {\n  list: async ({ node, nodesToHTML, providedStyleTag }) => {\n    const children = (\n      await nodesToHTML({\n        nodes: node.children,\n      })\n    ).join('')\n\n    return `<${node.tag}${providedStyleTag} class=\"list-${node.listType}\">${children}</${node.tag}>`\n  },\n  listitem: async ({ node, nodesToHTML, parent, providedCSSString }) => {\n    const hasSubLists = node.children.some((child) => child.type === 'list')\n\n    const children = (\n      await nodesToHTML({\n        nodes: node.children,\n      })\n    ).join('')\n\n    if ('listType' in parent && parent?.listType === 'check') {\n      const uuid = uuidv4()\n      return `<li\n          aria-checked=\"${node.checked ? 'true' : 'false'}\"\n          class=\"list-item-checkbox${node.checked ? ' list-item-checkbox-checked' : ' list-item-checkbox-unchecked'}${hasSubLists ? ' nestedListItem' : ''}\"\n          role=\"checkbox\"\n          style=\"list-style-type: none;${providedCSSString}\"\n          tabIndex=\"-1\"\n          value=\"${node.value}\"\n        >\n          ${\n            hasSubLists\n              ? children\n              : `<input${node.checked ? ' checked' : ''} id=\"${uuid}\" readOnly=\"true\" type=\"checkbox\" />\n            <label htmlFor=\"${uuid}\">${children}</label>\n            <br />`\n          }\n        </li>`\n    } else {\n      return `<li\n          class=\"${hasSubLists ? 'nestedListItem' : ''}\"\n          style=\"${hasSubLists ? `list-style-type: none;${providedCSSString}` : providedCSSString}\"\n          value=\"${node.value}\"\n        >${children}</li>`\n    }\n  },\n}\n"],"names":["v4","uuidv4","ListHTMLConverterAsync","list","node","nodesToHTML","providedStyleTag","children","nodes","join","tag","listType","listitem","parent","providedCSSString","hasSubLists","some","child","type","uuid","checked","value"],"mappings":";;;;AAAA,SAASA,EAAA,IAAMC,MAAM,QAAQ;;AAKtB,MAAMC,sBAAA,GAET;IACFC,IAAA,EAAM,MAAAA,CAAO,EAAEC,IAAI,EAAEC,WAAW,EAAEC,gBAAAA,EAAkB;QAClD,MAAMC,QAAA,GAAW,CACf,MAAMF,WAAA,CAAY;YAChBG,KAAA,EAAOJ,IAAA,CAAKG,QAAAA;QACd,EAAC,EACDE,IAAI,CAAC;QAEP,OAAO,CAAA,CAAA,EAAIL,IAAA,CAAKM,GAAG,GAAGJ,gBAAA,CAAA,aAAA,EAAgCF,IAAA,CAAKO,QAAQ,CAAA,EAAA,EAAKJ,QAAA,CAAA,EAAA,EAAaH,IAAA,CAAKM,GAAG,CAAA,CAAA,CAAG;IAClG;IACAE,QAAA,EAAU,MAAAA,CAAO,EAAER,IAAI,EAAEC,WAAW,EAAEQ,MAAM,EAAEC,iBAAAA,EAAmB;QAC/D,MAAMC,WAAA,GAAcX,IAAA,CAAKG,QAAQ,CAACS,IAAI,EAAEC,KAAA,GAAUA,KAAA,CAAMC,IAAI,KAAK;QAEjE,MAAMX,QAAA,GAAW,CACf,MAAMF,WAAA,CAAY;YAChBG,KAAA,EAAOJ,IAAA,CAAKG,QAAAA;QACd,EAAC,EACDE,IAAI,CAAC;QAEP,IAAI,cAAcI,MAAA,IAAUA,MAAA,EAAQF,QAAA,KAAa,SAAS;YACxD,MAAMQ,IAAA,OAAOlB,0OAAA;YACb,OAAO,CAAA;0BACaG,IAAA,CAAKgB,OAAO,GAAG,SAAS,QAAA;qCACbhB,IAAA,CAAKgB,OAAO,GAAG,gCAAgC,kCAAkCL,WAAA,GAAc,oBAAoB,GAAA;;yCAE/GD,iBAAA,CAAA;;mBAEtBV,IAAA,CAAKiB,KAAK,CAAA;;YAGjBN,WAAA,GACIR,QAAA,GACA,CAAA,MAAA,EAASH,IAAA,CAAKgB,OAAO,GAAG,aAAa,GAAA,KAAA,EAAUD,IAAA,CAAA;8BACjCA,IAAA,CAAA,EAAA,EAASZ,QAAA,CAAA;mBACpB,CAAA;cAEL;QACV,OAAO;YACL,OAAO,CAAA;mBACMQ,WAAA,GAAc,mBAAmB,GAAA;mBACjCA,WAAA,GAAc,CAAA,sBAAA,EAAyBD,iBAAA,EAAmB,GAAGA,iBAAA,CAAA;mBAC7DV,IAAA,CAAKiB,KAAK,CAAA;WAClBd,QAAA,CAAA,KAAA,CAAe;QACtB;IACF;AACF","ignoreList":[]}},
    {"offset": {"line": 8300, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/converters/lexicalToHtml/async/converters/paragraph.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToHtml/async/converters/paragraph.ts"],"sourcesContent":["import type { SerializedParagraphNode } from '../../../../../nodeTypes.js'\nimport type { HTMLConvertersAsync } from '../types.js'\n\nexport const ParagraphHTMLConverterAsync: HTMLConvertersAsync<SerializedParagraphNode> = {\n  paragraph: async ({ node, nodesToHTML, providedStyleTag }) => {\n    const children = await nodesToHTML({\n      nodes: node.children,\n    })\n\n    if (!children?.length) {\n      return `<p${providedStyleTag}><br /></p>`\n    }\n\n    return `<p${providedStyleTag}>${children.join('')}</p>`\n  },\n}\n"],"names":["ParagraphHTMLConverterAsync","paragraph","node","nodesToHTML","providedStyleTag","children","nodes","length","join"],"mappings":";;;;AAGO,MAAMA,2BAAA,GAA4E;IACvFC,SAAA,EAAW,MAAAA,CAAO,EAAEC,IAAI,EAAEC,WAAW,EAAEC,gBAAAA,EAAkB;QACvD,MAAMC,QAAA,GAAW,MAAMF,WAAA,CAAY;YACjCG,KAAA,EAAOJ,IAAA,CAAKG,QAAAA;QACd;QAEA,IAAI,CAACA,QAAA,EAAUE,MAAA,EAAQ;YACrB,OAAO,CAAA,EAAA,EAAKH,gBAAA,CAAA,WAAA,CAA6B;QAC3C;QAEA,OAAO,CAAA,EAAA,EAAKA,gBAAA,CAAA,CAAA,EAAoBC,QAAA,CAASG,IAAI,CAAC,IAAA,IAAA,CAAS;IACzD;AACF","ignoreList":[]}},
    {"offset": {"line": 8319, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/converters/lexicalToHtml/async/converters/tab.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToHtml/async/converters/tab.ts"],"sourcesContent":["import type { SerializedTabNode } from '../../../../../nodeTypes.js'\nimport type { HTMLConvertersAsync } from '../types.js'\n\nexport const TabHTMLConverterAsync: HTMLConvertersAsync<SerializedTabNode> = {\n  tab: '\\t',\n}\n"],"names":["TabHTMLConverterAsync","tab"],"mappings":";;;;AAGO,MAAMA,qBAAA,GAAgE;IAC3EC,GAAA,EAAK;AACP","ignoreList":[]}},
    {"offset": {"line": 8330, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/converters/lexicalToHtml/async/converters/table.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToHtml/async/converters/table.ts"],"sourcesContent":["import type {\n  SerializedTableCellNode,\n  SerializedTableNode,\n  SerializedTableRowNode,\n} from '../../../../../nodeTypes.js'\nimport type { HTMLConvertersAsync } from '../types.js'\n\nexport const TableHTMLConverterAsync: HTMLConvertersAsync<\n  SerializedTableCellNode | SerializedTableNode | SerializedTableRowNode\n> = {\n  table: async ({ node, nodesToHTML, providedStyleTag }) => {\n    const children = (\n      await nodesToHTML({\n        nodes: node.children,\n      })\n    ).join('')\n\n    return `<div${providedStyleTag} class=\"lexical-table-container\">\n        <table class=\"lexical-table\" style=\"border-collapse: collapse;\">\n          <tbody>${children}</tbody>\n        </table>\n      </div>`\n  },\n\n  tablecell: async ({ node, nodesToHTML, providedCSSString }) => {\n    const children = (\n      await nodesToHTML({\n        nodes: node.children,\n      })\n    ).join('')\n\n    const TagName = node.headerState > 0 ? 'th' : 'td'\n    const headerStateClass = `lexical-table-cell-header-${node.headerState}`\n\n    let style = 'border: 1px solid #ccc; padding: 8px;' + providedCSSString\n    if (node.backgroundColor) {\n      style += ` background-color: ${node.backgroundColor};`\n    }\n\n    const colSpanAttr = node.colSpan && node.colSpan > 1 ? ` colspan=\"${node.colSpan}\"` : ''\n    const rowSpanAttr = node.rowSpan && node.rowSpan > 1 ? ` rowspan=\"${node.rowSpan}\"` : ''\n\n    return `<${TagName}\n        class=\"lexical-table-cell ${headerStateClass}\"\n        ${colSpanAttr}\n        ${rowSpanAttr}\n        style=\"${style}\"\n      >\n        ${children}\n      </${TagName}>\n    `\n  },\n\n  tablerow: async ({ node, nodesToHTML, providedStyleTag }) => {\n    const children = (\n      await nodesToHTML({\n        nodes: node.children,\n      })\n    ).join('')\n\n    return `<tr${providedStyleTag} class=\"lexical-table-row\">\n        ${children}\n      </tr>`\n  },\n}\n"],"names":["TableHTMLConverterAsync","table","node","nodesToHTML","providedStyleTag","children","nodes","join","tablecell","providedCSSString","TagName","headerState","headerStateClass","style","backgroundColor","colSpanAttr","colSpan","rowSpanAttr","rowSpan","tablerow"],"mappings":";;;;AAOO,MAAMA,uBAAA,GAET;IACFC,KAAA,EAAO,MAAAA,CAAO,EAAEC,IAAI,EAAEC,WAAW,EAAEC,gBAAAA,EAAkB;QACnD,MAAMC,QAAA,GAAW,CACf,MAAMF,WAAA,CAAY;YAChBG,KAAA,EAAOJ,IAAA,CAAKG,QAAAA;QACd,EAAC,EACDE,IAAI,CAAC;QAEP,OAAO,CAAA,IAAA,EAAOH,gBAAA,CAAA;;mBAECC,QAAA,CAAA;;aAEN;IACX;IAEAG,SAAA,EAAW,MAAAA,CAAO,EAAEN,IAAI,EAAEC,WAAW,EAAEM,iBAAAA,EAAmB;QACxD,MAAMJ,QAAA,GAAW,CACf,MAAMF,WAAA,CAAY;YAChBG,KAAA,EAAOJ,IAAA,CAAKG,QAAAA;QACd,EAAC,EACDE,IAAI,CAAC;QAEP,MAAMG,OAAA,GAAUR,IAAA,CAAKS,WAAW,GAAG,IAAI,OAAO;QAC9C,MAAMC,gBAAA,GAAmB,CAAA,0BAAA,EAA6BV,IAAA,CAAKS,WAAW,EAAE;QAExE,IAAIE,KAAA,GAAQ,0CAA0CJ,iBAAA;QACtD,IAAIP,IAAA,CAAKY,eAAe,EAAE;YACxBD,KAAA,IAAS,CAAA,mBAAA,EAAsBX,IAAA,CAAKY,eAAe,CAAA,CAAA,CAAG;QACxD;QAEA,MAAMC,WAAA,GAAcb,IAAA,CAAKc,OAAO,IAAId,IAAA,CAAKc,OAAO,GAAG,IAAI,CAAA,UAAA,EAAad,IAAA,CAAKc,OAAO,CAAA,CAAA,CAAG,GAAG;QACtF,MAAMC,WAAA,GAAcf,IAAA,CAAKgB,OAAO,IAAIhB,IAAA,CAAKgB,OAAO,GAAG,IAAI,CAAA,UAAA,EAAahB,IAAA,CAAKgB,OAAO,CAAA,CAAA,CAAG,GAAG;QAEtF,OAAO,CAAA,CAAA,EAAIR,OAAA,CAAA;oCACqBE,gBAAA,CAAA;UAC1BG,WAAA,CAAA;UACAE,WAAA,CAAA;iBACOJ,KAAA,CAAA;;UAEPR,QAAA,CAAA;UACAK,OAAA,CAAA;KACL;IACH;IAEAS,QAAA,EAAU,MAAAA,CAAO,EAAEjB,IAAI,EAAEC,WAAW,EAAEC,gBAAAA,EAAkB;QACtD,MAAMC,QAAA,GAAW,CACf,MAAMF,WAAA,CAAY;YAChBG,KAAA,EAAOJ,IAAA,CAAKG,QAAAA;QACd,EAAC,EACDE,IAAI,CAAC;QAEP,OAAO,CAAA,GAAA,EAAMH,gBAAA,CAAA;UACPC,QAAA,CAAA;YACE;IACV;AACF","ignoreList":[]}},
    {"offset": {"line": 8380, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/lexical/utils/nodeFormat.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/lexical/utils/nodeFormat.ts"],"sourcesContent":["/* eslint-disable perfectionist/sort-objects */\n/* eslint-disable regexp/no-obscure-range */\n/* eslint-disable @typescript-eslint/no-redundant-type-constituents */\n/* eslint-disable regexp/no-misleading-unicode-character */\n//This copy-and-pasted from lexical here: https://github.com/facebook/lexical/blob/c2ceee223f46543d12c574e62155e619f9a18a5d/packages/lexical/src/LexicalConstants.ts\n\nimport type { ElementFormatType, TextFormatType, TextModeType } from 'lexical'\nexport type TextDetailType = 'directionless' | 'unmergable'\n\n// DOM\nexport const NodeFormat = {\n  DOM_ELEMENT_TYPE: 1,\n  DOM_TEXT_TYPE: 3,\n  // Reconciling\n  NO_DIRTY_NODES: 0,\n  HAS_DIRTY_NODES: 1,\n  FULL_RECONCILE: 2,\n  // Text node modes\n  IS_NORMAL: 0,\n  IS_TOKEN: 1,\n  IS_SEGMENTED: 2,\n  IS_INERT: 3,\n  // Text node formatting\n  IS_BOLD: 1,\n  IS_ITALIC: 1 << 1,\n  IS_STRIKETHROUGH: 1 << 2,\n  IS_UNDERLINE: 1 << 3,\n  IS_CODE: 1 << 4,\n  IS_SUBSCRIPT: 1 << 5,\n  IS_SUPERSCRIPT: 1 << 6,\n  IS_HIGHLIGHT: 1 << 7,\n  // Text node details\n  IS_DIRECTIONLESS: 1,\n  IS_UNMERGEABLE: 1 << 1,\n  // Element node formatting\n  IS_ALIGN_LEFT: 1,\n  IS_ALIGN_CENTER: 2,\n  IS_ALIGN_RIGHT: 3,\n  IS_ALIGN_JUSTIFY: 4,\n  IS_ALIGN_START: 5,\n  IS_ALIGN_END: 6,\n} as const\n\nexport const IS_ALL_FORMATTING =\n  NodeFormat.IS_BOLD |\n  NodeFormat.IS_ITALIC |\n  NodeFormat.IS_STRIKETHROUGH |\n  NodeFormat.IS_UNDERLINE |\n  NodeFormat.IS_CODE |\n  NodeFormat.IS_SUBSCRIPT |\n  NodeFormat.IS_SUPERSCRIPT |\n  NodeFormat.IS_HIGHLIGHT\n\n// Reconciliation\nexport const NON_BREAKING_SPACE = '\\u00A0'\n\nexport const DOUBLE_LINE_BREAK = '\\n\\n'\n\n// For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\n\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC'\nconst LTR =\n  'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' +\n  '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' +\n  '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF'\n\n// eslint-disable-next-line no-misleading-character-class\nexport const RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']')\n// eslint-disable-next-line no-misleading-character-class\nexport const LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']')\n\nexport const TEXT_TYPE_TO_FORMAT: Record<string | TextFormatType, number> = {\n  bold: NodeFormat.IS_BOLD,\n  code: NodeFormat.IS_CODE,\n  highlight: NodeFormat.IS_HIGHLIGHT,\n  italic: NodeFormat.IS_ITALIC,\n  strikethrough: NodeFormat.IS_STRIKETHROUGH,\n  subscript: NodeFormat.IS_SUBSCRIPT,\n  superscript: NodeFormat.IS_SUPERSCRIPT,\n  underline: NodeFormat.IS_UNDERLINE,\n}\n\nexport const DETAIL_TYPE_TO_DETAIL: Record<string | TextDetailType, number> = {\n  directionless: NodeFormat.IS_DIRECTIONLESS,\n  unmergeable: NodeFormat.IS_UNMERGEABLE,\n}\n\nexport const ELEMENT_TYPE_TO_FORMAT: Record<Exclude<ElementFormatType, ''>, number> = {\n  center: NodeFormat.IS_ALIGN_CENTER,\n  end: NodeFormat.IS_ALIGN_END,\n  justify: NodeFormat.IS_ALIGN_JUSTIFY,\n  left: NodeFormat.IS_ALIGN_LEFT,\n  right: NodeFormat.IS_ALIGN_RIGHT,\n  start: NodeFormat.IS_ALIGN_START,\n}\n\nexport const ELEMENT_FORMAT_TO_TYPE: Record<number, ElementFormatType> = {\n  [NodeFormat.IS_ALIGN_CENTER]: 'center',\n  [NodeFormat.IS_ALIGN_END]: 'end',\n  [NodeFormat.IS_ALIGN_JUSTIFY]: 'justify',\n  [NodeFormat.IS_ALIGN_LEFT]: 'left',\n  [NodeFormat.IS_ALIGN_RIGHT]: 'right',\n  [NodeFormat.IS_ALIGN_START]: 'start',\n}\n\nexport const TEXT_MODE_TO_TYPE: Record<TextModeType, 0 | 1 | 2> = {\n  normal: NodeFormat.IS_NORMAL,\n  segmented: NodeFormat.IS_SEGMENTED,\n  token: NodeFormat.IS_TOKEN,\n}\n\nexport const TEXT_TYPE_TO_MODE: Record<number, TextModeType> = {\n  [NodeFormat.IS_NORMAL]: 'normal',\n  [NodeFormat.IS_SEGMENTED]: 'segmented',\n  [NodeFormat.IS_TOKEN]: 'token',\n}\n"],"names":["NodeFormat","DOM_ELEMENT_TYPE","DOM_TEXT_TYPE","NO_DIRTY_NODES","HAS_DIRTY_NODES","FULL_RECONCILE","IS_NORMAL","IS_TOKEN","IS_SEGMENTED","IS_INERT","IS_BOLD","IS_ITALIC","IS_STRIKETHROUGH","IS_UNDERLINE","IS_CODE","IS_SUBSCRIPT","IS_SUPERSCRIPT","IS_HIGHLIGHT","IS_DIRECTIONLESS","IS_UNMERGEABLE","IS_ALIGN_LEFT","IS_ALIGN_CENTER","IS_ALIGN_RIGHT","IS_ALIGN_JUSTIFY","IS_ALIGN_START","IS_ALIGN_END","IS_ALL_FORMATTING","NON_BREAKING_SPACE","DOUBLE_LINE_BREAK","RTL","LTR","RTL_REGEX","RegExp","LTR_REGEX","TEXT_TYPE_TO_FORMAT","bold","code","highlight","italic","strikethrough","subscript","superscript","underline","DETAIL_TYPE_TO_DETAIL","directionless","unmergeable","ELEMENT_TYPE_TO_FORMAT","center","end","justify","left","right","start","ELEMENT_FORMAT_TO_TYPE","TEXT_MODE_TO_TYPE","normal","segmented","token","TEXT_TYPE_TO_MODE"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 8493, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/converters/lexicalToHtml/async/converters/text.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToHtml/async/converters/text.ts"],"sourcesContent":["import type { SerializedTextNode } from '../../../../../nodeTypes.js'\nimport type { HTMLConvertersAsync } from '../types.js'\n\nimport { NodeFormat } from '../../../../../lexical/utils/nodeFormat.js'\n\nexport const TextHTMLConverterAsync: HTMLConvertersAsync<SerializedTextNode> = {\n  text: ({ node }) => {\n    let text = node.text\n\n    if (node.format & NodeFormat.IS_BOLD) {\n      text = `<strong>${text}</strong>`\n    }\n    if (node.format & NodeFormat.IS_ITALIC) {\n      text = `<em>${text}</em>`\n    }\n    if (node.format & NodeFormat.IS_STRIKETHROUGH) {\n      text = `<span style=\"text-decoration: line-through;\">${text}</span>`\n    }\n    if (node.format & NodeFormat.IS_UNDERLINE) {\n      text = `<span style=\"text-decoration: underline;\">${text}</span>`\n    }\n    if (node.format & NodeFormat.IS_CODE) {\n      text = `<code>${text}</code>`\n    }\n    if (node.format & NodeFormat.IS_SUBSCRIPT) {\n      text = `<sub>${text}</sub>`\n    }\n    if (node.format & NodeFormat.IS_SUPERSCRIPT) {\n      text = `<sup>${text}</sup>`\n    }\n\n    return text\n  },\n}\n"],"names":["NodeFormat","TextHTMLConverterAsync","text","node","format","IS_BOLD","IS_ITALIC","IS_STRIKETHROUGH","IS_UNDERLINE","IS_CODE","IS_SUBSCRIPT","IS_SUPERSCRIPT"],"mappings":";;;;AAGA,SAASA,UAAU,QAAQ;;AAEpB,MAAMC,sBAAA,GAAkE;IAC7EC,IAAA,EAAMA,CAAC,EAAEC,IAAAA,EAAM;QACb,IAAID,IAAA,GAAOC,IAAA,CAAKD,IAAI;QAEpB,IAAIC,IAAA,CAAKC,MAAM,GAAGJ,qZAAA,CAAWK,OAAO,EAAE;YACpCH,IAAA,GAAO,CAAA,QAAA,EAAWA,IAAA,CAAA,SAAA,CAAe;QACnC;QACA,IAAIC,IAAA,CAAKC,MAAM,GAAGJ,qZAAA,CAAWM,SAAS,EAAE;YACtCJ,IAAA,GAAO,CAAA,IAAA,EAAOA,IAAA,CAAA,KAAA,CAAW;QAC3B;QACA,IAAIC,IAAA,CAAKC,MAAM,GAAGJ,qZAAA,CAAWO,gBAAgB,EAAE;YAC7CL,IAAA,GAAO,CAAA,6CAAA,EAAgDA,IAAA,CAAA,OAAA,CAAa;QACtE;QACA,IAAIC,IAAA,CAAKC,MAAM,GAAGJ,qZAAA,CAAWQ,YAAY,EAAE;YACzCN,IAAA,GAAO,CAAA,0CAAA,EAA6CA,IAAA,CAAA,OAAA,CAAa;QACnE;QACA,IAAIC,IAAA,CAAKC,MAAM,GAAGJ,qZAAA,CAAWS,OAAO,EAAE;YACpCP,IAAA,GAAO,CAAA,MAAA,EAASA,IAAA,CAAA,OAAA,CAAa;QAC/B;QACA,IAAIC,IAAA,CAAKC,MAAM,GAAGJ,qZAAA,CAAWU,YAAY,EAAE;YACzCR,IAAA,GAAO,CAAA,KAAA,EAAQA,IAAA,CAAA,MAAA,CAAY;QAC7B;QACA,IAAIC,IAAA,CAAKC,MAAM,GAAGJ,qZAAA,CAAWW,cAAc,EAAE;YAC3CT,IAAA,GAAO,CAAA,KAAA,EAAQA,IAAA,CAAA,MAAA,CAAY;QAC7B;QAEA,OAAOA,IAAA;IACT;AACF","ignoreList":[]}},
    {"offset": {"line": 8530, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/converters/lexicalToHtml/async/converters/upload.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToHtml/async/converters/upload.ts"],"sourcesContent":["import type { FileData, FileSizeImproved, TypeWithID } from 'payload'\n\nimport type { SerializedUploadNode } from '../../../../../nodeTypes.js'\nimport type { UploadDataImproved } from '../../../../upload/server/nodes/UploadNode.js'\nimport type { HTMLConvertersAsync } from '../types.js'\n\nexport const UploadHTMLConverterAsync: HTMLConvertersAsync<SerializedUploadNode> = {\n  upload: async ({ node, populate, providedStyleTag }) => {\n    const uploadNode = node as UploadDataImproved\n\n    let uploadDoc: (FileData & TypeWithID) | undefined = undefined\n\n    // If there's no valid upload data, populate return an empty string\n    if (typeof uploadNode.value !== 'object') {\n      if (!populate) {\n        return ''\n      }\n      uploadDoc = await populate<FileData & TypeWithID>({\n        id: uploadNode.value,\n        collectionSlug: uploadNode.relationTo,\n      })\n    } else {\n      uploadDoc = uploadNode.value as unknown as FileData & TypeWithID\n    }\n\n    if (!uploadDoc) {\n      return ''\n    }\n\n    const url = uploadDoc.url\n\n    // 1) If upload is NOT an image, return a link\n    if (!uploadDoc.mimeType.startsWith('image')) {\n      return `<a${providedStyleTag} href=\"${url}\" rel=\"noopener noreferrer\">${uploadDoc.filename}</a$>`\n    }\n\n    // 2) If image has no different sizes, return a simple <img />\n    if (!uploadDoc.sizes || !Object.keys(uploadDoc.sizes).length) {\n      return `\n        <img${providedStyleTag}\n          alt=\"${uploadDoc.filename}\"\n          height=\"${uploadDoc.height}\"\n          src=\"${url}\"\n          width=\"${uploadDoc.width}\"\n        />\n      `\n    }\n\n    // 3) If image has different sizes, build a <picture> element with <source> tags\n    let pictureHTML = ''\n\n    for (const size in uploadDoc.sizes) {\n      const imageSize = uploadDoc.sizes[size] as FileSizeImproved\n\n      if (\n        !imageSize ||\n        !imageSize.width ||\n        !imageSize.height ||\n        !imageSize.mimeType ||\n        !imageSize.filesize ||\n        !imageSize.filename ||\n        !imageSize.url\n      ) {\n        continue\n      }\n\n      pictureHTML += `\n        <source\n          media=\"(max-width: ${imageSize.width}px)\"\n          srcset=\"${imageSize.url}\"\n          type=\"${imageSize.mimeType}\"\n        />\n      `\n    }\n\n    pictureHTML += `\n      <img\n        alt=\"${uploadDoc.filename}\"\n        height=\"${uploadDoc.height}\"\n        src=\"${url}\"\n        width=\"${uploadDoc.width}\"\n      />\n    `\n\n    return `<picture${providedStyleTag}>${pictureHTML}</picture>`\n  },\n}\n"],"names":["UploadHTMLConverterAsync","upload","node","populate","providedStyleTag","uploadNode","uploadDoc","undefined","value","id","collectionSlug","relationTo","url","mimeType","startsWith","filename","sizes","Object","keys","length","height","width","pictureHTML","size","imageSize","filesize"],"mappings":";;;;AAMO,MAAMA,wBAAA,GAAsE;IACjFC,MAAA,EAAQ,MAAAA,CAAO,EAAEC,IAAI,EAAEC,QAAQ,EAAEC,gBAAAA,EAAkB;QACjD,MAAMC,UAAA,GAAaH,IAAA;QAEnB,IAAII,SAAA,GAAiDC,SAAA;QAErD,mEAAA;QACA,IAAI,OAAOF,UAAA,CAAWG,KAAK,KAAK,UAAU;YACxC,IAAI,CAACL,QAAA,EAAU;gBACb,OAAO;YACT;YACAG,SAAA,GAAY,MAAMH,QAAA,CAAgC;gBAChDM,EAAA,EAAIJ,UAAA,CAAWG,KAAK;gBACpBE,cAAA,EAAgBL,UAAA,CAAWM,UAAAA;YAC7B;QACF,OAAO;YACLL,SAAA,GAAYD,UAAA,CAAWG,KAAK;QAC9B;QAEA,IAAI,CAACF,SAAA,EAAW;YACd,OAAO;QACT;QAEA,MAAMM,GAAA,GAAMN,SAAA,CAAUM,GAAG;QAEzB,8CAAA;QACA,IAAI,CAACN,SAAA,CAAUO,QAAQ,CAACC,UAAU,CAAC,UAAU;YAC3C,OAAO,CAAA,EAAA,EAAKV,gBAAA,CAAA,OAAA,EAA0BQ,GAAA,CAAA,4BAAA,EAAkCN,SAAA,CAAUS,QAAQ,CAAA,KAAA,CAAO;QACnG;QAEA,8DAAA;QACA,IAAI,CAACT,SAAA,CAAUU,KAAK,IAAI,CAACC,MAAA,CAAOC,IAAI,CAACZ,SAAA,CAAUU,KAAK,EAAEG,MAAM,EAAE;YAC5D,OAAO,CAAA;cACCf,gBAAA,CAAA;iBACGE,SAAA,CAAUS,QAAQ,CAAA;oBACfT,SAAA,CAAUc,MAAM,CAAA;iBACnBR,GAAA,CAAA;mBACEN,SAAA,CAAUe,KAAK,CAAA;;OAE3B;QACH;QAEA,gFAAA;QACA,IAAIC,WAAA,GAAc;QAElB,IAAK,MAAMC,IAAA,IAAQjB,SAAA,CAAUU,KAAK,CAAE;YAClC,MAAMQ,SAAA,GAAYlB,SAAA,CAAUU,KAAK,CAACO,IAAA,CAAK;YAEvC,IACE,CAACC,SAAA,IACD,CAACA,SAAA,CAAUH,KAAK,IAChB,CAACG,SAAA,CAAUJ,MAAM,IACjB,CAACI,SAAA,CAAUX,QAAQ,IACnB,CAACW,SAAA,CAAUC,QAAQ,IACnB,CAACD,SAAA,CAAUT,QAAQ,IACnB,CAACS,SAAA,CAAUZ,GAAG,EACd;gBACA;YACF;YAEAU,WAAA,IAAe,CAAA;;+BAEUE,SAAA,CAAUH,KAAK,CAAA;oBAC1BG,SAAA,CAAUZ,GAAG,CAAA;kBACfY,SAAA,CAAUX,QAAQ,CAAA;;OAE7B;QACH;QAEAS,WAAA,IAAe,CAAA;;eAEJhB,SAAA,CAAUS,QAAQ,CAAA;kBACfT,SAAA,CAAUc,MAAM,CAAA;eACnBR,GAAA,CAAA;iBACEN,SAAA,CAAUe,KAAK,CAAA;;KAE3B;QAED,OAAO,CAAA,QAAA,EAAWjB,gBAAA,CAAA,CAAA,EAAoBkB,WAAA,CAAA,UAAA,CAAuB;IAC/D;AACF","ignoreList":[]}},
    {"offset": {"line": 8599, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/converters/lexicalToHtml/async/defaultConverters.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToHtml/async/defaultConverters.ts"],"sourcesContent":["import type { DefaultNodeTypes } from '../../../../nodeTypes.js'\nimport type { HTMLConvertersAsync } from './types.js'\n\nimport { BlockquoteHTMLConverterAsync } from './converters/blockquote.js'\nimport { HeadingHTMLConverterAsync } from './converters/heading.js'\nimport { HorizontalRuleHTMLConverterAsync } from './converters/horizontalRule.js'\nimport { LinebreakHTMLConverterAsync } from './converters/linebreak.js'\nimport { LinkHTMLConverterAsync } from './converters/link.js'\nimport { ListHTMLConverterAsync } from './converters/list.js'\nimport { ParagraphHTMLConverterAsync } from './converters/paragraph.js'\nimport { TabHTMLConverterAsync } from './converters/tab.js'\nimport { TableHTMLConverterAsync } from './converters/table.js'\nimport { TextHTMLConverterAsync } from './converters/text.js'\nimport { UploadHTMLConverterAsync } from './converters/upload.js'\n\nexport const defaultHTMLConvertersAsync: HTMLConvertersAsync<DefaultNodeTypes> = {\n  ...ParagraphHTMLConverterAsync,\n  ...TextHTMLConverterAsync,\n  ...LinebreakHTMLConverterAsync,\n  ...BlockquoteHTMLConverterAsync,\n  ...TableHTMLConverterAsync,\n  ...HeadingHTMLConverterAsync,\n  ...HorizontalRuleHTMLConverterAsync,\n  ...ListHTMLConverterAsync,\n  ...LinkHTMLConverterAsync({}),\n  ...UploadHTMLConverterAsync,\n  ...TabHTMLConverterAsync,\n}\n"],"names":["BlockquoteHTMLConverterAsync","HeadingHTMLConverterAsync","HorizontalRuleHTMLConverterAsync","LinebreakHTMLConverterAsync","LinkHTMLConverterAsync","ListHTMLConverterAsync","ParagraphHTMLConverterAsync","TabHTMLConverterAsync","TableHTMLConverterAsync","TextHTMLConverterAsync","UploadHTMLConverterAsync","defaultHTMLConvertersAsync"],"mappings":";;;;AAGA,SAASA,4BAA4B,QAAQ;AAC7C,SAASC,yBAAyB,QAAQ;AAC1C,SAASC,gCAAgC,QAAQ;AACjD,SAASC,2BAA2B,QAAQ;AAC5C,SAASC,sBAAsB,QAAQ;AACvC,SAASC,sBAAsB,QAAQ;AACvC,SAASC,2BAA2B,QAAQ;AAC5C,SAASC,qBAAqB,QAAQ;AACtC,SAASC,uBAAuB,QAAQ;AACxC,SAASC,sBAAsB,QAAQ;AACvC,SAASC,wBAAwB,QAAQ;;;;;;;;;;;;AAElC,MAAMC,0BAAA,GAAoE;IAC/E,GAAGL,mdAA2B;IAC9B,GAAGG,ycAAsB;IACzB,GAAGN,mdAA2B;IAC9B,GAAGH,qdAA4B;IAC/B,GAAGQ,2cAAuB;IAC1B,GAAGP,+cAAyB;IAC5B,GAAGC,6dAAgC;IACnC,GAAGG,ycAAsB;IACzB,OAAGD,ycAAA,EAAuB,CAAC,EAAE;IAC7B,GAAGM,6cAAwB;IAC3B,GAAGH,ucAAAA;AACL","ignoreList":[]}},
    {"offset": {"line": 8642, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/converters/lexicalToHtml/async/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/lexicalToHtml/async/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable no-console */\nimport type { SerializedEditorState, SerializedLexicalNode } from 'lexical'\n\nimport type { SerializedLexicalNodeWithParent } from '../shared/types.js'\nimport type {\n  HTMLConverterAsync,\n  HTMLConvertersAsync,\n  HTMLConvertersFunctionAsync,\n  HTMLPopulateFn,\n} from './types.js'\n\nimport { hasText } from '../../../../validate/hasText.js'\nimport { findConverterForNode } from '../shared/findConverterForNode.js'\nimport { defaultHTMLConvertersAsync } from './defaultConverters.js'\n\nexport type ConvertLexicalToHTMLAsyncArgs = {\n  /**\n   * Override class names for the container.\n   */\n  className?: string\n  converters?: HTMLConvertersAsync | HTMLConvertersFunctionAsync\n  data: SerializedEditorState\n  /**\n   * If true, removes the container div wrapper.\n   */\n  disableContainer?: boolean\n  /**\n   * If true, disables indentation globally. If an array, disables for specific node `type` values.\n   */\n  disableIndent?: boolean | string[]\n  /**\n   * If true, disables text alignment globally. If an array, disables for specific node `type` values.\n   */\n  disableTextAlign?: boolean | string[]\n  populate?: HTMLPopulateFn\n}\n\nexport async function convertLexicalToHTMLAsync({\n  className,\n  converters,\n  data,\n  disableContainer,\n  disableIndent,\n  disableTextAlign,\n  populate,\n}: ConvertLexicalToHTMLAsyncArgs): Promise<string> {\n  if (hasText(data)) {\n    let finalConverters: HTMLConvertersAsync = {}\n    if (converters) {\n      if (typeof converters === 'function') {\n        finalConverters = converters({ defaultConverters: defaultHTMLConvertersAsync })\n      } else {\n        finalConverters = converters\n      }\n    } else {\n      finalConverters = defaultHTMLConvertersAsync\n    }\n\n    const html = (\n      await convertLexicalNodesToHTMLAsync({\n        converters: finalConverters,\n        disableIndent,\n        disableTextAlign,\n        nodes: data?.root?.children,\n        parent: data?.root,\n        populate,\n      })\n    ).join('')\n\n    if (disableContainer) {\n      return html\n    } else {\n      return `<div class=\"${className ?? 'payload-richtext'}\">${html}</div>`\n    }\n  }\n  if (disableContainer) {\n    return ''\n  } else {\n    return `<div class=\"${className ?? 'payload-richtext'}\"></div>`\n  }\n}\n\nexport async function convertLexicalNodesToHTMLAsync({\n  converters,\n  disableIndent,\n  disableTextAlign,\n  nodes,\n  parent,\n  populate,\n}: {\n  converters: HTMLConvertersAsync\n  disableIndent?: boolean | string[]\n  disableTextAlign?: boolean | string[]\n  nodes: SerializedLexicalNode[]\n  parent: SerializedLexicalNodeWithParent\n  populate?: HTMLPopulateFn\n}): Promise<string[]> {\n  const unknownConverter: HTMLConverterAsync<any> = converters.unknown as HTMLConverterAsync<any>\n\n  const htmlArray: string[] = []\n\n  let i = -1\n  for (const node of nodes) {\n    i++\n    const { converterForNode, providedCSSString, providedStyleTag } = findConverterForNode({\n      converters,\n      disableIndent,\n      disableTextAlign,\n      node,\n      unknownConverter,\n    })\n\n    try {\n      let nodeHTML: string\n\n      if (converterForNode) {\n        const converted =\n          typeof converterForNode === 'function'\n            ? await converterForNode({\n                childIndex: i,\n                converters,\n                node,\n                populate,\n\n                nodesToHTML: async (args) => {\n                  return await convertLexicalNodesToHTMLAsync({\n                    converters: args.converters ?? converters,\n                    disableIndent: args.disableIndent ?? disableIndent,\n                    disableTextAlign: args.disableTextAlign ?? disableTextAlign,\n                    nodes: args.nodes,\n                    parent: args.parent ?? {\n                      ...node,\n                      parent,\n                    },\n                    populate,\n                  })\n                },\n                parent,\n                providedCSSString,\n                providedStyleTag,\n              })\n            : converterForNode\n        nodeHTML = converted\n      } else {\n        nodeHTML = '<span>unknown node</span>'\n      }\n\n      htmlArray.push(nodeHTML)\n    } catch (error) {\n      console.error('Error converting lexical node to HTML:', error, 'node:', node)\n      htmlArray.push('')\n    }\n  }\n\n  return htmlArray.filter(Boolean)\n}\n"],"names":["hasText","findConverterForNode","defaultHTMLConvertersAsync","convertLexicalToHTMLAsync","className","converters","data","disableContainer","disableIndent","disableTextAlign","populate","finalConverters","defaultConverters","html","convertLexicalNodesToHTMLAsync","nodes","root","children","parent","join","unknownConverter","unknown","htmlArray","i","node","converterForNode","providedCSSString","providedStyleTag","nodeHTML","converted","childIndex","nodesToHTML","args","push","error","console","filter","Boolean"],"mappings":"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","ignoreList":[]}},
    {"offset": {"line": 8742, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/features/converters/utilities/payloadPopulateFn.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/features/converters/utilities/payloadPopulateFn.ts"],"sourcesContent":["import { createLocalReq, type Payload, type PayloadRequest, type TypedLocale } from 'payload'\n\nimport type { HTMLPopulateFn } from '../lexicalToHtml/async/types.js'\n\nimport { populate } from '../../../populateGraphQL/populate.js'\n\nexport const getPayloadPopulateFn: (\n  args: {\n    currentDepth: number\n    depth: number\n    draft?: boolean\n    locale?: TypedLocale\n\n    overrideAccess?: boolean\n    showHiddenFields?: boolean\n  } & (\n    | {\n        /**\n         * This payload property will only be used if req is undefined. If localization is enabled, you must pass `req` instead.\n         */\n        payload: Payload\n        /**\n         * When the converter is called, req CAN be passed in depending on where it's run.\n         * If this is undefined and config is passed through, lexical will create a new req object for you.\n         */\n        req?: never\n      }\n    | {\n        /**\n         * This payload property will only be used if req is undefined. If localization is enabled, you must pass `req` instead.\n         */\n        payload?: never\n        /**\n         * When the converter is called, req CAN be passed in depending on where it's run.\n         * If this is undefined and config is passed through, lexical will create a new req object for you.\n         */\n        req: PayloadRequest\n      }\n  ),\n) => Promise<HTMLPopulateFn> = async ({\n  currentDepth,\n  depth,\n  draft,\n  overrideAccess,\n  payload,\n  req,\n  showHiddenFields,\n}) => {\n  let reqToUse: PayloadRequest | undefined = req\n  if (req === undefined && payload) {\n    reqToUse = await createLocalReq({}, payload)\n  }\n\n  if (!reqToUse) {\n    throw new Error('No req or payload provided')\n  }\n\n  const populateFn: HTMLPopulateFn = async ({ id, collectionSlug, select }) => {\n    const dataContainer: {\n      value?: any\n    } = {}\n\n    await populate({\n      id,\n      collectionSlug,\n      currentDepth,\n      data: dataContainer,\n      depth,\n      draft: draft ?? false,\n      key: 'value',\n      overrideAccess: overrideAccess ?? true,\n      req: reqToUse,\n      select,\n      showHiddenFields: showHiddenFields ?? false,\n    })\n\n    return dataContainer.value\n  }\n\n  return populateFn\n}\n"],"names":["createLocalReq","populate","getPayloadPopulateFn","currentDepth","depth","draft","overrideAccess","payload","req","showHiddenFields","reqToUse","undefined","Error","populateFn","id","collectionSlug","select","dataContainer","data","key","value"],"mappings":";;;;AAAA,SAASA,cAAc,QAA6D;AAIpF,SAASC,QAAQ,QAAQ;;;AAElB,MAAMC,oBAAA,GAiCkB,MAAAA,CAAO,EACpCC,YAAY,EACZC,KAAK,EACLC,KAAK,EACLC,cAAc,EACdC,OAAO,EACPC,GAAG,EACHC,gBAAAA,EACD;IACC,IAAIC,QAAA,GAAuCF,GAAA;IAC3C,IAAIA,GAAA,KAAQG,SAAA,IAAaJ,OAAA,EAAS;QAChCG,QAAA,GAAW,UAAMV,wRAAA,EAAe,CAAC,GAAGO,OAAA;IACtC;IAEA,IAAI,CAACG,QAAA,EAAU;QACb,MAAM,IAAIE,KAAA,CAAM;IAClB;IAEA,MAAMC,UAAA,GAA6B,MAAAA,CAAO,EAAEC,EAAE,EAAEC,cAAc,EAAEC,MAAAA,EAAQ;QACtE,MAAMC,aAAA,GAEF,CAAC;QAEL,UAAMhB,gZAAA,EAAS;YACba,EAAA;YACAC,cAAA;YACAZ,YAAA;YACAe,IAAA,EAAMD,aAAA;YACNb,KAAA;YACAC,KAAA,EAAOA,KAAA,IAAS;YAChBc,GAAA,EAAK;YACLb,cAAA,EAAgBA,cAAA,IAAkB;YAClCE,GAAA,EAAKE,QAAA;YACLM,MAAA;YACAP,gBAAA,EAAkBA,gBAAA,IAAoB;QACxC;QAEA,OAAOQ,aAAA,CAAcG,KAAK;IAC5B;IAEA,OAAOP,UAAA;AACT","ignoreList":[]}},
    {"offset": {"line": 8781, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/field/Diff/converters/link.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/field/Diff/converters/link.ts"],"sourcesContent":["import { createHash } from 'crypto'\n\nimport type {\n  HTMLConvertersAsync,\n  HTMLPopulateFn,\n} from '../../../features/converters/lexicalToHtml/async/types.js'\nimport type { SerializedAutoLinkNode, SerializedLinkNode } from '../../../nodeTypes.js'\n\nexport const LinkDiffHTMLConverterAsync: (args: {\n  internalDocToHref?: (args: {\n    linkNode: SerializedLinkNode\n    populate?: HTMLPopulateFn\n  }) => Promise<string> | string\n}) => HTMLConvertersAsync<SerializedAutoLinkNode | SerializedLinkNode> = ({\n  internalDocToHref,\n}) => ({\n  autolink: async ({ node, nodesToHTML, providedStyleTag }) => {\n    const children = (\n      await nodesToHTML({\n        nodes: node.children,\n      })\n    ).join('')\n\n    // hash fields to ensure they are diffed if they change\n    const nodeFieldsHash = createHash('sha256').update(JSON.stringify(node.fields)).digest('hex')\n\n    return `<a${providedStyleTag} data-fields-hash=\"${nodeFieldsHash}\" data-enable-match=\"true\" href=\"${node.fields.url}\"${node.fields.newTab ? ' rel=\"noopener noreferrer\" target=\"_blank\"' : ''}>\n        ${children}\n      </a>`\n  },\n  link: async ({ node, nodesToHTML, populate, providedStyleTag }) => {\n    const children = (\n      await nodesToHTML({\n        nodes: node.children,\n      })\n    ).join('')\n\n    let href: string = node.fields.url ?? ''\n    if (node.fields.linkType === 'internal') {\n      if (internalDocToHref) {\n        href = await internalDocToHref({ linkNode: node, populate })\n      } else {\n        console.error(\n          'Lexical => HTML converter: Link converter: found internal link, but internalDocToHref is not provided',\n        )\n        href = '#' // fallback\n      }\n    }\n\n    // hash fields to ensure they are diffed if they change\n    const nodeFieldsHash = createHash('sha256')\n      .update(JSON.stringify(node.fields ?? {}))\n      .digest('hex')\n\n    return `<a${providedStyleTag} data-fields-hash=\"${nodeFieldsHash}\" data-enable-match=\"true\" href=\"${href}\"${node.fields.newTab ? ' rel=\"noopener noreferrer\" target=\"_blank\"' : ''}>\n        ${children}\n      </a>`\n  },\n})\n"],"names":["createHash","LinkDiffHTMLConverterAsync","internalDocToHref","autolink","node","nodesToHTML","providedStyleTag","children","nodes","join","nodeFieldsHash","update","JSON","stringify","fields","digest","url","newTab","link","populate","href","linkType","linkNode","console","error"],"mappings":";;;;AAAA,SAASA,UAAU,QAAQ;;AAQpB,MAAMC,0BAAA,GAK4DA,CAAC,EACxEC,iBAAAA,EACD,GAAA,CAAM;QACLC,QAAA,EAAU,MAAAA,CAAO,EAAEC,IAAI,EAAEC,WAAW,EAAEC,gBAAAA,EAAkB;YACtD,MAAMC,QAAA,GAAW,CACf,MAAMF,WAAA,CAAY;gBAChBG,KAAA,EAAOJ,IAAA,CAAKG,QAAAA;YACd,EAAC,EACDE,IAAI,CAAC;YAEP,uDAAA;YACA,MAAMC,cAAA,OAAiBV,mHAAA,EAAW,UAAUW,MAAM,CAACC,IAAA,CAAKC,SAAS,CAACT,IAAA,CAAKU,MAAM,GAAGC,MAAM,CAAC;YAEvF,OAAO,CAAA,EAAA,EAAKT,gBAAA,CAAA,mBAAA,EAAsCI,cAAA,CAAA,iCAAA,EAAkDN,IAAA,CAAKU,MAAM,CAACE,GAAG,CAAA,CAAA,EAAIZ,IAAA,CAAKU,MAAM,CAACG,MAAM,GAAG,+CAA+C,GAAA;UACrLV,QAAA,CAAA;WACC;QACT;QACAW,IAAA,EAAM,MAAAA,CAAO,EAAEd,IAAI,EAAEC,WAAW,EAAEc,QAAQ,EAAEb,gBAAAA,EAAkB;YAC5D,MAAMC,QAAA,GAAW,CACf,MAAMF,WAAA,CAAY;gBAChBG,KAAA,EAAOJ,IAAA,CAAKG,QAAAA;YACd,EAAC,EACDE,IAAI,CAAC;YAEP,IAAIW,IAAA,GAAehB,IAAA,CAAKU,MAAM,CAACE,GAAG,IAAI;YACtC,IAAIZ,IAAA,CAAKU,MAAM,CAACO,QAAQ,KAAK,YAAY;gBACvC,IAAInB,iBAAA,EAAmB;oBACrBkB,IAAA,GAAO,MAAMlB,iBAAA,CAAkB;wBAAEoB,QAAA,EAAUlB,IAAA;wBAAMe;oBAAS;gBAC5D,OAAO;oBACLI,OAAA,CAAQC,KAAK,CACX;oBAEFJ,IAAA,GAAO,IAAI,WAAA;;gBACb;YACF;YAEA,uDAAA;YACA,MAAMV,cAAA,OAAiBV,mHAAA,EAAW,UAC/BW,MAAM,CAACC,IAAA,CAAKC,SAAS,CAACT,IAAA,CAAKU,MAAM,IAAI,CAAC,IACtCC,MAAM,CAAC;YAEV,OAAO,CAAA,EAAA,EAAKT,gBAAA,CAAA,mBAAA,EAAsCI,cAAA,CAAA,iCAAA,EAAkDU,IAAA,CAAA,CAAA,EAAQhB,IAAA,CAAKU,MAAM,CAACG,MAAM,GAAG,+CAA+C,GAAA;UAC1KV,QAAA,CAAA;WACC;QACT;IACF,CAAA","ignoreList":[]}},
    {"offset": {"line": 8826, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/field/Diff/converters/listitem/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/field/Diff/converters/listitem/index.tsx"],"sourcesContent":["import { CheckIcon } from '@payloadcms/ui/rsc'\n\nimport type { HTMLConvertersAsync } from '../../../../features/converters/lexicalToHtml/async/types.js'\nimport type { SerializedListItemNode } from '../../../../nodeTypes.js'\n\nimport './index.scss'\n\nexport const ListItemDiffHTMLConverterAsync: HTMLConvertersAsync<SerializedListItemNode> = {\n  listitem: async ({ node, nodesToHTML, parent, providedCSSString }) => {\n    const hasSubLists = node.children.some((child) => child.type === 'list')\n\n    const children = (\n      await nodesToHTML({\n        nodes: node.children,\n      })\n    ).join('')\n\n    if ('listType' in parent && parent?.listType === 'check') {\n      const ReactDOMServer = (await import('react-dom/server')).default\n\n      const JSX = (\n        <li\n          aria-checked={node.checked ? true : false}\n          className={`checkboxItem ${node.checked ? 'checkboxItem--checked' : 'checkboxItem--unchecked'}${\n            hasSubLists ? ' checkboxItem--nested' : ''\n          }`}\n          // eslint-disable-next-line jsx-a11y/no-noninteractive-element-to-interactive-role\n          role=\"checkbox\"\n          tabIndex={-1}\n          value={node.value}\n        >\n          {hasSubLists ? (\n            // When sublists exist, just render them safely as HTML\n            <div dangerouslySetInnerHTML={{ __html: children }} />\n          ) : (\n            // Otherwise, show our custom styled checkbox\n            <div className=\"checkboxItem__wrapper\">\n              <div\n                className=\"checkboxItem__icon\"\n                data-checked={node.checked}\n                data-enable-match=\"true\"\n              >\n                {node.checked && <CheckIcon />}\n              </div>\n              <span className=\"checkboxItem__label\">{children}</span>\n            </div>\n          )}\n        </li>\n      )\n\n      const html = ReactDOMServer.renderToStaticMarkup(JSX)\n\n      // Add style=\"list-style-type: none;${providedCSSString}\" to html\n      const styleIndex = html.indexOf('class=\"list-item-checkbox')\n      const classIndex = html.indexOf('class=\"list-item-checkbox', styleIndex)\n      const classEndIndex = html.indexOf('\"', classIndex + 6)\n      const className = html.substring(classIndex, classEndIndex)\n      const classNameWithStyle = `${className} style=\"list-style-type: none;${providedCSSString}\"`\n      const htmlWithStyle = html.replace(className, classNameWithStyle)\n\n      return htmlWithStyle\n    } else {\n      return `<li\n          class=\"${hasSubLists ? 'nestedListItem' : ''}\"\n          style=\"${hasSubLists ? `list-style-type: none;${providedCSSString}` : providedCSSString}\"\n          value=\"${node.value}\"\n          data-enable-match=\"true\"\n        >${children}</li>`\n    }\n  },\n}\n"],"names":["CheckIcon","ListItemDiffHTMLConverterAsync","listitem","node","nodesToHTML","parent","providedCSSString","hasSubLists","children","some","child","type","nodes","join","listType","ReactDOMServer","default","JSX","_jsx","checked","className","role","tabIndex","value","dangerouslySetInnerHTML","__html","_jsxs","html","renderToStaticMarkup","styleIndex","indexOf","classIndex","classEndIndex","substring","classNameWithStyle","htmlWithStyle","replace"],"mappings":";;;;;AAAA,SAASA,SAAS,QAAQ;;;AAOnB,MAAMC,8BAAA,GAA8E;IACzFC,QAAA,EAAU,MAAAA,CAAO,EAAEC,IAAI,EAAEC,WAAW,EAAEC,MAAM,EAAEC,iBAAAA,EAAmB;QAC/D,MAAMC,WAAA,GAAcJ,IAAA,CAAKK,QAAQ,CAACC,IAAI,EAAEC,KAAA,GAAUA,KAAA,CAAMC,IAAI,KAAK;QAEjE,MAAMH,QAAA,GAAW,CACf,MAAMJ,WAAA,CAAY;YAChBQ,KAAA,EAAOT,IAAA,CAAKK,QAAAA;QACd,EAAC,EACDK,IAAI,CAAC;QAEP,IAAI,cAAcR,MAAA,IAAUA,MAAA,EAAQS,QAAA,KAAa,SAAS;YACxD,MAAMC,cAAA,GAAiB,CAAC,MAAM,MAAM,CAAC,2NAAkB,EAAGC,OAAO;YAEjE,MAAMC,GAAA,GAAA,WAAA,OACJC,iYAAA,EAAC,MAAA;gBACC,gBAAcf,IAAA,CAAKgB,OAAO,GAAG,OAAO;gBACpCC,SAAA,EAAW,CAAA,aAAA,EAAgBjB,IAAA,CAAKgB,OAAO,GAAG,0BAA0B,4BAClEZ,WAAA,GAAc,0BAA0B,IACxC;gBACF,kFAAA;gBACAc,IAAA,EAAK;gBACLC,QAAA,EAAU,CAAC;gBACXC,KAAA,EAAOpB,IAAA,CAAKoB,KAAK;0BAEhBhB,WAAA,GACC,uDAAA;kCACAW,iYAAA,EAAC,OAAA;oBAAIM,uBAAA,EAAyB;wBAAEC,MAAA,EAAQjB;oBAAS;qBAEjD,6CAAA;kCACAkB,kYAAA,EAAC,OAAA;oBAAIN,SAAA,EAAU;;0CACbF,iYAAA,EAAC,OAAA;4BACCE,SAAA,EAAU;4BACV,gBAAcjB,IAAA,CAAKgB,OAAO;4BAC1B,qBAAkB;sCAEjBhB,IAAA,CAAKgB,OAAO,IAAA,WAAA,OAAID,iYAAA,EAAClB,+XAAA,EAAA,CAAA;;0CAEpBkB,iYAAA,EAAC,QAAA;4BAAKE,SAAA,EAAU;sCAAuBZ;;;;;YAM/C,MAAMmB,IAAA,GAAOZ,cAAA,CAAea,oBAAoB,CAACX,GAAA;YAEjD,iEAAA;YACA,MAAMY,UAAA,GAAaF,IAAA,CAAKG,OAAO,CAAC;YAChC,MAAMC,UAAA,GAAaJ,IAAA,CAAKG,OAAO,CAAC,6BAA6BD,UAAA;YAC7D,MAAMG,aAAA,GAAgBL,IAAA,CAAKG,OAAO,CAAC,KAAKC,UAAA,GAAa;YACrD,MAAMX,SAAA,GAAYO,IAAA,CAAKM,SAAS,CAACF,UAAA,EAAYC,aAAA;YAC7C,MAAME,kBAAA,GAAqB,GAAGd,SAAA,CAAA,8BAAA,EAA0Cd,iBAAA,CAAA,CAAA,CAAoB;YAC5F,MAAM6B,aAAA,GAAgBR,IAAA,CAAKS,OAAO,CAAChB,SAAA,EAAWc,kBAAA;YAE9C,OAAOC,aAAA;QACT,OAAO;YACL,OAAO,CAAA;mBACM5B,WAAA,GAAc,mBAAmB,GAAA;mBACjCA,WAAA,GAAc,CAAA,sBAAA,EAAyBD,iBAAA,EAAmB,GAAGA,iBAAA,CAAA;mBAC7DH,IAAA,CAAKoB,KAAK,CAAA;;WAElBf,QAAA,CAAA,KAAA,CAAe;QACtB;IACF;AACF","ignoreList":[]}},
    {"offset": {"line": 8894, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/field/Diff/converters/relationship/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/field/Diff/converters/relationship/index.tsx"],"sourcesContent":["import type { FileData, PayloadRequest, TypeWithID } from 'payload'\n\nimport { getTranslation, type I18nClient } from '@payloadcms/translations'\n\nimport './index.scss'\n\nimport { formatAdminURL } from 'payload/shared'\n\nimport type { HTMLConvertersAsync } from '../../../../features/converters/lexicalToHtml/async/types.js'\nimport type { SerializedRelationshipNode } from '../../../../nodeTypes.js'\n\nconst baseClass = 'lexical-relationship-diff'\n\nexport const RelationshipDiffHTMLConverterAsync: (args: {\n  i18n: I18nClient\n  req: PayloadRequest\n}) => HTMLConvertersAsync<SerializedRelationshipNode> = ({ i18n, req }) => {\n  return {\n    relationship: async ({ node, populate, providedCSSString }) => {\n      let data: (Record<string, any> & TypeWithID) | undefined = undefined\n\n      const id = typeof node.value === 'object' ? node.value.id : node.value\n\n      // If there's no valid upload data, populate return an empty string\n      if (typeof node.value !== 'object') {\n        if (!populate) {\n          return ''\n        }\n        data = await populate<FileData & TypeWithID>({\n          id,\n          collectionSlug: node.relationTo,\n        })\n      } else {\n        data = node.value as unknown as FileData & TypeWithID\n      }\n\n      const relatedCollection = req.payload.collections[node.relationTo]?.config\n\n      const ReactDOMServer = (await import('react-dom/server')).default\n\n      const JSX = (\n        <div\n          className={`${baseClass}${providedCSSString}`}\n          data-enable-match=\"true\"\n          data-id={id}\n          data-slug={node.relationTo}\n        >\n          <div className={`${baseClass}__card`}>\n            <div className={`${baseClass}__collectionLabel`}>\n              {i18n.t('fields:labelRelationship', {\n                label: relatedCollection?.labels?.singular\n                  ? getTranslation(relatedCollection?.labels?.singular, i18n)\n                  : relatedCollection?.slug,\n              })}\n            </div>\n            {data &&\n            relatedCollection?.admin?.useAsTitle &&\n            data[relatedCollection.admin.useAsTitle] ? (\n              <strong className={`${baseClass}__title`} data-enable-match=\"false\">\n                <a\n                  className={`${baseClass}__link`}\n                  data-enable-match=\"false\"\n                  href={formatAdminURL({\n                    adminRoute: req.payload.config.routes.admin,\n                    path: `/collections/${relatedCollection?.slug}/${data.id}`,\n                    serverURL: req.payload.config.serverURL,\n                  })}\n                  rel=\"noopener noreferrer\"\n                  target=\"_blank\"\n                >\n                  {data[relatedCollection.admin.useAsTitle]}\n                </a>\n              </strong>\n            ) : (\n              <strong>{id as string}</strong>\n            )}\n          </div>\n        </div>\n      )\n\n      // Render to HTML\n      const html = ReactDOMServer.renderToStaticMarkup(JSX)\n\n      return html\n    },\n  }\n}\n"],"names":["getTranslation","formatAdminURL","baseClass","RelationshipDiffHTMLConverterAsync","i18n","req","relationship","node","populate","providedCSSString","data","undefined","id","value","collectionSlug","relationTo","relatedCollection","payload","collections","config","ReactDOMServer","default","JSX","_jsx","className","_jsxs","t","label","labels","singular","slug","admin","useAsTitle","href","adminRoute","routes","path","serverURL","rel","target","html","renderToStaticMarkup"],"mappings":";;;;;AAEA,SAASA,cAAc,QAAyB;AAIhD,SAASC,cAAc,QAAQ;;;;AAK/B,MAAMC,SAAA,GAAY;AAEX,MAAMC,kCAAA,GAG2CA,CAAC,EAAEC,IAAI,EAAEC,GAAAA,EAAK;IACpE,OAAO;QACLC,YAAA,EAAc,MAAAA,CAAO,EAAEC,IAAI,EAAEC,QAAQ,EAAEC,iBAAAA,EAAmB;YACxD,IAAIC,IAAA,GAAuDC,SAAA;YAE3D,MAAMC,EAAA,GAAK,OAAOL,IAAA,CAAKM,KAAK,KAAK,WAAWN,IAAA,CAAKM,KAAK,CAACD,EAAE,GAAGL,IAAA,CAAKM,KAAK;YAEtE,mEAAA;YACA,IAAI,OAAON,IAAA,CAAKM,KAAK,KAAK,UAAU;gBAClC,IAAI,CAACL,QAAA,EAAU;oBACb,OAAO;gBACT;gBACAE,IAAA,GAAO,MAAMF,QAAA,CAAgC;oBAC3CI,EAAA;oBACAE,cAAA,EAAgBP,IAAA,CAAKQ,UAAAA;gBACvB;YACF,OAAO;gBACLL,IAAA,GAAOH,IAAA,CAAKM,KAAK;YACnB;YAEA,MAAMG,iBAAA,GAAoBX,GAAA,CAAIY,OAAO,CAACC,WAAW,CAACX,IAAA,CAAKQ,UAAU,CAAC,EAAEI,MAAA;YAEpE,MAAMC,cAAA,GAAiB,CAAC,MAAM,MAAM,CAAC,2NAAkB,EAAGC,OAAO;YAEjE,MAAMC,GAAA,GAAA,WAAA,OACJC,iYAAA,EAAC,OAAA;gBACCC,SAAA,EAAW,GAAGtB,SAAA,GAAYO,iBAAA,EAAmB;gBAC7C,qBAAkB;gBAClB,WAASG,EAAA;gBACT,aAAWL,IAAA,CAAKQ,UAAU;0BAE1B,WAAA,OAAAU,kYAAA,EAAC,OAAA;oBAAID,SAAA,EAAW,GAAGtB,SAAA,CAAA,MAAA,CAAiB;;0CAClCqB,iYAAA,EAAC,OAAA;4BAAIC,SAAA,EAAW,GAAGtB,SAAA,CAAA,iBAAA,CAA4B;sCAC5CE,IAAA,CAAKsB,CAAC,CAAC,4BAA4B;gCAClCC,KAAA,EAAOX,iBAAA,EAAmBY,MAAA,EAAQC,QAAA,OAC9B7B,+QAAA,EAAegB,iBAAA,EAAmBY,MAAA,EAAQC,QAAA,EAAUzB,IAAA,IACpDY,iBAAA,EAAmBc;4BACzB;;wBAEDpB,IAAA,IACDM,iBAAA,EAAmBe,KAAA,EAAOC,UAAA,IAC1BtB,IAAI,CAACM,iBAAA,CAAkBe,KAAK,CAACC,UAAU,CAAC,GAAA,WAAA,OACtCT,iYAAA,EAAC,UAAA;4BAAOC,SAAA,EAAW,GAAGtB,SAAA,CAAA,OAAA,CAAkB;4BAAE,qBAAkB;sCAC1D,WAAA,OAAAqB,iYAAA,EAAC,KAAA;gCACCC,SAAA,EAAW,GAAGtB,SAAA,CAAA,MAAA,CAAiB;gCAC/B,qBAAkB;gCAClB+B,IAAA,MAAMhC,wRAAA,EAAe;oCACnBiC,UAAA,EAAY7B,GAAA,CAAIY,OAAO,CAACE,MAAM,CAACgB,MAAM,CAACJ,KAAK;oCAC3CK,IAAA,EAAM,CAAA,aAAA,EAAgBpB,iBAAA,EAAmBc,IAAA,CAAA,CAAA,EAAQpB,IAAA,CAAKE,EAAE,EAAE;oCAC1DyB,SAAA,EAAWhC,GAAA,CAAIY,OAAO,CAACE,MAAM,CAACkB,SAAAA;gCAChC;gCACAC,GAAA,EAAI;gCACJC,MAAA,EAAO;0CAEN7B,IAAI,CAACM,iBAAA,CAAkBe,KAAK,CAACC,UAAU,CAAA;;+CAI5CT,iYAAA,EAAC,UAAA;sCAAQX;;;;;YAMjB,iBAAA;YACA,MAAM4B,IAAA,GAAOpB,cAAA,CAAeqB,oBAAoB,CAACnB,GAAA;YAEjD,OAAOkB,IAAA;QACT;IACF;AACF","ignoreList":[]}},
    {"offset": {"line": 8969, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/field/Diff/converters/unknown/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/field/Diff/converters/unknown/index.tsx"],"sourcesContent":["import type { LexicalNode } from 'lexical'\nimport type { PayloadRequest } from 'payload'\n\nimport { type I18nClient } from '@payloadcms/translations'\n\nimport './index.scss'\n\nimport { createHash } from 'crypto'\n\nimport type { HTMLConvertersAsync } from '../../../../features/converters/lexicalToHtml/async/types.js'\nimport type { SerializedBlockNode } from '../../../../nodeTypes.js'\n\nconst baseClass = 'lexical-unknown-diff'\n\nexport const UnknownDiffHTMLConverterAsync: (args: {\n  i18n: I18nClient\n  req: PayloadRequest\n}) => HTMLConvertersAsync<LexicalNode> = ({ i18n, req }) => {\n  return {\n    unknown: async ({ node, providedCSSString }) => {\n      const ReactDOMServer = (await import('react-dom/server')).default\n\n      // hash fields to ensure they are diffed if they change\n      const nodeFieldsHash = createHash('sha256')\n        .update(JSON.stringify(node ?? {}))\n        .digest('hex')\n\n      let nodeType = node.type\n\n      let nodeTypeSpecifier: null | string = null\n\n      if (node.type === 'block') {\n        nodeTypeSpecifier = (node as SerializedBlockNode).fields.blockType\n        nodeType = 'Block'\n      } else if (node.type === 'inlineBlock') {\n        nodeTypeSpecifier = (node as SerializedBlockNode).fields.blockType\n        nodeType = 'InlineBlock'\n      }\n\n      const JSX = (\n        <div\n          className={`${baseClass}${providedCSSString}`}\n          data-enable-match=\"true\"\n          data-fields-hash={`${nodeFieldsHash}`}\n        >\n          {nodeTypeSpecifier && (\n            <span className={`${baseClass}__specifier`}>{nodeTypeSpecifier}&nbsp;</span>\n          )}\n          <span>{nodeType}</span>\n          <div className={`${baseClass}__meta`}>\n            <br />\n          </div>\n        </div>\n      )\n\n      // Render to HTML\n      const html = ReactDOMServer.renderToStaticMarkup(JSX)\n\n      return html\n    },\n  }\n}\n"],"names":["createHash","baseClass","UnknownDiffHTMLConverterAsync","i18n","req","unknown","node","providedCSSString","ReactDOMServer","default","nodeFieldsHash","update","JSON","stringify","digest","nodeType","type","nodeTypeSpecifier","fields","blockType","JSX","_jsxs","className","_jsx","html","renderToStaticMarkup"],"mappings":";;;;;AAOA,SAASA,UAAU,QAAQ;;;AAK3B,MAAMC,SAAA,GAAY;AAEX,MAAMC,6BAAA,GAG4BA,CAAC,EAAEC,IAAI,EAAEC,GAAAA,EAAK;IACrD,OAAO;QACLC,OAAA,EAAS,MAAAA,CAAO,EAAEC,IAAI,EAAEC,iBAAAA,EAAmB;YACzC,MAAMC,cAAA,GAAiB,CAAC,MAAM,MAAM,CAAC,2NAAkB,EAAGC,OAAO;YAEjE,uDAAA;YACA,MAAMC,cAAA,OAAiBV,mHAAA,EAAW,UAC/BW,MAAM,CAACC,IAAA,CAAKC,SAAS,CAACP,IAAA,IAAQ,CAAC,IAC/BQ,MAAM,CAAC;YAEV,IAAIC,QAAA,GAAWT,IAAA,CAAKU,IAAI;YAExB,IAAIC,iBAAA,GAAmC;YAEvC,IAAIX,IAAA,CAAKU,IAAI,KAAK,SAAS;gBACzBC,iBAAA,GAAoBX,IAAC,CAA6BY,MAAM,CAACC,SAAS;gBAClEJ,QAAA,GAAW;YACb,OAAO,IAAIT,IAAA,CAAKU,IAAI,KAAK,eAAe;gBACtCC,iBAAA,GAAoBX,IAAC,CAA6BY,MAAM,CAACC,SAAS;gBAClEJ,QAAA,GAAW;YACb;YAEA,MAAMK,GAAA,GAAA,WAAA,OACJC,kYAAA,EAAC,OAAA;gBACCC,SAAA,EAAW,GAAGrB,SAAA,GAAYM,iBAAA,EAAmB;gBAC7C,qBAAkB;gBAClB,oBAAkB,GAAGG,cAAA,EAAgB;;oBAEpCO,iBAAA,IAAA,WAAA,OACCI,kYAAA,EAAC,QAAA;wBAAKC,SAAA,EAAW,GAAGrB,SAAA,CAAA,WAAA,CAAsB;;4BAAGgB,iBAAA;4BAAkB;yBAAA;;sCAEjEM,iYAAA,EAAC,QAAA;kCAAMR;;sCACPQ,iYAAA,EAAC,OAAA;wBAAID,SAAA,EAAW,GAAGrB,SAAA,CAAA,MAAA,CAAiB;kCAClC,WAAA,OAAAsB,iYAAA,EAAC,MAAA,CAAA;;;;YAKP,iBAAA;YACA,MAAMC,IAAA,GAAOhB,cAAA,CAAeiB,oBAAoB,CAACL,GAAA;YAEjD,OAAOI,IAAA;QACT;IACF;AACF","ignoreList":[]}},
    {"offset": {"line": 9024, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/field/Diff/converters/upload/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/field/Diff/converters/upload/index.tsx"],"sourcesContent":["import type { FileData, PayloadRequest, TypeWithID } from 'payload'\n\nimport { type I18nClient } from '@payloadcms/translations'\nimport { File } from '@payloadcms/ui/rsc'\nimport { createHash } from 'crypto'\n\nimport './index.scss'\n\nimport { formatFilesize } from 'payload/shared'\nimport React from 'react'\n\nimport type { HTMLConvertersAsync } from '../../../../features/converters/lexicalToHtml/async/types.js'\nimport type { UploadDataImproved } from '../../../../features/upload/server/nodes/UploadNode.js'\nimport type { SerializedUploadNode } from '../../../../nodeTypes.js'\n\nconst baseClass = 'lexical-upload-diff'\n\nexport const UploadDiffHTMLConverterAsync: (args: {\n  i18n: I18nClient\n  req: PayloadRequest\n}) => HTMLConvertersAsync<SerializedUploadNode> = ({ i18n, req }) => {\n  return {\n    upload: async ({ node, populate, providedCSSString }) => {\n      const uploadNode = node as UploadDataImproved\n\n      let uploadDoc: (FileData & TypeWithID) | undefined = undefined\n\n      // If there's no valid upload data, populate return an empty string\n      if (typeof uploadNode.value !== 'object') {\n        if (!populate) {\n          return ''\n        }\n        uploadDoc = await populate<FileData & TypeWithID>({\n          id: uploadNode.value,\n          collectionSlug: uploadNode.relationTo,\n        })\n      } else {\n        uploadDoc = uploadNode.value as unknown as FileData & TypeWithID\n      }\n\n      if (!uploadDoc) {\n        return ''\n      }\n\n      const relatedCollection = req.payload.collections[uploadNode.relationTo]?.config\n\n      const thumbnailSRC: string =\n        ('thumbnailURL' in uploadDoc && (uploadDoc?.thumbnailURL as string)) || uploadDoc?.url || ''\n\n      const ReactDOMServer = (await import('react-dom/server')).default\n\n      // hash fields to ensure they are diffed if they change\n      const nodeFieldsHash = createHash('sha256')\n        .update(JSON.stringify(node.fields ?? {}))\n        .digest('hex')\n\n      const JSX = (\n        <div\n          className={`${baseClass}${providedCSSString}`}\n          data-enable-match=\"true\"\n          data-fields-hash={`${nodeFieldsHash}`}\n          data-filename={uploadDoc?.filename}\n          data-lexical-upload-id={uploadNode.value}\n          data-lexical-upload-relation-to={uploadNode.relationTo}\n          data-src={thumbnailSRC}\n        >\n          <div className={`${baseClass}__card`}>\n            <div className={`${baseClass}__thumbnail`}>\n              {thumbnailSRC?.length ? (\n                <img alt={uploadDoc?.filename} src={thumbnailSRC} />\n              ) : (\n                <File />\n              )}\n            </div>\n            <div className={`${baseClass}__info`} data-enable-match=\"false\">\n              <strong>{uploadDoc?.filename}</strong>\n              <div className={`${baseClass}__meta`}>\n                {formatFilesize(uploadDoc?.filesize)}\n                {typeof uploadDoc?.width === 'number' && typeof uploadDoc?.height === 'number' && (\n                  <React.Fragment>\n                    &nbsp;-&nbsp;\n                    {uploadDoc?.width}x{uploadDoc?.height}\n                  </React.Fragment>\n                )}\n                {uploadDoc?.mimeType && (\n                  <React.Fragment>\n                    &nbsp;-&nbsp;\n                    {uploadDoc?.mimeType}\n                  </React.Fragment>\n                )}\n              </div>\n            </div>\n          </div>\n        </div>\n      )\n\n      // Render to HTML\n      const html = ReactDOMServer.renderToStaticMarkup(JSX)\n\n      return html\n    },\n  }\n}\n"],"names":["File","createHash","formatFilesize","React","baseClass","UploadDiffHTMLConverterAsync","i18n","req","upload","node","populate","providedCSSString","uploadNode","uploadDoc","undefined","value","id","collectionSlug","relationTo","relatedCollection","payload","collections","config","thumbnailSRC","thumbnailURL","url","ReactDOMServer","default","nodeFieldsHash","update","JSON","stringify","fields","digest","JSX","_jsx","className","filename","_jsxs","length","alt","src","filesize","width","height","Fragment","mimeType","html","renderToStaticMarkup"],"mappings":";;;;;AAGA,SAASA,IAAI,QAAQ;AACrB,SAASC,UAAU,QAAQ;AAI3B,SAASC,cAAc,QAAQ;AAC/B,OAAOC,KAAA,MAAW;;;;;;AAMlB,MAAMC,SAAA,GAAY;AAEX,MAAMC,4BAAA,GAGqCA,CAAC,EAAEC,IAAI,EAAEC,GAAAA,EAAK;IAC9D,OAAO;QACLC,MAAA,EAAQ,MAAAA,CAAO,EAAEC,IAAI,EAAEC,QAAQ,EAAEC,iBAAAA,EAAmB;YAClD,MAAMC,UAAA,GAAaH,IAAA;YAEnB,IAAII,SAAA,GAAiDC,SAAA;YAErD,mEAAA;YACA,IAAI,OAAOF,UAAA,CAAWG,KAAK,KAAK,UAAU;gBACxC,IAAI,CAACL,QAAA,EAAU;oBACb,OAAO;gBACT;gBACAG,SAAA,GAAY,MAAMH,QAAA,CAAgC;oBAChDM,EAAA,EAAIJ,UAAA,CAAWG,KAAK;oBACpBE,cAAA,EAAgBL,UAAA,CAAWM,UAAAA;gBAC7B;YACF,OAAO;gBACLL,SAAA,GAAYD,UAAA,CAAWG,KAAK;YAC9B;YAEA,IAAI,CAACF,SAAA,EAAW;gBACd,OAAO;YACT;YAEA,MAAMM,iBAAA,GAAoBZ,GAAA,CAAIa,OAAO,CAACC,WAAW,CAACT,UAAA,CAAWM,UAAU,CAAC,EAAEI,MAAA;YAE1E,MAAMC,YAAA,GACJ,cAAC,IAAkBV,SAAA,IAAcA,SAAA,EAAWW,YAAA,IAA4BX,SAAA,EAAWY,GAAA,IAAO;YAE5F,MAAMC,cAAA,GAAiB,CAAC,MAAM,MAAM,CAAC,2NAAkB,EAAGC,OAAO;YAEjE,uDAAA;YACA,MAAMC,cAAA,OAAiB3B,mHAAA,EAAW,UAC/B4B,MAAM,CAACC,IAAA,CAAKC,SAAS,CAACtB,IAAA,CAAKuB,MAAM,IAAI,CAAC,IACtCC,MAAM,CAAC;YAEV,MAAMC,GAAA,GAAA,WAAA,OACJC,iYAAA,EAAC,OAAA;gBACCC,SAAA,EAAW,GAAGhC,SAAA,GAAYO,iBAAA,EAAmB;gBAC7C,qBAAkB;gBAClB,oBAAkB,GAAGiB,cAAA,EAAgB;gBACrC,iBAAef,SAAA,EAAWwB,QAAA;gBAC1B,0BAAwBzB,UAAA,CAAWG,KAAK;gBACxC,mCAAiCH,UAAA,CAAWM,UAAU;gBACtD,YAAUK,YAAA;0BAEV,WAAA,OAAAe,kYAAA,EAAC,OAAA;oBAAIF,SAAA,EAAW,GAAGhC,SAAA,CAAA,MAAA,CAAiB;;0CAClC+B,iYAAA,EAAC,OAAA;4BAAIC,SAAA,EAAW,GAAGhC,SAAA,CAAA,WAAA,CAAsB;sCACtCmB,YAAA,EAAcgB,MAAA,GAAA,WAAA,OACbJ,iYAAA,EAAC,OAAA;gCAAIK,GAAA,EAAK3B,SAAA,EAAWwB,QAAA;gCAAUI,GAAA,EAAKlB;mDAEpCY,iYAAA,EAACnC,4XAAA,EAAA,CAAA;;0CAGLsC,kYAAA,EAAC,OAAA;4BAAIF,SAAA,EAAW,GAAGhC,SAAA,CAAA,MAAA,CAAiB;4BAAE,qBAAkB;;kDACtD+B,iYAAA,EAAC,UAAA;8CAAQtB,SAAA,EAAWwB;;kDACpBC,kYAAA,EAAC,OAAA;oCAAIF,SAAA,EAAW,GAAGhC,SAAA,CAAA,MAAA,CAAiB;;4CACjCF,sRAAA,EAAeW,SAAA,EAAW6B,QAAA;wCAC1B,OAAO7B,SAAA,EAAW8B,KAAA,KAAU,YAAY,OAAO9B,SAAA,EAAW+B,MAAA,KAAW,YAAA,WAAA,OACpEN,kYAAA,EAACnC,mXAAA,CAAM0C,QAAQ,EAAA;;gDAAC;gDAEbhC,SAAA,EAAW8B,KAAA;gDAAM;gDAAE9B,SAAA,EAAW+B,MAAA;6CAAA;;wCAGlC/B,SAAA,EAAWiC,QAAA,IAAA,WAAA,OACVR,kYAAA,EAACnC,mXAAA,CAAM0C,QAAQ,EAAA;;gDAAC;gDAEbhC,SAAA,EAAWiC,QAAA;6CAAA;;;;;;;;;YAS1B,iBAAA;YACA,MAAMC,IAAA,GAAOrB,cAAA,CAAesB,oBAAoB,CAACd,GAAA;YAEjD,OAAOa,IAAA;QACT;IACF;AACF","ignoreList":[]}},
    {"offset": {"line": 9124, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@payloadcms+richtext-lexical@3.64.0_@faceless-ui+modal@3.0.0_react-dom@19.0.0_react@19._bd7baf48251713852e8e278ca79c7dae/node_modules/@payloadcms/richtext-lexical/dist/field/Diff/index.js","sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/%40payloadcms%2Brichtext-lexical%403.64.0_%40faceless-ui%2Bmodal%403.0.0_react-dom%4019.0.0_react%4019._bd7baf48251713852e8e278ca79c7dae/node_modules/%40payloadcms/richtext-lexical/src/field/Diff/index.tsx"],"sourcesContent":["import type { SerializedEditorState } from 'lexical'\nimport type { RichTextFieldDiffServerComponent } from 'payload'\n\nimport { FieldDiffContainer, getHTMLDiffComponents } from '@payloadcms/ui/rsc'\n\nimport './index.scss'\nimport '../bundled.css'\n\nimport React from 'react'\n\nimport type { HTMLConvertersFunctionAsync } from '../../features/converters/lexicalToHtml/async/types.js'\n\nimport { convertLexicalToHTMLAsync } from '../../features/converters/lexicalToHtml/async/index.js'\nimport { getPayloadPopulateFn } from '../../features/converters/utilities/payloadPopulateFn.js'\nimport { LinkDiffHTMLConverterAsync } from './converters/link.js'\nimport { ListItemDiffHTMLConverterAsync } from './converters/listitem/index.js'\nimport { RelationshipDiffHTMLConverterAsync } from './converters/relationship/index.js'\nimport { UnknownDiffHTMLConverterAsync } from './converters/unknown/index.js'\nimport { UploadDiffHTMLConverterAsync } from './converters/upload/index.js'\n\nconst baseClass = 'lexical-diff'\n\nexport const LexicalDiffComponent: RichTextFieldDiffServerComponent = async (args) => {\n  const {\n    comparisonValue: valueFrom,\n    field,\n    i18n,\n    locale,\n    nestingLevel,\n    req,\n    versionValue: valueTo,\n  } = args\n\n  const converters: HTMLConvertersFunctionAsync = ({ defaultConverters }) => ({\n    ...defaultConverters,\n    ...LinkDiffHTMLConverterAsync({}),\n    ...ListItemDiffHTMLConverterAsync,\n    ...UploadDiffHTMLConverterAsync({ i18n, req }),\n    ...RelationshipDiffHTMLConverterAsync({ i18n, req }),\n    ...UnknownDiffHTMLConverterAsync({ i18n, req }),\n  })\n\n  const payloadPopulateFn = await getPayloadPopulateFn({\n    currentDepth: 0,\n    depth: 1,\n    req,\n  })\n  const fromHTML = await convertLexicalToHTMLAsync({\n    converters,\n    data: valueFrom as SerializedEditorState,\n    disableContainer: true,\n    populate: payloadPopulateFn,\n  })\n\n  const toHTML = await convertLexicalToHTMLAsync({\n    converters,\n    data: valueTo as SerializedEditorState,\n    disableContainer: true,\n    populate: payloadPopulateFn,\n  })\n\n  const { From, To } = getHTMLDiffComponents({\n    // Ensure empty paragraph is displayed for empty rich text fields - otherwise, toHTML may be displayed in the wrong column\n    fromHTML: fromHTML?.length ? fromHTML : '<p></p>',\n    toHTML: toHTML?.length ? toHTML : '<p></p>',\n  })\n\n  return (\n    <FieldDiffContainer\n      className={baseClass}\n      From={From}\n      i18n={i18n}\n      label={{\n        label: field.label,\n        locale,\n      }}\n      nestingLevel={nestingLevel}\n      To={To}\n    />\n  )\n}\n"],"names":["FieldDiffContainer","getHTMLDiffComponents","React","convertLexicalToHTMLAsync","getPayloadPopulateFn","LinkDiffHTMLConverterAsync","ListItemDiffHTMLConverterAsync","RelationshipDiffHTMLConverterAsync","UnknownDiffHTMLConverterAsync","UploadDiffHTMLConverterAsync","baseClass","LexicalDiffComponent","args","comparisonValue","valueFrom","field","i18n","locale","nestingLevel","req","versionValue","valueTo","converters","defaultConverters","payloadPopulateFn","currentDepth","depth","fromHTML","data","disableContainer","populate","toHTML","From","To","length","_jsx","className","label"],"mappings":";;;;;;AAGA,SAASA,kBAAkB,EAAEC,qBAAqB,QAAQ;AAK1D,OAAOC,KAAA,MAAW;AAIlB,SAASC,yBAAyB,QAAQ;AAC1C,SAASC,oBAAoB,QAAQ;AACrC,SAASC,0BAA0B,QAAQ;AAC3C,SAASC,8BAA8B,QAAQ;AAC/C,SAASC,kCAAkC,QAAQ;AACnD,SAASC,6BAA6B,QAAQ;AAC9C,SAASC,4BAA4B,QAAQ;;;;;;;;;;;;AAE7C,MAAMC,SAAA,GAAY;AAEX,MAAMC,oBAAA,GAAyD,OAAOC,IAAA;IAC3E,MAAM,EACJC,eAAA,EAAiBC,SAAS,EAC1BC,KAAK,EACLC,IAAI,EACJC,MAAM,EACNC,YAAY,EACZC,GAAG,EACHC,YAAA,EAAcC,OAAAA,EACf,GAAGT,IAAA;IAEJ,MAAMU,UAAA,GAA0CA,CAAC,EAAEC,iBAAAA,EAAmB,GAAA,CAAM;YAC1E,GAAGA,iBAAiB;YACpB,OAAGlB,0aAAA,EAA2B,CAAC,EAAE;YACjC,GAAGC,2bAA8B;YACjC,OAAGG,ubAAA,EAA6B;gBAAEO,IAAA;gBAAMG;YAAI,EAAE;YAC9C,OAAGZ,mcAAA,EAAmC;gBAAES,IAAA;gBAAMG;YAAI,EAAE;YACpD,OAAGX,ybAAA,EAA8B;gBAAEQ,IAAA;gBAAMG;YAAI,EAAA;QAC/C,CAAA;IAEA,MAAMK,iBAAA,GAAoB,UAAMpB,ybAAA,EAAqB;QACnDqB,YAAA,EAAc;QACdC,KAAA,EAAO;QACPP;IACF;IACA,MAAMQ,QAAA,GAAW,UAAMxB,+bAAA,EAA0B;QAC/CmB,UAAA;QACAM,IAAA,EAAMd,SAAA;QACNe,gBAAA,EAAkB;QAClBC,QAAA,EAAUN;IACZ;IAEA,MAAMO,MAAA,GAAS,UAAM5B,+bAAA,EAA0B;QAC7CmB,UAAA;QACAM,IAAA,EAAMP,OAAA;QACNQ,gBAAA,EAAkB;QAClBC,QAAA,EAAUN;IACZ;IAEA,MAAM,EAAEQ,IAAI,EAAEC,EAAAA,EAAI,OAAGhC,iZAAA,EAAsB;QACzC,0HAAA;QACA0B,QAAA,EAAUA,QAAA,EAAUO,MAAA,GAASP,QAAA,GAAW;QACxCI,MAAA,EAAQA,MAAA,EAAQG,MAAA,GAASH,MAAA,GAAS;IACpC;IAEA,OAAA,WAAA,OACEI,iYAAA,EAACnC,wZAAA,EAAA;QACCoC,SAAA,EAAW1B,SAAA;QACXsB,IAAA,EAAMA,IAAA;QACNhB,IAAA,EAAMA,IAAA;QACNqB,KAAA,EAAO;YACLA,KAAA,EAAOtB,KAAA,CAAMsB,KAAK;YAClBpB;QACF;QACAC,YAAA,EAAcA,YAAA;QACde,EAAA,EAAIA;;AAGV","ignoreList":[]}}]
}