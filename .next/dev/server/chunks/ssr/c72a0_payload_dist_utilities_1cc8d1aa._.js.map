{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/getBlockSelect.ts"],"sourcesContent":["import type { Block } from '../fields/config/types.js'\nimport type { SelectMode, SelectType } from '../types/index.js'\n\n/**\n * This is used for the Select API to determine the select level of a block.\n * It will ensure that `id` and `blockType` are always included in the select object.\n * @returns { blockSelect: boolean | SelectType, blockSelectMode: SelectMode }\n */\nexport const getBlockSelect = ({\n  block,\n  select,\n  selectMode,\n}: {\n  block: Block\n  select: SelectType[string]\n  selectMode: SelectMode\n}): { blockSelect: boolean | SelectType; blockSelectMode: SelectMode } => {\n  if (typeof select === 'object') {\n    let blockSelectMode = selectMode\n\n    const blocksSelect = {\n      ...select,\n    }\n\n    let blockSelect = blocksSelect[block.slug]\n\n    // sanitize `{ blocks: { cta: false }}` to `{ blocks: { cta: { id: true, blockType: true }}}`\n    if (selectMode === 'exclude' && blockSelect === false) {\n      blockSelectMode = 'include'\n\n      blockSelect = {\n        id: true,\n        blockType: true,\n      }\n    } else if (selectMode === 'include') {\n      if (!blockSelect) {\n        blockSelect = {}\n      }\n\n      if (typeof blockSelect === 'object') {\n        blockSelect = {\n          ...blockSelect,\n        }\n\n        blockSelect['id'] = true\n        blockSelect['blockType'] = true\n      }\n    }\n\n    return { blockSelect: blockSelect!, blockSelectMode }\n  }\n\n  return { blockSelect: select, blockSelectMode: selectMode }\n}\n"],"names":["getBlockSelect","block","select","selectMode","blockSelectMode","blocksSelect","blockSelect","slug","id","blockType"],"mappings":"AAGA;;;;CAIC,GACD;;;;AAAO,MAAMA,iBAAiB,CAAC,EAC7BC,KAAK,EACLC,MAAM,EACNC,UAAU,EAKX;IACC,IAAI,OAAOD,WAAW,UAAU;QAC9B,IAAIE,kBAAkBD;QAEtB,MAAME,eAAe;YACnB,GAAGH,MAAM;QACX;QAEA,IAAII,cAAcD,YAAY,CAACJ,MAAMM,IAAI,CAAC;QAE1C,6FAA6F;QAC7F,IAAIJ,eAAe,aAAaG,gBAAgB,OAAO;YACrDF,kBAAkB;YAElBE,cAAc;gBACZE,IAAI;gBACJC,WAAW;YACb;QACF,OAAO,IAAIN,eAAe,WAAW;YACnC,IAAI,CAACG,aAAa;gBAChBA,cAAc,CAAC;YACjB;YAEA,IAAI,OAAOA,gBAAgB,UAAU;gBACnCA,cAAc;oBACZ,GAAGA,WAAW;gBAChB;gBAEAA,WAAW,CAAC,KAAK,GAAG;gBACpBA,WAAW,CAAC,YAAY,GAAG;YAC7B;QACF;QAEA,OAAO;YAAEA,aAAaA;YAAcF;QAAgB;IACtD;IAEA,OAAO;QAAEE,aAAaJ;QAAQE,iBAAiBD;IAAW;AAC5D,EAAC"}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/stripUnselectedFields.ts"],"sourcesContent":["import type { Data } from '../admin/types.js'\nimport type { Field, TabAsField } from '../fields/config/types.js'\nimport type { SelectMode, SelectType } from '../types/index.js'\n\nimport { fieldAffectsData } from '../fields/config/types.js'\n\n/**\n * This is used for the Select API to strip out fields that are not selected.\n * It will mutate the given data object and determine if your recursive function should continue to run.\n * It is used within the `afterRead` hook as well as `getFormState`.\n * @returns boolean - whether or not the recursive function should continue\n */\nexport const stripUnselectedFields = ({\n  field,\n  select,\n  selectMode,\n  siblingDoc,\n}: {\n  field: Field | TabAsField\n  select: SelectType\n  selectMode: SelectMode\n  siblingDoc: Data\n}): boolean => {\n  let shouldContinue = true\n\n  if (fieldAffectsData(field) && select && selectMode && field.name) {\n    if (selectMode === 'include') {\n      if (!select[field.name]) {\n        delete siblingDoc[field.name]\n        shouldContinue = false\n      }\n    }\n\n    if (selectMode === 'exclude') {\n      if (select[field.name] === false) {\n        delete siblingDoc[field.name]\n        shouldContinue = false\n      }\n    }\n  }\n\n  return shouldContinue\n}\n"],"names":["fieldAffectsData","stripUnselectedFields","field","select","selectMode","siblingDoc","shouldContinue","name"],"mappings":";;;;AAIA,SAASA,gBAAgB,QAAQ,4BAA2B;;AAQrD,MAAMC,wBAAwB,CAAC,EACpCC,KAAK,EACLC,MAAM,EACNC,UAAU,EACVC,UAAU,EAMX;IACC,IAAIC,iBAAiB;IAErB,QAAIN,wRAAAA,EAAiBE,UAAUC,UAAUC,cAAcF,MAAMK,IAAI,EAAE;QACjE,IAAIH,eAAe,WAAW;YAC5B,IAAI,CAACD,MAAM,CAACD,MAAMK,IAAI,CAAC,EAAE;gBACvB,OAAOF,UAAU,CAACH,MAAMK,IAAI,CAAC;gBAC7BD,iBAAiB;YACnB;QACF;QAEA,IAAIF,eAAe,WAAW;YAC5B,IAAID,MAAM,CAACD,MAAMK,IAAI,CAAC,KAAK,OAAO;gBAChC,OAAOF,UAAU,CAACH,MAAMK,IAAI,CAAC;gBAC7BD,iBAAiB;YACnB;QACF;IACF;IAEA,OAAOA;AACT,EAAC"}},
    {"offset": {"line": 80, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/deepCopyObject.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { JsonValue } from '../types/index.js'\n\n/*\nMain deepCopyObject handling - from rfdc: https://github.com/davidmarkclements/rfdc/blob/master/index.js\n\nCopyright 2019 \"David Mark Clements <david.mark.clements@gmail.com>\"\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\ndocumentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\nthe rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and\nto permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions\nof the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\nTO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\nCONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.\n*/\n\nfunction copyBuffer(cur: any) {\n  if (cur instanceof Buffer) {\n    return Buffer.from(cur)\n  }\n\n  return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length)\n}\n\nconst constructorHandlers = new Map()\nconstructorHandlers.set(Date, (o: any) => new Date(o))\nconstructorHandlers.set(Map, (o: any, fn: any) => new Map(cloneArray<any>(Array.from(o), fn)))\nconstructorHandlers.set(Set, (o: any, fn: any) => new Set(cloneArray(Array.from(o), fn)))\nconstructorHandlers.set(RegExp, (regex: RegExp) => new RegExp(regex.source, regex.flags))\n\nlet handler: ((o: any, fn: any) => any) | null = null\n\nfunction cloneArray<T extends object>(a: T, fn: (o: any) => any): T {\n  const keys = Object.keys(a)\n  const a2 = new Array(keys.length) as T\n  for (let i = 0; i < keys.length; i++) {\n    const k = keys[i] as keyof typeof a\n    const cur = a[k] as any\n    if (typeof cur !== 'object' || cur === null) {\n      a2[k] = cur\n    } else if (cur instanceof RegExp) {\n      a2[k] = new RegExp(cur.source, cur.flags) as any\n    } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {\n      a2[k] = handler(cur, fn)\n    } else if (ArrayBuffer.isView(cur)) {\n      a2[k] = copyBuffer(cur)\n    } else {\n      a2[k] = fn(cur)\n    }\n  }\n  return a2\n}\n\nexport const deepCopyObject = <T>(o: T): T => {\n  if (typeof o !== 'object' || o === null) {\n    return o\n  }\n  if (Array.isArray(o)) {\n    return cloneArray(o, deepCopyObject)\n  }\n  if (o instanceof RegExp) {\n    return new RegExp(o.source, o.flags) as T\n  }\n\n  if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {\n    return handler(o, deepCopyObject)\n  }\n  const o2 = {} as T\n  for (const k in o) {\n    if (Object.hasOwnProperty.call(o, k) === false) {\n      continue\n    }\n    const cur = o[k]\n    if (typeof cur !== 'object' || cur === null) {\n      o2[k] = cur\n    } else if (cur instanceof RegExp) {\n      o2[k] = new RegExp(cur.source, cur.flags) as any\n    } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {\n      o2[k] = handler(cur, deepCopyObject)\n    } else if (ArrayBuffer.isView(cur)) {\n      o2[k] = copyBuffer(cur)\n    } else {\n      o2[k] = deepCopyObject(cur)\n    }\n  }\n  return o2\n}\n\n/*\nFast deepCopyObjectSimple handling - from fast-json-clone: https://github.com/rhysd/fast-json-clone\n\nBenchmark: https://github.com/AlessioGr/fastest-deep-clone-json/blob/main/test/benchmark.js\n*/\n\n/**\n * A deepCopyObject implementation which only works for JSON objects and arrays, and is faster than\n * JSON.parse(JSON.stringify(obj))\n *\n * @param value The JSON value to be cloned. There are two invariants. 1) It must not contain circles\n *              as JSON does not allow it. This function will cause infinite loop for such values by\n *              design. 2) It must contain JSON values only. Other values like `Date`, `Regexp`, `Map`,\n *              `Set`, `Buffer`, ... are not allowed.\n * @returns The cloned JSON value.\n */\nexport function deepCopyObjectSimple<T extends JsonValue>(value: T, filterUndefined = false): T {\n  if (typeof value !== 'object' || value === null) {\n    return value\n  } else if (Array.isArray(value)) {\n    return value.map((e) =>\n      typeof e !== 'object' || e === null ? e : deepCopyObjectSimple(e, filterUndefined),\n    ) as T\n  } else {\n    if (value instanceof Date) {\n      return new Date(value) as unknown as T\n    }\n    const ret: { [key: string]: T } = {}\n    for (const k in value) {\n      const v = value[k]\n      if (filterUndefined && v === undefined) {\n        continue\n      }\n      ret[k] =\n        typeof v !== 'object' || v === null\n          ? v\n          : (deepCopyObjectSimple(v as T, filterUndefined) as any)\n    }\n    return ret as unknown as T\n  }\n}\n\nexport function deepCopyObjectSimpleWithoutReactComponents<T extends JsonValue>(value: T): T {\n  if (\n    typeof value === 'object' &&\n    value !== null &&\n    '$$typeof' in value &&\n    typeof value.$$typeof === 'symbol'\n  ) {\n    return undefined!\n  } else if (typeof value !== 'object' || value === null) {\n    return value\n  } else if (Array.isArray(value)) {\n    return value.map((e) =>\n      typeof e !== 'object' || e === null ? e : deepCopyObjectSimpleWithoutReactComponents(e),\n    ) as T\n  } else {\n    if (value instanceof Date) {\n      return new Date(value) as unknown as T\n    }\n    const ret: { [key: string]: T } = {}\n    for (const k in value) {\n      const v = value[k]\n      ret[k] =\n        typeof v !== 'object' || v === null\n          ? v\n          : (deepCopyObjectSimpleWithoutReactComponents(v as T) as any)\n    }\n    return ret as unknown as T\n  }\n}\n\n/**\n * A deepCopyObject implementation which is slower than deepCopyObject, but more correct.\n * Can be used if correctness is more important than speed. Supports circular dependencies\n */\nexport function deepCopyObjectComplex<T>(object: T, cache: WeakMap<any, any> = new WeakMap()): T {\n  if (object === null) {\n    return null!\n  }\n\n  if (cache.has(object)) {\n    return cache.get(object)\n  }\n\n  // Handle File\n  if (object instanceof File) {\n    return object as unknown as T\n  }\n\n  // Handle Date\n  if (object instanceof Date) {\n    return new Date(object.getTime()) as unknown as T\n  }\n\n  // Handle RegExp\n  if (object instanceof RegExp) {\n    return new RegExp(object.source, object.flags) as unknown as T\n  }\n\n  // Handle Map\n  if (object instanceof Map) {\n    const clonedMap = new Map()\n    cache.set(object, clonedMap)\n    for (const [key, value] of object.entries()) {\n      clonedMap.set(key, deepCopyObjectComplex(value, cache))\n    }\n    return clonedMap as unknown as T\n  }\n\n  // Handle Set\n  if (object instanceof Set) {\n    const clonedSet = new Set()\n    cache.set(object, clonedSet)\n    for (const value of object.values()) {\n      clonedSet.add(deepCopyObjectComplex(value, cache))\n    }\n    return clonedSet as unknown as T\n  }\n\n  // Handle Array and Object\n  if (typeof object === 'object' && object !== null) {\n    if ('$$typeof' in object && typeof object.$$typeof === 'symbol') {\n      return object\n    }\n\n    const clonedObject: any = Array.isArray(object)\n      ? []\n      : Object.create(Object.getPrototypeOf(object))\n    cache.set(object, clonedObject)\n\n    for (const key in object) {\n      if (\n        Object.prototype.hasOwnProperty.call(object, key) ||\n        Object.getOwnPropertySymbols(object).includes(key as any)\n      ) {\n        clonedObject[key] = deepCopyObjectComplex(object[key], cache)\n      }\n    }\n\n    return clonedObject as T\n  }\n\n  // Handle all other cases\n  return object\n}\n"],"names":["copyBuffer","cur","Buffer","from","constructor","buffer","slice","byteOffset","length","constructorHandlers","Map","set","Date","o","fn","cloneArray","Array","Set","RegExp","regex","source","flags","handler","a","keys","Object","a2","i","k","get","ArrayBuffer","isView","deepCopyObject","isArray","o2","hasOwnProperty","call","deepCopyObjectSimple","value","filterUndefined","map","e","ret","v","undefined","deepCopyObjectSimpleWithoutReactComponents","$$typeof","deepCopyObjectComplex","object","cache","WeakMap","has","File","getTime","clonedMap","key","entries","clonedSet","values","add","clonedObject","create","getPrototypeOf","prototype","getOwnPropertySymbols","includes"],"mappings":"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"}},
    {"offset": {"line": 270, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/isValidID.ts"],"sourcesContent":["import ObjectIdImport from 'bson-objectid'\n\nconst ObjectId = 'default' in ObjectIdImport ? ObjectIdImport.default : ObjectIdImport\n\nexport const isValidID = (\n  value: number | string,\n  type: 'number' | 'ObjectID' | 'text',\n  // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n): boolean => {\n  if (type === 'text' && value) {\n    if (['object', 'string'].includes(typeof value)) {\n      const isObjectID = ObjectId.isValid(value as string)\n      return typeof value === 'string' || isObjectID\n    }\n    return false\n  }\n\n  if (typeof value === 'number' && !Number.isNaN(value)) {\n    return true\n  }\n\n  if (type === 'ObjectID') {\n    return ObjectId.isValid(String(value))\n  }\n}\n"],"names":["ObjectIdImport","ObjectId","default","isValidID","value","type","includes","isObjectID","isValid","Number","isNaN","String"],"mappings":";;;;AAAA,OAAOA,oBAAoB,gBAAe;;AAE1C,MAAMC,WAAW,aAAaD,oNAAAA,GAAiBA,oNAAAA,CAAeE,OAAO,GAAGF,oNAAAA;AAEjE,MAAMG,YAAY,CACvBC,OACAC;IAGA,IAAIA,SAAS,UAAUD,OAAO;QAC5B,IAAI;YAAC;YAAU;SAAS,CAACE,QAAQ,CAAC,OAAOF,QAAQ;YAC/C,MAAMG,aAAaN,SAASO,OAAO,CAACJ;YACpC,OAAO,OAAOA,UAAU,YAAYG;QACtC;QACA,OAAO;IACT;IAEA,IAAI,OAAOH,UAAU,YAAY,CAACK,OAAOC,KAAK,CAACN,QAAQ;QACrD,OAAO;IACT;IAEA,IAAIC,SAAS,YAAY;QACvB,OAAOJ,SAASO,OAAO,CAACG,OAAOP;IACjC;AACF,EAAC"}},
    {"offset": {"line": 299, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/isNumber.ts"],"sourcesContent":["export function isNumber(value: unknown): value is number {\n  if (value === null || value === undefined || (typeof value === 'string' && value.trim() === '')) {\n    return false\n  }\n\n  return !Number.isNaN(Number(value))\n}\n"],"names":["isNumber","value","undefined","trim","Number","isNaN"],"mappings":";;;;AAAO,SAASA,SAASC,KAAc;IACrC,IAAIA,UAAU,QAAQA,UAAUC,aAAc,OAAOD,UAAU,YAAYA,MAAME,IAAI,OAAO,IAAK;QAC/F,OAAO;IACT;IAEA,OAAO,CAACC,OAAOC,KAAK,CAACD,OAAOH;AAC9B"}},
    {"offset": {"line": 313, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/isReactComponent.ts"],"sourcesContent":["import type React from 'react'\n\nconst clientRefSymbol = Symbol.for('react.client.reference')\n\nexport function isReactServerComponentOrFunction<T extends any>(\n  component: any | React.ComponentType,\n): component is T {\n  return typeof component === 'function' && component.$$typeof !== clientRefSymbol\n}\n\nexport function isReactClientComponent<T extends any>(\n  component: any | React.ComponentType,\n): component is T {\n  return typeof component === 'function' && component.$$typeof === clientRefSymbol\n}\n\nexport function isReactComponentOrFunction<T extends any>(\n  component: any | React.ComponentType,\n): component is T {\n  return typeof component === 'function'\n}\n"],"names":["clientRefSymbol","Symbol","for","isReactServerComponentOrFunction","component","$$typeof","isReactClientComponent","isReactComponentOrFunction"],"mappings":";;;;;;;;AAEA,MAAMA,kBAAkBC,OAAOC,GAAG,CAAC;AAE5B,SAASC,iCACdC,SAAoC;IAEpC,OAAO,OAAOA,cAAc,cAAcA,UAAUC,QAAQ,KAAKL;AACnE;AAEO,SAASM,uBACdF,SAAoC;IAEpC,OAAO,OAAOA,cAAc,cAAcA,UAAUC,QAAQ,KAAKL;AACnE;AAEO,SAASO,2BACdH,SAAoC;IAEpC,OAAO,OAAOA,cAAc;AAC9B"}},
    {"offset": {"line": 335, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/isPlainObject.ts"],"sourcesContent":["import { isReactComponentOrFunction } from './isReactComponent.js'\n\nexport function isPlainObject(o: any): boolean {\n  // Is this a React component?\n  if (isReactComponentOrFunction(o)) {\n    return false\n  }\n\n  // from https://github.com/fastify/deepmerge/blob/master/index.js#L77\n  return typeof o === 'object' && o !== null && !(o instanceof RegExp) && !(o instanceof Date)\n}\n"],"names":["isReactComponentOrFunction","isPlainObject","o","RegExp","Date"],"mappings":";;;;AAAA,SAASA,0BAA0B,QAAQ,wBAAuB;;AAE3D,SAASC,cAAcC,CAAM;IAClC,6BAA6B;IAC7B,QAAIF,sSAAAA,EAA2BE,IAAI;QACjC,OAAO;IACT;IAEA,qEAAqE;IACrE,OAAO,OAAOA,MAAM,YAAYA,MAAM,QAAQ,CAAEA,CAAAA,aAAaC,MAAK,KAAM,CAAED,CAAAA,aAAaE,IAAG;AAC5F"}},
    {"offset": {"line": 353, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/deepMerge.ts"],"sourcesContent":["import deepMerge from 'deepmerge'\n\nimport { isPlainObject } from './isPlainObject.js'\n\nexport { deepMerge }\n/**\n * Fully-featured deepMerge.\n *\n * Array handling: Arrays in the target object are combined with the source object's arrays.\n */\nexport function deepMergeWithCombinedArrays<T extends object>(\n  obj1: object,\n  obj2: object,\n  options: deepMerge.Options = {},\n): T {\n  return deepMerge<T>(obj1, obj2, {\n    arrayMerge: (target, source, options) => {\n      const destination = target.slice()\n\n      source.forEach((item, index) => {\n        if (typeof destination[index] === 'undefined') {\n          destination[index] = options?.cloneUnlessOtherwiseSpecified(item, options)\n        } else if (options?.isMergeableObject(item)) {\n          destination[index] = deepMerge(target[index], item, options)\n        } else if (target.indexOf(item) === -1) {\n          destination.push(item)\n        }\n      })\n      return destination\n    },\n    ...options,\n  })\n}\n\n/**\n * Fully-featured deepMerge.\n *\n * Array handling: Arrays in the target object are replaced by the source object's arrays.\n */\nexport function deepMergeWithSourceArrays<T extends object>(obj1: object, obj2: object): T {\n  return deepMerge<T>(obj1, obj2, { arrayMerge: (_, source) => source })\n}\n\n/**\n * Fully-featured deepMerge. Does not clone React components by default.\n */\nexport function deepMergeWithReactComponents<T extends object>(obj1: object, obj2: object): T {\n  return deepMerge<T>(obj1, obj2, {\n    isMergeableObject: isPlainObject,\n  })\n}\n"],"names":["deepMerge","isPlainObject","deepMergeWithCombinedArrays","obj1","obj2","options","arrayMerge","target","source","destination","slice","forEach","item","index","cloneUnlessOtherwiseSpecified","isMergeableObject","indexOf","push","deepMergeWithSourceArrays","_","deepMergeWithReactComponents"],"mappings":";;;;;;;;AAAA,OAAOA,eAAe,YAAW;AAEjC,SAASC,aAAa,QAAQ,qBAAoB;;;;AAQ3C,SAASC,4BACdC,IAAY,EACZC,IAAY,EACZC,UAA6B,CAAC,CAAC;IAE/B,WAAOL,yMAAAA,EAAaG,MAAMC,MAAM;QAC9BE,YAAY,CAACC,QAAQC,QAAQH;YAC3B,MAAMI,cAAcF,OAAOG,KAAK;YAEhCF,OAAOG,OAAO,CAAC,CAACC,MAAMC;gBACpB,IAAI,OAAOJ,WAAW,CAACI,MAAM,KAAK,aAAa;oBAC7CJ,WAAW,CAACI,MAAM,GAAGR,SAASS,8BAA8BF,MAAMP;gBACpE,OAAO,IAAIA,SAASU,kBAAkBH,OAAO;oBAC3CH,WAAW,CAACI,MAAM,OAAGb,yMAAAA,EAAUO,MAAM,CAACM,MAAM,EAAED,MAAMP;gBACtD,OAAO,IAAIE,OAAOS,OAAO,CAACJ,UAAU,CAAC,GAAG;oBACtCH,YAAYQ,IAAI,CAACL;gBACnB;YACF;YACA,OAAOH;QACT;QACA,GAAGJ,OAAO;IACZ;AACF;AAOO,SAASa,0BAA4Cf,IAAY,EAAEC,IAAY;IACpF,WAAOJ,yMAAAA,EAAaG,MAAMC,MAAM;QAAEE,YAAY,CAACa,GAAGX,SAAWA;IAAO;AACtE;AAKO,SAASY,6BAA+CjB,IAAY,EAAEC,IAAY;IACvF,WAAOJ,yMAAAA,EAAaG,MAAMC,MAAM;QAC9BW,mBAAmBd,sRAAAA;IACrB;AACF"}},
    {"offset": {"line": 398, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/getTranslatedLabel.ts"],"sourcesContent":["import { getTranslation, type I18n } from '@payloadcms/translations'\n\nimport type { LabelFunction, StaticLabel } from '../config/types.js'\n\nexport const getTranslatedLabel = (\n  label: LabelFunction | StaticLabel | undefined,\n  i18n?: I18n,\n): string | undefined => {\n  if (typeof label === 'function') {\n    return label({ i18n: i18n!, t: i18n!.t })\n  }\n\n  if (typeof label === 'object') {\n    return getTranslation(label, i18n!)\n  }\n\n  return label\n}\n"],"names":["getTranslation","getTranslatedLabel","label","i18n","t"],"mappings":";;;;AAAA,SAASA,cAAc,QAAmB,2BAA0B;;AAI7D,MAAMC,qBAAqB,CAChCC,OACAC;IAEA,IAAI,OAAOD,UAAU,YAAY;QAC/B,OAAOA,MAAM;YAAEC,MAAMA;YAAOC,GAAGD,KAAMC,CAAC;QAAC;IACzC;IAEA,IAAI,OAAOF,UAAU,UAAU;QAC7B,WAAOF,+QAAAA,EAAeE,OAAOC;IAC/B;IAEA,OAAOD;AACT,EAAC"}},
    {"offset": {"line": 420, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/findUp.ts"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\n\n/**\n * Synchronously walks up parent directories until a condition is met and/or one of the file names within the fileNames array is found.\n */\nexport function findUpSync({\n  condition,\n  dir,\n  fileNames,\n}: {\n  condition?: (dir: string) => boolean | Promise<boolean | string> | string\n  dir: string\n  fileNames?: string[]\n}): null | string {\n  const { root } = path.parse(dir)\n\n  while (true) {\n    if (fileNames?.length) {\n      let found = false\n      for (const fileName of fileNames) {\n        const filePath = path.join(dir, fileName)\n        const exists = pathExistsAndIsAccessibleSync(filePath)\n        if (exists) {\n          if (!condition) {\n            return filePath\n          }\n          found = true\n          break\n        }\n      }\n      if (!found && dir !== root) {\n        dir = path.dirname(dir) // Move up one directory level.\n        continue\n      }\n    }\n    const result = condition?.(dir)\n    if (result === true) {\n      return dir\n    }\n    if (typeof result === 'string' && result?.length) {\n      return result\n    }\n    if (dir === root) {\n      return null // Reached the root directory without a match.\n    }\n    dir = path.dirname(dir) // Move up one directory level.\n  }\n}\n\n/**\n * Asynchronously walks up parent directories until a condition is met and/or one of the file names within the fileNames array is found.\n */\nexport async function findUp({\n  condition,\n  dir,\n  fileNames,\n}: {\n  condition?: (dir: string) => boolean | Promise<boolean | string> | string\n  dir: string\n  fileNames?: string[]\n}): Promise<null | string> {\n  const { root } = path.parse(dir)\n\n  while (true) {\n    if (fileNames?.length) {\n      let found = false\n      for (const fileName of fileNames) {\n        const filePath = path.resolve(dir, fileName)\n        const exists = await pathExistsAndIsAccessible(filePath)\n        if (exists) {\n          if (!condition) {\n            return filePath\n          }\n          found = true\n          break\n        }\n      }\n      if (!found && dir !== root) {\n        dir = path.dirname(dir) // Move up one directory level.\n        continue\n      }\n    }\n    const result = await condition?.(dir)\n    if (result === true) {\n      return dir\n    }\n    if (typeof result === 'string' && result?.length) {\n      return result\n    }\n    if (dir === root) {\n      return null // Reached the root directory without a match.\n    }\n    dir = path.dirname(dir) // Move up one directory level.\n  }\n}\n\n// From https://github.com/sindresorhus/path-exists/blob/main/index.js\n// fs.accessSync is preferred over fs.existsSync as it's usually a good idea\n// to check if the process has permission to read/write to a file before doing so.\n// Also see https://github.com/nodejs/node/issues/39960\nexport function pathExistsAndIsAccessibleSync(path: string) {\n  try {\n    fs.accessSync(path)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport async function pathExistsAndIsAccessible(path: string) {\n  try {\n    await fs.promises.access(path)\n    return true\n  } catch {\n    return false\n  }\n}\n"],"names":["fs","path","findUpSync","condition","dir","fileNames","root","parse","length","found","fileName","filePath","join","exists","pathExistsAndIsAccessibleSync","dirname","result","findUp","resolve","pathExistsAndIsAccessible","accessSync","promises","access"],"mappings":";;;;;;;;;;AAAA,OAAOA,QAAQ,KAAI;AACnB,OAAOC,UAAU,OAAM;;;AAKhB,SAASC,WAAW,EACzBC,SAAS,EACTC,GAAG,EACHC,SAAS,EAKV;IACC,MAAM,EAAEC,IAAI,EAAE,GAAGL,4GAAAA,CAAKM,KAAK,CAACH;IAE5B,MAAO,KAAM;QACX,IAAIC,WAAWG,QAAQ;YACrB,IAAIC,QAAQ;YACZ,KAAK,MAAMC,YAAYL,UAAW;gBAChC,MAAMM,WAAWV,4GAAAA,CAAKW,IAAI,CAACR,KAAKM;gBAChC,MAAMG,SAASC,8BAA8BH;gBAC7C,IAAIE,QAAQ;oBACV,IAAI,CAACV,WAAW;wBACd,OAAOQ;oBACT;oBACAF,QAAQ;oBACR;gBACF;YACF;YACA,IAAI,CAACA,SAASL,QAAQE,MAAM;gBAC1BF,MAAMH,4GAAAA,CAAKc,OAAO,CAACX,KAAK,+BAA+B;;gBACvD;YACF;QACF;QACA,MAAMY,SAASb,YAAYC;QAC3B,IAAIY,WAAW,MAAM;YACnB,OAAOZ;QACT;QACA,IAAI,OAAOY,WAAW,YAAYA,QAAQR,QAAQ;YAChD,OAAOQ;QACT;QACA,IAAIZ,QAAQE,MAAM;YAChB,OAAO,KAAK,8CAA8C;;QAC5D;QACAF,MAAMH,4GAAAA,CAAKc,OAAO,CAACX,KAAK,+BAA+B;;IACzD;AACF;AAKO,eAAea,OAAO,EAC3Bd,SAAS,EACTC,GAAG,EACHC,SAAS,EAKV;IACC,MAAM,EAAEC,IAAI,EAAE,GAAGL,4GAAAA,CAAKM,KAAK,CAACH;IAE5B,MAAO,KAAM;QACX,IAAIC,WAAWG,QAAQ;YACrB,IAAIC,QAAQ;YACZ,KAAK,MAAMC,YAAYL,UAAW;gBAChC,MAAMM,WAAWV,4GAAAA,CAAKiB,OAAO,CAACd,KAAKM;gBACnC,MAAMG,SAAS,MAAMM,0BAA0BR;gBAC/C,IAAIE,QAAQ;oBACV,IAAI,CAACV,WAAW;wBACd,OAAOQ;oBACT;oBACAF,QAAQ;oBACR;gBACF;YACF;YACA,IAAI,CAACA,SAASL,QAAQE,MAAM;gBAC1BF,MAAMH,4GAAAA,CAAKc,OAAO,CAACX,KAAK,+BAA+B;;gBACvD;YACF;QACF;QACA,MAAMY,SAAS,MAAMb,YAAYC;QACjC,IAAIY,WAAW,MAAM;YACnB,OAAOZ;QACT;QACA,IAAI,OAAOY,WAAW,YAAYA,QAAQR,QAAQ;YAChD,OAAOQ;QACT;QACA,IAAIZ,QAAQE,MAAM;YAChB,OAAO,KAAK,8CAA8C;;QAC5D;QACAF,MAAMH,4GAAAA,CAAKc,OAAO,CAACX,KAAK,+BAA+B;;IACzD;AACF;AAMO,SAASU,8BAA8Bb,IAAY;IACxD,IAAI;QACFD,wGAAAA,CAAGoB,UAAU,CAACnB;QACd,OAAO;IACT,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,eAAekB,0BAA0BlB,IAAY;IAC1D,IAAI;QACF,MAAMD,wGAAAA,CAAGqB,QAAQ,CAACC,MAAM,CAACrB;QACzB,OAAO;IACT,EAAE,OAAM;QACN,OAAO;IACT;AACF"}},
    {"offset": {"line": 528, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/dependencies/isError.ts"],"sourcesContent":["/*\n  This source code has been taken and modified from https://github.com/vercel/next.js/blob/be87132327ea28acd4bf7af09a401bac2374cb64/packages/next/src/lib/is-error.ts\n\n  License:\n\n  The MIT License (MIT)\n\n  Copyright (c) 2024 Vercel, Inc.\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nexport interface ErrorWithCode extends Error {\n  code?: number | string\n}\n\nexport function isError(err: unknown): err is ErrorWithCode {\n  return typeof err === 'object' && err !== null && 'name' in err && 'message' in err\n}\n"],"names":["isError","err"],"mappings":"AAAA;;;;;;;;;;;;;;AAcA,GAMA;;;;AAAO,SAASA,QAAQC,GAAY;IAClC,OAAO,OAAOA,QAAQ,YAAYA,QAAQ,QAAQ,UAAUA,OAAO,aAAaA;AAClF"}},
    {"offset": {"line": 553, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/dependencies/realPath.ts"],"sourcesContent":["/*\n  This source code has been taken from https://github.com/vercel/next.js/blob/39498d604c3b25d92a483153fe648a7ee456fbda/packages/next/src/lib/realpath.ts\n\n  License:\n\n  The MIT License (MIT)\n\n  Copyright (c) 2024 Vercel, Inc.\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nimport fs from 'fs'\n\nconst isWindows = process.platform === 'win32'\n\n// Interesting learning from this, that fs.realpathSync is 70x slower than fs.realpathSync.native:\n// https://sun0day.github.io/blog/vite/why-vite4_3-is-faster.html#fs-realpathsync-issue\n// https://github.com/nodejs/node/issues/2680\n// However, we can't use fs.realpathSync.native on Windows due to behavior differences.\nexport const realpathSync = isWindows ? fs.realpathSync : fs.realpathSync.native\n"],"names":["fs","isWindows","process","platform","realpathSync","native"],"mappings":";;;;AAAA;;;;;;;;;;;;;;AAcA,GACA,OAAOA,QAAQ,KAAI;;AAEnB,MAAMC,YAAYC,QAAQC,QAAQ,KAAK;AAMhC,MAAMC,eAAeH,sCAAYD,GAAGI,YAAY,WAAGJ,wGAAAA,CAAGI,YAAY,CAACC,MAAM,CAAA"}},
    {"offset": {"line": 579, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/dependencies/resolveFrom.ts"],"sourcesContent":["/*\n  This source code has been taken and modified from https://github.com/vercel/next.js/blob/39498d604c3b25d92a483153fe648a7ee456fbda/packages/next/src/lib/resolve-from.ts\n\n  License:\n\n  The MIT License (MIT)\n\n  Copyright (c) 2024 Vercel, Inc.\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n// source: https://github.com/sindresorhus/resolve-from\nimport { createRequire } from 'module'\nimport path from 'path'\n\nimport { isError } from './isError.js'\nimport { realpathSync } from './realPath.js'\n\nexport const resolveFrom = (fromDirectory: string, moduleId: string, silent?: boolean) => {\n  if (typeof fromDirectory !== 'string') {\n    throw new TypeError(\n      `Expected \\`fromDir\\` to be of type \\`string\\`, got \\`${typeof fromDirectory}\\``,\n    )\n  }\n\n  if (typeof moduleId !== 'string') {\n    throw new TypeError(\n      `Expected \\`moduleId\\` to be of type \\`string\\`, got \\`${typeof moduleId}\\``,\n    )\n  }\n\n  try {\n    fromDirectory = realpathSync(fromDirectory)\n  } catch (error: unknown) {\n    if (isError(error) && error.code === 'ENOENT') {\n      fromDirectory = path.resolve(fromDirectory)\n    } else if (silent) {\n      return\n    } else {\n      throw error\n    }\n  }\n\n  const fromFile = path.join(fromDirectory, 'noop.js')\n\n  const require = createRequire(import.meta.url)\n\n  const Module = require('module')\n\n  const resolveFileName = () => {\n    return Module._resolveFilename(moduleId, {\n      id: fromFile,\n      filename: fromFile,\n      paths: Module._nodeModulePaths(fromDirectory),\n    })\n  }\n\n  if (silent) {\n    try {\n      return resolveFileName()\n    } catch (ignore) {\n      return\n    }\n  }\n\n  return resolveFileName()\n}\n"],"names":["createRequire","path","isError","realpathSync","resolveFrom","fromDirectory","moduleId","silent","TypeError","error","code","resolve","fromFile","join","require","url","Module","resolveFileName","_resolveFilename","id","filename","paths","_nodeModulePaths","ignore"],"mappings":";;;;AAAA;;;;;;;;;;;;;;AAcA,GAEA,uDAAuD;AACvD,SAASA,aAAa,QAAQ,SAAQ;AACtC,OAAOC,UAAU,OAAM;AAEvB,SAASC,OAAO,QAAQ,eAAc;AACtC,SAASC,YAAY,QAAQ,gBAAe;;;;;;;;;;AAErC,MAAMC,cAAc,CAACC,eAAuBC,UAAkBC;IACnE,IAAI,OAAOF,kBAAkB,UAAU;QACrC,MAAM,IAAIG,UACR,CAAC,qDAAqD,EAAE,OAAOH,cAAc,EAAE,CAAC;IAEpF;IAEA,IAAI,OAAOC,aAAa,UAAU;QAChC,MAAM,IAAIE,UACR,CAAC,sDAAsD,EAAE,OAAOF,SAAS,EAAE,CAAC;IAEhF;IAEA,IAAI;QACFD,oBAAgBF,gSAAAA,EAAaE;IAC/B,EAAE,OAAOI,OAAgB;QACvB,QAAIP,0RAAAA,EAAQO,UAAUA,MAAMC,IAAI,KAAK,UAAU;YAC7CL,gBAAgBJ,4GAAAA,CAAKU,OAAO,CAACN;QAC/B,OAAO,IAAIE,QAAQ;YACjB;QACF,OAAO;YACL,MAAME;QACR;IACF;IAEA,MAAMG,WAAWX,4GAAAA,CAAKY,IAAI,CAACR,eAAe;IAE1C,MAAMS,cAAUd,sHAAAA,EAAc,8BAAYe,GAAG;IAE7C,MAAMC,SAASF,QAAQ;IAEvB,MAAMG,kBAAkB;QACtB,OAAOD,OAAOE,gBAAgB,CAACZ,UAAU;YACvCa,IAAIP;YACJQ,UAAUR;YACVS,OAAOL,OAAOM,gBAAgB,CAACjB;QACjC;IACF;IAEA,IAAIE,QAAQ;QACV,IAAI;YACF,OAAOU;QACT,EAAE,OAAOM,QAAQ;YACf;QACF;IACF;IAEA,OAAON;AACT,EAAC"}},
    {"offset": {"line": 652, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/dependencies/getDependencies.ts"],"sourcesContent":["/*\n  This source code has been taken and modified from https://github.com/vercel/next.js/blob/41a80533f900467e1b788bd2673abe2dca20be6a/packages/next/src/lib/has-necessary-dependencies.ts\n\n  License:\n\n  The MIT License (MIT)\n\n  Copyright (c) 2024 Vercel, Inc.\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport { promises as fs } from 'fs'\nimport path from 'path'\nimport { fileURLToPath } from 'url'\n\nimport { findUp } from '../findUp.js'\nimport { resolveFrom } from './resolveFrom.js'\n\nconst filename = fileURLToPath(import.meta.url)\nconst dirname = path.dirname(filename)\n\nconst payloadPkgDirname = path.resolve(dirname, '../../../') // pkg dir (outside src)\n\nconst resolvedCwd = path.resolve(process.cwd())\n\nexport type NecessaryDependencies = {\n  missing: string[]\n  resolved: Map<\n    string,\n    {\n      path: string\n      version: string\n    }\n  >\n}\n\nexport async function getDependencies(\n  baseDir: string,\n  requiredPackages: string[],\n): Promise<NecessaryDependencies> {\n  const resolutions = new Map<\n    string,\n    {\n      path: string\n      version: string\n    }\n  >()\n  const missingPackages: string[] = []\n\n  await Promise.all(\n    requiredPackages.map(async (pkg) => {\n      try {\n        const pkgPath = await fs.realpath(resolveFrom(baseDir, pkg))\n        const pkgDir = path.dirname(pkgPath)\n\n        let packageJsonFilePath: null | string = null\n\n        const foundPackageJsonDir = await findUp({\n          dir: pkgDir,\n          fileNames: ['package.json'],\n        })\n\n        if (foundPackageJsonDir) {\n          const resolvedFoundPath = path.resolve(foundPackageJsonDir)\n\n          if (\n            resolvedFoundPath.startsWith(resolvedCwd) ||\n            resolvedFoundPath.startsWith(payloadPkgDirname)\n          ) {\n            // We don't want to match node modules outside the user's project. Checking for both process.cwd and dirname is a reliable way to do this.\n            packageJsonFilePath = resolvedFoundPath\n          }\n        }\n\n        // No need to check if packageJsonFilePath exists - findUp checks that for us\n        if (packageJsonFilePath) {\n          // parse version\n          const packageJson = JSON.parse(await fs.readFile(packageJsonFilePath, 'utf8'))\n          const version = packageJson.version\n\n          resolutions.set(pkg, {\n            path: packageJsonFilePath,\n            version,\n          })\n        } else {\n          return missingPackages.push(pkg)\n        }\n      } catch (_) {\n        return missingPackages.push(pkg)\n      }\n    }),\n  )\n\n  return {\n    missing: missingPackages,\n    resolved: resolutions,\n  }\n}\n"],"names":["promises","fs","path","fileURLToPath","findUp","resolveFrom","filename","url","dirname","payloadPkgDirname","resolve","resolvedCwd","process","cwd","getDependencies","baseDir","requiredPackages","resolutions","Map","missingPackages","Promise","all","map","pkg","pkgPath","realpath","pkgDir","packageJsonFilePath","foundPackageJsonDir","dir","fileNames","resolvedFoundPath","startsWith","packageJson","JSON","parse","readFile","version","set","push","_","missing","resolved"],"mappings":";;;;AAAA;;;;;;;;;;;;;;AAcA,GAEA,SAASA,YAAYC,EAAE,QAAQ,KAAI;AACnC,OAAOC,UAAU,OAAM;AACvB,SAASC,aAAa,QAAQ,MAAK;AAEnC,SAASC,MAAM,QAAQ,eAAc;AACrC,SAASC,WAAW,QAAQ,mBAAkB;;;;;;;;;;;AAE9C,MAAMC,eAAWH,gHAAAA,EAAc,8BAAYI,GAAG;AAC9C,MAAMC,UAAUN,4GAAAA,CAAKM,OAAO,CAACF;AAE7B,MAAMG,oBAAoBP,4GAAAA,CAAKQ,OAAO,CAACF,SAAS,aAAa,wBAAwB;;AAErF,MAAMG,cAAcT,4GAAAA,CAAKQ,OAAO,CAACE,QAAQC,GAAG;AAarC,eAAeC,gBACpBC,OAAe,EACfC,gBAA0B;IAE1B,MAAMC,cAAc,IAAIC;IAOxB,MAAMC,kBAA4B,EAAE;IAEpC,MAAMC,QAAQC,GAAG,CACfL,iBAAiBM,GAAG,CAAC,OAAOC;QAC1B,IAAI;YACF,MAAMC,UAAU,MAAMvB,yGAAAA,CAAGwB,QAAQ,KAACpB,kSAAAA,EAAYU,SAASQ;YACvD,MAAMG,SAASxB,4GAAAA,CAAKM,OAAO,CAACgB;YAE5B,IAAIG,sBAAqC;YAEzC,MAAMC,sBAAsB,UAAMxB,wQAAAA,EAAO;gBACvCyB,KAAKH;gBACLI,WAAW;oBAAC;iBAAe;YAC7B;YAEA,IAAIF,qBAAqB;gBACvB,MAAMG,oBAAoB7B,4GAAAA,CAAKQ,OAAO,CAACkB;gBAEvC,IACEG,kBAAkBC,UAAU,CAACrB,gBAC7BoB,kBAAkBC,UAAU,CAACvB,oBAC7B;oBACA,0IAA0I;oBAC1IkB,sBAAsBI;gBACxB;YACF;YAEA,6EAA6E;YAC7E,IAAIJ,qBAAqB;gBACvB,gBAAgB;gBAChB,MAAMM,cAAcC,KAAKC,KAAK,CAAC,MAAMlC,yGAAAA,CAAGmC,QAAQ,CAACT,qBAAqB;gBACtE,MAAMU,UAAUJ,YAAYI,OAAO;gBAEnCpB,YAAYqB,GAAG,CAACf,KAAK;oBACnBrB,MAAMyB;oBACNU;gBACF;YACF,OAAO;gBACL,OAAOlB,gBAAgBoB,IAAI,CAAChB;YAC9B;QACF,EAAE,OAAOiB,GAAG;YACV,OAAOrB,gBAAgBoB,IAAI,CAAChB;QAC9B;IACF;IAGF,OAAO;QACLkB,SAAStB;QACTuB,UAAUzB;IACZ;AACF"}},
    {"offset": {"line": 736, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/dependencies/versionUtils.ts"],"sourcesContent":["import type { CustomVersionParser } from './dependencyChecker.js'\n\nexport function parseVersion(version: string): { parts: number[]; preReleases: string[] } {\n  const [mainVersion, ...preReleases] = version.split('-')\n  const parts = mainVersion!.split('.').map(Number)\n  return { parts, preReleases }\n}\n\nfunction extractNumbers(str: string): number[] {\n  const matches = str.match(/\\d+/g) || []\n  return matches.map(Number)\n}\n\nfunction comparePreRelease(v1: string, v2: string): number {\n  const num1 = extractNumbers(v1)\n  const num2 = extractNumbers(v2)\n\n  for (let i = 0; i < Math.max(num1.length, num2.length); i++) {\n    if ((num1[i] || 0) < (num2[i] || 0)) {\n      return -1\n    }\n    if ((num1[i] || 0) > (num2[i] || 0)) {\n      return 1\n    }\n  }\n\n  // If numeric parts are equal, compare the whole string\n  if (v1 < v2) {\n    return -1\n  }\n  if (v1 > v2) {\n    return 1\n  }\n  return 0\n}\n\n/**\n * Compares two semantic version strings, including handling pre-release identifiers.\n *\n * This function first compares the major, minor, and patch components as integers.\n * If these components are equal, it then moves on to compare pre-release versions.\n * Pre-release versions are compared first by extracting and comparing any numerical values.\n * If numerical values are equal, it compares the whole pre-release string lexicographically.\n *\n * @param {string} compare - The first version string to compare.\n * @param {string} to - The second version string to compare.\n * @param {function} [customVersionParser] - An optional function to parse version strings into parts and pre-releases.\n * @returns {string} - Returns greater if compare is greater than to, lower if compare is less than to, and equal if they are equal.\n */\nexport function compareVersions(\n  compare: string,\n  to: string,\n  customVersionParser?: CustomVersionParser,\n): 'equal' | 'greater' | 'lower' {\n  const { parts: parts1, preReleases: preReleases1 } = customVersionParser\n    ? customVersionParser(compare)\n    : parseVersion(compare)\n  const { parts: parts2, preReleases: preReleases2 } = customVersionParser\n    ? customVersionParser(to)\n    : parseVersion(to)\n\n  // Compare main version parts\n  for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {\n    if ((parts1[i] || 0) > (parts2[i] || 0)) {\n      return 'greater'\n    }\n    if ((parts1[i] || 0) < (parts2[i] || 0)) {\n      return 'lower'\n    }\n  }\n\n  // Compare pre-release parts if main versions are equal\n  if (preReleases1?.length || preReleases2?.length) {\n    for (let i = 0; i < Math.max(preReleases1.length, preReleases2.length); i++) {\n      if (!preReleases1[i]) {\n        return 'greater'\n      }\n      if (!preReleases2[i]) {\n        return 'lower'\n      }\n\n      const result = comparePreRelease(preReleases1[i]!, preReleases2[i]!)\n      if (result !== 0) {\n        return result === 1 ? 'greater' : 'lower'\n      }\n      // Equal => continue for loop to check for next pre-release part\n    }\n  }\n\n  return 'equal'\n}\n"],"names":["parseVersion","version","mainVersion","preReleases","split","parts","map","Number","extractNumbers","str","matches","match","comparePreRelease","v1","v2","num1","num2","i","Math","max","length","compareVersions","compare","to","customVersionParser","parts1","preReleases1","parts2","preReleases2","result"],"mappings":";;;;;;AAEO,SAASA,aAAaC,OAAe;IAC1C,MAAM,CAACC,aAAa,GAAGC,YAAY,GAAGF,QAAQG,KAAK,CAAC;IACpD,MAAMC,QAAQH,YAAaE,KAAK,CAAC,KAAKE,GAAG,CAACC;IAC1C,OAAO;QAAEF;QAAOF;IAAY;AAC9B;AAEA,SAASK,eAAeC,GAAW;IACjC,MAAMC,UAAUD,IAAIE,KAAK,CAAC,WAAW,EAAE;IACvC,OAAOD,QAAQJ,GAAG,CAACC;AACrB;AAEA,SAASK,kBAAkBC,EAAU,EAAEC,EAAU;IAC/C,MAAMC,OAAOP,eAAeK;IAC5B,MAAMG,OAAOR,eAAeM;IAE5B,IAAK,IAAIG,IAAI,GAAGA,IAAIC,KAAKC,GAAG,CAACJ,KAAKK,MAAM,EAAEJ,KAAKI,MAAM,GAAGH,IAAK;QAC3D,IAAKF,CAAAA,IAAI,CAACE,EAAE,IAAI,CAAA,IAAMD,CAAAA,IAAI,CAACC,EAAE,IAAI,CAAA,GAAI;YACnC,OAAO,CAAC;QACV;QACA,IAAKF,CAAAA,IAAI,CAACE,EAAE,IAAI,CAAA,IAAMD,CAAAA,IAAI,CAACC,EAAE,IAAI,CAAA,GAAI;YACnC,OAAO;QACT;IACF;IAEA,uDAAuD;IACvD,IAAIJ,KAAKC,IAAI;QACX,OAAO,CAAC;IACV;IACA,IAAID,KAAKC,IAAI;QACX,OAAO;IACT;IACA,OAAO;AACT;AAeO,SAASO,gBACdC,OAAe,EACfC,EAAU,EACVC,mBAAyC;IAEzC,MAAM,EAAEnB,OAAOoB,MAAM,EAAEtB,aAAauB,YAAY,EAAE,GAAGF,sBACjDA,oBAAoBF,WACpBtB,aAAasB;IACjB,MAAM,EAAEjB,OAAOsB,MAAM,EAAExB,aAAayB,YAAY,EAAE,GAAGJ,sBACjDA,oBAAoBD,MACpBvB,aAAauB;IAEjB,6BAA6B;IAC7B,IAAK,IAAIN,IAAI,GAAGA,IAAIC,KAAKC,GAAG,CAACM,OAAOL,MAAM,EAAEO,OAAOP,MAAM,GAAGH,IAAK;QAC/D,IAAKQ,CAAAA,MAAM,CAACR,EAAE,IAAI,CAAA,IAAMU,CAAAA,MAAM,CAACV,EAAE,IAAI,CAAA,GAAI;YACvC,OAAO;QACT;QACA,IAAKQ,CAAAA,MAAM,CAACR,EAAE,IAAI,CAAA,IAAMU,CAAAA,MAAM,CAACV,EAAE,IAAI,CAAA,GAAI;YACvC,OAAO;QACT;IACF;IAEA,uDAAuD;IACvD,IAAIS,cAAcN,UAAUQ,cAAcR,QAAQ;QAChD,IAAK,IAAIH,IAAI,GAAGA,IAAIC,KAAKC,GAAG,CAACO,aAAaN,MAAM,EAAEQ,aAAaR,MAAM,GAAGH,IAAK;YAC3E,IAAI,CAACS,YAAY,CAACT,EAAE,EAAE;gBACpB,OAAO;YACT;YACA,IAAI,CAACW,YAAY,CAACX,EAAE,EAAE;gBACpB,OAAO;YACT;YAEA,MAAMY,SAASjB,kBAAkBc,YAAY,CAACT,EAAE,EAAGW,YAAY,CAACX,EAAE;YAClE,IAAIY,WAAW,GAAG;gBAChB,OAAOA,WAAW,IAAI,YAAY;YACpC;QACA,gEAAgE;QAClE;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 808, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/dependencies/dependencyChecker.ts"],"sourcesContent":["import path from 'path'\nimport { fileURLToPath } from 'url'\n\nimport { getDependencies } from '../../index.js'\nimport { compareVersions } from './versionUtils.js'\n\nconst filename = fileURLToPath(import.meta.url)\nconst dirname = path.dirname(filename)\n\nexport type CustomVersionParser = (version: string) => { parts: number[]; preReleases: string[] }\n\nexport type DependencyCheckerArgs = {\n  /**\n   * Define dependency groups to ensure that all dependencies within that group are on the same version, and that no dependencies in that group with different versions are found\n   */\n  dependencyGroups?: {\n    dependencies: string[]\n    /**\n     * Name of the dependency group to be displayed in the error message\n     */\n    name: string\n    targetVersion?: string\n    targetVersionDependency?: string\n  }[]\n  /**\n   * Dependency package names keyed to their required versions. Supports >= (greater or equal than version) as a prefix, or no prefix for the exact version\n   */\n  dependencyVersions?: {\n    [dependency: string]: {\n      customVersionParser?: CustomVersionParser\n      required?: boolean\n      version?: string\n    }\n  }\n}\n\nexport async function checkDependencies({\n  dependencyGroups,\n  dependencyVersions,\n}: DependencyCheckerArgs): Promise<void> {\n  if (dependencyGroups?.length) {\n    for (const dependencyGroup of dependencyGroups) {\n      const resolvedDependencies = await getDependencies(dirname, dependencyGroup.dependencies)\n\n      // Go through each resolved dependency. If any dependency has a mismatching version, throw an error\n      const foundVersions: {\n        [version: string]: string\n      } = {}\n      for (const [_pkg, { version }] of resolvedDependencies.resolved) {\n        if (!Object.keys(foundVersions).includes(version)) {\n          foundVersions[version] = _pkg\n        }\n      }\n      if (Object.keys(foundVersions).length > 1) {\n        const targetVersion =\n          dependencyGroup.targetVersion ??\n          resolvedDependencies.resolved.get(dependencyGroup.targetVersionDependency!)?.version\n        if (targetVersion) {\n          const formattedVersionsWithPackageNameString = Object.entries(foundVersions)\n            .filter(([version]) => version !== targetVersion)\n            .map(([version, pkg]) => `${pkg}@${version} (Please change this to ${targetVersion})`)\n            .join(', ')\n          throw new Error(\n            `Mismatching \"${dependencyGroup.name}\" dependency versions found: ${formattedVersionsWithPackageNameString}. All \"${dependencyGroup.name}\" packages must have the same version. This is an error with your set-up, not a bug in Payload. Please go to your package.json and ensure all \"${dependencyGroup.name}\" packages have the same version.`,\n          )\n        } else {\n          const formattedVersionsWithPackageNameString = Object.entries(foundVersions)\n            .map(([version, pkg]) => `${pkg}@${version}`)\n            .join(', ')\n          throw new Error(\n            `Mismatching \"${dependencyGroup.name}\" dependency versions found: ${formattedVersionsWithPackageNameString}. All \"${dependencyGroup.name}\" packages must have the same version. This is an error with your set-up, not a bug in Payload. Please go to your package.json and ensure all \"${dependencyGroup.name}\" packages have the same version.`,\n          )\n        }\n      }\n    }\n  }\n\n  if (dependencyVersions && Object.keys(dependencyVersions).length) {\n    const resolvedDependencies = await getDependencies(dirname, Object.keys(dependencyVersions))\n    for (const [dependency, settings] of Object.entries(dependencyVersions)) {\n      const resolvedDependency = resolvedDependencies.resolved.get(dependency)\n      if (!resolvedDependency) {\n        if (!settings.required) {\n          continue\n        }\n        throw new Error(`Dependency ${dependency} not found. Please ensure it is installed.`)\n      }\n\n      if (settings.version) {\n        const settingsVersionToCheck = settings.version.startsWith('>=')\n          ? settings.version.slice(2)\n          : settings.version\n\n        const versionCompareResult = compareVersions(\n          resolvedDependency.version,\n          settingsVersionToCheck,\n          settings.customVersionParser,\n        )\n\n        if (settings.version.startsWith('>=')) {\n          if (versionCompareResult === 'lower') {\n            throw new Error(\n              `Dependency ${dependency} is on version ${resolvedDependency.version}, but ${settings.version} or greater is required. Please update this dependency.`,\n            )\n          }\n        } else if (versionCompareResult === 'lower' || versionCompareResult === 'greater') {\n          throw new Error(\n            `Dependency ${dependency} is on version ${resolvedDependency.version}, but ${settings.version} is required. Please update this dependency.`,\n          )\n        }\n      }\n    }\n  }\n}\n"],"names":["path","fileURLToPath","getDependencies","compareVersions","filename","url","dirname","checkDependencies","dependencyGroups","dependencyVersions","length","dependencyGroup","resolvedDependencies","dependencies","foundVersions","_pkg","version","resolved","Object","keys","includes","targetVersion","get","targetVersionDependency","formattedVersionsWithPackageNameString","entries","filter","map","pkg","join","Error","name","dependency","settings","resolvedDependency","required","settingsVersionToCheck","startsWith","slice","versionCompareResult","customVersionParser"],"mappings":"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"}},
    {"offset": {"line": 878, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/flattenAllFields.ts"],"sourcesContent":["import type {\n  Block,\n  Field,\n  FlattenedBlock,\n  FlattenedBlocksField,\n  FlattenedField,\n  FlattenedJoinField,\n} from '../fields/config/types.js'\n\nimport { fieldAffectsData, tabHasName } from '../fields/config/types.js'\n\nexport const flattenBlock = ({ block }: { block: Block }): FlattenedBlock => {\n  return {\n    ...block,\n    flattenedFields: flattenAllFields({ fields: block.fields }),\n  }\n}\n\nconst flattenedFieldsCache = new Map<Field[], FlattenedField[]>()\n\n/**\n * Flattens all fields in a collection, preserving the nested field structure.\n * @param cache\n * @param fields\n */\nexport const flattenAllFields = ({\n  cache,\n  fields,\n}: {\n  /** Allows you to get FlattenedField[] from Field[] anywhere without performance overhead by caching. */\n  cache?: boolean\n  fields: Field[]\n}): FlattenedField[] => {\n  if (cache) {\n    const maybeFields = flattenedFieldsCache.get(fields)\n    if (maybeFields) {\n      return maybeFields\n    }\n  }\n\n  const result: FlattenedField[] = []\n\n  for (const field of fields) {\n    switch (field.type) {\n      case 'array':\n      case 'group': {\n        if (fieldAffectsData(field)) {\n          result.push({ ...field, flattenedFields: flattenAllFields({ fields: field.fields }) })\n        } else {\n          for (const nestedField of flattenAllFields({ fields: field.fields })) {\n            result.push(nestedField)\n          }\n        }\n        break\n      }\n\n      case 'blocks': {\n        const blocks: FlattenedBlock[] = []\n        let blockReferences: (FlattenedBlock | string)[] | undefined = undefined\n        if (field.blockReferences) {\n          blockReferences = []\n          for (const block of field.blockReferences) {\n            if (typeof block === 'string') {\n              blockReferences.push(block)\n              continue\n            }\n            blockReferences.push(flattenBlock({ block }))\n          }\n        } else {\n          for (const block of field.blocks) {\n            if (typeof block === 'string') {\n              blocks.push(block)\n              continue\n            }\n            blocks.push(flattenBlock({ block }))\n          }\n        }\n\n        const resultField: FlattenedBlocksField = {\n          ...field,\n          blockReferences,\n          blocks,\n        }\n\n        result.push(resultField)\n        break\n      }\n\n      case 'collapsible':\n      case 'row': {\n        for (const nestedField of flattenAllFields({ fields: field.fields })) {\n          result.push(nestedField)\n        }\n        break\n      }\n\n      case 'join': {\n        result.push(field as FlattenedJoinField)\n        break\n      }\n\n      case 'tabs': {\n        for (const tab of field.tabs) {\n          if (!tabHasName(tab)) {\n            for (const nestedField of flattenAllFields({ fields: tab.fields })) {\n              result.push(nestedField)\n            }\n          } else {\n            result.push({\n              ...tab,\n              type: 'tab',\n              flattenedFields: flattenAllFields({ fields: tab.fields }),\n            })\n          }\n        }\n        break\n      }\n\n      default: {\n        if (field.type !== 'ui') {\n          result.push(field)\n        }\n      }\n    }\n  }\n\n  flattenedFieldsCache.set(fields, result)\n\n  return result\n}\n"],"names":["fieldAffectsData","tabHasName","flattenBlock","block","flattenedFields","flattenAllFields","fields","flattenedFieldsCache","Map","cache","maybeFields","get","result","field","type","push","nestedField","blocks","blockReferences","undefined","resultField","tab","tabs","set"],"mappings":";;;;;;AASA,SAASA,gBAAgB,EAAEC,UAAU,QAAQ,4BAA2B;;AAEjE,MAAMC,eAAe,CAAC,EAAEC,KAAK,EAAoB;IACtD,OAAO;QACL,GAAGA,KAAK;QACRC,iBAAiBC,iBAAiB;YAAEC,QAAQH,MAAMG,MAAM;QAAC;IAC3D;AACF,EAAC;AAED,MAAMC,uBAAuB,IAAIC;AAO1B,MAAMH,mBAAmB,CAAC,EAC/BI,KAAK,EACLH,MAAM,EAKP;IACC,IAAIG,OAAO;QACT,MAAMC,cAAcH,qBAAqBI,GAAG,CAACL;QAC7C,IAAII,aAAa;YACf,OAAOA;QACT;IACF;IAEA,MAAME,SAA2B,EAAE;IAEnC,KAAK,MAAMC,SAASP,OAAQ;QAC1B,OAAQO,MAAMC,IAAI;YAChB,KAAK;YACL,KAAK;gBAAS;oBACZ,QAAId,wRAAAA,EAAiBa,QAAQ;wBAC3BD,OAAOG,IAAI,CAAC;4BAAE,GAAGF,KAAK;4BAAET,iBAAiBC,iBAAiB;gCAAEC,QAAQO,MAAMP,MAAM;4BAAC;wBAAG;oBACtF,OAAO;wBACL,KAAK,MAAMU,eAAeX,iBAAiB;4BAAEC,QAAQO,MAAMP,MAAM;wBAAC,GAAI;4BACpEM,OAAOG,IAAI,CAACC;wBACd;oBACF;oBACA;gBACF;YAEA,KAAK;gBAAU;oBACb,MAAMC,SAA2B,EAAE;oBACnC,IAAIC,kBAA2DC;oBAC/D,IAAIN,MAAMK,eAAe,EAAE;wBACzBA,kBAAkB,EAAE;wBACpB,KAAK,MAAMf,SAASU,MAAMK,eAAe,CAAE;4BACzC,IAAI,OAAOf,UAAU,UAAU;gCAC7Be,gBAAgBH,IAAI,CAACZ;gCACrB;4BACF;4BACAe,gBAAgBH,IAAI,CAACb,aAAa;gCAAEC;4BAAM;wBAC5C;oBACF,OAAO;wBACL,KAAK,MAAMA,SAASU,MAAMI,MAAM,CAAE;4BAChC,IAAI,OAAOd,UAAU,UAAU;gCAC7Bc,OAAOF,IAAI,CAACZ;gCACZ;4BACF;4BACAc,OAAOF,IAAI,CAACb,aAAa;gCAAEC;4BAAM;wBACnC;oBACF;oBAEA,MAAMiB,cAAoC;wBACxC,GAAGP,KAAK;wBACRK;wBACAD;oBACF;oBAEAL,OAAOG,IAAI,CAACK;oBACZ;gBACF;YAEA,KAAK;YACL,KAAK;gBAAO;oBACV,KAAK,MAAMJ,eAAeX,iBAAiB;wBAAEC,QAAQO,MAAMP,MAAM;oBAAC,GAAI;wBACpEM,OAAOG,IAAI,CAACC;oBACd;oBACA;gBACF;YAEA,KAAK;gBAAQ;oBACXJ,OAAOG,IAAI,CAACF;oBACZ;gBACF;YAEA,KAAK;gBAAQ;oBACX,KAAK,MAAMQ,OAAOR,MAAMS,IAAI,CAAE;wBAC5B,IAAI,KAACrB,kRAAAA,EAAWoB,MAAM;4BACpB,KAAK,MAAML,eAAeX,iBAAiB;gCAAEC,QAAQe,IAAIf,MAAM;4BAAC,GAAI;gCAClEM,OAAOG,IAAI,CAACC;4BACd;wBACF,OAAO;4BACLJ,OAAOG,IAAI,CAAC;gCACV,GAAGM,GAAG;gCACNP,MAAM;gCACNV,iBAAiBC,iBAAiB;oCAAEC,QAAQe,IAAIf,MAAM;gCAAC;4BACzD;wBACF;oBACF;oBACA;gBACF;YAEA;gBAAS;oBACP,IAAIO,MAAMC,IAAI,KAAK,MAAM;wBACvBF,OAAOG,IAAI,CAACF;oBACd;gBACF;QACF;IACF;IAEAN,qBAAqBgB,GAAG,CAACjB,QAAQM;IAEjC,OAAOA;AACT,EAAC"}},
    {"offset": {"line": 1009, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/formatLabels.ts"],"sourcesContent":["import pluralize from 'pluralize'\nconst { isPlural, singular } = pluralize\n\nconst capitalizeFirstLetter = (string: string): string =>\n  string.charAt(0).toUpperCase() + string.slice(1)\n\nconst toWords = (inputString: string, joinWords = false): string => {\n  const notNullString = inputString || ''\n  const trimmedString = notNullString.trim()\n  const arrayOfStrings = trimmedString.split(/[\\s-]/)\n\n  const splitStringsArray: string[] = []\n  arrayOfStrings.forEach((tempString) => {\n    if (tempString !== '') {\n      const splitWords = tempString.split(/(?=[A-Z])/).join(' ')\n      splitStringsArray.push(capitalizeFirstLetter(splitWords))\n    }\n  })\n\n  return joinWords ? splitStringsArray.join('').replace(/\\s/g, '') : splitStringsArray.join(' ')\n}\n\nconst formatLabels = (slug: string): { plural: string; singular: string } => {\n  const words = toWords(slug)\n\n  return isPlural(slug)\n    ? {\n        plural: words,\n        singular: singular(words),\n      }\n    : {\n        plural: pluralize(words),\n        singular: words,\n      }\n}\n\nconst formatNames = (slug: string): { plural: string; singular: string } => {\n  const words = toWords(slug, true)\n  return isPlural(slug)\n    ? {\n        plural: words,\n        singular: singular(words),\n      }\n    : {\n        plural: pluralize(words),\n        singular: words,\n      }\n}\n\nexport { formatLabels, formatNames, toWords }\n"],"names":["pluralize","isPlural","singular","capitalizeFirstLetter","string","charAt","toUpperCase","slice","toWords","inputString","joinWords","notNullString","trimmedString","trim","arrayOfStrings","split","splitStringsArray","forEach","tempString","splitWords","join","push","replace","formatLabels","slug","words","plural","formatNames"],"mappings":";;;;;;;;AAAA,OAAOA,eAAe,YAAW;;AACjC,MAAM,EAAEC,QAAQ,EAAEC,QAAQ,EAAE,GAAGF,uMAAAA;AAE/B,MAAMG,wBAAwB,CAACC,SAC7BA,OAAOC,MAAM,CAAC,GAAGC,WAAW,KAAKF,OAAOG,KAAK,CAAC;AAEhD,MAAMC,UAAU,CAACC,aAAqBC,YAAY,KAAK;IACrD,MAAMC,gBAAgBF,eAAe;IACrC,MAAMG,gBAAgBD,cAAcE,IAAI;IACxC,MAAMC,iBAAiBF,cAAcG,KAAK,CAAC;IAE3C,MAAMC,oBAA8B,EAAE;IACtCF,eAAeG,OAAO,CAAC,CAACC;QACtB,IAAIA,eAAe,IAAI;YACrB,MAAMC,aAAaD,WAAWH,KAAK,CAAC,aAAaK,IAAI,CAAC;YACtDJ,kBAAkBK,IAAI,CAAClB,sBAAsBgB;QAC/C;IACF;IAEA,OAAOT,YAAYM,kBAAkBI,IAAI,CAAC,IAAIE,OAAO,CAAC,OAAO,MAAMN,kBAAkBI,IAAI,CAAC;AAC5F;AAEA,MAAMG,eAAe,CAACC;IACpB,MAAMC,QAAQjB,QAAQgB;IAEtB,OAAOvB,SAASuB,QACZ;QACEE,QAAQD;QACRvB,UAAUA,SAASuB;IACrB,IACA;QACEC,YAAQ1B,uMAAAA,EAAUyB;QAClBvB,UAAUuB;IACZ;AACN;AAEA,MAAME,cAAc,CAACH;IACnB,MAAMC,QAAQjB,QAAQgB,MAAM;IAC5B,OAAOvB,SAASuB,QACZ;QACEE,QAAQD;QACRvB,UAAUA,SAASuB;IACrB,IACA;QACEC,YAAQ1B,uMAAAA,EAAUyB;QAClBvB,UAAUuB;IACZ;AACN"}},
    {"offset": {"line": 1060, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/getCollectionIDFieldTypes.ts"],"sourcesContent":["import type { SanitizedConfig } from '../config/types.js'\n\n/**\n *  While the default ID is determined by the db adapter, it can still differ for a collection if they\n *  define a custom ID field. This builds a map of collection slugs to their ID field type.\n * @param defaultIDType as defined by the database adapter\n */\nexport function getCollectionIDFieldTypes({\n  config,\n  defaultIDType,\n}: {\n  config: SanitizedConfig\n  defaultIDType: 'number' | 'text'\n}): { [key: string]: 'number' | 'string' } {\n  return config.collections.reduce(\n    (acc, collection) => {\n      const customCollectionIdField = collection.fields.find(\n        (field) => 'name' in field && field.name === 'id',\n      )\n\n      acc[collection.slug] = defaultIDType === 'text' ? 'string' : 'number'\n\n      if (customCollectionIdField) {\n        acc[collection.slug] = customCollectionIdField.type === 'number' ? 'number' : 'string'\n      }\n\n      return acc\n    },\n    {} as Record<string, 'number' | 'string'>,\n  )\n}\n"],"names":["getCollectionIDFieldTypes","config","defaultIDType","collections","reduce","acc","collection","customCollectionIdField","fields","find","field","name","slug","type"],"mappings":"AAEA;;;;CAIC,GACD;;;;AAAO,SAASA,0BAA0B,EACxCC,MAAM,EACNC,aAAa,EAId;IACC,OAAOD,OAAOE,WAAW,CAACC,MAAM,CAC9B,CAACC,KAAKC;QACJ,MAAMC,0BAA0BD,WAAWE,MAAM,CAACC,IAAI,CACpD,CAACC,QAAU,UAAUA,SAASA,MAAMC,IAAI,KAAK;QAG/CN,GAAG,CAACC,WAAWM,IAAI,CAAC,GAAGV,kBAAkB,SAAS,WAAW;QAE7D,IAAIK,yBAAyB;YAC3BF,GAAG,CAACC,WAAWM,IAAI,CAAC,GAAGL,wBAAwBM,IAAI,KAAK,WAAW,WAAW;QAChF;QAEA,OAAOR;IACT,GACA,CAAC;AAEL"}},
    {"offset": {"line": 1082, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/configToJSONSchema.ts"],"sourcesContent":["import type { I18n } from '@payloadcms/translations'\nimport type { JSONSchema4, JSONSchema4TypeName } from 'json-schema'\n\nimport type { Auth } from '../auth/types.js'\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { FieldAffectingData, FlattenedField, Option } from '../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\n\nimport { MissingEditorProp } from '../errors/MissingEditorProp.js'\nimport { fieldAffectsData } from '../fields/config/types.js'\nimport { generateJobsJSONSchemas } from '../queues/config/generateJobsJSONSchemas.js'\nimport { formatNames } from './formatLabels.js'\nimport { getCollectionIDFieldTypes } from './getCollectionIDFieldTypes.js'\n\nconst fieldIsRequired = (field: FlattenedField): boolean => {\n  const isConditional = Boolean(field?.admin && field?.admin?.condition)\n  if (isConditional) {\n    return false\n  }\n\n  const isMarkedRequired = 'required' in field && field.required === true\n  if (fieldAffectsData(field) && isMarkedRequired) {\n    return true\n  }\n\n  // if any subfields are required, this field is required\n  if ('fields' in field && field.type !== 'array') {\n    return field.flattenedFields.some((subField) => fieldIsRequired(subField))\n  }\n\n  return false\n}\n\nfunction buildOptionEnums(options: Option[]): string[] {\n  return options.map((option) => {\n    if (typeof option === 'object' && 'value' in option) {\n      return option.value\n    }\n\n    return option\n  })\n}\n\nfunction generateEntitySchemas(\n  entities: (SanitizedCollectionConfig | SanitizedGlobalConfig)[],\n): JSONSchema4 {\n  const properties = [...entities].reduce(\n    (acc, { slug }) => {\n      acc[slug] = {\n        $ref: `#/definitions/${slug}`,\n      }\n\n      return acc\n    },\n    {} as Record<string, JSONSchema4>,\n  )\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n  }\n}\n\nfunction generateEntitySelectSchemas(\n  entities: (SanitizedCollectionConfig | SanitizedGlobalConfig)[],\n): JSONSchema4 {\n  const properties = [...entities].reduce(\n    (acc, { slug }) => {\n      acc[slug] = {\n        $ref: `#/definitions/${slug}_select`,\n      }\n\n      return acc\n    },\n    {} as Record<string, JSONSchema4>,\n  )\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n  }\n}\n\nfunction generateCollectionJoinsSchemas(collections: SanitizedCollectionConfig[]): JSONSchema4 {\n  const properties = [...collections].reduce<Record<string, JSONSchema4>>(\n    (acc, { slug, joins, polymorphicJoins }) => {\n      const schema = {\n        type: 'object',\n        additionalProperties: false,\n        properties: {},\n        required: [] as string[],\n      } satisfies JSONSchema4\n\n      for (const collectionSlug in joins) {\n        for (const join of joins[collectionSlug]!) {\n          ;(schema.properties as any)[join.joinPath] = {\n            type: 'string',\n            enum: [collectionSlug],\n          }\n          schema.required.push(join.joinPath)\n        }\n      }\n\n      for (const join of polymorphicJoins) {\n        ;(schema.properties as any)[join.joinPath] = {\n          type: 'string',\n          enum: join.field.collection,\n        }\n        schema.required.push(join.joinPath)\n      }\n\n      if (Object.keys(schema.properties).length > 0) {\n        acc[slug] = schema\n      }\n\n      return acc\n    },\n    {},\n  )\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n  }\n}\n\nfunction generateLocaleEntitySchemas(localization: SanitizedConfig['localization']): JSONSchema4 {\n  if (localization && 'locales' in localization && localization?.locales) {\n    const localesFromConfig = localization?.locales\n\n    const locales = [...localesFromConfig].map((locale) => {\n      return locale.code\n    }, [])\n\n    return {\n      type: 'string',\n      enum: locales,\n    }\n  }\n\n  return {\n    type: 'null',\n  }\n}\n\nfunction generateAuthEntitySchemas(entities: SanitizedCollectionConfig[]): JSONSchema4 {\n  const properties: JSONSchema4[] = [...entities]\n    .filter(({ auth }) => Boolean(auth))\n    .map(({ slug }) => {\n      return {\n        allOf: [\n          { $ref: `#/definitions/${slug}` },\n          {\n            type: 'object',\n            additionalProperties: false,\n            properties: {\n              collection: { type: 'string', enum: [slug] },\n            },\n            required: ['collection'],\n          },\n        ],\n      }\n    }, {})\n\n  return {\n    oneOf: properties,\n  }\n}\n\n/**\n * Generates the JSON Schema for database configuration\n *\n * @example { db: idType: string }\n */\nfunction generateDbEntitySchema(config: SanitizedConfig): JSONSchema4 {\n  const defaultIDType: JSONSchema4 =\n    config.db?.defaultIDType === 'number' ? { type: 'number' } : { type: 'string' }\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties: {\n      defaultIDType,\n    },\n    required: ['defaultIDType'],\n  }\n}\n\n/**\n * Returns a JSON Schema Type with 'null' added if the field is not required.\n */\nexport function withNullableJSONSchemaType(\n  fieldType: JSONSchema4TypeName,\n  isRequired: boolean,\n): JSONSchema4TypeName | JSONSchema4TypeName[] {\n  const fieldTypes = [fieldType]\n  if (isRequired) {\n    return fieldType\n  }\n  fieldTypes.push('null')\n  return fieldTypes\n}\n\nfunction entityOrFieldToJsDocs({\n  entity,\n  i18n,\n}: {\n  entity: FlattenedField | SanitizedCollectionConfig | SanitizedGlobalConfig\n  i18n?: I18n\n}): string | undefined {\n  let description: string | undefined = undefined\n  if (entity?.admin?.description) {\n    if (typeof entity?.admin?.description === 'string') {\n      description = entity?.admin?.description\n    } else if (typeof entity?.admin?.description === 'object') {\n      if (entity?.admin?.description?.en) {\n        description = entity?.admin?.description?.en\n      } else if (entity?.admin?.description?.[i18n!.language]) {\n        description = entity?.admin?.description?.[i18n!.language]\n      }\n    } else if (typeof entity?.admin?.description === 'function' && i18n) {\n      // do not evaluate description functions for generating JSDocs. The output of\n      // those can differ depending on where and when they are called, creating\n      // inconsistencies in the generated JSDocs.\n    }\n  }\n  return description\n}\nexport function fieldsToJSONSchema(\n  /**\n   * Used for relationship fields, to determine whether to use a string or number type for the ID.\n   * While there is a default ID field type set by the db adapter, they can differ on a collection-level\n   * if they have custom ID fields.\n   */\n  collectionIDFieldTypes: { [key: string]: 'number' | 'string' },\n  fields: FlattenedField[],\n  /**\n   * Allows you to define new top-level interfaces that can be re-used in the output schema.\n   */\n  interfaceNameDefinitions: Map<string, JSONSchema4>,\n  config?: SanitizedConfig,\n  i18n?: I18n,\n): {\n  properties: {\n    [k: string]: JSONSchema4\n  }\n  required: string[]\n} {\n  const requiredFieldNames = new Set<string>()\n\n  return {\n    properties: Object.fromEntries(\n      fields.reduce((fieldSchemas, field, index) => {\n        const isRequired = fieldAffectsData(field) && fieldIsRequired(field)\n\n        const fieldDescription = entityOrFieldToJsDocs({ entity: field, i18n })\n        const baseFieldSchema: JSONSchema4 = {}\n        if (fieldDescription) {\n          baseFieldSchema.description = fieldDescription\n        }\n\n        let fieldSchema: JSONSchema4\n\n        switch (field.type) {\n          case 'array': {\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: withNullableJSONSchemaType('array', isRequired),\n              items: {\n                type: 'object',\n                additionalProperties: false,\n                ...fieldsToJSONSchema(\n                  collectionIDFieldTypes,\n                  field.flattenedFields,\n                  interfaceNameDefinitions,\n                  config,\n                  i18n,\n                ),\n              },\n            }\n\n            if (field.interfaceName) {\n              interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n              fieldSchema = {\n                $ref: `#/definitions/${field.interfaceName}`,\n              }\n            }\n            break\n          }\n          case 'blocks': {\n            // Check for a case where no blocks are provided.\n            // We need to generate an empty array for this case, note that JSON schema 4 doesn't support empty arrays\n            // so the best we can get is `unknown[]`\n            const hasBlocks = Boolean(\n              field.blockReferences ? field.blockReferences.length : field.blocks.length,\n            )\n\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: withNullableJSONSchemaType('array', isRequired),\n              items: hasBlocks\n                ? {\n                    oneOf: (field.blockReferences ?? field.blocks).map((block) => {\n                      if (typeof block === 'string') {\n                        const resolvedBlock = config?.blocks?.find((b) => b.slug === block)\n                        return {\n                          $ref: `#/definitions/${resolvedBlock!.interfaceName ?? resolvedBlock!.slug}`,\n                        }\n                      }\n                      const blockFieldSchemas = fieldsToJSONSchema(\n                        collectionIDFieldTypes,\n                        block.flattenedFields,\n                        interfaceNameDefinitions,\n                        config,\n                        i18n,\n                      )\n\n                      const blockSchema: JSONSchema4 = {\n                        type: 'object',\n                        additionalProperties: false,\n                        properties: {\n                          ...blockFieldSchemas.properties,\n                          blockType: {\n                            const: block.slug,\n                          },\n                        },\n                        required: ['blockType', ...blockFieldSchemas.required],\n                      }\n\n                      if (block.interfaceName) {\n                        interfaceNameDefinitions.set(block.interfaceName, blockSchema)\n\n                        return {\n                          $ref: `#/definitions/${block.interfaceName}`,\n                        }\n                      }\n\n                      return blockSchema\n                    }),\n                  }\n                : {},\n            }\n            break\n          }\n          case 'checkbox': {\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: withNullableJSONSchemaType('boolean', isRequired),\n            }\n            break\n          }\n          case 'code':\n          case 'date':\n          case 'email':\n          case 'textarea': {\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: withNullableJSONSchemaType('string', isRequired),\n            }\n            break\n          }\n\n          case 'group': {\n            if (fieldAffectsData(field)) {\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: 'object',\n                additionalProperties: false,\n                ...fieldsToJSONSchema(\n                  collectionIDFieldTypes,\n                  field.flattenedFields,\n                  interfaceNameDefinitions,\n                  config,\n                  i18n,\n                ),\n              }\n\n              if (field.interfaceName) {\n                interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n                fieldSchema = { $ref: `#/definitions/${field.interfaceName}` }\n              }\n            }\n            break\n          }\n\n          case 'join': {\n            let items: JSONSchema4\n\n            if (Array.isArray(field.collection)) {\n              items = {\n                oneOf: field.collection.map((collection) => ({\n                  type: 'object',\n                  additionalProperties: false,\n                  properties: {\n                    relationTo: {\n                      const: collection,\n                    },\n                    value: {\n                      oneOf: [\n                        {\n                          type: collectionIDFieldTypes[collection],\n                        },\n                        {\n                          $ref: `#/definitions/${collection}`,\n                        },\n                      ],\n                    },\n                  },\n                  required: ['collectionSlug', 'value'],\n                })),\n              }\n            } else {\n              items = {\n                oneOf: [\n                  {\n                    type: collectionIDFieldTypes[field.collection],\n                  },\n                  {\n                    $ref: `#/definitions/${field.collection}`,\n                  },\n                ],\n              }\n            }\n\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: 'object',\n              additionalProperties: false,\n              properties: {\n                docs: {\n                  type: 'array',\n                  items,\n                },\n                hasNextPage: { type: 'boolean' },\n                totalDocs: { type: 'number' },\n              },\n            }\n            break\n          }\n\n          case 'json': {\n            fieldSchema = field.jsonSchema?.schema || {\n              ...baseFieldSchema,\n              type: ['object', 'array', 'string', 'number', 'boolean', 'null'],\n            }\n            break\n          }\n\n          case 'number': {\n            if (field.hasMany === true) {\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: { type: 'number' },\n              }\n            } else {\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: withNullableJSONSchemaType('number', isRequired),\n              }\n            }\n            break\n          }\n\n          case 'point': {\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: withNullableJSONSchemaType('array', isRequired),\n              items: [\n                {\n                  type: 'number',\n                },\n                {\n                  type: 'number',\n                },\n              ],\n              maxItems: 2,\n              minItems: 2,\n            }\n            break\n          }\n\n          case 'radio': {\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: withNullableJSONSchemaType('string', isRequired),\n              enum: buildOptionEnums(field.options),\n            }\n\n            if (field.interfaceName) {\n              interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n              fieldSchema = {\n                $ref: `#/definitions/${field.interfaceName}`,\n              }\n            }\n\n            break\n          }\n          case 'relationship':\n          case 'upload': {\n            if (Array.isArray(field.relationTo)) {\n              if (field.hasMany) {\n                fieldSchema = {\n                  ...baseFieldSchema,\n                  type: withNullableJSONSchemaType('array', isRequired),\n                  items: {\n                    oneOf: field.relationTo.map((relation) => {\n                      return {\n                        type: 'object',\n                        additionalProperties: false,\n                        properties: {\n                          relationTo: {\n                            const: relation,\n                          },\n                          value: {\n                            oneOf: [\n                              {\n                                type: collectionIDFieldTypes[relation],\n                              },\n                              {\n                                $ref: `#/definitions/${relation}`,\n                              },\n                            ],\n                          },\n                        },\n                        required: ['value', 'relationTo'],\n                      }\n                    }),\n                  },\n                }\n              } else {\n                fieldSchema = {\n                  ...baseFieldSchema,\n                  oneOf: field.relationTo.map((relation) => {\n                    return {\n                      type: withNullableJSONSchemaType('object', isRequired),\n                      additionalProperties: false,\n                      properties: {\n                        relationTo: {\n                          const: relation,\n                        },\n                        value: {\n                          oneOf: [\n                            {\n                              type: collectionIDFieldTypes[relation],\n                            },\n                            {\n                              $ref: `#/definitions/${relation}`,\n                            },\n                          ],\n                        },\n                      },\n                      required: ['value', 'relationTo'],\n                    }\n                  }),\n                }\n              }\n            } else if (field.hasMany) {\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: {\n                  oneOf: [\n                    {\n                      type: collectionIDFieldTypes[field.relationTo],\n                    },\n                    {\n                      $ref: `#/definitions/${field.relationTo}`,\n                    },\n                  ],\n                },\n              }\n            } else {\n              fieldSchema = {\n                ...baseFieldSchema,\n                oneOf: [\n                  {\n                    type: withNullableJSONSchemaType(\n                      collectionIDFieldTypes[field.relationTo]!,\n                      isRequired,\n                    ),\n                  },\n                  { $ref: `#/definitions/${field.relationTo}` },\n                ],\n              }\n            }\n\n            break\n          }\n          case 'richText': {\n            if (!field?.editor) {\n              throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n            }\n            if (typeof field.editor === 'function') {\n              throw new Error('Attempted to access unsanitized rich text editor.')\n            }\n            if (field.editor.outputSchema) {\n              fieldSchema = {\n                ...baseFieldSchema,\n                ...field.editor.outputSchema({\n                  collectionIDFieldTypes,\n                  config,\n                  field,\n                  i18n,\n                  interfaceNameDefinitions,\n                  isRequired,\n                }),\n              }\n            } else {\n              // Maintain backwards compatibility with existing rich text editors\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: {\n                  type: 'object',\n                },\n              }\n            }\n\n            break\n          }\n\n          case 'select': {\n            const optionEnums = buildOptionEnums(field.options)\n            // We get the previous field to check for a date in the case of a timezone select\n            // This works because timezone selects are always inserted right after a date with 'timezone: true'\n            const previousField = fields?.[index - 1]\n            const isTimezoneField =\n              previousField?.type === 'date' && previousField.timezone && field.name.includes('_tz')\n\n            // Timezone selects should reference the supportedTimezones definition\n            if (isTimezoneField) {\n              fieldSchema = {\n                $ref: `#/definitions/supportedTimezones`,\n              }\n            } else {\n              if (field.hasMany) {\n                fieldSchema = {\n                  ...baseFieldSchema,\n                  type: withNullableJSONSchemaType('array', isRequired),\n                  items: {\n                    type: 'string',\n                  },\n                }\n                if (optionEnums?.length) {\n                  ;(fieldSchema.items as JSONSchema4).enum = optionEnums\n                }\n              } else {\n                fieldSchema = {\n                  ...baseFieldSchema,\n                  type: withNullableJSONSchemaType('string', isRequired),\n                }\n                if (optionEnums?.length) {\n                  fieldSchema.enum = optionEnums\n                }\n              }\n\n              if (field.interfaceName) {\n                interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n                fieldSchema = {\n                  $ref: `#/definitions/${field.interfaceName}`,\n                }\n              }\n              break\n            }\n\n            break\n          }\n          case 'tab': {\n            fieldSchema = {\n              ...baseFieldSchema,\n              type: 'object',\n              additionalProperties: false,\n              ...fieldsToJSONSchema(\n                collectionIDFieldTypes,\n                field.flattenedFields,\n                interfaceNameDefinitions,\n                config,\n                i18n,\n              ),\n            }\n\n            if (field.interfaceName) {\n              interfaceNameDefinitions.set(field.interfaceName, fieldSchema)\n\n              fieldSchema = { $ref: `#/definitions/${field.interfaceName}` }\n            }\n            break\n          }\n\n          case 'text':\n            if (field.hasMany === true) {\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: withNullableJSONSchemaType('array', isRequired),\n                items: { type: 'string' },\n              }\n            } else {\n              fieldSchema = {\n                ...baseFieldSchema,\n                type: withNullableJSONSchemaType('string', isRequired),\n              }\n            }\n            break\n\n          default: {\n            break\n          }\n        }\n\n        if ('typescriptSchema' in field && field?.typescriptSchema?.length) {\n          for (const schema of field.typescriptSchema) {\n            fieldSchema = schema({ jsonSchema: fieldSchema! })\n          }\n        }\n\n        if (fieldSchema! && fieldAffectsData(field)) {\n          if (isRequired && fieldSchema.required !== false) {\n            requiredFieldNames.add(field.name)\n          }\n          fieldSchemas.set(field.name, fieldSchema)\n        }\n\n        return fieldSchemas\n      }, new Map<string, JSONSchema4>()),\n    ),\n    required: Array.from(requiredFieldNames),\n  }\n}\n\n// This function is part of the public API and is exported through payload/utilities\nexport function entityToJSONSchema(\n  config: SanitizedConfig,\n  entity: SanitizedCollectionConfig | SanitizedGlobalConfig,\n  interfaceNameDefinitions: Map<string, JSONSchema4>,\n  defaultIDType: 'number' | 'text',\n  collectionIDFieldTypes?: { [key: string]: 'number' | 'string' },\n  i18n?: I18n,\n): JSONSchema4 {\n  if (!collectionIDFieldTypes) {\n    collectionIDFieldTypes = getCollectionIDFieldTypes({ config, defaultIDType })\n  }\n\n  const title = entity.typescript?.interface\n    ? entity.typescript.interface\n    : formatNames(entity.slug).singular\n\n  let mutableFields = [...entity.flattenedFields]\n\n  const idField: FieldAffectingData = { name: 'id', type: defaultIDType as 'text', required: true }\n  const customIdField = mutableFields.find((field) => field.name === 'id') as FieldAffectingData\n\n  if (customIdField && customIdField.type !== 'group' && customIdField.type !== 'tab') {\n    mutableFields = mutableFields.map((field) => {\n      if (field === customIdField) {\n        return { ...field, required: true }\n      }\n\n      return field\n    })\n  } else {\n    mutableFields.unshift(idField)\n  }\n\n  // mark timestamp fields required\n  if ('timestamps' in entity && entity.timestamps !== false) {\n    mutableFields = mutableFields.map((field) => {\n      if (field.name === 'createdAt' || field.name === 'updatedAt') {\n        return {\n          ...field,\n          required: true,\n        }\n      }\n      return field\n    })\n  }\n\n  if (\n    'auth' in entity &&\n    entity.auth &&\n    (!entity.auth?.disableLocalStrategy ||\n      (typeof entity.auth?.disableLocalStrategy === 'object' &&\n        entity.auth.disableLocalStrategy.enableFields))\n  ) {\n    mutableFields.push({\n      name: 'password',\n      type: 'text',\n    })\n  }\n\n  const jsonSchema: JSONSchema4 = {\n    type: 'object',\n    additionalProperties: false,\n    title,\n    ...fieldsToJSONSchema(\n      collectionIDFieldTypes,\n      mutableFields,\n      interfaceNameDefinitions,\n      config,\n      i18n,\n    ),\n  }\n\n  const entityDescription = entityOrFieldToJsDocs({ entity, i18n })\n\n  if (entityDescription) {\n    jsonSchema.description = entityDescription\n  }\n\n  return jsonSchema\n}\n\nexport function fieldsToSelectJSONSchema({\n  config,\n  fields,\n  interfaceNameDefinitions,\n}: {\n  config: SanitizedConfig\n  fields: FlattenedField[]\n  interfaceNameDefinitions: Map<string, JSONSchema4>\n}): JSONSchema4 {\n  const schema: JSONSchema4 = {\n    type: 'object',\n    additionalProperties: false,\n    properties: {},\n  }\n\n  for (const field of fields) {\n    switch (field.type) {\n      case 'array':\n      case 'group':\n      case 'tab': {\n        let fieldSchema: JSONSchema4 = fieldsToSelectJSONSchema({\n          config,\n          fields: field.flattenedFields,\n          interfaceNameDefinitions,\n        })\n\n        if (field.interfaceName) {\n          const definition = `${field.interfaceName}_select`\n          interfaceNameDefinitions.set(definition, fieldSchema)\n\n          fieldSchema = {\n            $ref: `#/definitions/${definition}`,\n          }\n        }\n\n        schema.properties![field.name] = {\n          oneOf: [\n            {\n              type: 'boolean',\n            },\n            fieldSchema,\n          ],\n        }\n\n        break\n      }\n\n      case 'blocks': {\n        const blocksSchema: JSONSchema4 = {\n          type: 'object',\n          additionalProperties: false,\n          properties: {},\n        }\n\n        for (const block of field.blockReferences ?? field.blocks) {\n          if (typeof block === 'string') {\n            continue // TODO\n          }\n\n          let blockSchema = fieldsToSelectJSONSchema({\n            config,\n            fields: block.flattenedFields,\n            interfaceNameDefinitions,\n          })\n\n          if (block.interfaceName) {\n            const definition = `${block.interfaceName}_select`\n            interfaceNameDefinitions.set(definition, blockSchema)\n            blockSchema = {\n              $ref: `#/definitions/${definition}`,\n            }\n          }\n\n          blocksSchema.properties![block.slug] = {\n            oneOf: [\n              {\n                type: 'boolean',\n              },\n              blockSchema,\n            ],\n          }\n        }\n\n        schema.properties![field.name] = {\n          oneOf: [\n            {\n              type: 'boolean',\n            },\n            blocksSchema,\n          ],\n        }\n\n        break\n      }\n\n      default:\n        schema.properties![field.name] = {\n          type: 'boolean',\n        }\n        break\n    }\n  }\n\n  return schema\n}\n\nconst fieldType: JSONSchema4 = {\n  type: 'string',\n  required: false,\n}\nconst generateAuthFieldTypes = ({\n  type,\n  loginWithUsername,\n}: {\n  loginWithUsername: Auth['loginWithUsername']\n  type: 'forgotOrUnlock' | 'login' | 'register'\n}): JSONSchema4 => {\n  if (loginWithUsername) {\n    switch (type) {\n      case 'forgotOrUnlock': {\n        if (loginWithUsername.allowEmailLogin) {\n          // allow email or username for unlock/forgot-password\n          return {\n            additionalProperties: false,\n            oneOf: [\n              {\n                additionalProperties: false,\n                properties: { email: fieldType },\n                required: ['email'],\n              },\n              {\n                additionalProperties: false,\n                properties: { username: fieldType },\n                required: ['username'],\n              },\n            ],\n          }\n        } else {\n          // allow only username for unlock/forgot-password\n          return {\n            additionalProperties: false,\n            properties: { username: fieldType },\n            required: ['username'],\n          }\n        }\n      }\n\n      case 'login': {\n        if (loginWithUsername.allowEmailLogin) {\n          // allow username or email and require password for login\n          return {\n            additionalProperties: false,\n            oneOf: [\n              {\n                additionalProperties: false,\n                properties: { email: fieldType, password: fieldType },\n                required: ['email', 'password'],\n              },\n              {\n                additionalProperties: false,\n                properties: { password: fieldType, username: fieldType },\n                required: ['username', 'password'],\n              },\n            ],\n          }\n        } else {\n          // allow only username and password for login\n          return {\n            additionalProperties: false,\n            properties: {\n              password: fieldType,\n              username: fieldType,\n            },\n            required: ['username', 'password'],\n          }\n        }\n      }\n\n      case 'register': {\n        const requiredFields: ('email' | 'password' | 'username')[] = ['password']\n        const properties: {\n          email?: JSONSchema4['properties']\n          password?: JSONSchema4['properties']\n          username?: JSONSchema4['properties']\n        } = {\n          password: fieldType,\n          username: fieldType,\n        }\n\n        if (loginWithUsername.requireEmail) {\n          requiredFields.push('email')\n        }\n        if (loginWithUsername.requireUsername) {\n          requiredFields.push('username')\n        }\n        if (loginWithUsername.requireEmail || loginWithUsername.allowEmailLogin) {\n          properties.email = fieldType\n        }\n\n        return {\n          additionalProperties: false,\n          properties,\n          required: requiredFields,\n        }\n      }\n    }\n  }\n\n  // default email (and password for login/register)\n  return {\n    additionalProperties: false,\n    properties: { email: fieldType, password: fieldType },\n    required: ['email', 'password'],\n  }\n}\n\nexport function authCollectionToOperationsJSONSchema(\n  config: SanitizedCollectionConfig,\n): JSONSchema4 {\n  const loginWithUsername = config.auth?.loginWithUsername\n  const loginUserFields: JSONSchema4 = generateAuthFieldTypes({ type: 'login', loginWithUsername })\n  const forgotOrUnlockUserFields: JSONSchema4 = generateAuthFieldTypes({\n    type: 'forgotOrUnlock',\n    loginWithUsername,\n  })\n  const registerUserFields: JSONSchema4 = generateAuthFieldTypes({\n    type: 'register',\n    loginWithUsername,\n  })\n\n  const properties: JSONSchema4['properties'] = {\n    forgotPassword: forgotOrUnlockUserFields,\n    login: loginUserFields,\n    registerFirstUser: registerUserFields,\n    unlock: forgotOrUnlockUserFields,\n  }\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n    title: `${formatNames(config.slug).singular}AuthOperations`,\n  }\n}\n\n// Generates the JSON Schema for supported timezones\nexport function timezonesToJSONSchema(\n  supportedTimezones: SanitizedConfig['admin']['timezones']['supportedTimezones'],\n): JSONSchema4 {\n  return {\n    description: 'Supported timezones in IANA format.',\n    enum: supportedTimezones.map((timezone) =>\n      typeof timezone === 'string' ? timezone : timezone.value,\n    ),\n  }\n}\n\nfunction generateAuthOperationSchemas(collections: SanitizedCollectionConfig[]): JSONSchema4 {\n  const properties = collections.reduce(\n    (acc, collection) => {\n      if (collection.auth) {\n        acc[collection.slug] = {\n          $ref: `#/definitions/auth/${collection.slug}`,\n        }\n      }\n      return acc\n    },\n    {} as Record<string, JSONSchema4>,\n  )\n\n  return {\n    type: 'object',\n    additionalProperties: false,\n    properties,\n    required: Object.keys(properties),\n  }\n}\n\n/**\n * This is used for generating the TypeScript types (payload-types.ts) with the payload generate:types command.\n */\nexport function configToJSONSchema(\n  config: SanitizedConfig,\n  defaultIDType?: 'number' | 'text',\n  i18n?: I18n,\n): JSONSchema4 {\n  // a mutable Map to store custom top-level `interfaceName` types. Fields with an `interfaceName` property will be moved to the top-level definitions here\n  const interfaceNameDefinitions: Map<string, JSONSchema4> = new Map()\n\n  //  Used for relationship fields, to determine whether to use a string or number type for the ID.\n  const collectionIDFieldTypes = getCollectionIDFieldTypes({\n    config,\n    defaultIDType: defaultIDType!,\n  })\n\n  // Collections and Globals have to be moved to the top-level definitions as well. Reason: The top-level type will be the `Config` type - we don't want all collection and global\n  // types to be inlined inside the `Config` type\n\n  const entities: {\n    entity: SanitizedCollectionConfig | SanitizedGlobalConfig\n    type: 'collection' | 'global'\n  }[] = [\n    ...config.globals.map((global) => ({ type: 'global' as const, entity: global })),\n    ...config.collections.map((collection) => ({\n      type: 'collection' as const,\n      entity: collection,\n    })),\n  ]\n\n  const entityDefinitions: { [k: string]: JSONSchema4 } = entities.reduce(\n    (acc, { type, entity }) => {\n      acc[entity.slug] = entityToJSONSchema(\n        config,\n        entity,\n        interfaceNameDefinitions,\n        defaultIDType!,\n        collectionIDFieldTypes,\n        i18n,\n      )\n      const select = fieldsToSelectJSONSchema({\n        config,\n        fields: entity.flattenedFields,\n        interfaceNameDefinitions,\n      })\n\n      if (type === 'global') {\n        select.properties!.globalType = {\n          type: 'boolean',\n        }\n      }\n\n      acc[`${entity.slug}_select`] = {\n        type: 'object',\n        additionalProperties: false,\n        ...select,\n      }\n\n      return acc\n    },\n    {} as Record<string, JSONSchema4>,\n  )\n\n  const timezoneDefinitions = timezonesToJSONSchema(config.admin.timezones.supportedTimezones)\n\n  const authOperationDefinitions = [...config.collections]\n    .filter(({ auth }) => Boolean(auth))\n    .reduce(\n      (acc, authCollection) => {\n        acc.auth[authCollection.slug] = authCollectionToOperationsJSONSchema(authCollection)\n        return acc\n      },\n      { auth: {} as Record<string, JSONSchema4> },\n    )\n\n  const jobsSchemas = config.jobs\n    ? generateJobsJSONSchemas(\n        config,\n        config.jobs,\n        interfaceNameDefinitions,\n        collectionIDFieldTypes,\n        i18n,\n      )\n    : {}\n\n  const blocksDefinition: JSONSchema4 | undefined = {\n    type: 'object',\n    additionalProperties: false,\n    properties: {},\n    required: [],\n  }\n  if (config?.blocks?.length) {\n    for (const block of config.blocks) {\n      const blockFieldSchemas = fieldsToJSONSchema(\n        collectionIDFieldTypes,\n        block.flattenedFields,\n        interfaceNameDefinitions,\n        config,\n        i18n,\n      )\n\n      const blockSchema: JSONSchema4 = {\n        type: 'object',\n        additionalProperties: false,\n        properties: {\n          ...blockFieldSchemas.properties,\n          blockType: {\n            const: block.slug,\n          },\n        },\n        required: ['blockType', ...blockFieldSchemas.required],\n      }\n\n      const interfaceName = block.interfaceName ?? block.slug\n      interfaceNameDefinitions.set(interfaceName, blockSchema)\n\n      blocksDefinition.properties![block.slug] = {\n        $ref: `#/definitions/${interfaceName}`,\n      }\n      ;(blocksDefinition.required as string[]).push(block.slug)\n    }\n  }\n\n  let jsonSchema: JSONSchema4 = {\n    additionalProperties: false,\n    definitions: {\n      supportedTimezones: timezoneDefinitions,\n      ...entityDefinitions,\n      ...Object.fromEntries(interfaceNameDefinitions),\n      ...authOperationDefinitions,\n    },\n    // These properties here will be very simple, as all the complexity is in the definitions. These are just the properties for the top-level `Config` type\n    type: 'object',\n    properties: {\n      auth: generateAuthOperationSchemas(config.collections),\n      blocks: blocksDefinition,\n      collections: generateEntitySchemas(config.collections || []),\n      collectionsJoins: generateCollectionJoinsSchemas(config.collections || []),\n      collectionsSelect: generateEntitySelectSchemas(config.collections || []),\n      db: generateDbEntitySchema(config),\n      globals: generateEntitySchemas(config.globals || []),\n      globalsSelect: generateEntitySelectSchemas(config.globals || []),\n      locale: generateLocaleEntitySchemas(config.localization),\n      user: generateAuthEntitySchemas(config.collections),\n    },\n    required: [\n      'user',\n      'locale',\n      'collections',\n      'collectionsSelect',\n      'collectionsJoins',\n      'globalsSelect',\n      'globals',\n      'auth',\n      'db',\n      'jobs',\n      'blocks',\n    ],\n    title: 'Config',\n  }\n\n  if (jobsSchemas.definitions?.size) {\n    for (const [key, value] of jobsSchemas.definitions) {\n      jsonSchema.definitions![key] = value\n    }\n  }\n  if (jobsSchemas.properties) {\n    jsonSchema.properties!.jobs = {\n      type: 'object',\n      additionalProperties: false,\n      properties: jobsSchemas.properties,\n      required: ['tasks', 'workflows'],\n    }\n  }\n\n  if (config?.typescript?.schema?.length) {\n    for (const schema of config.typescript.schema) {\n      jsonSchema = schema({ collectionIDFieldTypes, config, i18n: i18n!, jsonSchema })\n    }\n  }\n\n  return jsonSchema\n}\n"],"names":["MissingEditorProp","fieldAffectsData","generateJobsJSONSchemas","formatNames","getCollectionIDFieldTypes","fieldIsRequired","field","isConditional","Boolean","admin","condition","isMarkedRequired","required","type","flattenedFields","some","subField","buildOptionEnums","options","map","option","value","generateEntitySchemas","entities","properties","reduce","acc","slug","$ref","additionalProperties","Object","keys","generateEntitySelectSchemas","generateCollectionJoinsSchemas","collections","joins","polymorphicJoins","schema","collectionSlug","join","joinPath","enum","push","collection","length","generateLocaleEntitySchemas","localization","locales","localesFromConfig","locale","code","generateAuthEntitySchemas","filter","auth","allOf","oneOf","generateDbEntitySchema","config","defaultIDType","db","withNullableJSONSchemaType","fieldType","isRequired","fieldTypes","entityOrFieldToJsDocs","entity","i18n","description","undefined","en","language","fieldsToJSONSchema","collectionIDFieldTypes","fields","interfaceNameDefinitions","requiredFieldNames","Set","fromEntries","fieldSchemas","index","fieldDescription","baseFieldSchema","fieldSchema","items","interfaceName","set","hasBlocks","blockReferences","blocks","block","resolvedBlock","find","b","blockFieldSchemas","blockSchema","blockType","const","Array","isArray","relationTo","docs","hasNextPage","totalDocs","jsonSchema","hasMany","maxItems","minItems","relation","editor","Error","outputSchema","optionEnums","previousField","isTimezoneField","timezone","name","includes","typescriptSchema","add","Map","from","entityToJSONSchema","title","typescript","interface","singular","mutableFields","idField","customIdField","unshift","timestamps","disableLocalStrategy","enableFields","entityDescription","fieldsToSelectJSONSchema","definition","blocksSchema","generateAuthFieldTypes","loginWithUsername","allowEmailLogin","email","username","password","requiredFields","requireEmail","requireUsername","authCollectionToOperationsJSONSchema","loginUserFields","forgotOrUnlockUserFields","registerUserFields","forgotPassword","login","registerFirstUser","unlock","timezonesToJSONSchema","supportedTimezones","generateAuthOperationSchemas","configToJSONSchema","globals","global","entityDefinitions","select","globalType","timezoneDefinitions","timezones","authOperationDefinitions","authCollection","jobsSchemas","jobs","blocksDefinition","definitions","collectionsJoins","collectionsSelect","globalsSelect","user","size","key"],"mappings":"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"}},
    {"offset": {"line": 2257, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/sanitizeFallbackLocale.ts"],"sourcesContent":["import type { SanitizedLocalizationConfig } from '../config/types.js'\nimport type { TypedLocale } from '../index.js'\n\ninterface Args {\n  fallbackLocale: false | TypedLocale | TypedLocale[]\n  locale: string\n  localization: SanitizedLocalizationConfig\n}\n\n/**\n * Sanitizes fallbackLocale based on a provided fallbackLocale, locale and localization config\n *\n * Handles the following scenarios:\n * - determines if a fallback locale should be used\n * - determines if a locale specific fallback should be used in place of the default locale\n * - sets the fallbackLocale to 'null' if no fallback locale should be used\n */\nexport const sanitizeFallbackLocale = ({\n  fallbackLocale,\n  locale,\n  localization,\n}: Args): null | string => {\n  let hasFallbackLocale = false\n\n  if (fallbackLocale === undefined || fallbackLocale === null) {\n    hasFallbackLocale = Boolean(localization && localization.fallback)\n  }\n\n  if (\n    fallbackLocale &&\n    (Array.isArray(fallbackLocale) || !['false', 'none', 'null'].includes(fallbackLocale))\n  ) {\n    hasFallbackLocale = true\n  }\n\n  if (hasFallbackLocale) {\n    if (!fallbackLocale) {\n      // Check for locale specific fallback\n      const localeSpecificFallback =\n        localization && localization?.locales?.length\n          ? localization.locales.find((localeConfig) => localeConfig.code === locale)\n              ?.fallbackLocale\n          : undefined\n\n      if (localeSpecificFallback) {\n        fallbackLocale = localeSpecificFallback\n      } else {\n        // Use defaultLocale as fallback otherwise\n        if (localization && 'fallback' in localization && localization.fallback) {\n          fallbackLocale = localization.defaultLocale\n        }\n      }\n    }\n  } else {\n    fallbackLocale = null\n  }\n\n  return fallbackLocale as null | string\n}\n"],"names":["sanitizeFallbackLocale","fallbackLocale","locale","localization","hasFallbackLocale","undefined","Boolean","fallback","Array","isArray","includes","localeSpecificFallback","locales","length","find","localeConfig","code","defaultLocale"],"mappings":"AASA;;;;;;;CAOC,GACD;;;;AAAO,MAAMA,yBAAyB,CAAC,EACrCC,cAAc,EACdC,MAAM,EACNC,YAAY,EACP;IACL,IAAIC,oBAAoB;IAExB,IAAIH,mBAAmBI,aAAaJ,mBAAmB,MAAM;QAC3DG,oBAAoBE,QAAQH,gBAAgBA,aAAaI,QAAQ;IACnE;IAEA,IACEN,kBACCO,CAAAA,MAAMC,OAAO,CAACR,mBAAmB,CAAC;QAAC;QAAS;QAAQ;KAAO,CAACS,QAAQ,CAACT,eAAc,GACpF;QACAG,oBAAoB;IACtB;IAEA,IAAIA,mBAAmB;QACrB,IAAI,CAACH,gBAAgB;YACnB,qCAAqC;YACrC,MAAMU,yBACJR,gBAAgBA,cAAcS,SAASC,SACnCV,aAAaS,OAAO,CAACE,IAAI,CAAC,CAACC,eAAiBA,aAAaC,IAAI,KAAKd,SAC9DD,iBACJI;YAEN,IAAIM,wBAAwB;gBAC1BV,iBAAiBU;YACnB,OAAO;gBACL,0CAA0C;gBAC1C,IAAIR,gBAAgB,cAAcA,gBAAgBA,aAAaI,QAAQ,EAAE;oBACvEN,iBAAiBE,aAAac,aAAa;gBAC7C;YACF;QACF;IACF,OAAO;QACLhB,iBAAiB;IACnB;IAEA,OAAOA;AACT,EAAC"}},
    {"offset": {"line": 2302, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/createLocalReq.ts"],"sourcesContent":["import type { Payload, RequestContext, TypedLocale, TypedUser } from '../index.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { getDataLoader } from '../collections/dataloader.js'\nimport { getLocalI18n } from '../translations/getLocalI18n.js'\nimport { sanitizeFallbackLocale } from '../utilities/sanitizeFallbackLocale.js'\n\nfunction getRequestContext(\n  req: Partial<PayloadRequest> = { context: null } as unknown as PayloadRequest,\n  context: RequestContext = {},\n): RequestContext {\n  if (req.context) {\n    if (Object.keys(req.context).length === 0 && req.context.constructor === Object) {\n      // if req.context is `{}` avoid unnecessary spread\n      return context\n    } else {\n      return { ...req.context, ...context }\n    }\n  } else {\n    return context\n  }\n}\n\nconst attachFakeURLProperties = (req: Partial<PayloadRequest>, urlSuffix?: string) => {\n  /**\n   * *NOTE*\n   * If no URL is provided, the local API was called outside\n   * the context of a request. Therefore we create a fake URL object.\n   * `ts-expect-error` is used below for properties that are 'read-only'.\n   * Since they do not exist yet we can safely ignore the error.\n   */\n  let urlObject: undefined | URL\n\n  function getURLObject() {\n    if (urlObject) {\n      return urlObject\n    }\n\n    const fallbackURL = `http://${req.host || 'localhost'}${urlSuffix || ''}`\n\n    const urlToUse =\n      req?.url || req.payload?.config?.serverURL\n        ? `${req.payload?.config.serverURL}${urlSuffix || ''}`\n        : fallbackURL\n\n    try {\n      urlObject = new URL(urlToUse)\n    } catch (_err) {\n      req.payload?.logger.error(\n        `Failed to create URL object from URL: ${urlToUse}, falling back to ${fallbackURL}`,\n      )\n\n      urlObject = new URL(fallbackURL)\n    }\n\n    return urlObject\n  }\n\n  if (!req.host) {\n    req.host = getURLObject().host\n  }\n\n  if (!req.protocol) {\n    req.protocol = getURLObject().protocol\n  }\n\n  if (!req.pathname) {\n    req.pathname = getURLObject().pathname\n  }\n\n  if (!req.searchParams) {\n    // @ts-expect-error eslint-disable-next-line no-param-reassign\n    req.searchParams = getURLObject().searchParams\n  }\n\n  if (!req.origin) {\n    // @ts-expect-error eslint-disable-next-line no-param-reassign\n    req.origin = getURLObject().origin\n  }\n\n  if (!req?.url) {\n    // @ts-expect-error eslint-disable-next-line no-param-reassign\n    req.url = getURLObject().href\n  }\n}\n\nexport type CreateLocalReqOptions = {\n  context?: RequestContext\n  fallbackLocale?: false | TypedLocale\n  locale?: string\n  req?: Partial<PayloadRequest>\n  urlSuffix?: string\n  user?: TypedUser\n}\n\ntype CreateLocalReq = (options: CreateLocalReqOptions, payload: Payload) => Promise<PayloadRequest>\n\nexport const createLocalReq: CreateLocalReq = async (\n  { context, fallbackLocale, locale: localeArg, req = {} as PayloadRequest, urlSuffix, user },\n  payload,\n): Promise<PayloadRequest> => {\n  const localization = payload.config?.localization\n\n  if (localization) {\n    const locale = localeArg === '*' ? 'all' : localeArg\n    const defaultLocale = localization.defaultLocale\n    const localeCandidate = locale || req?.locale || req?.query?.locale\n\n    req.locale =\n      localeCandidate && typeof localeCandidate === 'string' ? localeCandidate : defaultLocale\n\n    const sanitizedFallback = sanitizeFallbackLocale({\n      fallbackLocale: fallbackLocale!,\n      locale: req.locale,\n      localization,\n    })\n\n    req.fallbackLocale = sanitizedFallback!\n  }\n\n  const i18n =\n    req?.i18n ||\n    (await getLocalI18n({ config: payload.config, language: payload.config.i18n.fallbackLanguage }))\n\n  if (!req.headers) {\n    req.headers = new Headers()\n  }\n\n  req.context = getRequestContext(req, context)\n  req.payloadAPI = req?.payloadAPI || 'local'\n  req.payload = payload\n  req.i18n = i18n\n  req.t = i18n.t\n  req.user = user || req?.user || null\n  req.payloadDataLoader = req?.payloadDataLoader || getDataLoader(req as PayloadRequest)\n  req.routeParams = req?.routeParams || {}\n  req.query = req?.query || {}\n\n  attachFakeURLProperties(req, urlSuffix)\n\n  return req as PayloadRequest\n}\n"],"names":["getDataLoader","getLocalI18n","sanitizeFallbackLocale","getRequestContext","req","context","Object","keys","length","constructor","attachFakeURLProperties","urlSuffix","urlObject","getURLObject","fallbackURL","host","urlToUse","url","payload","config","serverURL","URL","_err","logger","error","protocol","pathname","searchParams","origin","href","createLocalReq","fallbackLocale","locale","localeArg","user","localization","defaultLocale","localeCandidate","query","sanitizedFallback","i18n","language","fallbackLanguage","headers","Headers","payloadAPI","t","payloadDataLoader","routeParams"],"mappings":"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"}},
    {"offset": {"line": 2410, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/getFieldByPath.ts"],"sourcesContent":["import type { SanitizedConfig } from '../config/types.js'\nimport type { FlattenedField } from '../fields/config/types.js'\n\n/**\n * Get the field from by its path.\n * Can accept nested paths, e.g: group.title, array.group.title\n * If there were any localized on the path, pathHasLocalized will be true and localizedPath will look like:\n * group.<locale>.title // group is localized here\n */\nexport const getFieldByPath = ({\n  config,\n  fields,\n  includeRelationships = false,\n  localizedPath = '',\n  path,\n}: {\n  config?: SanitizedConfig\n  fields: FlattenedField[]\n  includeRelationships?: boolean\n  localizedPath?: string\n  path: string\n}): {\n  field: FlattenedField\n  localizedPath: string\n  pathHasLocalized: boolean\n} | null => {\n  let currentFields: FlattenedField[] = fields\n\n  let currentField: FlattenedField | null = null\n\n  const segments = path.split('.')\n\n  let pathHasLocalized = false\n\n  while (segments.length > 0) {\n    const segment = segments.shift()\n    localizedPath = `${localizedPath ? `${localizedPath}.` : ''}${segment}`\n    const field = currentFields.find((each) => each.name === segment)\n\n    if (!field) {\n      return null\n    }\n\n    if (field.localized) {\n      pathHasLocalized = true\n      localizedPath = `${localizedPath}.<locale>`\n    }\n\n    if ('flattenedFields' in field) {\n      currentFields = field.flattenedFields\n    }\n\n    if (\n      config &&\n      includeRelationships &&\n      (field.type === 'relationship' || field.type === 'upload') &&\n      !Array.isArray(field.relationTo)\n    ) {\n      const flattenedFields = config.collections.find(\n        (e) => e.slug === field.relationTo,\n      )?.flattenedFields\n      if (flattenedFields) {\n        currentFields = flattenedFields\n      }\n\n      if (segments.length === 1 && segments[0] === 'id') {\n        return { field, localizedPath, pathHasLocalized }\n      }\n    }\n\n    if ('blocks' in field) {\n      for (const block of field.blocks) {\n        const maybeField = getFieldByPath({\n          config,\n          fields: block.flattenedFields,\n          includeRelationships,\n          localizedPath,\n          path: [...segments].join('.'),\n        })\n\n        if (maybeField) {\n          return maybeField\n        }\n      }\n    }\n\n    currentField = field\n  }\n\n  if (!currentField) {\n    return null\n  }\n\n  return { field: currentField, localizedPath, pathHasLocalized }\n}\n"],"names":["getFieldByPath","config","fields","includeRelationships","localizedPath","path","currentFields","currentField","segments","split","pathHasLocalized","length","segment","shift","field","find","each","name","localized","flattenedFields","type","Array","isArray","relationTo","collections","e","slug","block","blocks","maybeField","join"],"mappings":"AAGA;;;;;CAKC,GACD;;;;AAAO,MAAMA,iBAAiB,CAAC,EAC7BC,MAAM,EACNC,MAAM,EACNC,uBAAuB,KAAK,EAC5BC,gBAAgB,EAAE,EAClBC,IAAI,EAOL;IAKC,IAAIC,gBAAkCJ;IAEtC,IAAIK,eAAsC;IAE1C,MAAMC,WAAWH,KAAKI,KAAK,CAAC;IAE5B,IAAIC,mBAAmB;IAEvB,MAAOF,SAASG,MAAM,GAAG,EAAG;QAC1B,MAAMC,UAAUJ,SAASK,KAAK;QAC9BT,gBAAgB,GAAGA,gBAAgB,GAAGA,cAAc,CAAC,CAAC,GAAG,KAAKQ,SAAS;QACvE,MAAME,QAAQR,cAAcS,IAAI,CAAC,CAACC,OAASA,KAAKC,IAAI,KAAKL;QAEzD,IAAI,CAACE,OAAO;YACV,OAAO;QACT;QAEA,IAAIA,MAAMI,SAAS,EAAE;YACnBR,mBAAmB;YACnBN,gBAAgB,GAAGA,cAAc,SAAS,CAAC;QAC7C;QAEA,IAAI,qBAAqBU,OAAO;YAC9BR,gBAAgBQ,MAAMK,eAAe;QACvC;QAEA,IACElB,UACAE,wBACCW,CAAAA,MAAMM,IAAI,KAAK,kBAAkBN,MAAMM,IAAI,KAAK,QAAO,KACxD,CAACC,MAAMC,OAAO,CAACR,MAAMS,UAAU,GAC/B;YACA,MAAMJ,kBAAkBlB,OAAOuB,WAAW,CAACT,IAAI,CAC7C,CAACU,IAAMA,EAAEC,IAAI,KAAKZ,MAAMS,UAAU,GACjCJ;YACH,IAAIA,iBAAiB;gBACnBb,gBAAgBa;YAClB;YAEA,IAAIX,SAASG,MAAM,KAAK,KAAKH,QAAQ,CAAC,EAAE,KAAK,MAAM;gBACjD,OAAO;oBAAEM;oBAAOV;oBAAeM;gBAAiB;YAClD;QACF;QAEA,IAAI,YAAYI,OAAO;YACrB,KAAK,MAAMa,SAASb,MAAMc,MAAM,CAAE;gBAChC,MAAMC,aAAa7B,eAAe;oBAChCC;oBACAC,QAAQyB,MAAMR,eAAe;oBAC7BhB;oBACAC;oBACAC,MAAM;2BAAIG;qBAAS,CAACsB,IAAI,CAAC;gBAC3B;gBAEA,IAAID,YAAY;oBACd,OAAOA;gBACT;YACF;QACF;QAEAtB,eAAeO;IACjB;IAEA,IAAI,CAACP,cAAc;QACjB,OAAO;IACT;IAEA,OAAO;QAAEO,OAAOP;QAAcH;QAAeM;IAAiB;AAChE,EAAC"}},
    {"offset": {"line": 2482, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/addDataAndFileToRequest.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\n\nimport { APIError } from '../errors/APIError.js'\nimport { processMultipartFormdata } from '../uploads/fetchAPI-multipart/index.js'\n\ntype AddDataAndFileToRequest = (req: PayloadRequest) => Promise<void>\n\n/**\n * Mutates the Request, appending 'data' and 'file' if found\n */\nexport const addDataAndFileToRequest: AddDataAndFileToRequest = async (req) => {\n  const { body, headers, method, payload } = req\n\n  if (method && ['PATCH', 'POST', 'PUT'].includes(method.toUpperCase()) && body) {\n    const [contentType] = (headers.get('Content-Type') || '').split(';', 1)\n    const bodyByteSize = parseInt(req.headers.get('Content-Length') || '0', 10)\n\n    if (contentType === 'application/json') {\n      let data = {}\n      try {\n        const text = await req.text?.()\n        data = text ? JSON.parse(text) : {}\n      } catch (error) {\n        req.payload.logger.error(error)\n      } finally {\n        req.data = data\n        // @ts-expect-error attach json method to request\n        req.json = () => Promise.resolve(data)\n      }\n    } else if (bodyByteSize && contentType?.includes('multipart/')) {\n      const { error, fields, files } = await processMultipartFormdata({\n        options: {\n          ...(payload.config.bodyParser || {}),\n          ...(payload.config.upload || {}),\n        },\n        request: req as Request,\n      })\n\n      if (error) {\n        throw new APIError(error.message)\n      }\n\n      if (files?.file) {\n        req.file = files.file\n      }\n\n      if (fields?._payload && typeof fields._payload === 'string') {\n        req.data = JSON.parse(fields._payload)\n      }\n\n      if (!req.file && fields?.file && typeof fields?.file === 'string') {\n        const { clientUploadContext, collectionSlug, filename, mimeType, size } = JSON.parse(\n          fields.file,\n        )\n        const uploadConfig = req.payload.collections[collectionSlug]!.config.upload\n\n        if (!uploadConfig.handlers) {\n          throw new APIError('uploadConfig.handlers is not present for ' + collectionSlug)\n        }\n\n        let response: null | Response = null\n        let error: unknown\n\n        for (const handler of uploadConfig.handlers) {\n          try {\n            const result = await handler(req, {\n              doc: null!,\n              params: {\n                clientUploadContext, // Pass additional specific to adapters context returned from UploadHandler, then staticHandler can use them.\n                collection: collectionSlug,\n                filename,\n              },\n            })\n            if (result) {\n              response = result\n            }\n            // If we couldn't get the file from that handler, save the error and try other.\n          } catch (err) {\n            error = err\n          }\n        }\n\n        if (!response) {\n          if (error) {\n            payload.logger.error(error)\n          }\n\n          throw new APIError('Expected response from the upload handler.')\n        }\n\n        req.file = {\n          name: filename,\n          clientUploadContext,\n          data: Buffer.from(await response.arrayBuffer()),\n          mimetype: response.headers.get('Content-Type') || mimeType,\n          size,\n        }\n      }\n    }\n  }\n}\n"],"names":["APIError","processMultipartFormdata","addDataAndFileToRequest","req","body","headers","method","payload","includes","toUpperCase","contentType","get","split","bodyByteSize","parseInt","data","text","JSON","parse","error","logger","json","Promise","resolve","fields","files","options","config","bodyParser","upload","request","message","file","_payload","clientUploadContext","collectionSlug","filename","mimeType","size","uploadConfig","collections","handlers","response","handler","result","doc","params","collection","err","name","Buffer","from","arrayBuffer","mimetype"],"mappings":"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"}},
    {"offset": {"line": 2575, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/addLocalesToRequest.ts"],"sourcesContent":["import type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { sanitizeFallbackLocale } from './sanitizeFallbackLocale.js'\n\n/**\n * Mutates the Request to contain 'locale' and 'fallbackLocale' based on data or searchParams\n */\nexport function addLocalesToRequestFromData(req: PayloadRequest): void {\n  const {\n    data,\n    payload: { config },\n  } = req\n\n  if (data) {\n    const localeOnReq = req.locale\n    const fallbackLocaleOnReq = req.fallbackLocale\n    let localeFromData!: string\n    let fallbackLocaleFromData!: string | string[]\n\n    if (!localeOnReq && data?.locale && typeof data.locale === 'string') {\n      localeFromData = data.locale\n    }\n\n    if (!fallbackLocaleOnReq) {\n      if (data?.['fallback-locale'] && typeof data?.['fallback-locale'] === 'string') {\n        fallbackLocaleFromData = data['fallback-locale']\n      }\n\n      if (data?.['fallbackLocale'] && typeof data?.['fallbackLocale'] === 'string') {\n        fallbackLocaleFromData = data['fallbackLocale']\n      }\n    }\n\n    if (!localeOnReq || !fallbackLocaleOnReq) {\n      const { fallbackLocale, locale } = sanitizeLocales({\n        fallbackLocale: fallbackLocaleFromData,\n        locale: localeFromData,\n        localization: config.localization,\n      })\n\n      if (localeFromData) {\n        req.locale = locale\n      }\n\n      if (fallbackLocaleFromData) {\n        req.fallbackLocale = fallbackLocale\n      }\n    }\n  }\n}\n\ntype SanitizeLocalesArgs = {\n  fallbackLocale: string | string[]\n  locale: string\n  localization: SanitizedConfig['localization']\n}\ntype SanitizeLocalesReturn = {\n  fallbackLocale?: string | string[]\n  locale?: string\n}\nexport const sanitizeLocales = ({\n  fallbackLocale,\n  locale,\n  localization,\n}: SanitizeLocalesArgs): SanitizeLocalesReturn => {\n  // Check if localization has fallback enabled or if a fallback locale is provided\n\n  if (localization) {\n    fallbackLocale = sanitizeFallbackLocale({\n      fallbackLocale,\n      locale,\n      localization,\n    })!\n  }\n\n  if (['*', 'all'].includes(locale)) {\n    locale = 'all'\n  } else if (localization && !localization.localeCodes.includes(locale) && localization.fallback) {\n    locale = localization.defaultLocale\n  }\n\n  return {\n    fallbackLocale,\n    locale,\n  }\n}\n"],"names":["sanitizeFallbackLocale","addLocalesToRequestFromData","req","data","payload","config","localeOnReq","locale","fallbackLocaleOnReq","fallbackLocale","localeFromData","fallbackLocaleFromData","sanitizeLocales","localization","includes","localeCodes","fallback","defaultLocale"],"mappings":";;;;;;AAGA,SAASA,sBAAsB,QAAQ,8BAA6B;;AAK7D,SAASC,4BAA4BC,GAAmB;IAC7D,MAAM,EACJC,IAAI,EACJC,SAAS,EAAEC,MAAM,EAAE,EACpB,GAAGH;IAEJ,IAAIC,MAAM;QACR,MAAMG,cAAcJ,IAAIK,MAAM;QAC9B,MAAMC,sBAAsBN,IAAIO,cAAc;QAC9C,IAAIC;QACJ,IAAIC;QAEJ,IAAI,CAACL,eAAeH,MAAMI,UAAU,OAAOJ,KAAKI,MAAM,KAAK,UAAU;YACnEG,iBAAiBP,KAAKI,MAAM;QAC9B;QAEA,IAAI,CAACC,qBAAqB;YACxB,IAAIL,MAAM,CAAC,kBAAkB,IAAI,OAAOA,MAAM,CAAC,kBAAkB,KAAK,UAAU;gBAC9EQ,yBAAyBR,IAAI,CAAC,kBAAkB;YAClD;YAEA,IAAIA,MAAM,CAAC,iBAAiB,IAAI,OAAOA,MAAM,CAAC,iBAAiB,KAAK,UAAU;gBAC5EQ,yBAAyBR,IAAI,CAAC,iBAAiB;YACjD;QACF;QAEA,IAAI,CAACG,eAAe,CAACE,qBAAqB;YACxC,MAAM,EAAEC,cAAc,EAAEF,MAAM,EAAE,GAAGK,gBAAgB;gBACjDH,gBAAgBE;gBAChBJ,QAAQG;gBACRG,cAAcR,OAAOQ,YAAY;YACnC;YAEA,IAAIH,gBAAgB;gBAClBR,IAAIK,MAAM,GAAGA;YACf;YAEA,IAAII,wBAAwB;gBAC1BT,IAAIO,cAAc,GAAGA;YACvB;QACF;IACF;AACF;AAWO,MAAMG,kBAAkB,CAAC,EAC9BH,cAAc,EACdF,MAAM,EACNM,YAAY,EACQ;IACpB,iFAAiF;IAEjF,IAAIA,cAAc;QAChBJ,qBAAiBT,wSAAAA,EAAuB;YACtCS;YACAF;YACAM;QACF;IACF;IAEA,IAAI;QAAC;QAAK;KAAM,CAACC,QAAQ,CAACP,SAAS;QACjCA,SAAS;IACX,OAAO,IAAIM,gBAAgB,CAACA,aAAaE,WAAW,CAACD,QAAQ,CAACP,WAAWM,aAAaG,QAAQ,EAAE;QAC9FT,SAASM,aAAaI,aAAa;IACrC;IAEA,OAAO;QACLR;QACAF;IACF;AACF,EAAC"}},
    {"offset": {"line": 2642, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/wrapInternalEndpoints.ts"],"sourcesContent":["import type { Endpoint } from '../config/types.js'\n\nimport { addDataAndFileToRequest } from './addDataAndFileToRequest.js'\nimport { addLocalesToRequestFromData } from './addLocalesToRequest.js'\n\nexport const wrapInternalEndpoints = (endpoints: Endpoint[]): Endpoint[] => {\n  return endpoints.map((endpoint) => {\n    const handler = endpoint.handler\n\n    if (['patch', 'post'].includes(endpoint.method)) {\n      endpoint.handler = async (req) => {\n        await addDataAndFileToRequest(req)\n        addLocalesToRequestFromData(req)\n        return handler(req)\n      }\n    }\n\n    return endpoint\n  })\n}\n"],"names":["addDataAndFileToRequest","addLocalesToRequestFromData","wrapInternalEndpoints","endpoints","map","endpoint","handler","includes","method","req"],"mappings":";;;;AAEA,SAASA,uBAAuB,QAAQ,+BAA8B;AACtE,SAASC,2BAA2B,QAAQ,2BAA0B;;;AAE/D,MAAMC,wBAAwB,CAACC;IACpC,OAAOA,UAAUC,GAAG,CAAC,CAACC;QACpB,MAAMC,UAAUD,SAASC,OAAO;QAEhC,IAAI;YAAC;YAAS;SAAO,CAACC,QAAQ,CAACF,SAASG,MAAM,GAAG;YAC/CH,SAASC,OAAO,GAAG,OAAOG;gBACxB,UAAMT,0SAAAA,EAAwBS;oBAC9BR,0SAAAA,EAA4BQ;gBAC5B,OAAOH,QAAQG;YACjB;QACF;QAEA,OAAOJ;IACT;AACF,EAAC"}},
    {"offset": {"line": 2670, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/headersWithCors.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\n\ntype CorsArgs = {\n  headers: Headers\n  req: Partial<PayloadRequest>\n}\nexport const headersWithCors = ({ headers, req }: CorsArgs): Headers => {\n  const cors = req?.payload?.config.cors\n  const requestOrigin = req?.headers?.get('Origin')\n\n  if (cors) {\n    const defaultAllowedHeaders = [\n      'Origin',\n      'X-Requested-With',\n      'Content-Type',\n      'Accept',\n      'Authorization',\n      'Content-Encoding',\n      'x-apollo-tracing',\n      'X-Payload-HTTP-Method-Override',\n    ]\n\n    headers.set('Access-Control-Allow-Methods', 'PUT, PATCH, POST, GET, DELETE, OPTIONS')\n\n    if (typeof cors === 'object' && 'headers' in cors) {\n      headers.set(\n        'Access-Control-Allow-Headers',\n        [...defaultAllowedHeaders, ...cors.headers].filter(Boolean).join(', '),\n      )\n    } else {\n      headers.set('Access-Control-Allow-Headers', defaultAllowedHeaders.join(', '))\n    }\n\n    if (cors === '*' || (typeof cors === 'object' && 'origins' in cors && cors.origins === '*')) {\n      headers.set('Access-Control-Allow-Origin', '*')\n    } else if (\n      (Array.isArray(cors) && cors.indexOf(requestOrigin!) > -1) ||\n      (!Array.isArray(cors) &&\n        typeof cors === 'object' &&\n        'origins' in cors &&\n        cors.origins.indexOf(requestOrigin!) > -1)\n    ) {\n      headers.set('Access-Control-Allow-Credentials', 'true')\n      headers.set('Access-Control-Allow-Origin', requestOrigin!)\n    }\n  }\n\n  return headers\n}\n"],"names":["headersWithCors","headers","req","cors","payload","config","requestOrigin","get","defaultAllowedHeaders","set","filter","Boolean","join","origins","Array","isArray","indexOf"],"mappings":";;;;AAMO,MAAMA,kBAAkB,CAAC,EAAEC,OAAO,EAAEC,GAAG,EAAY;IACxD,MAAMC,OAAOD,KAAKE,SAASC,OAAOF;IAClC,MAAMG,gBAAgBJ,KAAKD,SAASM,IAAI;IAExC,IAAIJ,MAAM;QACR,MAAMK,wBAAwB;YAC5B;YACA;YACA;YACA;YACA;YACA;YACA;YACA;SACD;QAEDP,QAAQQ,GAAG,CAAC,gCAAgC;QAE5C,IAAI,OAAON,SAAS,YAAY,aAAaA,MAAM;YACjDF,QAAQQ,GAAG,CACT,gCACA;mBAAID;mBAA0BL,KAAKF,OAAO;aAAC,CAACS,MAAM,CAACC,SAASC,IAAI,CAAC;QAErE,OAAO;YACLX,QAAQQ,GAAG,CAAC,gCAAgCD,sBAAsBI,IAAI,CAAC;QACzE;QAEA,IAAIT,SAAS,OAAQ,OAAOA,SAAS,YAAY,aAAaA,QAAQA,KAAKU,OAAO,KAAK,KAAM;YAC3FZ,QAAQQ,GAAG,CAAC,+BAA+B;QAC7C,OAAO,IACJK,MAAMC,OAAO,CAACZ,SAASA,KAAKa,OAAO,CAACV,iBAAkB,CAAC,KACvD,CAACQ,MAAMC,OAAO,CAACZ,SACd,OAAOA,SAAS,YAChB,aAAaA,QACbA,KAAKU,OAAO,CAACG,OAAO,CAACV,iBAAkB,CAAC,GAC1C;YACAL,QAAQQ,GAAG,CAAC,oCAAoC;YAChDR,QAAQQ,GAAG,CAAC,+BAA+BH;QAC7C;IACF;IAEA,OAAOL;AACT,EAAC"}},
    {"offset": {"line": 2710, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/killTransaction.ts"],"sourcesContent":["import type { MarkRequired } from 'ts-essentials'\n\nimport type { PayloadRequest } from '../types/index.js'\n\n/**\n * Rollback the transaction from the req using the db adapter and removes it from the req\n */\nexport async function killTransaction(\n  req: MarkRequired<Partial<PayloadRequest>, 'payload'>,\n): Promise<void> {\n  const { payload, transactionID } = req\n  if (transactionID && !(transactionID instanceof Promise)) {\n    try {\n      await payload.db.rollbackTransaction(req.transactionID!)\n    } catch (ignore) {\n      // swallow any errors while attempting to rollback\n    }\n    delete req.transactionID\n  }\n}\n"],"names":["killTransaction","req","payload","transactionID","Promise","db","rollbackTransaction","ignore"],"mappings":"AAIA;;CAEC,GACD;;;;AAAO,eAAeA,gBACpBC,GAAqD;IAErD,MAAM,EAAEC,OAAO,EAAEC,aAAa,EAAE,GAAGF;IACnC,IAAIE,iBAAiB,CAAEA,CAAAA,yBAAyBC,OAAM,GAAI;QACxD,IAAI;YACF,MAAMF,QAAQG,EAAE,CAACC,mBAAmB,CAACL,IAAIE,aAAa;QACxD,EAAE,OAAOI,QAAQ;QACf,kDAAkD;QACpD;QACA,OAAON,IAAIE,aAAa;IAC1B;AACF"}},
    {"offset": {"line": 2731, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/telemetry/conf/envPaths.ts"],"sourcesContent":["// @ts-strict-ignore\n/**\n * Taken from https://github.com/sindresorhus/env-paths/blob/main/index.js\n *\n * MIT License\n *\n * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport os from 'node:os'\nimport path from 'node:path'\nimport process from 'node:process'\n\nconst homedir = os.homedir()\nconst tmpdir = os.tmpdir()\nconst { env } = process\n\nconst macos = (name: string) => {\n  const library = path.join(homedir, 'Library')\n\n  return {\n    cache: path.join(library, 'Caches', name),\n    config: path.join(library, 'Preferences', name),\n    data: path.join(library, 'Application Support', name),\n    log: path.join(library, 'Logs', name),\n    temp: path.join(tmpdir, name),\n  }\n}\n\nconst windows = (name: string) => {\n  const appData = env.APPDATA || path.join(homedir, 'AppData', 'Roaming')\n  const localAppData = env.LOCALAPPDATA || path.join(homedir, 'AppData', 'Local')\n\n  return {\n    // Data/config/cache/log are invented by me as Windows isn't opinionated about this\n    cache: path.join(localAppData, name, 'Cache'),\n    config: path.join(appData, name, 'Config'),\n    data: path.join(localAppData, name, 'Data'),\n    log: path.join(localAppData, name, 'Log'),\n    temp: path.join(tmpdir, name),\n  }\n}\n\n// https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html\nconst linux = (name: string) => {\n  const username = path.basename(homedir)\n\n  return {\n    cache: path.join(env.XDG_CACHE_HOME || path.join(homedir, '.cache'), name),\n    config: path.join(env.XDG_CONFIG_HOME || path.join(homedir, '.config'), name),\n    data: path.join(env.XDG_DATA_HOME || path.join(homedir, '.local', 'share'), name),\n    // https://wiki.debian.org/XDGBaseDirectorySpecification#state\n    log: path.join(env.XDG_STATE_HOME || path.join(homedir, '.local', 'state'), name),\n    temp: path.join(tmpdir, username, name),\n  }\n}\n\nexport function envPaths(name: string, { suffix = 'nodejs' } = {}) {\n  if (typeof name !== 'string') {\n    throw new TypeError(`Expected a string, got ${typeof name}`)\n  }\n\n  if (suffix) {\n    // Add suffix to prevent possible conflict with native apps\n    name += `-${suffix}`\n  }\n\n  if (process.platform === 'darwin') {\n    return macos(name)\n  }\n\n  if (process.platform === 'win32') {\n    return windows(name)\n  }\n\n  return linux(name)\n}\n"],"names":["os","path","process","homedir","tmpdir","env","macos","name","library","join","cache","config","data","log","temp","windows","appData","APPDATA","localAppData","LOCALAPPDATA","linux","username","basename","XDG_CACHE_HOME","XDG_CONFIG_HOME","XDG_DATA_HOME","XDG_STATE_HOME","envPaths","suffix","TypeError","platform"],"mappings":";;;;AAAA,oBAAoB;AACpB;;;;;;;;;;;;CAYC,GAED,OAAOA,QAAQ,UAAS;AACxB,OAAOC,UAAU,YAAW;AAC5B,OAAOC,aAAa,eAAc;;;;AAElC,MAAMC,UAAUH,wHAAAA,CAAGG,OAAO;AAC1B,MAAMC,SAASJ,wHAAAA,CAAGI,MAAM;AACxB,MAAM,EAAEC,GAAG,EAAE,GAAGH,kIAAAA;AAEhB,MAAMI,QAAQ,CAACC;IACb,MAAMC,UAAUP,4HAAAA,CAAKQ,IAAI,CAACN,SAAS;IAEnC,OAAO;QACLO,OAAOT,4HAAAA,CAAKQ,IAAI,CAACD,SAAS,UAAUD;QACpCI,QAAQV,4HAAAA,CAAKQ,IAAI,CAACD,SAAS,eAAeD;QAC1CK,MAAMX,4HAAAA,CAAKQ,IAAI,CAACD,SAAS,uBAAuBD;QAChDM,KAAKZ,4HAAAA,CAAKQ,IAAI,CAACD,SAAS,QAAQD;QAChCO,MAAMb,4HAAAA,CAAKQ,IAAI,CAACL,QAAQG;IAC1B;AACF;AAEA,MAAMQ,UAAU,CAACR;IACf,MAAMS,UAAUX,IAAIY,OAAO,IAAIhB,4HAAAA,CAAKQ,IAAI,CAACN,SAAS,WAAW;IAC7D,MAAMe,eAAeb,IAAIc,YAAY,IAAIlB,4HAAAA,CAAKQ,IAAI,CAACN,SAAS,WAAW;IAEvE,OAAO;QACL,mFAAmF;QACnFO,OAAOT,4HAAAA,CAAKQ,IAAI,CAACS,cAAcX,MAAM;QACrCI,QAAQV,4HAAAA,CAAKQ,IAAI,CAACO,SAAST,MAAM;QACjCK,MAAMX,4HAAAA,CAAKQ,IAAI,CAACS,cAAcX,MAAM;QACpCM,KAAKZ,4HAAAA,CAAKQ,IAAI,CAACS,cAAcX,MAAM;QACnCO,MAAMb,4HAAAA,CAAKQ,IAAI,CAACL,QAAQG;IAC1B;AACF;AAEA,+EAA+E;AAC/E,MAAMa,QAAQ,CAACb;IACb,MAAMc,WAAWpB,4HAAAA,CAAKqB,QAAQ,CAACnB;IAE/B,OAAO;QACLO,OAAOT,4HAAAA,CAAKQ,IAAI,CAACJ,IAAIkB,cAAc,IAAItB,4HAAAA,CAAKQ,IAAI,CAACN,SAAS,WAAWI;QACrEI,QAAQV,4HAAAA,CAAKQ,IAAI,CAACJ,IAAImB,eAAe,IAAIvB,4HAAAA,CAAKQ,IAAI,CAACN,SAAS,YAAYI;QACxEK,MAAMX,4HAAAA,CAAKQ,IAAI,CAACJ,IAAIoB,aAAa,IAAIxB,4HAAAA,CAAKQ,IAAI,CAACN,SAAS,UAAU,UAAUI;QAC5E,8DAA8D;QAC9DM,KAAKZ,4HAAAA,CAAKQ,IAAI,CAACJ,IAAIqB,cAAc,IAAIzB,4HAAAA,CAAKQ,IAAI,CAACN,SAAS,UAAU,UAAUI;QAC5EO,MAAMb,4HAAAA,CAAKQ,IAAI,CAACL,QAAQiB,UAAUd;IACpC;AACF;AAEO,SAASoB,SAASpB,IAAY,EAAE,EAAEqB,SAAS,QAAQ,EAAE,GAAG,CAAC,CAAC;IAC/D,IAAI,OAAOrB,SAAS,UAAU;QAC5B,MAAM,IAAIsB,UAAU,CAAC,uBAAuB,EAAE,OAAOtB,MAAM;IAC7D;IAEA,IAAIqB,QAAQ;QACV,2DAA2D;QAC3DrB,QAAQ,CAAC,CAAC,EAAEqB,QAAQ;IACtB;IAEA,IAAI1B,kIAAAA,CAAQ4B,QAAQ,KAAK,UAAU;QACjC,OAAOxB,MAAMC;IACf;IAEA,IAAIL,kIAAAA,CAAQ4B,QAAQ,KAAK,SAAS;QAChC,OAAOf,QAAQR;IACjB;IAEA,OAAOa,MAAMb;AACf"}},
    {"offset": {"line": 2811, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/telemetry/conf/index.ts"],"sourcesContent":["/**\n * Taken & simplified from https://github.com/sindresorhus/conf/blob/main/source/index.ts\n *\n * MIT License\n *\n * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport assert from 'node:assert'\nimport fs from 'node:fs'\nimport path from 'node:path'\n\nimport { envPaths } from './envPaths.js'\n\nconst createPlainObject = <T = Record<string, unknown>>(): T => Object.create(null)\n\nconst checkValueType = (key: string, value: unknown): void => {\n  const nonJsonTypes = new Set(['function', 'symbol', 'undefined'])\n\n  const type = typeof value\n\n  if (nonJsonTypes.has(type)) {\n    throw new TypeError(\n      `Setting a value of type \\`${type}\\` for key \\`${key}\\` is not allowed as it's not supported by JSON`,\n    )\n  }\n}\n\nexport class Conf<T extends Record<string, any> = Record<string, unknown>>\n  implements Iterable<[keyof T, T[keyof T]]>\n{\n  readonly #options: Readonly<Partial<Options>>\n  private readonly _deserialize: Deserialize<T> = (value) => JSON.parse(value)\n  private readonly _serialize: Serialize<T> = (value) => JSON.stringify(value, undefined, '\\t')\n\n  readonly events: EventTarget\n\n  readonly path: string\n\n  constructor() {\n    const options: Partial<Options> = {\n      configFileMode: 0o666,\n      configName: 'config',\n      fileExtension: 'json',\n      projectSuffix: 'nodejs',\n    }\n\n    const cwd = envPaths('payload', { suffix: options.projectSuffix }).config\n\n    this.#options = options\n\n    this.events = new EventTarget()\n\n    const fileExtension = options.fileExtension ? `.${options.fileExtension}` : ''\n    this.path = path.resolve(cwd, `${options.configName ?? 'config'}${fileExtension}`)\n\n    const fileStore = this.store\n    const store = Object.assign(createPlainObject(), fileStore)\n\n    try {\n      assert.deepEqual(fileStore, store)\n    } catch {\n      this.store = store\n    }\n  }\n\n  private _ensureDirectory(): void {\n    // Ensure the directory exists as it could have been deleted in the meantime.\n    fs.mkdirSync(path.dirname(this.path), { recursive: true })\n  }\n\n  private _write(value: T): void {\n    const data: string | Uint8Array = this._serialize(value)\n\n    fs.writeFileSync(this.path, data, { mode: this.#options.configFileMode })\n  }\n\n  /**\n   Delete an item.\n\n   @param key - The key of the item to delete.\n   */\n  delete(key: string): void {\n    const { store } = this\n    delete store[key]\n\n    this.store = store\n  }\n\n  /**\n   Get an item.\n\n   @param key - The key of the item to get.\n   */\n  get<Key extends keyof T>(key: Key): T[Key] {\n    const { store } = this\n    return store[key]\n  }\n\n  /**\n   Set an item or multiple items at once.\n\n   @param key - You can use [dot-notation](https://github.com/sindresorhus/dot-prop) in a key to access nested properties. Or a hashmap of items to set at once.\n   @param value - Must be JSON serializable. Trying to set the type `undefined`, `function`, or `symbol` will result in a `TypeError`.\n   */\n  set<Key extends keyof T>(key: string, value?: T[Key] | unknown): void {\n    if (typeof key !== 'string' && typeof key !== 'object') {\n      throw new TypeError(\n        `Expected \\`key\\` to be of type \\`string\\` or \\`object\\`, got ${typeof key}`,\n      )\n    }\n\n    if (typeof key !== 'object' && value === undefined) {\n      throw new TypeError('Use `delete()` to clear values')\n    }\n\n    const { store } = this\n\n    const set = (key: string, value?: T | T[Key] | unknown): void => {\n      checkValueType(key, value)\n      store[key as Key] = value as T[Key]\n    }\n\n    if (typeof key === 'object') {\n      const object = key\n      for (const [key, value] of Object.entries(object)) {\n        set(key, value)\n      }\n    } else {\n      set(key, value)\n    }\n\n    this.store = store\n  }\n\n  *[Symbol.iterator](): IterableIterator<[keyof T, T[keyof T]]> {\n    for (const [key, value] of Object.entries(this.store)) {\n      yield [key, value]\n    }\n  }\n  get size(): number {\n    return Object.keys(this.store).length\n  }\n  get store(): T {\n    try {\n      const dataString = fs.readFileSync(this.path, 'utf8')\n      const deserializedData = this._deserialize(dataString)\n      return Object.assign(createPlainObject(), deserializedData)\n    } catch (error: unknown) {\n      if ((error as any)?.code === 'ENOENT') {\n        this._ensureDirectory()\n        return createPlainObject()\n      }\n\n      throw error\n    }\n  }\n\n  set store(value: T) {\n    this._ensureDirectory()\n\n    this._write(value)\n\n    this.events.dispatchEvent(new Event('change'))\n  }\n}\n\nexport type Options = {\n  /**\n   The config is cleared if reading the config file causes a `SyntaxError`. This is a good behavior for unimportant data, as the config file is not intended to be hand-edited, so it usually means the config is corrupt and there's nothing the user can do about it anyway. However, if you let the user edit the config file directly, mistakes might happen and it could be more useful to throw an error when the config is invalid instead of clearing.\n\n   @default false\n   */\n  clearInvalidConfig?: boolean\n\n  /**\n   The [mode](https://en.wikipedia.org/wiki/File-system_permissions#Numeric_notation) that will be used for the config file.\n\n   You would usually not need this, but it could be useful if you want to restrict the permissions of the config file. Setting a permission such as `0o600` would result in a config file that can only be accessed by the user running the program.\n\n   Note that setting restrictive permissions can cause problems if different users need to read the file. A common problem is a user running your tool with and without `sudo` and then not being able to access the config the second time.\n\n   @default 0o666\n   */\n  readonly configFileMode?: number\n\n  /**\n   Name of the config file (without extension).\n\n   Useful if you need multiple config files for your app or module. For example, different config files between two major versions.\n\n   @default 'config'\n   */\n  configName?: string\n\n  /**\n   Extension of the config file.\n\n   You would usually not need this, but could be useful if you want to interact with a file with a custom file extension that can be associated with your app. These might be simple save/export/preference files that are intended to be shareable or saved outside of the app.\n\n   @default 'json'\n   */\n  fileExtension?: string\n\n  readonly projectSuffix?: string\n}\n\nexport type Serialize<T> = (value: T) => string\nexport type Deserialize<T> = (text: string) => T\n"],"names":["assert","fs","path","envPaths","createPlainObject","Object","create","checkValueType","key","value","nonJsonTypes","Set","type","has","TypeError","Conf","_deserialize","JSON","parse","_serialize","stringify","undefined","events","constructor","options","configFileMode","configName","fileExtension","projectSuffix","cwd","suffix","config","EventTarget","resolve","fileStore","store","assign","deepEqual","_ensureDirectory","mkdirSync","dirname","recursive","_write","data","writeFileSync","mode","delete","get","set","object","entries","Symbol","iterator","size","keys","length","dataString","readFileSync","deserializedData","error","code","dispatchEvent","Event"],"mappings":"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"}},
    {"offset": {"line": 2965, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/telemetry/oneWayHash.ts"],"sourcesContent":["import type { BinaryLike } from 'crypto'\n\nimport { createHash } from 'crypto'\n\nexport const oneWayHash = (data: BinaryLike, secret: string): string => {\n  const hash = createHash('sha256')\n\n  // prepend value with payload secret. This ensure one-way.\n  hash.update(secret)\n\n  // Update is an append operation, not a replacement. The secret from the prior\n  // update is still present!\n  hash.update(data)\n  return hash.digest('hex')\n}\n"],"names":["createHash","oneWayHash","data","secret","hash","update","digest"],"mappings":";;;;AAEA,SAASA,UAAU,QAAQ,SAAQ;;AAE5B,MAAMC,aAAa,CAACC,MAAkBC;IAC3C,MAAMC,WAAOJ,mHAAAA,EAAW;IAExB,0DAA0D;IAC1DI,KAAKC,MAAM,CAACF;IAEZ,8EAA8E;IAC9E,2BAA2B;IAC3BC,KAAKC,MAAM,CAACH;IACZ,OAAOE,KAAKE,MAAM,CAAC;AACrB,EAAC"}},
    {"offset": {"line": 2984, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/telemetry/index.ts"],"sourcesContent":["import { execSync } from 'child_process'\nimport ciInfo from 'ci-info'\nimport { randomBytes } from 'crypto'\nimport fs from 'fs'\nimport path from 'path'\nimport { fileURLToPath } from 'url'\n\nimport type { Payload } from '../../types/index.js'\nimport type { AdminInitEvent } from './events/adminInit.js'\nimport type { ServerInitEvent } from './events/serverInit.js'\n\nimport { findUp } from '../findUp.js'\nimport { Conf } from './conf/index.js'\nimport { oneWayHash } from './oneWayHash.js'\n\nexport type BaseEvent = {\n  ciName: null | string\n  dbAdapter: string\n  emailAdapter: null | string\n  envID: string\n  isCI: boolean\n  locales: string[]\n  localizationDefaultLocale: null | string\n  localizationEnabled: boolean\n  nodeEnv: string\n  nodeVersion: string\n  payloadVersion: string\n  projectID: string\n  projectIDSource: 'cwd' | 'git' | 'packageJSON' | 'serverURL'\n  uploadAdapters: string[]\n}\n\ntype PackageJSON = {\n  dependencies: Record<string, string | undefined>\n  name: string\n}\n\ntype TelemetryEvent = AdminInitEvent | ServerInitEvent\n\ntype Args = {\n  event: TelemetryEvent\n  payload: Payload\n}\n\nlet baseEvent: BaseEvent | null = null\n\nexport const sendEvent = async ({ event, payload }: Args): Promise<void> => {\n  try {\n    if (payload.config.telemetry !== false) {\n      const { packageJSON, packageJSONPath } = await getPackageJSON()\n\n      // Only generate the base event once\n      if (!baseEvent) {\n        const { projectID, source: projectIDSource } = getProjectID(payload, packageJSON!)\n        baseEvent = {\n          ciName: ciInfo.isCI ? ciInfo.name : null,\n          envID: getEnvID(),\n          isCI: ciInfo.isCI,\n          nodeEnv: process.env.NODE_ENV || 'development',\n          nodeVersion: process.version,\n          payloadVersion: getPayloadVersion(packageJSON!),\n          projectID,\n          projectIDSource,\n          ...getLocalizationInfo(payload),\n          dbAdapter: payload.db.name,\n          emailAdapter: payload.email?.name || null,\n          uploadAdapters: payload.config.upload.adapters,\n        }\n      }\n\n      if (process.env.PAYLOAD_TELEMETRY_DEBUG) {\n        payload.logger.info({\n          event: { ...baseEvent, ...event, packageJSONPath },\n          msg: 'Telemetry Event',\n        })\n        return\n      }\n\n      await fetch('https://telemetry.payloadcms.com/events', {\n        body: JSON.stringify({ ...baseEvent, ...event }),\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        method: 'post',\n      })\n    }\n  } catch (_) {\n    // Eat any errors in sending telemetry event\n  }\n}\n\n/**\n * This is a quasi-persistent identifier used to dedupe recurring events. It's\n * generated from random data and completely anonymous.\n */\nconst getEnvID = (): string => {\n  const conf = new Conf()\n  const ENV_ID = 'envID'\n\n  const val = conf.get(ENV_ID)\n  if (val) {\n    return val as string\n  }\n\n  const generated = randomBytes(32).toString('hex')\n  conf.set(ENV_ID, generated)\n  return generated\n}\n\nconst getProjectID = (\n  payload: Payload,\n  packageJSON: PackageJSON,\n): { projectID: string; source: BaseEvent['projectIDSource'] } => {\n  const gitID = getGitID(payload)\n  if (gitID) {\n    return { projectID: oneWayHash(gitID, payload.secret), source: 'git' }\n  }\n\n  const packageJSONID = getPackageJSONID(payload, packageJSON)\n  if (packageJSONID) {\n    return { projectID: oneWayHash(packageJSONID, payload.secret), source: 'packageJSON' }\n  }\n\n  const serverURL = payload.config.serverURL\n  if (serverURL) {\n    return { projectID: oneWayHash(serverURL, payload.secret), source: 'serverURL' }\n  }\n\n  const cwd = process.cwd()\n  return { projectID: oneWayHash(cwd, payload.secret), source: 'cwd' }\n}\n\nconst getGitID = (payload: Payload) => {\n  try {\n    const originBuffer = execSync('git config --local --get remote.origin.url', {\n      stdio: 'pipe',\n      timeout: 1000,\n    })\n\n    return oneWayHash(String(originBuffer).trim(), payload.secret)\n  } catch (_) {\n    return null\n  }\n}\n\nconst getPackageJSON = async (): Promise<{\n  packageJSON?: PackageJSON\n  packageJSONPath: string\n}> => {\n  let packageJSONPath = path.resolve(process.cwd(), 'package.json')\n\n  if (!fs.existsSync(packageJSONPath)) {\n    // Old logic\n    const filename = fileURLToPath(import.meta.url)\n    const dirname = path.dirname(filename)\n    packageJSONPath = (await findUp({\n      dir: dirname,\n      fileNames: ['package.json'],\n    }))!\n  }\n\n  const jsonContentString = await fs.promises.readFile(packageJSONPath, 'utf-8')\n  const jsonContent: PackageJSON = JSON.parse(jsonContentString)\n  return { packageJSON: jsonContent, packageJSONPath }\n}\n\nconst getPackageJSONID = (payload: Payload, packageJSON: PackageJSON): string => {\n  return oneWayHash(packageJSON.name, payload.secret)\n}\n\nexport const getPayloadVersion = (packageJSON: PackageJSON): string => {\n  return packageJSON?.dependencies?.payload ?? ''\n}\n\nexport const getLocalizationInfo = (\n  payload: Payload,\n): Pick<BaseEvent, 'locales' | 'localizationDefaultLocale' | 'localizationEnabled'> => {\n  if (!payload.config.localization) {\n    return {\n      locales: [],\n      localizationDefaultLocale: null,\n      localizationEnabled: false,\n    }\n  }\n\n  return {\n    locales: payload.config.localization.localeCodes,\n    localizationDefaultLocale: payload.config.localization.defaultLocale,\n    localizationEnabled: true,\n  }\n}\n"],"names":["execSync","ciInfo","randomBytes","fs","path","fileURLToPath","findUp","Conf","oneWayHash","baseEvent","sendEvent","event","payload","config","telemetry","packageJSON","packageJSONPath","getPackageJSON","projectID","source","projectIDSource","getProjectID","ciName","isCI","name","envID","getEnvID","nodeEnv","process","env","NODE_ENV","nodeVersion","version","payloadVersion","getPayloadVersion","getLocalizationInfo","dbAdapter","db","emailAdapter","email","uploadAdapters","upload","adapters","PAYLOAD_TELEMETRY_DEBUG","logger","info","msg","fetch","body","JSON","stringify","headers","method","_","conf","ENV_ID","val","get","generated","toString","set","gitID","getGitID","secret","packageJSONID","getPackageJSONID","serverURL","cwd","originBuffer","stdio","timeout","String","trim","resolve","existsSync","filename","url","dirname","dir","fileNames","jsonContentString","promises","readFile","jsonContent","parse","dependencies","localization","locales","localizationDefaultLocale","localizationEnabled","localeCodes","defaultLocale"],"mappings":"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"}},
    {"offset": {"line": 3161, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/telemetry/events/adminInit.ts"],"sourcesContent":["import type { Payload } from '../../../index.js'\nimport type { PayloadRequest } from '../../../types/index.js'\n\nimport { sendEvent } from '../index.js'\nimport { oneWayHash } from '../oneWayHash.js'\n\nexport type AdminInitEvent = {\n  domainID?: string\n  type: 'admin-init'\n  userID?: string\n}\n\ntype Args = {\n  headers: Request['headers']\n  payload: Payload\n  user: PayloadRequest['user']\n}\nexport const adminInit = ({ headers, payload, user }: Args): void => {\n  const host = headers.get('host')\n\n  let domainID: string\n  let userID: string\n\n  if (host) {\n    domainID = oneWayHash(host, payload.secret)\n  }\n\n  if (user?.id) {\n    userID = oneWayHash(String(user.id), payload.secret)\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  sendEvent({\n    event: {\n      type: 'admin-init',\n      domainID: domainID!,\n      userID: userID!,\n    },\n    payload,\n  })\n}\n"],"names":["sendEvent","oneWayHash","adminInit","headers","payload","user","host","get","domainID","userID","secret","id","String","event","type"],"mappings":";;;;AAGA,SAASA,SAAS,QAAQ,cAAa;AACvC,SAASC,UAAU,QAAQ,mBAAkB;;;AAatC,MAAMC,YAAY,CAAC,EAAEC,OAAO,EAAEC,OAAO,EAAEC,IAAI,EAAQ;IACxD,MAAMC,OAAOH,QAAQI,GAAG,CAAC;IAEzB,IAAIC;IACJ,IAAIC;IAEJ,IAAIH,MAAM;QACRE,eAAWP,6RAAAA,EAAWK,MAAMF,QAAQM,MAAM;IAC5C;IAEA,IAAIL,MAAMM,IAAI;QACZF,aAASR,6RAAAA,EAAWW,OAAOP,KAAKM,EAAE,GAAGP,QAAQM,MAAM;IACrD;IAEA,mEAAmE;QACnEV,uRAAAA,EAAU;QACRa,OAAO;YACLC,MAAM;YACNN,UAAUA;YACVC,QAAQA;QACV;QACAL;IACF;AACF,EAAC"}},
    {"offset": {"line": 3193, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/getEntityPolicies.ts"],"sourcesContent":["import type { CollectionPermission, FieldsPermissions, GlobalPermission } from '../auth/types.js'\nimport type { SanitizedCollectionConfig, TypeWithID } from '../collections/config/types.js'\nimport type { Access } from '../config/types.js'\nimport type { Field, FieldAccess } from '../fields/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { BlockSlug } from '../index.js'\nimport type { AllOperations, JsonObject, Payload, PayloadRequest, Where } from '../types/index.js'\n\nimport { combineQueries } from '../database/combineQueries.js'\nimport { tabHasName } from '../fields/config/types.js'\n\nexport type BlockPolicies = Record<BlockSlug, FieldsPermissions | Promise<FieldsPermissions>>\ntype Args = {\n  blockPolicies: BlockPolicies\n  entity: SanitizedCollectionConfig | SanitizedGlobalConfig\n  id?: number | string\n  operations: AllOperations[]\n  req: PayloadRequest\n  type: 'collection' | 'global'\n}\n\ntype ReturnType<T extends Args> = T['type'] extends 'global'\n  ? GlobalPermission\n  : CollectionPermission\n\ntype CreateAccessPromise = (args: {\n  access: Access | FieldAccess\n  accessLevel: 'entity' | 'field'\n  disableWhere?: boolean\n  operation: AllOperations\n  policiesObj: CollectionPermission | GlobalPermission\n}) => Promise<void>\n\ntype EntityDoc = JsonObject | TypeWithID\n\n/**\n * Build up permissions object for an entity (collection or global)\n */\nexport async function getEntityPolicies<T extends Args>(args: T): Promise<ReturnType<T>> {\n  const { id, type, blockPolicies, entity, operations, req } = args\n  const { data, locale, payload, user } = req\n  const isLoggedIn = !!user\n\n  const policies = {\n    fields: {},\n  } as ReturnType<T>\n\n  let docBeingAccessed: EntityDoc | Promise<EntityDoc | undefined> | undefined\n\n  async function getEntityDoc({\n    operation,\n    where,\n  }: { operation?: AllOperations; where?: Where } = {}): Promise<EntityDoc | undefined> {\n    if (!entity.slug) {\n      return undefined\n    }\n\n    if (type === 'global') {\n      return payload.findGlobal({\n        slug: entity.slug,\n        depth: 0,\n        fallbackLocale: null,\n        locale,\n        overrideAccess: true,\n        req,\n      })\n    }\n\n    if (type === 'collection' && id) {\n      if (typeof where === 'object') {\n        const options = {\n          collection: entity.slug,\n          depth: 0,\n          fallbackLocale: null,\n          limit: 1,\n          locale,\n          overrideAccess: true,\n          req,\n        }\n\n        if (operation === 'readVersions') {\n          const paginatedRes = await payload.findVersions({\n            ...options,\n            where: combineQueries(where, { parent: { equals: id } }),\n          })\n          return paginatedRes?.docs?.[0] || undefined\n        }\n\n        const paginatedRes = await payload.find({\n          ...options,\n          pagination: false,\n          where: combineQueries(where, { id: { equals: id } }),\n        })\n\n        return paginatedRes?.docs?.[0] || undefined\n      }\n\n      return payload.findByID({\n        id,\n        collection: entity.slug,\n        depth: 0,\n        fallbackLocale: null,\n        locale,\n        overrideAccess: true,\n        req,\n        trash: true,\n      })\n    }\n  }\n\n  const createAccessPromise: CreateAccessPromise = async ({\n    access,\n    accessLevel,\n    disableWhere = false,\n    operation,\n    policiesObj,\n  }) => {\n    const mutablePolicies = policiesObj as Record<string, any>\n    if (accessLevel === 'field' && docBeingAccessed === undefined) {\n      // assign docBeingAccessed first as the promise to avoid multiple calls to getEntityDoc\n      docBeingAccessed = getEntityDoc().then((doc) => {\n        docBeingAccessed = doc\n      })\n    }\n\n    // awaiting the promise to ensure docBeingAccessed is assigned before it is used\n    await docBeingAccessed\n\n    // https://payloadcms.slack.com/archives/C048Z9C2BEX/p1702054928343769\n    const accessResult = await access({ id, data, doc: docBeingAccessed, req })\n\n    // Where query was returned from access function => check if document is returned when querying with where\n    if (typeof accessResult === 'object' && !disableWhere) {\n      mutablePolicies[operation] = {\n        permission:\n          id || type === 'global'\n            ? !!(await getEntityDoc({ operation, where: accessResult }))\n            : true,\n        where: accessResult,\n      }\n    } else if (mutablePolicies[operation]?.permission !== false) {\n      mutablePolicies[operation] = {\n        permission: !!accessResult,\n      }\n    }\n  }\n\n  for (const operation of operations) {\n    if (typeof entity.access[operation as keyof typeof entity.access] === 'function') {\n      await createAccessPromise({\n        access: entity.access[operation as keyof typeof entity.access],\n        accessLevel: 'entity',\n        operation,\n        policiesObj: policies,\n      })\n    } else {\n      ;(policies as any)[operation] = {\n        permission: isLoggedIn,\n      }\n    }\n\n    await executeFieldPolicies({\n      blockPolicies,\n      createAccessPromise,\n      entityPermission: (policies as any)[operation].permission as boolean,\n      fields: entity.fields,\n      operation,\n      payload,\n      policiesObj: policies,\n    })\n  }\n\n  return policies\n}\n\n/**\n * Build up permissions object and run access functions for each field of an entity\n */\nconst executeFieldPolicies = async ({\n  blockPolicies,\n  createAccessPromise,\n  entityPermission,\n  fields,\n  operation,\n  payload,\n  policiesObj,\n}: {\n  blockPolicies: BlockPolicies\n  createAccessPromise: CreateAccessPromise\n  entityPermission: boolean\n  fields: Field[]\n  operation: AllOperations\n  payload: Payload\n  policiesObj: CollectionPermission | FieldsPermissions | GlobalPermission\n}) => {\n  const mutablePolicies = policiesObj.fields as Record<string, any>\n\n  // Fields don't have all operations of a collection\n  if (operation === 'delete' || operation === 'readVersions' || operation === 'unlock') {\n    return\n  }\n\n  await Promise.all(\n    fields.map(async (field) => {\n      if ('name' in field && field.name) {\n        if (!mutablePolicies[field.name]) {\n          mutablePolicies[field.name] = {}\n        }\n\n        if ('access' in field && field.access && typeof field.access[operation] === 'function') {\n          await createAccessPromise({\n            access: field.access[operation],\n            accessLevel: 'field',\n            disableWhere: true,\n            operation,\n            policiesObj: mutablePolicies[field.name],\n          })\n        } else {\n          mutablePolicies[field.name][operation] = {\n            permission: (policiesObj as any)[operation]?.permission,\n          }\n        }\n\n        if ('fields' in field && field.fields) {\n          if (!mutablePolicies[field.name].fields) {\n            mutablePolicies[field.name].fields = {}\n          }\n\n          await executeFieldPolicies({\n            blockPolicies,\n            createAccessPromise,\n            entityPermission,\n            fields: field.fields,\n            operation,\n            payload,\n            policiesObj: mutablePolicies[field.name],\n          })\n        }\n\n        if (\n          ('blocks' in field && field.blocks?.length) ||\n          ('blockReferences' in field && field.blockReferences?.length)\n        ) {\n          if (!mutablePolicies[field.name]?.blocks) {\n            mutablePolicies[field.name].blocks = {}\n          }\n\n          await Promise.all(\n            (field.blockReferences ?? field.blocks).map(async (_block) => {\n              const block = typeof _block === 'string' ? payload.blocks[_block] : _block\n\n              // Skip if block doesn't exist (invalid block reference)\n              if (!block) {\n                return\n              }\n\n              if (typeof _block === 'string') {\n                if (blockPolicies[_block]) {\n                  if (typeof blockPolicies[_block].then === 'function') {\n                    // Earlier access to this block is still pending, so await it instead of re-running executeFieldPolicies\n                    mutablePolicies[field.name].blocks[block.slug] = await blockPolicies[_block]\n                  } else {\n                    // It's already a resolved policy object\n                    mutablePolicies[field.name].blocks[block.slug] = blockPolicies[_block]\n                  }\n                  return\n                } else {\n                  // We have not seen this block slug yet. Immediately create a promise\n                  // so that any parallel calls will just await this same promise\n                  // instead of re-running executeFieldPolicies.\n                  blockPolicies[_block] = (async () => {\n                    // If the block doesn't exist yet in our mutablePolicies, initialize it\n                    if (!mutablePolicies[field.name].blocks?.[block.slug]) {\n                      // Use field-level permission instead of entityPermission for blocks\n                      // This ensures that if the field has access control, it applies to all blocks in the field\n                      const fieldPermission =\n                        mutablePolicies[field.name][operation]?.permission ?? entityPermission\n\n                      mutablePolicies[field.name].blocks[block.slug] = {\n                        fields: {},\n                        [operation]: { permission: fieldPermission },\n                      }\n                    } else if (!mutablePolicies[field.name].blocks[block.slug][operation]) {\n                      // Use field-level permission for consistency\n                      const fieldPermission =\n                        mutablePolicies[field.name][operation]?.permission ?? entityPermission\n\n                      mutablePolicies[field.name].blocks[block.slug][operation] = {\n                        permission: fieldPermission,\n                      }\n                    }\n\n                    await executeFieldPolicies({\n                      blockPolicies,\n                      createAccessPromise,\n                      entityPermission:\n                        mutablePolicies[field.name][operation]?.permission ?? entityPermission,\n                      fields: block.fields,\n                      operation,\n                      payload,\n                      policiesObj: mutablePolicies[field.name].blocks[block.slug],\n                    })\n\n                    return mutablePolicies[field.name].blocks[block.slug]\n                  })()\n\n                  mutablePolicies[field.name].blocks[block.slug] = await blockPolicies[_block]\n                  blockPolicies[_block] = mutablePolicies[field.name].blocks[block.slug]\n                  return\n                }\n              }\n\n              if (!mutablePolicies[field.name].blocks?.[block.slug]) {\n                // Use field-level permission instead of entityPermission for blocks\n                const fieldPermission =\n                  mutablePolicies[field.name][operation]?.permission ?? entityPermission\n\n                mutablePolicies[field.name].blocks[block.slug] = {\n                  fields: {},\n                  [operation]: { permission: fieldPermission },\n                }\n              } else if (!mutablePolicies[field.name].blocks[block.slug][operation]) {\n                // Use field-level permission for consistency\n                const fieldPermission =\n                  mutablePolicies[field.name][operation]?.permission ?? entityPermission\n\n                mutablePolicies[field.name].blocks[block.slug][operation] = {\n                  permission: fieldPermission,\n                }\n              }\n\n              await executeFieldPolicies({\n                blockPolicies,\n                createAccessPromise,\n                entityPermission:\n                  mutablePolicies[field.name][operation]?.permission ?? entityPermission,\n                fields: block.fields,\n                operation,\n                payload,\n                policiesObj: mutablePolicies[field.name].blocks[block.slug],\n              })\n            }),\n          )\n        }\n      } else if ('fields' in field && field.fields) {\n        await executeFieldPolicies({\n          blockPolicies,\n          createAccessPromise,\n          entityPermission,\n          fields: field.fields,\n          operation,\n          payload,\n          policiesObj,\n        })\n      } else if (field.type === 'tabs') {\n        await Promise.all(\n          field.tabs.map(async (tab) => {\n            if (tabHasName(tab)) {\n              if (!mutablePolicies[tab.name]) {\n                mutablePolicies[tab.name] = {\n                  fields: {},\n                  [operation]: { permission: entityPermission },\n                }\n              } else if (!mutablePolicies[tab.name][operation]) {\n                mutablePolicies[tab.name][operation] = { permission: entityPermission }\n              }\n              await executeFieldPolicies({\n                blockPolicies,\n                createAccessPromise,\n                entityPermission,\n                fields: tab.fields,\n                operation,\n                payload,\n                policiesObj: mutablePolicies[tab.name],\n              })\n            } else {\n              await executeFieldPolicies({\n                blockPolicies,\n                createAccessPromise,\n                entityPermission,\n                fields: tab.fields,\n                operation,\n                payload,\n                policiesObj,\n              })\n            }\n          }),\n        )\n      }\n    }),\n  )\n}\n"],"names":["combineQueries","tabHasName","getEntityPolicies","args","id","type","blockPolicies","entity","operations","req","data","locale","payload","user","isLoggedIn","policies","fields","docBeingAccessed","getEntityDoc","operation","where","slug","undefined","findGlobal","depth","fallbackLocale","overrideAccess","options","collection","limit","paginatedRes","findVersions","parent","equals","docs","find","pagination","findByID","trash","createAccessPromise","access","accessLevel","disableWhere","policiesObj","mutablePolicies","then","doc","accessResult","permission","executeFieldPolicies","entityPermission","Promise","all","map","field","name","blocks","length","blockReferences","_block","block","fieldPermission","tabs","tab"],"mappings":"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"}},
    {"offset": {"line": 3505, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/sanitizePermissions.ts"],"sourcesContent":["import type { MarkOptional } from 'ts-essentials'\n\nimport type {\n  CollectionPermission,\n  FieldPermissions,\n  FieldsPermissions,\n  GlobalPermission,\n  Permissions,\n  SanitizedBlocksPermissions,\n  SanitizedFieldPermissions,\n  SanitizedFieldsPermissions,\n  SanitizedPermissions,\n} from '../auth/types.js'\n\nfunction checkAndSanitizeFieldsPermssions(data: FieldsPermissions): boolean {\n  let allFieldPermissionsTrue = true\n  for (const key in data) {\n    if (typeof data[key] === 'object') {\n      if (!checkAndSanitizePermissions(data[key])) {\n        allFieldPermissionsTrue = false\n      } else {\n        ;(data[key] as unknown as SanitizedFieldPermissions) = true\n      }\n    } else if (data[key] !== true) {\n      allFieldPermissionsTrue = false\n    }\n  }\n\n  // If all values are true or it's an empty object, return true\n  return allFieldPermissionsTrue\n}\n\n/**\n * Check if all permissions in a FieldPermissions, CollectionPermission or GlobalPermission object are true.\n * If nested fields or blocks are present, the function will recursively check those as well.\n */\nfunction checkAndSanitizePermissions(\n  _data: CollectionPermission | FieldPermissions | GlobalPermission,\n): boolean {\n  const data = _data as Record<string, any>\n  /**\n   * Check blocks permissions\n   */\n  let blocksPermissions = true\n  if ('blocks' in data && data.blocks) {\n    for (const blockSlug in data.blocks) {\n      if (typeof data.blocks[blockSlug] === 'object') {\n        for (const key in data.blocks[blockSlug]) {\n          /**\n           * Check fields in nested blocks\n           */\n          if (key === 'fields') {\n            if (data.blocks[blockSlug].fields) {\n              if (!checkAndSanitizeFieldsPermssions(data.blocks[blockSlug].fields)) {\n                blocksPermissions = false\n              } else {\n                ;(data.blocks[blockSlug].fields as unknown as SanitizedFieldsPermissions) = true\n              }\n            }\n          } else {\n            if (typeof data.blocks[blockSlug][key] === 'object') {\n              /**\n               * Check Permissions in nested blocks\n               */\n              if (isPermissionObject(data.blocks[blockSlug][key])) {\n                if (\n                  data.blocks[blockSlug][key]['permission'] === true &&\n                  !('where' in data.blocks[blockSlug][key])\n                ) {\n                  // If the permission is true and there is no where clause, set the key to true\n                  data.blocks[blockSlug][key] = true\n                  continue\n                } else if (\n                  data.blocks[blockSlug][key]['permission'] === true &&\n                  'where' in data.blocks[blockSlug][key]\n                ) {\n                  // otherwise do nothing so we can keep the where clause\n                  blocksPermissions = false\n                } else {\n                  blocksPermissions = false\n                  data.blocks[blockSlug][key] = false\n                  delete data.blocks[blockSlug][key]\n                  continue\n                }\n              } else {\n                throw new Error('Unexpected object in block permissions')\n              }\n            }\n          }\n        }\n      } else if (data.blocks[blockSlug] !== true) {\n        // If any value is not true, return false\n        blocksPermissions = false\n        delete data.blocks[blockSlug]\n      }\n    }\n    if (blocksPermissions) {\n      ;(data.blocks as unknown as SanitizedBlocksPermissions) = true\n    }\n  }\n\n  /**\n   * Check nested Fields permissions\n   */\n  let fieldsPermissions = true\n  if (data.fields) {\n    if (!checkAndSanitizeFieldsPermssions(data.fields)) {\n      fieldsPermissions = false\n    } else {\n      ;(data.fields as unknown as SanitizedFieldsPermissions) = true\n    }\n  }\n\n  /**\n   * Check other Permissions objects (e.g. read, write)\n   */\n  let otherPermissions = true\n  for (const key in data) {\n    if (key === 'fields' || key === 'blocks') {\n      continue\n    }\n    if (typeof data[key] === 'object') {\n      if (isPermissionObject(data[key])) {\n        if (data[key]['permission'] === true && !('where' in data[key])) {\n          // If the permission is true and there is no where clause, set the key to true\n          data[key] = true\n          continue\n        } else if (data[key]['permission'] === true && 'where' in data[key]) {\n          // otherwise do nothing so we can keep the where clause\n          otherPermissions = false\n        } else {\n          otherPermissions = false\n          data[key] = false\n          delete data[key]\n          continue\n        }\n      } else {\n        throw new Error('Unexpected object in fields permissions')\n      }\n    } else if (data[key] !== true) {\n      // If any value is not true, return false\n      otherPermissions = false\n    }\n  }\n\n  // If all values are true or it's an empty object, return true\n  return fieldsPermissions && blocksPermissions && otherPermissions\n}\n\n/**\n * Check if an object is a permission object.\n */\nfunction isPermissionObject(data: unknown): boolean {\n  return (\n    typeof data === 'object' && 'permission' in data! && typeof data['permission'] === 'boolean'\n  )\n}\n\n/**\n * Recursively remove empty objects from an object.\n */\nfunction cleanEmptyObjects(obj: any): void {\n  Object.keys(obj).forEach((key) => {\n    if (typeof obj[key] === 'object' && obj[key] !== null) {\n      // Recursive call\n      cleanEmptyObjects(obj[key])\n      if (Object.keys(obj[key]).length === 0) {\n        // Delete the key if the object is empty\n        delete obj[key]\n      }\n    } else if (obj[key] === null || obj[key] === undefined) {\n      delete obj[key]\n    }\n  })\n}\n\nexport function recursivelySanitizeCollections(obj: Permissions['collections']): void {\n  if (typeof obj !== 'object') {\n    return\n  }\n\n  const collectionPermissions = Object.values(obj)\n\n  for (const collectionPermission of collectionPermissions) {\n    checkAndSanitizePermissions(collectionPermission)\n  }\n}\n\nexport function recursivelySanitizeGlobals(obj: Permissions['globals']): void {\n  if (typeof obj !== 'object') {\n    return\n  }\n\n  const globalPermissions = Object.values(obj)\n\n  for (const globalPermission of globalPermissions) {\n    checkAndSanitizePermissions(globalPermission)\n  }\n}\n\n/**\n * Recursively remove empty objects and false values from an object.\n */\nexport function sanitizePermissions(\n  data: MarkOptional<Permissions, 'canAccessAdmin'>,\n): SanitizedPermissions {\n  if (data.canAccessAdmin === false) {\n    delete data.canAccessAdmin\n  }\n\n  if (data.collections) {\n    recursivelySanitizeCollections(data.collections)\n  }\n\n  if (data.globals) {\n    recursivelySanitizeGlobals(data.globals)\n  }\n\n  // Run clean up of empty objects at the end\n  cleanEmptyObjects(data)\n\n  return data as unknown as SanitizedPermissions\n}\n"],"names":["checkAndSanitizeFieldsPermssions","data","allFieldPermissionsTrue","key","checkAndSanitizePermissions","_data","blocksPermissions","blocks","blockSlug","fields","isPermissionObject","Error","fieldsPermissions","otherPermissions","cleanEmptyObjects","obj","Object","keys","forEach","length","undefined","recursivelySanitizeCollections","collectionPermissions","values","collectionPermission","recursivelySanitizeGlobals","globalPermissions","globalPermission","sanitizePermissions","canAccessAdmin","collections","globals"],"mappings":";;;;;;;;AAcA,SAASA,iCAAiCC,IAAuB;IAC/D,IAAIC,0BAA0B;IAC9B,IAAK,MAAMC,OAAOF,KAAM;QACtB,IAAI,OAAOA,IAAI,CAACE,IAAI,KAAK,UAAU;YACjC,IAAI,CAACC,4BAA4BH,IAAI,CAACE,IAAI,GAAG;gBAC3CD,0BAA0B;YAC5B,OAAO;;gBACHD,IAAI,CAACE,IAAI,GAA4C;YACzD;QACF,OAAO,IAAIF,IAAI,CAACE,IAAI,KAAK,MAAM;YAC7BD,0BAA0B;QAC5B;IACF;IAEA,8DAA8D;IAC9D,OAAOA;AACT;AAEA;;;CAGC,GACD,SAASE,4BACPC,KAAiE;IAEjE,MAAMJ,OAAOI;IACb;;GAEC,GACD,IAAIC,oBAAoB;IACxB,IAAI,YAAYL,QAAQA,KAAKM,MAAM,EAAE;QACnC,IAAK,MAAMC,aAAaP,KAAKM,MAAM,CAAE;YACnC,IAAI,OAAON,KAAKM,MAAM,CAACC,UAAU,KAAK,UAAU;gBAC9C,IAAK,MAAML,OAAOF,KAAKM,MAAM,CAACC,UAAU,CAAE;oBACxC;;WAEC,GACD,IAAIL,QAAQ,UAAU;wBACpB,IAAIF,KAAKM,MAAM,CAACC,UAAU,CAACC,MAAM,EAAE;4BACjC,IAAI,CAACT,iCAAiCC,KAAKM,MAAM,CAACC,UAAU,CAACC,MAAM,GAAG;gCACpEH,oBAAoB;4BACtB,OAAO;;gCACHL,KAAKM,MAAM,CAACC,UAAU,CAACC,MAAM,GAA6C;4BAC9E;wBACF;oBACF,OAAO;wBACL,IAAI,OAAOR,KAAKM,MAAM,CAACC,UAAU,CAACL,IAAI,KAAK,UAAU;4BACnD;;eAEC,GACD,IAAIO,mBAAmBT,KAAKM,MAAM,CAACC,UAAU,CAACL,IAAI,GAAG;gCACnD,IACEF,KAAKM,MAAM,CAACC,UAAU,CAACL,IAAI,CAAC,aAAa,KAAK,QAC9C,CAAE,CAAA,WAAWF,KAAKM,MAAM,CAACC,UAAU,CAACL,IAAG,GACvC;oCACA,8EAA8E;oCAC9EF,KAAKM,MAAM,CAACC,UAAU,CAACL,IAAI,GAAG;oCAC9B;gCACF,OAAO,IACLF,KAAKM,MAAM,CAACC,UAAU,CAACL,IAAI,CAAC,aAAa,KAAK,QAC9C,WAAWF,KAAKM,MAAM,CAACC,UAAU,CAACL,IAAI,EACtC;oCACA,uDAAuD;oCACvDG,oBAAoB;gCACtB,OAAO;oCACLA,oBAAoB;oCACpBL,KAAKM,MAAM,CAACC,UAAU,CAACL,IAAI,GAAG;oCAC9B,OAAOF,KAAKM,MAAM,CAACC,UAAU,CAACL,IAAI;oCAClC;gCACF;4BACF,OAAO;gCACL,MAAM,IAAIQ,MAAM;4BAClB;wBACF;oBACF;gBACF;YACF,OAAO,IAAIV,KAAKM,MAAM,CAACC,UAAU,KAAK,MAAM;gBAC1C,yCAAyC;gBACzCF,oBAAoB;gBACpB,OAAOL,KAAKM,MAAM,CAACC,UAAU;YAC/B;QACF;QACA,IAAIF,mBAAmB;;YACnBL,KAAKM,MAAM,GAA6C;QAC5D;IACF;IAEA;;GAEC,GACD,IAAIK,oBAAoB;IACxB,IAAIX,KAAKQ,MAAM,EAAE;QACf,IAAI,CAACT,iCAAiCC,KAAKQ,MAAM,GAAG;YAClDG,oBAAoB;QACtB,OAAO;;YACHX,KAAKQ,MAAM,GAA6C;QAC5D;IACF;IAEA;;GAEC,GACD,IAAII,mBAAmB;IACvB,IAAK,MAAMV,OAAOF,KAAM;QACtB,IAAIE,QAAQ,YAAYA,QAAQ,UAAU;YACxC;QACF;QACA,IAAI,OAAOF,IAAI,CAACE,IAAI,KAAK,UAAU;YACjC,IAAIO,mBAAmBT,IAAI,CAACE,IAAI,GAAG;gBACjC,IAAIF,IAAI,CAACE,IAAI,CAAC,aAAa,KAAK,QAAQ,CAAE,CAAA,WAAWF,IAAI,CAACE,IAAG,GAAI;oBAC/D,8EAA8E;oBAC9EF,IAAI,CAACE,IAAI,GAAG;oBACZ;gBACF,OAAO,IAAIF,IAAI,CAACE,IAAI,CAAC,aAAa,KAAK,QAAQ,WAAWF,IAAI,CAACE,IAAI,EAAE;oBACnE,uDAAuD;oBACvDU,mBAAmB;gBACrB,OAAO;oBACLA,mBAAmB;oBACnBZ,IAAI,CAACE,IAAI,GAAG;oBACZ,OAAOF,IAAI,CAACE,IAAI;oBAChB;gBACF;YACF,OAAO;gBACL,MAAM,IAAIQ,MAAM;YAClB;QACF,OAAO,IAAIV,IAAI,CAACE,IAAI,KAAK,MAAM;YAC7B,yCAAyC;YACzCU,mBAAmB;QACrB;IACF;IAEA,8DAA8D;IAC9D,OAAOD,qBAAqBN,qBAAqBO;AACnD;AAEA;;CAEC,GACD,SAASH,mBAAmBT,IAAa;IACvC,OACE,OAAOA,SAAS,YAAY,gBAAgBA,QAAS,OAAOA,IAAI,CAAC,aAAa,KAAK;AAEvF;AAEA;;CAEC,GACD,SAASa,kBAAkBC,GAAQ;IACjCC,OAAOC,IAAI,CAACF,KAAKG,OAAO,CAAC,CAACf;QACxB,IAAI,OAAOY,GAAG,CAACZ,IAAI,KAAK,YAAYY,GAAG,CAACZ,IAAI,KAAK,MAAM;YACrD,iBAAiB;YACjBW,kBAAkBC,GAAG,CAACZ,IAAI;YAC1B,IAAIa,OAAOC,IAAI,CAACF,GAAG,CAACZ,IAAI,EAAEgB,MAAM,KAAK,GAAG;gBACtC,wCAAwC;gBACxC,OAAOJ,GAAG,CAACZ,IAAI;YACjB;QACF,OAAO,IAAIY,GAAG,CAACZ,IAAI,KAAK,QAAQY,GAAG,CAACZ,IAAI,KAAKiB,WAAW;YACtD,OAAOL,GAAG,CAACZ,IAAI;QACjB;IACF;AACF;AAEO,SAASkB,+BAA+BN,GAA+B;IAC5E,IAAI,OAAOA,QAAQ,UAAU;QAC3B;IACF;IAEA,MAAMO,wBAAwBN,OAAOO,MAAM,CAACR;IAE5C,KAAK,MAAMS,wBAAwBF,sBAAuB;QACxDlB,4BAA4BoB;IAC9B;AACF;AAEO,SAASC,2BAA2BV,GAA2B;IACpE,IAAI,OAAOA,QAAQ,UAAU;QAC3B;IACF;IAEA,MAAMW,oBAAoBV,OAAOO,MAAM,CAACR;IAExC,KAAK,MAAMY,oBAAoBD,kBAAmB;QAChDtB,4BAA4BuB;IAC9B;AACF;AAKO,SAASC,oBACd3B,IAAiD;IAEjD,IAAIA,KAAK4B,cAAc,KAAK,OAAO;QACjC,OAAO5B,KAAK4B,cAAc;IAC5B;IAEA,IAAI5B,KAAK6B,WAAW,EAAE;QACpBT,+BAA+BpB,KAAK6B,WAAW;IACjD;IAEA,IAAI7B,KAAK8B,OAAO,EAAE;QAChBN,2BAA2BxB,KAAK8B,OAAO;IACzC;IAEA,2CAA2C;IAC3CjB,kBAAkBb;IAElB,OAAOA;AACT"}},
    {"offset": {"line": 3689, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/getRequestEntity.ts"],"sourcesContent":["import type { Collection } from '../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { APIError } from '../errors/APIError.js'\n\nexport const getRequestCollection = (req: PayloadRequest): Collection => {\n  const collectionSlug = req.routeParams?.collection\n\n  if (typeof collectionSlug !== 'string') {\n    throw new APIError(`No collection was specified`, 400)\n  }\n\n  const collection = req.payload.collections[collectionSlug]\n\n  if (!collection) {\n    throw new APIError(`Collection with the slug ${collectionSlug} was not found`, 404)\n  }\n\n  return collection\n}\n\nexport const getRequestCollectionWithID = <T extends boolean>(\n  req: PayloadRequest,\n  {\n    disableSanitize,\n    optionalID,\n  }: {\n    disableSanitize?: T\n    optionalID?: boolean\n  } = {},\n): {\n  collection: Collection\n  id: T extends true ? string : number | string\n} => {\n  const collection = getRequestCollection(req)\n  const id = req.routeParams?.id\n\n  if (typeof id !== 'string') {\n    if (optionalID) {\n      return {\n        id: undefined!,\n        collection,\n      }\n    }\n\n    throw new APIError(`ID was not specified`, 400)\n  }\n\n  if (disableSanitize === true) {\n    return {\n      id,\n      collection,\n    }\n  }\n\n  let sanitizedID: number | string = id\n\n  // If default db ID type is a number, we should sanitize\n  let shouldSanitize = Boolean(req.payload.db.defaultIDType === 'number')\n\n  // UNLESS the customIDType for this collection is text.... then we leave it\n  if (shouldSanitize && collection.customIDType === 'text') {\n    shouldSanitize = false\n  }\n\n  // If we still should sanitize, parse float\n  if (shouldSanitize) {\n    sanitizedID = parseFloat(sanitizedID)\n  }\n\n  return {\n    // @ts-expect-error generic return\n    id: sanitizedID,\n    collection,\n  }\n}\n\nexport const getRequestGlobal = (req: PayloadRequest): SanitizedGlobalConfig => {\n  const globalSlug = req.routeParams?.global\n\n  if (typeof globalSlug !== 'string') {\n    throw new APIError(`No global was specified`, 400)\n  }\n\n  const globalConfig = req.payload.globals.config.find((each) => each.slug === globalSlug)\n\n  if (!globalConfig) {\n    throw new APIError(`Global with the slug ${globalSlug} was not found`, 404)\n  }\n\n  return globalConfig\n}\n"],"names":["APIError","getRequestCollection","req","collectionSlug","routeParams","collection","payload","collections","getRequestCollectionWithID","disableSanitize","optionalID","id","undefined","sanitizedID","shouldSanitize","Boolean","db","defaultIDType","customIDType","parseFloat","getRequestGlobal","globalSlug","global","globalConfig","globals","config","find","each","slug"],"mappings":";;;;;;;;AAIA,SAASA,QAAQ,QAAQ,wBAAuB;;AAEzC,MAAMC,uBAAuB,CAACC;IACnC,MAAMC,iBAAiBD,IAAIE,WAAW,EAAEC;IAExC,IAAI,OAAOF,mBAAmB,UAAU;QACtC,MAAM,IAAIH,yQAAAA,CAAS,CAAC,2BAA2B,CAAC,EAAE;IACpD;IAEA,MAAMK,aAAaH,IAAII,OAAO,CAACC,WAAW,CAACJ,eAAe;IAE1D,IAAI,CAACE,YAAY;QACf,MAAM,IAAIL,yQAAAA,CAAS,CAAC,yBAAyB,EAAEG,eAAe,cAAc,CAAC,EAAE;IACjF;IAEA,OAAOE;AACT,EAAC;AAEM,MAAMG,6BAA6B,CACxCN,KACA,EACEO,eAAe,EACfC,UAAU,EAIX,GAAG,CAAC,CAAC;IAKN,MAAML,aAAaJ,qBAAqBC;IACxC,MAAMS,KAAKT,IAAIE,WAAW,EAAEO;IAE5B,IAAI,OAAOA,OAAO,UAAU;QAC1B,IAAID,YAAY;YACd,OAAO;gBACLC,IAAIC;gBACJP;YACF;QACF;QAEA,MAAM,IAAIL,yQAAAA,CAAS,CAAC,oBAAoB,CAAC,EAAE;IAC7C;IAEA,IAAIS,oBAAoB,MAAM;QAC5B,OAAO;YACLE;YACAN;QACF;IACF;IAEA,IAAIQ,cAA+BF;IAEnC,wDAAwD;IACxD,IAAIG,iBAAiBC,QAAQb,IAAII,OAAO,CAACU,EAAE,CAACC,aAAa,KAAK;IAE9D,2EAA2E;IAC3E,IAAIH,kBAAkBT,WAAWa,YAAY,KAAK,QAAQ;QACxDJ,iBAAiB;IACnB;IAEA,2CAA2C;IAC3C,IAAIA,gBAAgB;QAClBD,cAAcM,WAAWN;IAC3B;IAEA,OAAO;QACL,kCAAkC;QAClCF,IAAIE;QACJR;IACF;AACF,EAAC;AAEM,MAAMe,mBAAmB,CAAClB;IAC/B,MAAMmB,aAAanB,IAAIE,WAAW,EAAEkB;IAEpC,IAAI,OAAOD,eAAe,UAAU;QAClC,MAAM,IAAIrB,yQAAAA,CAAS,CAAC,uBAAuB,CAAC,EAAE;IAChD;IAEA,MAAMuB,eAAerB,IAAII,OAAO,CAACkB,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAACC,OAASA,KAAKC,IAAI,KAAKP;IAE7E,IAAI,CAACE,cAAc;QACjB,MAAM,IAAIvB,yQAAAA,CAAS,CAAC,qBAAqB,EAAEqB,WAAW,cAAc,CAAC,EAAE;IACzE;IAEA,OAAOE;AACT,EAAC"}},
    {"offset": {"line": 3760, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/appendNonTrashedFilter.ts"],"sourcesContent":["import type { Where } from '../types/index.js'\n\nexport const appendNonTrashedFilter = ({\n  deletedAtPath = 'deletedAt',\n  enableTrash,\n  trash,\n  where,\n}: {\n  deletedAtPath?: string\n  enableTrash: boolean\n  trash?: boolean\n  where: Where\n}): Where => {\n  if (!enableTrash || trash) {\n    return where\n  }\n\n  const notTrashedFilter = {\n    [deletedAtPath]: { exists: false },\n  }\n\n  if (where?.and) {\n    return {\n      ...where,\n      and: [...where.and, notTrashedFilter],\n    }\n  }\n\n  return {\n    and: [notTrashedFilter, ...(where ? [where] : [])],\n  }\n}\n"],"names":["appendNonTrashedFilter","deletedAtPath","enableTrash","trash","where","notTrashedFilter","exists","and"],"mappings":";;;;AAEO,MAAMA,yBAAyB,CAAC,EACrCC,gBAAgB,WAAW,EAC3BC,WAAW,EACXC,KAAK,EACLC,KAAK,EAMN;IACC,IAAI,CAACF,eAAeC,OAAO;QACzB,OAAOC;IACT;IAEA,MAAMC,mBAAmB;QACvB,CAACJ,cAAc,EAAE;YAAEK,QAAQ;QAAM;IACnC;IAEA,IAAIF,OAAOG,KAAK;QACd,OAAO;YACL,GAAGH,KAAK;YACRG,KAAK;mBAAIH,MAAMG,GAAG;gBAAEF;aAAiB;QACvC;IACF;IAEA,OAAO;QACLE,KAAK;YAACF;eAAsBD,QAAQ;gBAACA;aAAM,GAAG,EAAE;SAAE;IACpD;AACF,EAAC"}},
    {"offset": {"line": 3795, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/commitTransaction.ts"],"sourcesContent":["import type { MarkRequired } from 'ts-essentials'\n\nimport type { PayloadRequest } from '../types/index.js'\n\n/**\n * complete a transaction calling adapter db.commitTransaction and delete the transactionID from req\n */\nexport async function commitTransaction(\n  req: MarkRequired<Partial<PayloadRequest>, 'payload'>,\n): Promise<void> {\n  const { payload, transactionID } = req\n\n  await payload.db.commitTransaction(transactionID!)\n  delete req.transactionID\n}\n"],"names":["commitTransaction","req","payload","transactionID","db"],"mappings":"AAIA;;CAEC,GACD;;;;AAAO,eAAeA,kBACpBC,GAAqD;IAErD,MAAM,EAAEC,OAAO,EAAEC,aAAa,EAAE,GAAGF;IAEnC,MAAMC,QAAQE,EAAE,CAACJ,iBAAiB,CAACG;IACnC,OAAOF,IAAIE,aAAa;AAC1B"}},
    {"offset": {"line": 3810, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/formatAdminURL.ts"],"sourcesContent":["import type { Config } from '../config/types.js'\n\n/** Will read the `routes.admin` config and appropriately handle `\"/\"` admin paths */\nexport const formatAdminURL = (args: {\n  adminRoute: NonNullable<Config['routes']>['admin']\n  basePath?: string\n  path: '' | `/${string}` | null | undefined\n  serverURL?: Config['serverURL']\n}): string => {\n  const { adminRoute, basePath = '', path: pathFromArgs, serverURL } = args\n  const path = pathFromArgs || ''\n\n  if (adminRoute) {\n    if (adminRoute === '/') {\n      if (!path) {\n        return `${serverURL || ''}${basePath}${adminRoute}`\n      }\n    } else {\n      return `${serverURL || ''}${basePath}${adminRoute}${path}`\n    }\n  }\n\n  return `${serverURL || ''}${basePath}${path}`\n}\n"],"names":["formatAdminURL","args","adminRoute","basePath","path","pathFromArgs","serverURL"],"mappings":"AAEA,mFAAmF,GACnF;;;;AAAO,MAAMA,iBAAiB,CAACC;IAM7B,MAAM,EAAEC,UAAU,EAAEC,WAAW,EAAE,EAAEC,MAAMC,YAAY,EAAEC,SAAS,EAAE,GAAGL;IACrE,MAAMG,OAAOC,gBAAgB;IAE7B,IAAIH,YAAY;QACd,IAAIA,eAAe,KAAK;YACtB,IAAI,CAACE,MAAM;gBACT,OAAO,GAAGE,aAAa,KAAKH,WAAWD,YAAY;YACrD;QACF,OAAO;YACL,OAAO,GAAGI,aAAa,KAAKH,WAAWD,aAAaE,MAAM;QAC5D;IACF;IAEA,OAAO,GAAGE,aAAa,KAAKH,WAAWC,MAAM;AAC/C,EAAC"}},
    {"offset": {"line": 3832, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/initTransaction.ts"],"sourcesContent":["import type { MarkRequired } from 'ts-essentials'\n\nimport type { PayloadRequest } from '../types/index.js'\n\n/**\n * Starts a new transaction using the db adapter with a random id and then assigns it to the req.transaction\n * @returns true if beginning a transaction and false when req already has a transaction to use\n */\nexport async function initTransaction(\n  req: MarkRequired<Partial<PayloadRequest>, 'payload'>,\n): Promise<boolean> {\n  const { payload, transactionID } = req\n  if (transactionID instanceof Promise) {\n    // wait for whoever else is already creating the transaction\n    await transactionID\n    return false\n  }\n\n  if (transactionID) {\n    // we already have a transaction, we're not in charge of committing it\n    return false\n  }\n  if (typeof payload.db.beginTransaction === 'function') {\n    // create a new transaction\n    req.transactionID = payload.db.beginTransaction().then((transactionID) => {\n      if (transactionID) {\n        req.transactionID = transactionID\n      }\n\n      return transactionID!\n    })\n    return !!(await req.transactionID)\n  }\n  return false\n}\n"],"names":["initTransaction","req","payload","transactionID","Promise","db","beginTransaction","then"],"mappings":"AAIA;;;CAGC,GACD;;;;AAAO,eAAeA,gBACpBC,GAAqD;IAErD,MAAM,EAAEC,OAAO,EAAEC,aAAa,EAAE,GAAGF;IACnC,IAAIE,yBAAyBC,SAAS;QACpC,4DAA4D;QAC5D,MAAMD;QACN,OAAO;IACT;IAEA,IAAIA,eAAe;QACjB,sEAAsE;QACtE,OAAO;IACT;IACA,IAAI,OAAOD,QAAQG,EAAE,CAACC,gBAAgB,KAAK,YAAY;QACrD,2BAA2B;QAC3BL,IAAIE,aAAa,GAAGD,QAAQG,EAAE,CAACC,gBAAgB,GAAGC,IAAI,CAAC,CAACJ;YACtD,IAAIA,eAAe;gBACjBF,IAAIE,aAAa,GAAGA;YACtB;YAEA,OAAOA;QACT;QACA,OAAO,CAAC,CAAE,MAAMF,IAAIE,aAAa;IACnC;IACA,OAAO;AACT"}},
    {"offset": {"line": 3866, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/getSelectMode.ts"],"sourcesContent":["import type { SelectMode, SelectType } from '../types/index.js'\n\nexport const getSelectMode = (select: SelectType): SelectMode => {\n  for (const key in select) {\n    const selectValue = select[key]\n    if (selectValue === false) {\n      return 'exclude'\n    }\n\n    if (typeof selectValue === 'object') {\n      return getSelectMode(selectValue)\n    }\n  }\n\n  return 'include'\n}\n"],"names":["getSelectMode","select","key","selectValue"],"mappings":";;;;AAEO,MAAMA,gBAAgB,CAACC;IAC5B,IAAK,MAAMC,OAAOD,OAAQ;QACxB,MAAME,cAAcF,MAAM,CAACC,IAAI;QAC/B,IAAIC,gBAAgB,OAAO;YACzB,OAAO;QACT;QAEA,IAAI,OAAOA,gBAAgB,UAAU;YACnC,OAAOH,cAAcG;QACvB;IACF;IAEA,OAAO;AACT,EAAC"}},
    {"offset": {"line": 3886, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/sanitizeInternalFields.ts"],"sourcesContent":["export const sanitizeInternalFields = <T extends Record<string, unknown>>(incomingDoc: T): T => {\n  // Create a new object to hold the sanitized fields\n  const newDoc: Record<string, unknown> = {}\n\n  for (const key in incomingDoc) {\n    const val = incomingDoc[key]\n    if (key === '_id') {\n      newDoc['id'] = val\n    } else if (key !== '__v') {\n      newDoc[key] = val\n    }\n  }\n\n  return newDoc as T\n}\n"],"names":["sanitizeInternalFields","incomingDoc","newDoc","key","val"],"mappings":";;;;AAAO,MAAMA,yBAAyB,CAAoCC;IACxE,mDAAmD;IACnD,MAAMC,SAAkC,CAAC;IAEzC,IAAK,MAAMC,OAAOF,YAAa;QAC7B,MAAMG,MAAMH,WAAW,CAACE,IAAI;QAC5B,IAAIA,QAAQ,OAAO;YACjBD,MAAM,CAAC,KAAK,GAAGE;QACjB,OAAO,IAAID,QAAQ,OAAO;YACxBD,MAAM,CAACC,IAAI,GAAGC;QAChB;IACF;IAEA,OAAOF;AACT,EAAC"}},
    {"offset": {"line": 3907, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/sanitizeJoinParams.ts"],"sourcesContent":["import type { JoinQuery } from '../types/index.js'\n\nimport { isNumber } from './isNumber.js'\n\nexport type JoinParams =\n  | {\n      [schemaPath: string]:\n        | {\n            limit?: unknown\n            sort?: string\n            where?: unknown\n          }\n        | false\n    }\n  | false\n\n/**\n * Convert request JoinQuery object from strings to numbers\n * @param joins\n */\nexport const sanitizeJoinParams = (_joins: JoinParams = {}): JoinQuery => {\n  const joinQuery: Record<string, any> = {}\n  const joins = _joins as Record<string, any>\n\n  Object.keys(joins).forEach((schemaPath) => {\n    if (joins[schemaPath] === 'false' || joins[schemaPath] === false) {\n      joinQuery[schemaPath] = false\n    } else {\n      joinQuery[schemaPath] = {\n        count: joins[schemaPath].count === 'true',\n        limit: isNumber(joins[schemaPath]?.limit) ? Number(joins[schemaPath].limit) : undefined,\n        page: isNumber(joins[schemaPath]?.page) ? Number(joins[schemaPath].page) : undefined,\n        sort: joins[schemaPath]?.sort ? joins[schemaPath].sort : undefined,\n        where: joins[schemaPath]?.where ? joins[schemaPath].where : undefined,\n      }\n    }\n  })\n\n  return joinQuery\n}\n"],"names":["isNumber","sanitizeJoinParams","_joins","joinQuery","joins","Object","keys","forEach","schemaPath","count","limit","Number","undefined","page","sort","where"],"mappings":";;;;AAEA,SAASA,QAAQ,QAAQ,gBAAe;;AAkBjC,MAAMC,qBAAqB,CAACC,SAAqB,CAAC,CAAC;IACxD,MAAMC,YAAiC,CAAC;IACxC,MAAMC,QAAQF;IAEdG,OAAOC,IAAI,CAACF,OAAOG,OAAO,CAAC,CAACC;QAC1B,IAAIJ,KAAK,CAACI,WAAW,KAAK,WAAWJ,KAAK,CAACI,WAAW,KAAK,OAAO;YAChEL,SAAS,CAACK,WAAW,GAAG;QAC1B,OAAO;YACLL,SAAS,CAACK,WAAW,GAAG;gBACtBC,OAAOL,KAAK,CAACI,WAAW,CAACC,KAAK,KAAK;gBACnCC,WAAOV,4QAAAA,EAASI,KAAK,CAACI,WAAW,EAAEE,SAASC,OAAOP,KAAK,CAACI,WAAW,CAACE,KAAK,IAAIE;gBAC9EC,UAAMb,4QAAAA,EAASI,KAAK,CAACI,WAAW,EAAEK,QAAQF,OAAOP,KAAK,CAACI,WAAW,CAACK,IAAI,IAAID;gBAC3EE,MAAMV,KAAK,CAACI,WAAW,EAAEM,OAAOV,KAAK,CAACI,WAAW,CAACM,IAAI,GAAGF;gBACzDG,OAAOX,KAAK,CAACI,WAAW,EAAEO,QAAQX,KAAK,CAACI,WAAW,CAACO,KAAK,GAAGH;YAC9D;QACF;IACF;IAEA,OAAOT;AACT,EAAC"}},
    {"offset": {"line": 3935, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/sanitizeSelectParam.ts"],"sourcesContent":["import type { SelectType } from '../types/index.js'\n\n/**\n * Sanitizes REST select query to SelectType\n */\nexport const sanitizeSelectParam = (unsanitizedSelect: unknown): SelectType | undefined => {\n  if (unsanitizedSelect && typeof unsanitizedSelect === 'object') {\n    for (const _k in unsanitizedSelect) {\n      const k = _k as keyof typeof unsanitizedSelect\n      if (unsanitizedSelect[k] === 'true') {\n        ;(unsanitizedSelect as Record<string, any>)[k] = true\n      } else if (unsanitizedSelect[k] === 'false') {\n        ;(unsanitizedSelect as Record<string, any>)[k] = false\n      } else if (typeof unsanitizedSelect[k] === 'object') {\n        sanitizeSelectParam(unsanitizedSelect[k])\n      }\n    }\n  }\n\n  return unsanitizedSelect as SelectType\n}\n"],"names":["sanitizeSelectParam","unsanitizedSelect","_k","k"],"mappings":"AAEA;;CAEC,GACD;;;;AAAO,MAAMA,sBAAsB,CAACC;IAClC,IAAIA,qBAAqB,OAAOA,sBAAsB,UAAU;QAC9D,IAAK,MAAMC,MAAMD,kBAAmB;YAClC,MAAME,IAAID;YACV,IAAID,iBAAiB,CAACE,EAAE,KAAK,QAAQ;;gBACjCF,iBAAyC,CAACE,EAAE,GAAG;YACnD,OAAO,IAAIF,iBAAiB,CAACE,EAAE,KAAK,SAAS;;gBACzCF,iBAAyC,CAACE,EAAE,GAAG;YACnD,OAAO,IAAI,OAAOF,iBAAiB,CAACE,EAAE,KAAK,UAAU;gBACnDH,oBAAoBC,iBAAiB,CAACE,EAAE;YAC1C;QACF;IACF;IAEA,OAAOF;AACT,EAAC"}},
    {"offset": {"line": 3962, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/sanitizePopulateParam.ts"],"sourcesContent":["import type { PopulateType } from '../types/index.js'\n\nimport { sanitizeSelectParam } from './sanitizeSelectParam.js'\n\n/**\n * Sanitizes REST populate query to PopulateType\n */\nexport const sanitizePopulateParam = (unsanitizedPopulate: unknown): PopulateType | undefined => {\n  if (!unsanitizedPopulate || typeof unsanitizedPopulate !== 'object') {\n    return\n  }\n\n  for (const k in unsanitizedPopulate) {\n    ;(unsanitizedPopulate as Record<string, any>)[k] = sanitizeSelectParam(\n      unsanitizedPopulate[k as keyof typeof unsanitizedPopulate],\n    )\n  }\n\n  return unsanitizedPopulate as PopulateType\n}\n"],"names":["sanitizeSelectParam","sanitizePopulateParam","unsanitizedPopulate","k"],"mappings":";;;;AAEA,SAASA,mBAAmB,QAAQ,2BAA0B;;AAKvD,MAAMC,wBAAwB,CAACC;IACpC,IAAI,CAACA,uBAAuB,OAAOA,wBAAwB,UAAU;QACnE;IACF;IAEA,IAAK,MAAMC,KAAKD,oBAAqB;;QACjCA,mBAA2C,CAACC,EAAE,OAAGH,kSAAAA,EACjDE,mBAAmB,CAACC,EAAsC;IAE9D;IAEA,OAAOD;AACT,EAAC"}},
    {"offset": {"line": 3982, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/parseCookies.ts"],"sourcesContent":["export const parseCookies = (headers: Request['headers']): Map<string, string> => {\n  const list = new Map<string, string>()\n  const rc = headers.get('Cookie')\n\n  if (rc) {\n    rc.split(';').forEach((cookie) => {\n      const parts = cookie.split('=')\n      const key = parts.shift()?.trim()\n      const encodedValue = parts.join('=')\n\n      try {\n        const decodedValue = decodeURI(encodedValue)\n        list.set(key!, decodedValue)\n      } catch {\n        // ignore invalid encoded values\n      }\n    })\n  }\n\n  return list\n}\n"],"names":["parseCookies","headers","list","Map","rc","get","split","forEach","cookie","parts","key","shift","trim","encodedValue","join","decodedValue","decodeURI","set"],"mappings":";;;;AAAO,MAAMA,eAAe,CAACC;IAC3B,MAAMC,OAAO,IAAIC;IACjB,MAAMC,KAAKH,QAAQI,GAAG,CAAC;IAEvB,IAAID,IAAI;QACNA,GAAGE,KAAK,CAAC,KAAKC,OAAO,CAAC,CAACC;YACrB,MAAMC,QAAQD,OAAOF,KAAK,CAAC;YAC3B,MAAMI,MAAMD,MAAME,KAAK,IAAIC;YAC3B,MAAMC,eAAeJ,MAAMK,IAAI,CAAC;YAEhC,IAAI;gBACF,MAAMC,eAAeC,UAAUH;gBAC/BX,KAAKe,GAAG,CAACP,KAAMK;YACjB,EAAE,OAAM;YACN,gCAAgC;YAClC;QACF;IACF;IAEA,OAAOb;AACT,EAAC"}},
    {"offset": {"line": 4008, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/isURLAllowed.ts"],"sourcesContent":["import type { AllowList } from '../uploads/types.js'\n\nexport const isURLAllowed = (url: string, allowList: AllowList): boolean => {\n  try {\n    const parsedUrl = new URL(url)\n\n    return allowList.some((allowItem) => {\n      return Object.entries(allowItem).every(([key, value]) => {\n        // Skip undefined or null values\n        if (!value) {\n          return true\n        }\n        // Compare protocol with colon\n        if (key === 'protocol') {\n          return typeof value === 'string' && parsedUrl.protocol === `${value}:`\n        }\n\n        if (key === 'pathname') {\n          // Convert wildcards to a regex\n          const regexPattern = value\n            .replace(/\\*\\*/g, '.*') // Match any path\n            .replace(/\\*/g, '[^/]*') // Match any part of a path segment\n            .replace(/\\/$/, '(/)?') // Allow optional trailing slash\n          const regex = new RegExp(`^${regexPattern}$`)\n          return regex.test(parsedUrl.pathname)\n        }\n\n        // Default comparison for all other properties (hostname, port, search)\n        return parsedUrl[key as keyof URL] === value\n      })\n    })\n  } catch {\n    return false // If the URL is invalid, deny by default\n  }\n}\n"],"names":["isURLAllowed","url","allowList","parsedUrl","URL","some","allowItem","Object","entries","every","key","value","protocol","regexPattern","replace","regex","RegExp","test","pathname"],"mappings":";;;;AAEO,MAAMA,eAAe,CAACC,KAAaC;IACxC,IAAI;QACF,MAAMC,YAAY,IAAIC,IAAIH;QAE1B,OAAOC,UAAUG,IAAI,CAAC,CAACC;YACrB,OAAOC,OAAOC,OAAO,CAACF,WAAWG,KAAK,CAAC,CAAC,CAACC,KAAKC,MAAM;gBAClD,gCAAgC;gBAChC,IAAI,CAACA,OAAO;oBACV,OAAO;gBACT;gBACA,8BAA8B;gBAC9B,IAAID,QAAQ,YAAY;oBACtB,OAAO,OAAOC,UAAU,YAAYR,UAAUS,QAAQ,KAAK,GAAGD,MAAM,CAAC,CAAC;gBACxE;gBAEA,IAAID,QAAQ,YAAY;oBACtB,+BAA+B;oBAC/B,MAAMG,eAAeF,MAClBG,OAAO,CAAC,SAAS,MAAM,iBAAiB;qBACxCA,OAAO,CAAC,OAAO,SAAS,mCAAmC;qBAC3DA,OAAO,CAAC,OAAO,QAAQ,gCAAgC;;oBAC1D,MAAMC,QAAQ,IAAIC,OAAO,CAAC,CAAC,EAAEH,aAAa,CAAC,CAAC;oBAC5C,OAAOE,MAAME,IAAI,CAACd,UAAUe,QAAQ;gBACtC;gBAEA,uEAAuE;gBACvE,OAAOf,SAAS,CAACO,IAAiB,KAAKC;YACzC;QACF;IACF,EAAE,OAAM;QACN,OAAO,MAAM,yCAAyC;;IACxD;AACF,EAAC"}},
    {"offset": {"line": 4047, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/validateMimeType.ts"],"sourcesContent":["export const validateMimeType = (mimeType: string, allowedMimeTypes: string[]): boolean => {\n  const cleanedMimeTypes = allowedMimeTypes.map((v) => v.replace('*', ''))\n  return cleanedMimeTypes.some((cleanedMimeType) => mimeType.startsWith(cleanedMimeType))\n}\n"],"names":["validateMimeType","mimeType","allowedMimeTypes","cleanedMimeTypes","map","v","replace","some","cleanedMimeType","startsWith"],"mappings":";;;;AAAO,MAAMA,mBAAmB,CAACC,UAAkBC;IACjD,MAAMC,mBAAmBD,iBAAiBE,GAAG,CAAC,CAACC,IAAMA,EAAEC,OAAO,CAAC,KAAK;IACpE,OAAOH,iBAAiBI,IAAI,CAAC,CAACC,kBAAoBP,SAASQ,UAAU,CAACD;AACxE,EAAC"}},
    {"offset": {"line": 4059, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/parseBooleanString.ts"],"sourcesContent":["/**\n * Useful when parsing query parameters where booleans are represented as strings.\n * Falls back to `undefined` to allow default handling elsewhere.\n */\nexport const parseBooleanString = (\n  value: boolean | null | string | undefined,\n): boolean | undefined => {\n  if (typeof value === 'boolean') {\n    return value\n  }\n\n  if (value === 'true') {\n    return true\n  }\n\n  if (value === 'false') {\n    return false\n  }\n\n  return undefined\n}\n"],"names":["parseBooleanString","value","undefined"],"mappings":"AAAA;;;CAGC,GACD;;;;AAAO,MAAMA,qBAAqB,CAChCC;IAEA,IAAI,OAAOA,UAAU,WAAW;QAC9B,OAAOA;IACT;IAEA,IAAIA,UAAU,QAAQ;QACpB,OAAO;IACT;IAEA,IAAIA,UAAU,SAAS;QACrB,OAAO;IACT;IAEA,OAAOC;AACT,EAAC"}},
    {"offset": {"line": 4082, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/parseParams/index.ts"],"sourcesContent":["import type { JoinQuery, PopulateType, SelectType, Where } from '../../types/index.js'\nimport type { JoinParams } from '../sanitizeJoinParams.js'\n\nimport { isNumber } from '../isNumber.js'\nimport { parseBooleanString } from '../parseBooleanString.js'\nimport { sanitizeJoinParams } from '../sanitizeJoinParams.js'\nimport { sanitizePopulateParam } from '../sanitizePopulateParam.js'\nimport { sanitizeSelectParam } from '../sanitizeSelectParam.js'\n\ntype ParsedParams = {\n  autosave?: boolean\n  data?: Record<string, unknown>\n  depth?: number\n  draft?: boolean\n  field?: string\n  flattenLocales?: boolean\n  joins?: JoinQuery\n  limit?: number\n  overrideLock?: boolean\n  page?: number\n  pagination?: boolean\n  populate?: PopulateType\n  publishSpecificLocale?: string\n  select?: SelectType\n  selectedLocales?: string[]\n  sort?: string[]\n  trash?: boolean\n  where?: Where\n} & Record<string, unknown>\n\ntype RawParams = {\n  [key: string]: unknown\n  autosave?: string\n  data?: string\n  depth?: string\n  draft?: string\n  field?: string\n  flattenLocales?: string\n  joins?: JoinParams\n  limit?: string\n  overrideLock?: string\n  page?: string\n  pagination?: string\n  populate?: unknown\n  publishSpecificLocale?: string\n  select?: unknown\n  selectedLocales?: string\n  sort?: string\n  trash?: string\n  where?: Where\n}\n\nexport const booleanParams = [\n  'autosave',\n  'draft',\n  'trash',\n  'overrideLock',\n  'pagination',\n  'flattenLocales',\n]\n\nexport const numberParams = ['depth', 'limit', 'page']\n\n/**\n * Takes raw query parameters and parses them into the correct types that Payload expects.\n * Examples:\n *   a. `draft` provided as a string of \"true\" is converted to a boolean\n *   b. `depth` provided as a string of \"0\" is converted to a number\n *   c. `sort` provided as a comma-separated string is converted to an array of strings\n */\nexport const parseParams = (params: RawParams): ParsedParams => {\n  const parsedParams = (params || {}) as ParsedParams\n\n  // iterate through known params to make this very fast\n  for (const key of booleanParams) {\n    if (key in params) {\n      parsedParams[key] = parseBooleanString(params[key] as boolean | string)\n    }\n  }\n\n  for (const key of numberParams) {\n    if (key in params) {\n      if (isNumber(params[key])) {\n        parsedParams[key] = Number(params[key])\n      }\n    }\n  }\n\n  if ('populate' in params) {\n    parsedParams.populate = sanitizePopulateParam(params.populate)\n  }\n\n  if ('select' in params) {\n    parsedParams.select = sanitizeSelectParam(params.select)\n  }\n\n  if ('joins' in params) {\n    parsedParams.joins = sanitizeJoinParams(params.joins as JoinParams)\n  }\n\n  if ('sort' in params) {\n    parsedParams.sort = typeof params.sort === 'string' ? params.sort.split(',') : undefined\n  }\n\n  if ('data' in params && typeof params.data === 'string' && params.data.length > 0) {\n    parsedParams.data = JSON.parse(params.data)\n  }\n\n  return parsedParams\n}\n"],"names":["isNumber","parseBooleanString","sanitizeJoinParams","sanitizePopulateParam","sanitizeSelectParam","booleanParams","numberParams","parseParams","params","parsedParams","key","Number","populate","select","joins","sort","split","undefined","data","length","JSON","parse"],"mappings":";;;;;;;;AAGA,SAASA,QAAQ,QAAQ,iBAAgB;AACzC,SAASC,kBAAkB,QAAQ,2BAA0B;AAC7D,SAASC,kBAAkB,QAAQ,2BAA0B;AAC7D,SAASC,qBAAqB,QAAQ,8BAA6B;AACnE,SAASC,mBAAmB,QAAQ,4BAA2B;;;;;;AA6CxD,MAAMC,gBAAgB;IAC3B;IACA;IACA;IACA;IACA;IACA;CACD,CAAA;AAEM,MAAMC,eAAe;IAAC;IAAS;IAAS;CAAO,CAAA;AAS/C,MAAMC,cAAc,CAACC;IAC1B,MAAMC,eAAgBD,UAAU,CAAC;IAEjC,sDAAsD;IACtD,KAAK,MAAME,OAAOL,cAAe;QAC/B,IAAIK,OAAOF,QAAQ;YACjBC,YAAY,CAACC,IAAI,OAAGT,gSAAAA,EAAmBO,MAAM,CAACE,IAAI;QACpD;IACF;IAEA,KAAK,MAAMA,OAAOJ,aAAc;QAC9B,IAAII,OAAOF,QAAQ;YACjB,QAAIR,4QAAAA,EAASQ,MAAM,CAACE,IAAI,GAAG;gBACzBD,YAAY,CAACC,IAAI,GAAGC,OAAOH,MAAM,CAACE,IAAI;YACxC;QACF;IACF;IAEA,IAAI,cAAcF,QAAQ;QACxBC,aAAaG,QAAQ,OAAGT,sSAAAA,EAAsBK,OAAOI,QAAQ;IAC/D;IAEA,IAAI,YAAYJ,QAAQ;QACtBC,aAAaI,MAAM,OAAGT,kSAAAA,EAAoBI,OAAOK,MAAM;IACzD;IAEA,IAAI,WAAWL,QAAQ;QACrBC,aAAaK,KAAK,OAAGZ,gSAAAA,EAAmBM,OAAOM,KAAK;IACtD;IAEA,IAAI,UAAUN,QAAQ;QACpBC,aAAaM,IAAI,GAAG,OAAOP,OAAOO,IAAI,KAAK,WAAWP,OAAOO,IAAI,CAACC,KAAK,CAAC,OAAOC;IACjF;IAEA,IAAI,UAAUT,UAAU,OAAOA,OAAOU,IAAI,KAAK,YAAYV,OAAOU,IAAI,CAACC,MAAM,GAAG,GAAG;QACjFV,aAAaS,IAAI,GAAGE,KAAKC,KAAK,CAACb,OAAOU,IAAI;IAC5C;IAEA,OAAOT;AACT,EAAC"}},
    {"offset": {"line": 4149, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/isolateObjectProperty.ts"],"sourcesContent":["/**\n * Creates a proxy for the given object that has its own property\n */\nexport function isolateObjectProperty<T extends object>(object: T, key: (keyof T)[] | keyof T): T {\n  const keys = Array.isArray(key) ? key : [key]\n  const delegate = {} as T\n\n  // Initialize delegate with the keys, if they exist in the original object\n  for (const k of keys) {\n    if (k in object) {\n      delegate[k] = object[k]\n    }\n  }\n\n  const handler: ProxyHandler<T> = {\n    deleteProperty(target, p): boolean {\n      return Reflect.deleteProperty(keys.includes(p as keyof T) ? delegate : target, p)\n    },\n    get(target, p, receiver) {\n      return Reflect.get(keys.includes(p as keyof T) ? delegate : target, p, receiver)\n    },\n    has(target, p) {\n      return Reflect.has(keys.includes(p as keyof T) ? delegate : target, p)\n    },\n    set(target, p, newValue, receiver) {\n      if (keys.includes(p as keyof T)) {\n        // in case of transactionID we must ignore any receiver, because\n        // \"If provided and target does not have a setter for propertyKey, the property will be set on receiver instead.\"\n        return Reflect.set(delegate, p, newValue)\n      } else {\n        return Reflect.set(target, p, newValue, receiver)\n      }\n    },\n  }\n  return new Proxy(object, handler)\n}\n"],"names":["isolateObjectProperty","object","key","keys","Array","isArray","delegate","k","handler","deleteProperty","target","p","Reflect","includes","get","receiver","has","set","newValue","Proxy"],"mappings":"AAAA;;CAEC,GACD;;;;AAAO,SAASA,sBAAwCC,MAAS,EAAEC,GAA0B;IAC3F,MAAMC,OAAOC,MAAMC,OAAO,CAACH,OAAOA,MAAM;QAACA;KAAI;IAC7C,MAAMI,WAAW,CAAC;IAElB,0EAA0E;IAC1E,KAAK,MAAMC,KAAKJ,KAAM;QACpB,IAAII,KAAKN,QAAQ;YACfK,QAAQ,CAACC,EAAE,GAAGN,MAAM,CAACM,EAAE;QACzB;IACF;IAEA,MAAMC,UAA2B;QAC/BC,gBAAeC,MAAM,EAAEC,CAAC;YACtB,OAAOC,QAAQH,cAAc,CAACN,KAAKU,QAAQ,CAACF,KAAgBL,WAAWI,QAAQC;QACjF;QACAG,KAAIJ,MAAM,EAAEC,CAAC,EAAEI,QAAQ;YACrB,OAAOH,QAAQE,GAAG,CAACX,KAAKU,QAAQ,CAACF,KAAgBL,WAAWI,QAAQC,GAAGI;QACzE;QACAC,KAAIN,MAAM,EAAEC,CAAC;YACX,OAAOC,QAAQI,GAAG,CAACb,KAAKU,QAAQ,CAACF,KAAgBL,WAAWI,QAAQC;QACtE;QACAM,KAAIP,MAAM,EAAEC,CAAC,EAAEO,QAAQ,EAAEH,QAAQ;YAC/B,IAAIZ,KAAKU,QAAQ,CAACF,IAAe;gBAC/B,gEAAgE;gBAChE,iHAAiH;gBACjH,OAAOC,QAAQK,GAAG,CAACX,UAAUK,GAAGO;YAClC,OAAO;gBACL,OAAON,QAAQK,GAAG,CAACP,QAAQC,GAAGO,UAAUH;YAC1C;QACF;IACF;IACA,OAAO,IAAII,MAAMlB,QAAQO;AAC3B"}},
    {"offset": {"line": 4192, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/filterDataToSelectedLocales.ts"],"sourcesContent":["import type { Block, Field, FlattenedBlock } from '../fields/config/types.js'\nimport type { SanitizedConfig } from '../index.js'\nimport type { JsonObject } from '../types/index.js'\n\nimport { fieldAffectsData, fieldShouldBeLocalized, tabHasName } from '../fields/config/types.js'\n\ntype FilterDataToSelectedLocalesArgs = {\n  configBlockReferences: SanitizedConfig['blocks']\n  docWithLocales: JsonObject\n  fields: Field[]\n  parentIsLocalized?: boolean\n  selectedLocales: string[]\n}\n\n/**\n * Filters localized field data to only include specified locales.\n * For non-localized fields, returns all data as-is.\n * For localized fields, if selectedLocales is provided, returns only those locales.\n * If selectedLocales is not provided and field is localized, returns all locales.\n */\nexport function filterDataToSelectedLocales({\n  configBlockReferences,\n  docWithLocales,\n  fields,\n  parentIsLocalized = false,\n  selectedLocales,\n}: FilterDataToSelectedLocalesArgs): JsonObject {\n  if (!docWithLocales || typeof docWithLocales !== 'object') {\n    return docWithLocales\n  }\n\n  const result: JsonObject = {}\n\n  for (const field of fields) {\n    if (fieldAffectsData(field)) {\n      const fieldIsLocalized = fieldShouldBeLocalized({ field, parentIsLocalized })\n\n      switch (field.type) {\n        case 'array': {\n          if (Array.isArray(docWithLocales[field.name])) {\n            result[field.name] = docWithLocales[field.name].map((item: JsonObject) =>\n              filterDataToSelectedLocales({\n                configBlockReferences,\n                docWithLocales: item,\n                fields: field.fields,\n                parentIsLocalized: fieldIsLocalized,\n                selectedLocales,\n              }),\n            )\n          }\n          break\n        }\n\n        case 'blocks': {\n          if (field.name in docWithLocales && Array.isArray(docWithLocales[field.name])) {\n            result[field.name] = docWithLocales[field.name].map((blockData: JsonObject) => {\n              let block: Block | FlattenedBlock | undefined\n              if (configBlockReferences && field.blockReferences) {\n                for (const blockOrReference of field.blockReferences) {\n                  if (typeof blockOrReference === 'string') {\n                    block = configBlockReferences.find((b) => b.slug === blockData.blockType)\n                  } else {\n                    block = blockOrReference\n                  }\n                }\n              } else if (field.blocks) {\n                block = field.blocks.find((b) => b.slug === blockData.blockType)\n              }\n\n              if (block) {\n                return filterDataToSelectedLocales({\n                  configBlockReferences,\n                  docWithLocales: blockData,\n                  fields: block?.fields || [],\n                  parentIsLocalized: fieldIsLocalized,\n                  selectedLocales,\n                })\n              }\n\n              return blockData\n            })\n          }\n          break\n        }\n\n        case 'group': {\n          // Named groups create a nested data structure\n          if (\n            fieldAffectsData(field) &&\n            field.name in docWithLocales &&\n            typeof docWithLocales[field.name] === 'object'\n          ) {\n            result[field.name] = filterDataToSelectedLocales({\n              configBlockReferences,\n              docWithLocales: docWithLocales[field.name] as JsonObject,\n              fields: field.fields,\n              parentIsLocalized: fieldIsLocalized,\n              selectedLocales,\n            })\n          } else {\n            // Unnamed groups pass through the same data level\n            const nestedResult = filterDataToSelectedLocales({\n              configBlockReferences,\n              docWithLocales,\n              fields: field.fields,\n              parentIsLocalized,\n              selectedLocales,\n            })\n            Object.assign(result, nestedResult)\n          }\n          break\n        }\n\n        default: {\n          // For all other data-affecting fields (text, number, select, etc.)\n          if (field.name in docWithLocales) {\n            const value = docWithLocales[field.name]\n\n            // If the field is localized and has locale data\n            if (fieldIsLocalized && value && typeof value === 'object' && !Array.isArray(value)) {\n              // If selectedLocales is provided, filter to only those locales\n              if (selectedLocales && selectedLocales.length > 0) {\n                const filtered: Record<string, unknown> = {}\n                for (const locale of selectedLocales) {\n                  if (locale in value) {\n                    filtered[locale] = value[locale]\n                  }\n                }\n                if (Object.keys(filtered).length > 0) {\n                  result[field.name] = filtered\n                }\n              } else {\n                // If no selectedLocales, include all locales\n                result[field.name] = value\n              }\n            } else {\n              // Non-localized field or non-object value\n              result[field.name] = value\n            }\n          }\n          break\n        }\n      }\n    } else {\n      // Layout-only fields that don't affect data structure\n      switch (field.type) {\n        case 'collapsible':\n        case 'row': {\n          // These pass through the same data level\n          const nestedResult = filterDataToSelectedLocales({\n            configBlockReferences,\n            docWithLocales,\n            fields: field.fields,\n            parentIsLocalized,\n            selectedLocales,\n          })\n          Object.assign(result, nestedResult)\n          break\n        }\n\n        case 'tabs': {\n          for (const tab of field.tabs) {\n            if (tabHasName(tab)) {\n              // Named tabs create a nested data structure\n              if (tab.name in docWithLocales && typeof docWithLocales[tab.name] === 'object') {\n                result[tab.name] = filterDataToSelectedLocales({\n                  configBlockReferences,\n                  docWithLocales: docWithLocales[tab.name],\n                  fields: tab.fields,\n                  parentIsLocalized,\n                  selectedLocales,\n                })\n              }\n            } else {\n              // Unnamed tabs pass through the same data level\n              const nestedResult = filterDataToSelectedLocales({\n                configBlockReferences,\n                docWithLocales,\n                fields: tab.fields,\n                parentIsLocalized,\n                selectedLocales,\n              })\n              Object.assign(result, nestedResult)\n            }\n          }\n          break\n        }\n      }\n    }\n  }\n\n  return result\n}\n"],"names":["fieldAffectsData","fieldShouldBeLocalized","tabHasName","filterDataToSelectedLocales","configBlockReferences","docWithLocales","fields","parentIsLocalized","selectedLocales","result","field","fieldIsLocalized","type","Array","isArray","name","map","item","blockData","block","blockReferences","blockOrReference","find","b","slug","blockType","blocks","nestedResult","Object","assign","value","length","filtered","locale","keys","tab","tabs"],"mappings":"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"}},
    {"offset": {"line": 4361, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/validatePDF.ts"],"sourcesContent":["export function validatePDF(buffer: Buffer) {\n  // Check for PDF header\n  const header = buffer.subarray(0, 8).toString('latin1')\n  if (!header.startsWith('%PDF-')) {\n    return false\n  }\n\n  // Check for EOF marker and xref table\n  const endSize = Math.min(1024, buffer.length)\n  const end = buffer.subarray(buffer.length - endSize).toString('latin1')\n\n  if (!end.includes('%%EOF') || !end.includes('xref')) {\n    return false\n  }\n\n  return true\n}\n"],"names":["validatePDF","buffer","header","subarray","toString","startsWith","endSize","Math","min","length","end","includes"],"mappings":";;;;AAAO,SAASA,YAAYC,MAAc;IACxC,uBAAuB;IACvB,MAAMC,SAASD,OAAOE,QAAQ,CAAC,GAAG,GAAGC,QAAQ,CAAC;IAC9C,IAAI,CAACF,OAAOG,UAAU,CAAC,UAAU;QAC/B,OAAO;IACT;IAEA,sCAAsC;IACtC,MAAMC,UAAUC,KAAKC,GAAG,CAAC,MAAMP,OAAOQ,MAAM;IAC5C,MAAMC,MAAMT,OAAOE,QAAQ,CAACF,OAAOQ,MAAM,GAAGH,SAASF,QAAQ,CAAC;IAE9D,IAAI,CAACM,IAAIC,QAAQ,CAAC,YAAY,CAACD,IAAIC,QAAQ,CAAC,SAAS;QACnD,OAAO;IACT;IAEA,OAAO;AACT"}},
    {"offset": {"line": 4383, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/mapAsync.ts"],"sourcesContent":["export async function mapAsync<T, U>(\n  arr: T[],\n  callbackfn: (item: T, index: number, array: T[]) => Promise<U>,\n): Promise<U[]> {\n  return Promise.all(arr.map(callbackfn))\n}\n"],"names":["mapAsync","arr","callbackfn","Promise","all","map"],"mappings":";;;;AAAO,eAAeA,SACpBC,GAAQ,EACRC,UAA8D;IAE9D,OAAOC,QAAQC,GAAG,CAACH,IAAII,GAAG,CAACH;AAC7B"}},
    {"offset": {"line": 4394, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/sanitizeSelect.ts"],"sourcesContent":["import { deepMergeSimple } from '@payloadcms/translations/utilities'\n\nimport type { FlattenedField } from '../fields/config/types.js'\nimport type { SelectIncludeType, SelectType } from '../types/index.js'\n\nimport { getSelectMode } from './getSelectMode.js'\n\n// Transform post.title -> post, post.category.title -> post\nconst stripVirtualPathToCurrentCollection = ({\n  fields,\n  path,\n  versions,\n}: {\n  fields: FlattenedField[]\n  path: string\n  versions: boolean\n}) => {\n  const resultSegments: string[] = []\n\n  if (versions) {\n    resultSegments.push('version')\n    const versionField = fields.find((each) => each.name === 'version')\n\n    if (versionField && versionField.type === 'group') {\n      fields = versionField.flattenedFields\n    }\n  }\n\n  for (const segment of path.split('.')) {\n    const field = fields.find((each) => each.name === segment)\n\n    if (!field) {\n      continue\n    }\n\n    resultSegments.push(segment)\n\n    if (field.type === 'relationship' || field.type === 'upload') {\n      return resultSegments.join('.')\n    }\n  }\n\n  return resultSegments.join('.')\n}\n\nconst getAllVirtualRelations = ({ fields }: { fields: FlattenedField[] }) => {\n  const result: string[] = []\n\n  for (const field of fields) {\n    if ('virtual' in field && typeof field.virtual === 'string') {\n      result.push(field.virtual)\n    } else if (field.type === 'group' || field.type === 'tab') {\n      const nestedResult = getAllVirtualRelations({ fields: field.flattenedFields })\n\n      for (const nestedItem of nestedResult) {\n        result.push(nestedItem)\n      }\n    }\n  }\n\n  return result\n}\n\nconst resolveVirtualRelationsToSelect = ({\n  fields,\n  selectValue,\n  topLevelFields,\n  versions,\n}: {\n  fields: FlattenedField[]\n  selectValue: SelectIncludeType | true\n  topLevelFields: FlattenedField[]\n  versions: boolean\n}) => {\n  const result: string[] = []\n  if (selectValue === true) {\n    for (const item of getAllVirtualRelations({ fields })) {\n      result.push(\n        stripVirtualPathToCurrentCollection({ fields: topLevelFields, path: item, versions }),\n      )\n    }\n  } else {\n    for (const fieldName in selectValue) {\n      const field = fields.find((each) => each.name === fieldName)\n      if (!field) {\n        continue\n      }\n\n      if ('virtual' in field && typeof field.virtual === 'string') {\n        result.push(\n          stripVirtualPathToCurrentCollection({\n            fields: topLevelFields,\n            path: field.virtual,\n            versions,\n          }),\n        )\n      } else if (field.type === 'group' || field.type === 'tab') {\n        for (const item of resolveVirtualRelationsToSelect({\n          fields: field.flattenedFields,\n          selectValue: selectValue[fieldName]!,\n          topLevelFields,\n          versions,\n        })) {\n          result.push(\n            stripVirtualPathToCurrentCollection({ fields: topLevelFields, path: item, versions }),\n          )\n        }\n      }\n    }\n  }\n\n  return result\n}\n\nexport const sanitizeSelect = ({\n  fields,\n  forceSelect,\n  select,\n  versions,\n}: {\n  fields: FlattenedField[]\n  forceSelect?: SelectType\n  select?: SelectType\n  versions?: boolean\n}): SelectType | undefined => {\n  if (!select) {\n    return select\n  }\n\n  const selectMode = getSelectMode(select)\n\n  if (selectMode === 'exclude') {\n    return select\n  }\n\n  if (forceSelect) {\n    select = deepMergeSimple(select, forceSelect)\n  }\n\n  if (select) {\n    const virtualRelations = resolveVirtualRelationsToSelect({\n      fields,\n      selectValue: select as SelectIncludeType,\n      topLevelFields: fields,\n      versions: versions ?? false,\n    })\n\n    for (const path of virtualRelations) {\n      let currentRef = select\n      const segments = path.split('.')\n      for (let i = 0; i < segments.length; i++) {\n        const isLast = segments.length - 1 === i\n        const segment = segments[i]!\n\n        if (isLast) {\n          currentRef[segment] = true\n        } else {\n          if (!(segment in currentRef)) {\n            currentRef[segment] = {}\n            currentRef = currentRef[segment]\n          }\n        }\n      }\n    }\n  }\n\n  return select\n}\n"],"names":["deepMergeSimple","getSelectMode","stripVirtualPathToCurrentCollection","fields","path","versions","resultSegments","push","versionField","find","each","name","type","flattenedFields","segment","split","field","join","getAllVirtualRelations","result","virtual","nestedResult","nestedItem","resolveVirtualRelationsToSelect","selectValue","topLevelFields","item","fieldName","sanitizeSelect","forceSelect","select","selectMode","virtualRelations","currentRef","segments","i","length","isLast"],"mappings":"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"}},
    {"offset": {"line": 4523, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/checkDocumentLockStatus.ts"],"sourcesContent":["import type { TypeWithID } from '../collections/config/types.js'\nimport type { PaginatedDocs } from '../database/types.js'\nimport type { JsonObject, PayloadRequest } from '../types/index.js'\n\nimport { Locked } from '../errors/index.js'\nimport { lockedDocumentsCollectionSlug } from '../locked-documents/config.js'\n\ntype CheckDocumentLockStatusArgs = {\n  collectionSlug?: string\n  globalSlug?: string\n  id?: number | string\n  lockDurationDefault?: number\n  lockErrorMessage?: string\n  overrideLock?: boolean\n  req: PayloadRequest\n}\n\nexport const checkDocumentLockStatus = async ({\n  id,\n  collectionSlug,\n  globalSlug,\n  lockDurationDefault = 300, // Default 5 minutes in seconds\n  lockErrorMessage,\n  overrideLock = true,\n  req,\n}: CheckDocumentLockStatusArgs): Promise<void> => {\n  const { payload } = req\n\n  // Retrieve the lockDocuments property for either collection or global\n  const lockDocumentsProp = collectionSlug\n    ? payload.collections?.[collectionSlug]?.config?.lockDocuments\n    : payload.config?.globals?.find((g) => g.slug === globalSlug)?.lockDocuments\n\n  const isLockingEnabled = lockDocumentsProp !== false\n\n  let lockedDocumentQuery = {}\n\n  if (collectionSlug) {\n    lockedDocumentQuery = {\n      and: [\n        { 'document.relationTo': { equals: collectionSlug } },\n        { 'document.value': { equals: id } },\n      ],\n    }\n  } else if (globalSlug) {\n    lockedDocumentQuery = { globalSlug: { equals: globalSlug } }\n  } else {\n    throw new Error('Either collectionSlug or globalSlug must be provided.')\n  }\n\n  if (!isLockingEnabled) {\n    return\n  }\n\n  // Only perform lock checks if overrideLock is false and locking is enabled\n  if (!overrideLock) {\n    const defaultLockErrorMessage = collectionSlug\n      ? `Document with ID ${id} is currently locked by another user and cannot be modified.`\n      : `Global document with slug \"${globalSlug}\" is currently locked by another user and cannot be modified.`\n\n    const finalLockErrorMessage = lockErrorMessage || defaultLockErrorMessage\n\n    const lockedDocumentResult: PaginatedDocs<JsonObject & TypeWithID> = await payload.db.find({\n      collection: lockedDocumentsCollectionSlug,\n      limit: 1,\n      pagination: false,\n      sort: '-updatedAt',\n      where: lockedDocumentQuery,\n    })\n\n    // If there's a locked document, check lock conditions\n    const lockedDoc = lockedDocumentResult?.docs[0]\n    if (lockedDoc) {\n      const lastEditedAt = new Date(lockedDoc?.updatedAt).getTime()\n      const now = new Date().getTime()\n\n      const lockDuration =\n        typeof lockDocumentsProp === 'object' ? lockDocumentsProp.duration : lockDurationDefault\n\n      const lockDurationInMilliseconds = lockDuration * 1000\n      const currentUserId = req.user?.id\n\n      // document is locked by another user and the lock hasn't expired\n      if (\n        lockedDoc.user?.value !== currentUserId &&\n        now - lastEditedAt <= lockDurationInMilliseconds\n      ) {\n        throw new Locked(finalLockErrorMessage)\n      }\n    }\n  }\n\n  // Perform the delete operation regardless of overrideLock status\n  await payload.db.deleteMany({\n    collection: lockedDocumentsCollectionSlug,\n    // Not passing req fails on postgres\n    req: payload.db.name === 'mongoose' ? undefined : req,\n    where: lockedDocumentQuery,\n  })\n}\n"],"names":["Locked","lockedDocumentsCollectionSlug","checkDocumentLockStatus","id","collectionSlug","globalSlug","lockDurationDefault","lockErrorMessage","overrideLock","req","payload","lockDocumentsProp","collections","config","lockDocuments","globals","find","g","slug","isLockingEnabled","lockedDocumentQuery","and","equals","Error","defaultLockErrorMessage","finalLockErrorMessage","lockedDocumentResult","db","collection","limit","pagination","sort","where","lockedDoc","docs","lastEditedAt","Date","updatedAt","getTime","now","lockDuration","duration","lockDurationInMilliseconds","currentUserId","user","value","deleteMany","name","undefined"],"mappings":";;;;AAIA,SAASA,MAAM,QAAQ,qBAAoB;AAC3C,SAASC,6BAA6B,QAAQ,gCAA+B;;;AAYtE,MAAMC,0BAA0B,OAAO,EAC5CC,EAAE,EACFC,cAAc,EACdC,UAAU,EACVC,sBAAsB,GAAG,EACzBC,gBAAgB,EAChBC,eAAe,IAAI,EACnBC,GAAG,EACyB;IAC5B,MAAM,EAAEC,OAAO,EAAE,GAAGD;IAEpB,sEAAsE;IACtE,MAAME,oBAAoBP,iBACtBM,QAAQE,WAAW,EAAE,CAACR,eAAe,EAAES,QAAQC,gBAC/CJ,QAAQG,MAAM,EAAEE,SAASC,KAAK,CAACC,IAAMA,EAAEC,IAAI,KAAKb,aAAaS;IAEjE,MAAMK,mBAAmBR,sBAAsB;IAE/C,IAAIS,sBAAsB,CAAC;IAE3B,IAAIhB,gBAAgB;QAClBgB,sBAAsB;YACpBC,KAAK;gBACH;oBAAE,uBAAuB;wBAAEC,QAAQlB;oBAAe;gBAAE;gBACpD;oBAAE,kBAAkB;wBAAEkB,QAAQnB;oBAAG;gBAAE;aACpC;QACH;IACF,OAAO,IAAIE,YAAY;QACrBe,sBAAsB;YAAEf,YAAY;gBAAEiB,QAAQjB;YAAW;QAAE;IAC7D,OAAO;QACL,MAAM,IAAIkB,MAAM;IAClB;IAEA,IAAI,CAACJ,kBAAkB;QACrB;IACF;IAEA,2EAA2E;IAC3E,IAAI,CAACX,cAAc;QACjB,MAAMgB,0BAA0BpB,iBAC5B,CAAC,iBAAiB,EAAED,GAAG,4DAA4D,CAAC,GACpF,CAAC,2BAA2B,EAAEE,WAAW,6DAA6D,CAAC;QAE3G,MAAMoB,wBAAwBlB,oBAAoBiB;QAElD,MAAME,uBAA+D,MAAMhB,QAAQiB,EAAE,CAACX,IAAI,CAAC;YACzFY,YAAY3B,ySAAAA;YACZ4B,OAAO;YACPC,YAAY;YACZC,MAAM;YACNC,OAAOZ;QACT;QAEA,sDAAsD;QACtD,MAAMa,YAAYP,sBAAsBQ,IAAI,CAAC,EAAE;QAC/C,IAAID,WAAW;YACb,MAAME,eAAe,IAAIC,KAAKH,WAAWI,WAAWC,OAAO;YAC3D,MAAMC,MAAM,IAAIH,OAAOE,OAAO;YAE9B,MAAME,eACJ,OAAO7B,sBAAsB,WAAWA,kBAAkB8B,QAAQ,GAAGnC;YAEvE,MAAMoC,6BAA6BF,eAAe;YAClD,MAAMG,gBAAgBlC,IAAImC,IAAI,EAAEzC;YAEhC,iEAAiE;YACjE,IACE8B,UAAUW,IAAI,EAAEC,UAAUF,iBAC1BJ,MAAMJ,gBAAgBO,4BACtB;gBACA,MAAM,IAAI1C,qQAAAA,CAAOyB;YACnB;QACF;IACF;IAEA,iEAAiE;IACjE,MAAMf,QAAQiB,EAAE,CAACmB,UAAU,CAAC;QAC1BlB,YAAY3B,ySAAAA;QACZ,oCAAoC;QACpCQ,KAAKC,QAAQiB,EAAE,CAACoB,IAAI,KAAK,aAAaC,YAAYvC;QAClDuB,OAAOZ;IACT;AACF,EAAC"}},
    {"offset": {"line": 4601, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/flattenTopLevelFields.ts"],"sourcesContent":["import type { I18nClient } from '@payloadcms/translations'\n\nimport { getTranslation } from '@payloadcms/translations'\n\nimport type { ClientTab } from '../admin/fields/Tabs.js'\nimport type { ClientField } from '../fields/config/client.js'\nimport type {\n  Field,\n  FieldAffectingData,\n  FieldAffectingDataClient,\n  FieldPresentationalOnly,\n  FieldPresentationalOnlyClient,\n  Tab,\n} from '../fields/config/types.js'\n\nimport {\n  fieldAffectsData,\n  fieldHasSubFields,\n  fieldIsPresentationalOnly,\n  tabHasName,\n} from '../fields/config/types.js'\n\ntype FlattenedField<TField> = TField extends ClientField\n  ? { accessor?: string; labelWithPrefix?: string } & (\n      | FieldAffectingDataClient\n      | FieldPresentationalOnlyClient\n    )\n  : { accessor?: string; labelWithPrefix?: string } & (FieldAffectingData | FieldPresentationalOnly)\n\ntype TabType<TField> = TField extends ClientField ? ClientTab : Tab\n\n/**\n * Options to control how fields are flattened.\n */\ntype FlattenFieldsOptions = {\n  /**\n   * i18n context used for translating `label` values via `getTranslation`.\n   */\n  i18n?: I18nClient\n  /**\n   * If true, presentational-only fields (like UI fields) will be included\n   * in the output. Otherwise, they will be skipped.\n   * Default: false.\n   */\n  keepPresentationalFields?: boolean\n  /**\n   * A label prefix to prepend to translated labels when building `labelWithPrefix`.\n   * Used recursively when flattening nested fields.\n   */\n  labelPrefix?: string\n  /**\n   * If true, nested fields inside `group` & `tabs` fields will be lifted to the top level\n   * and given contextual `accessor` and `labelWithPrefix` values.\n   * Default: false.\n   */\n  moveSubFieldsToTop?: boolean\n  /**\n   * A path prefix to prepend to field names when building the `accessor`.\n   * Used recursively when flattening nested fields.\n   */\n  pathPrefix?: string\n}\n\n/**\n * Flattens a collection's fields into a single array of fields, optionally\n * extracting nested fields in group fields.\n *\n * @param fields - Array of fields to flatten\n * @param options - Options to control the flattening behavior\n */\nexport function flattenTopLevelFields<TField extends ClientField | Field>(\n  fields: TField[] = [],\n  options?: boolean | FlattenFieldsOptions,\n): FlattenedField<TField>[] {\n  const normalizedOptions: FlattenFieldsOptions =\n    typeof options === 'boolean' ? { keepPresentationalFields: options } : (options ?? {})\n\n  const {\n    i18n,\n    keepPresentationalFields,\n    labelPrefix,\n    moveSubFieldsToTop = false,\n    pathPrefix,\n  } = normalizedOptions\n\n  return fields.reduce<FlattenedField<TField>[]>((acc, field) => {\n    // If a group field has subfields and has a name, otherwise we catch it below along with collapsible and row fields\n    if (field.type === 'group' && 'fields' in field) {\n      if (moveSubFieldsToTop) {\n        const isNamedGroup = 'name' in field && typeof field.name === 'string' && !!field.name\n        const groupName = 'name' in field ? field.name : undefined\n\n        const translatedLabel =\n          'label' in field && field.label && i18n\n            ? getTranslation(field.label as string, i18n)\n            : undefined\n\n        const labelWithPrefix = labelPrefix\n          ? `${labelPrefix} > ${translatedLabel ?? groupName}`\n          : (translatedLabel ?? groupName)\n\n        const nameWithPrefix =\n          'name' in field && field.name\n            ? pathPrefix\n              ? `${pathPrefix}.${field.name}`\n              : field.name\n            : pathPrefix\n\n        acc.push(\n          // Need to include the top-level group field when hoisting its subfields,\n          // so that `buildColumnState` can detect and render a column if the group\n          // has a custom admin Cell component defined in its configuration.\n          // See: packages/ui/src/providers/TableColumns/buildColumnState/index.tsx\n          field as FlattenedField<TField>,\n          ...flattenTopLevelFields(field.fields as TField[], {\n            i18n,\n            keepPresentationalFields,\n            labelPrefix: isNamedGroup ? labelWithPrefix : labelPrefix,\n            moveSubFieldsToTop,\n            pathPrefix: isNamedGroup ? nameWithPrefix : pathPrefix,\n          }),\n        )\n      } else {\n        if (fieldAffectsData(field)) {\n          // Hoisting diabled - keep as top level field\n          acc.push(field as FlattenedField<TField>)\n        } else {\n          acc.push(...flattenTopLevelFields(field.fields as TField[], options))\n        }\n      }\n    } else if (field.type === 'tabs' && 'tabs' in field) {\n      return [\n        ...acc,\n        ...field.tabs.reduce<FlattenedField<TField>[]>((tabFields, tab) => {\n          if (tabHasName(tab)) {\n            if (moveSubFieldsToTop) {\n              const translatedLabel =\n                'label' in tab && tab.label && i18n ? getTranslation(tab.label, i18n) : undefined\n\n              const labelWithPrefixForTab = labelPrefix\n                ? `${labelPrefix} > ${translatedLabel ?? tab.name}`\n                : (translatedLabel ?? tab.name)\n\n              const pathPrefixForTab = tab.name\n                ? pathPrefix\n                  ? `${pathPrefix}.${tab.name}`\n                  : tab.name\n                : pathPrefix\n\n              return [\n                ...tabFields,\n                ...flattenTopLevelFields(tab.fields as TField[], {\n                  i18n,\n                  keepPresentationalFields,\n                  labelPrefix: labelWithPrefixForTab,\n                  moveSubFieldsToTop,\n                  pathPrefix: pathPrefixForTab,\n                }),\n              ]\n            } else {\n              // Named tab, hoisting disabled: keep as top-level field\n              return [\n                ...tabFields,\n                {\n                  ...tab,\n                  type: 'tab',\n                } as unknown as FlattenedField<TField>,\n              ]\n            }\n          } else {\n            // Unnamed tab: always hoist its fields\n            return [...tabFields, ...flattenTopLevelFields<TField>(tab.fields as TField[], options)]\n          }\n        }, []),\n      ]\n    } else if (fieldHasSubFields(field) && ['collapsible', 'row'].includes(field.type)) {\n      // Recurse into row and collapsible\n      acc.push(...flattenTopLevelFields(field.fields as TField[], options))\n    } else if (\n      fieldAffectsData(field) ||\n      (keepPresentationalFields && fieldIsPresentationalOnly(field))\n    ) {\n      // Ignore nested `id` fields when inside nested structure\n      if (field.name === 'id' && labelPrefix !== undefined) {\n        return acc\n      }\n\n      const translatedLabel =\n        'label' in field && field.label && i18n ? getTranslation(field.label, i18n) : undefined\n\n      const name = 'name' in field ? field.name : undefined\n\n      const isHoistingFromGroup = pathPrefix !== undefined || labelPrefix !== undefined\n\n      acc.push({\n        ...(field as FlattenedField<TField>),\n        ...(moveSubFieldsToTop &&\n          isHoistingFromGroup && {\n            accessor: pathPrefix && name ? `${pathPrefix}.${name}` : (name ?? ''),\n            labelWithPrefix: labelPrefix\n              ? `${labelPrefix} > ${translatedLabel ?? name}`\n              : (translatedLabel ?? name),\n          }),\n      })\n    }\n\n    return acc\n  }, [])\n}\n"],"names":["getTranslation","fieldAffectsData","fieldHasSubFields","fieldIsPresentationalOnly","tabHasName","flattenTopLevelFields","fields","options","normalizedOptions","keepPresentationalFields","i18n","labelPrefix","moveSubFieldsToTop","pathPrefix","reduce","acc","field","type","isNamedGroup","name","groupName","undefined","translatedLabel","label","labelWithPrefix","nameWithPrefix","push","tabs","tabFields","tab","labelWithPrefixForTab","pathPrefixForTab","includes","isHoistingFromGroup","accessor"],"mappings":"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"}},
    {"offset": {"line": 4708, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/extractID.ts"],"sourcesContent":["export const extractID = <IDType extends number | string>(\n  objectOrID: { id: IDType } | IDType,\n): IDType => {\n  if (typeof objectOrID === 'string' || typeof objectOrID === 'number') {\n    return objectOrID\n  }\n\n  return objectOrID.id\n}\n"],"names":["extractID","objectOrID","id"],"mappings":";;;;AAAO,MAAMA,YAAY,CACvBC;IAEA,IAAI,OAAOA,eAAe,YAAY,OAAOA,eAAe,UAAU;QACpE,OAAOA;IACT;IAEA,OAAOA,WAAWC,EAAE;AACtB,EAAC"}},
    {"offset": {"line": 4722, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/transformWhereQuery.ts"],"sourcesContent":["import type { Where } from '../types/index.js'\n\n/**\n * Transforms a basic \"where\" query into a format in which the \"where builder\" can understand.\n * Even though basic queries are valid, we need to hoist them into the \"and\" / \"or\" format.\n * Use this function alongside `validateWhereQuery` to check that for valid queries before transforming.\n * @example\n * Inaccurate: [text][equals]=example%20post\n * Accurate: [or][0][and][0][text][equals]=example%20post\n */\nexport const transformWhereQuery = (whereQuery: Where): Where => {\n  if (!whereQuery) {\n    return {}\n  }\n\n  // Check if 'whereQuery' has 'or' field but no 'and'. This is the case for \"correct\" queries\n  if (whereQuery.or && !whereQuery.and) {\n    return {\n      or: whereQuery.or.map((query) => {\n        // ...but if the or query does not have an and, we need to add it\n        if (!query.and) {\n          return {\n            and: [query],\n          }\n        }\n        return query\n      }),\n    }\n  }\n\n  // Check if 'whereQuery' has 'and' field but no 'or'.\n  if (whereQuery.and && !whereQuery.or) {\n    return {\n      or: [\n        {\n          and: whereQuery.and,\n        },\n      ],\n    }\n  }\n\n  // Check if 'whereQuery' has neither 'or' nor 'and'.\n  if (!whereQuery.or && !whereQuery.and) {\n    return {\n      or: [\n        {\n          and: [whereQuery], // top-level siblings are considered 'and'\n        },\n      ],\n    }\n  }\n\n  // If 'whereQuery' has 'or' and 'and', just return it as it is.\n  return whereQuery\n}\n"],"names":["transformWhereQuery","whereQuery","or","and","map","query"],"mappings":"AAEA;;;;;;;CAOC,GACD;;;;AAAO,MAAMA,sBAAsB,CAACC;IAClC,IAAI,CAACA,YAAY;QACf,OAAO,CAAC;IACV;IAEA,4FAA4F;IAC5F,IAAIA,WAAWC,EAAE,IAAI,CAACD,WAAWE,GAAG,EAAE;QACpC,OAAO;YACLD,IAAID,WAAWC,EAAE,CAACE,GAAG,CAAC,CAACC;gBACrB,iEAAiE;gBACjE,IAAI,CAACA,MAAMF,GAAG,EAAE;oBACd,OAAO;wBACLA,KAAK;4BAACE;yBAAM;oBACd;gBACF;gBACA,OAAOA;YACT;QACF;IACF;IAEA,qDAAqD;IACrD,IAAIJ,WAAWE,GAAG,IAAI,CAACF,WAAWC,EAAE,EAAE;QACpC,OAAO;YACLA,IAAI;gBACF;oBACEC,KAAKF,WAAWE,GAAG;gBACrB;aACD;QACH;IACF;IAEA,oDAAoD;IACpD,IAAI,CAACF,WAAWC,EAAE,IAAI,CAACD,WAAWE,GAAG,EAAE;QACrC,OAAO;YACLD,IAAI;gBACF;oBACEC,KAAK;wBAACF;qBAAW;gBACnB;aACD;QACH;IACF;IAEA,+DAA+D;IAC/D,OAAOA;AACT,EAAC"}},
    {"offset": {"line": 4782, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/validateWhereQuery.ts"],"sourcesContent":["import type { Operator, Where } from '../types/index.js'\n\nimport { validOperatorSet } from '../types/constants.js'\n\n/**\n * Validates that a \"where\" query is in a format in which the \"where builder\" can understand.\n * Even though basic queries are valid, we need to hoist them into the \"and\" / \"or\" format.\n * Use this function alongside `transformWhereQuery` to perform a transformation if the query is not valid.\n * @example\n * Inaccurate: [text][equals]=example%20post\n * Accurate: [or][0][and][0][text][equals]=example%20post\n */\nexport const validateWhereQuery = (whereQuery: Where): whereQuery is Where => {\n  if (\n    whereQuery?.or &&\n    (whereQuery?.or?.length === 0 ||\n      (whereQuery?.or?.length > 0 &&\n        whereQuery?.or?.[0]?.and &&\n        whereQuery?.or?.[0]?.and?.length > 0))\n  ) {\n    // At this point we know that the whereQuery has 'or' and 'and' fields,\n    // now let's check the structure and content of these fields.\n\n    const isValid = whereQuery.or.every((orQuery) => {\n      if (orQuery.and && Array.isArray(orQuery.and)) {\n        return orQuery.and.every((andQuery) => {\n          if (typeof andQuery !== 'object') {\n            return false\n          }\n\n          const andKeys = Object.keys(andQuery)\n\n          // If there are no keys, it's not a valid WhereField.\n          if (andKeys.length === 0) {\n            return false\n          }\n\n          for (const key of andKeys) {\n            const operator = Object.keys(andQuery[key]!)[0]\n            // Check if the key is a valid Operator.\n            if (!operator || !validOperatorSet.has(operator as Operator)) {\n              return false\n            }\n          }\n          return true\n        })\n      }\n      return false\n    })\n\n    return isValid\n  }\n\n  return false\n}\n"],"names":["validOperatorSet","validateWhereQuery","whereQuery","or","length","and","isValid","every","orQuery","Array","isArray","andQuery","andKeys","Object","keys","key","operator","has"],"mappings":";;;;AAEA,SAASA,gBAAgB,QAAQ,wBAAuB;;AAUjD,MAAMC,qBAAqB,CAACC;IACjC,IACEA,YAAYC,MACXD,CAAAA,YAAYC,IAAIC,WAAW,KACzBF,YAAYC,IAAIC,SAAS,KACxBF,YAAYC,IAAI,CAAC,EAAE,EAAEE,OACrBH,YAAYC,IAAI,CAAC,EAAE,EAAEE,KAAKD,SAAS,CAAC,GACxC;QACA,uEAAuE;QACvE,6DAA6D;QAE7D,MAAME,UAAUJ,WAAWC,EAAE,CAACI,KAAK,CAAC,CAACC;YACnC,IAAIA,QAAQH,GAAG,IAAII,MAAMC,OAAO,CAACF,QAAQH,GAAG,GAAG;gBAC7C,OAAOG,QAAQH,GAAG,CAACE,KAAK,CAAC,CAACI;oBACxB,IAAI,OAAOA,aAAa,UAAU;wBAChC,OAAO;oBACT;oBAEA,MAAMC,UAAUC,OAAOC,IAAI,CAACH;oBAE5B,qDAAqD;oBACrD,IAAIC,QAAQR,MAAM,KAAK,GAAG;wBACxB,OAAO;oBACT;oBAEA,KAAK,MAAMW,OAAOH,QAAS;wBACzB,MAAMI,WAAWH,OAAOC,IAAI,CAACH,QAAQ,CAACI,IAAI,CAAE,CAAC,EAAE;wBAC/C,wCAAwC;wBACxC,IAAI,CAACC,YAAY,CAAChB,iRAAAA,CAAiBiB,GAAG,CAACD,WAAuB;4BAC5D,OAAO;wBACT;oBACF;oBACA,OAAO;gBACT;YACF;YACA,OAAO;QACT;QAEA,OAAOV;IACT;IAEA,OAAO;AACT,EAAC"}},
    {"offset": {"line": 4823, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/traverseFields.ts"],"sourcesContent":["import type { Config, SanitizedConfig } from '../config/types.js'\nimport type { ArrayField, Block, BlocksField, Field, TabAsField } from '../fields/config/types.js'\n\nimport {\n  fieldAffectsData,\n  fieldHasSubFields,\n  fieldShouldBeLocalized,\n  tabHasName,\n} from '../fields/config/types.js'\n\nconst traverseArrayOrBlocksField = ({\n  callback,\n  callbackStack,\n  config,\n  data,\n  field,\n  fillEmpty,\n  leavesFirst,\n  parentIsLocalized,\n  parentPath,\n  parentRef,\n}: {\n  callback: TraverseFieldsCallback\n  callbackStack: (() => ReturnType<TraverseFieldsCallback>)[]\n  config?: Config | SanitizedConfig\n  data: Record<string, unknown>[]\n  field: ArrayField | BlocksField\n  fillEmpty: boolean\n  leavesFirst: boolean\n  parentIsLocalized: boolean\n  parentPath: string\n  parentRef?: unknown\n}) => {\n  if (fillEmpty) {\n    if (field.type === 'array') {\n      traverseFields({\n        callback,\n        callbackStack,\n        config,\n        fields: field.fields,\n        isTopLevel: false,\n        leavesFirst,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: `${parentPath}${field.name}.`,\n        parentRef,\n      })\n    }\n    if (field.type === 'blocks') {\n      for (const _block of field.blockReferences ?? field.blocks) {\n        // TODO: iterate over blocks mapped to block slug in v4, or pass through payload.blocks\n        const block =\n          typeof _block === 'string' ? config?.blocks?.find((b) => b.slug === _block) : _block\n        if (block) {\n          traverseFields({\n            callback,\n            callbackStack,\n            config,\n            fields: block.fields,\n            isTopLevel: false,\n            leavesFirst,\n            parentIsLocalized: parentIsLocalized || field.localized,\n            parentPath: `${parentPath}${field.name}.`,\n            parentRef,\n          })\n        }\n      }\n    }\n    return\n  }\n  for (const ref of data) {\n    let fields!: Field[]\n    if (field.type === 'blocks' && typeof ref?.blockType === 'string') {\n      // TODO: iterate over blocks mapped to block slug in v4, or pass through payload.blocks\n      const block = field.blockReferences\n        ? ((config?.blocks?.find((b) => b.slug === ref.blockType) ??\n            field.blockReferences.find(\n              (b) => typeof b !== 'string' && b.slug === ref.blockType,\n            )) as Block)\n        : field.blocks.find((b) => b.slug === ref.blockType)\n\n      fields = block?.fields as Field[]\n    } else if (field.type === 'array') {\n      fields = field.fields\n    }\n\n    if (fields) {\n      traverseFields({\n        callback,\n        callbackStack,\n        config,\n        fields,\n        fillEmpty,\n        isTopLevel: false,\n        leavesFirst,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: `${parentPath}${field.name}.`,\n        parentRef,\n        ref,\n      })\n    }\n  }\n}\n\nexport type TraverseFieldsCallback = (args: {\n  /**\n   * The current field\n   */\n  field: Field | TabAsField\n  /**\n   * Function that when called will skip the current field and continue to the next\n   */\n  next?: () => void\n  parentIsLocalized: boolean\n  parentPath: string\n  /**\n   * The parent reference object\n   */\n  parentRef?: Record<string, unknown> | unknown\n  /**\n   * The current reference object\n   */\n  ref?: Record<string, unknown> | unknown\n}) => boolean | void\n\ntype TraverseFieldsArgs = {\n  callback: TraverseFieldsCallback\n  callbackStack?: (() => ReturnType<TraverseFieldsCallback>)[]\n  config?: Config | SanitizedConfig\n  fields: (Field | TabAsField)[]\n  fillEmpty?: boolean\n  isTopLevel?: boolean\n  /**\n   * @default false\n   *\n   * if this is `true`, the callback functions of the leaf fields will be called before the parent fields.\n   * The return value of the callback function will be ignored.\n   */\n  leavesFirst?: boolean\n  parentIsLocalized?: boolean\n  parentPath?: string\n  parentRef?: Record<string, unknown> | unknown\n  ref?: Record<string, unknown> | unknown\n}\n\n/**\n * Iterate a recurse an array of fields, calling a callback for each field\n *\n * @param fields\n * @param callback callback called for each field, discontinue looping if callback returns truthy\n * @param fillEmpty fill empty properties to use this without data\n * @param ref the data or any artifacts assigned in the callback during field recursion\n * @param parentRef the data or any artifacts assigned in the callback during field recursion one level up\n */\nexport const traverseFields = ({\n  callback,\n  callbackStack: _callbackStack = [],\n  config,\n  fields,\n  fillEmpty = true,\n  isTopLevel = true,\n  leavesFirst = false,\n  parentIsLocalized,\n  parentPath = '',\n  parentRef = {},\n  ref = {},\n}: TraverseFieldsArgs): void => {\n  const fieldsMatched = fields.some((field) => {\n    let callbackStack: (() => ReturnType<TraverseFieldsCallback>)[] = []\n    if (!isTopLevel) {\n      callbackStack = _callbackStack\n    }\n    let skip = false\n    const next = () => {\n      skip = true\n    }\n\n    if (!ref || typeof ref !== 'object') {\n      return\n    }\n\n    if (\n      !leavesFirst &&\n      callback &&\n      callback({ field, next, parentIsLocalized: parentIsLocalized!, parentPath, parentRef, ref })\n    ) {\n      return true\n    } else if (leavesFirst) {\n      callbackStack.push(() =>\n        callback({\n          field,\n          next,\n          parentIsLocalized: parentIsLocalized!,\n          parentPath,\n          parentRef,\n          ref,\n        }),\n      )\n    }\n\n    if (skip) {\n      return false\n    }\n\n    // avoid mutation of ref for all fields\n    let currentRef = ref\n    let currentParentRef = parentRef\n\n    if (field.type === 'tabs' && 'tabs' in field) {\n      for (const tab of field.tabs) {\n        let tabRef = ref\n\n        if (skip) {\n          return false\n        }\n\n        if ('name' in tab && tab.name) {\n          if (\n            !ref[tab.name as keyof typeof ref] ||\n            typeof ref[tab.name as keyof typeof ref] !== 'object'\n          ) {\n            if (fillEmpty) {\n              if (tab.localized) {\n                ;(ref as Record<string, any>)[tab.name] = { en: {} }\n              } else {\n                ;(ref as Record<string, any>)[tab.name] = {}\n              }\n            } else {\n              continue\n            }\n          }\n\n          if (\n            callback &&\n            !leavesFirst &&\n            callback({\n              field: { ...tab, type: 'tab' },\n              next,\n              parentIsLocalized: parentIsLocalized!,\n              parentPath,\n              parentRef: currentParentRef,\n              ref: tabRef,\n            })\n          ) {\n            return true\n          } else if (leavesFirst) {\n            callbackStack.push(() =>\n              callback({\n                field: { ...tab, type: 'tab' },\n                next,\n                parentIsLocalized: parentIsLocalized!,\n                parentPath,\n                parentRef: currentParentRef,\n                ref: tabRef,\n              }),\n            )\n          }\n\n          tabRef = tabRef[tab.name as keyof typeof tabRef]\n\n          if (tab.localized) {\n            for (const key in tabRef as Record<string, unknown>) {\n              if (\n                tabRef[key as keyof typeof tabRef] &&\n                typeof tabRef[key as keyof typeof tabRef] === 'object'\n              ) {\n                traverseFields({\n                  callback,\n                  callbackStack,\n                  config,\n                  fields: tab.fields,\n                  fillEmpty,\n                  isTopLevel: false,\n                  leavesFirst,\n                  parentIsLocalized: true,\n                  parentPath: `${parentPath}${tab.name}.`,\n                  parentRef: currentParentRef,\n                  ref: tabRef[key as keyof typeof tabRef],\n                })\n              }\n            }\n          }\n        } else {\n          if (\n            callback &&\n            !leavesFirst &&\n            callback({\n              field: { ...tab, type: 'tab' },\n              next,\n              parentIsLocalized: parentIsLocalized!,\n              parentPath,\n              parentRef: currentParentRef,\n              ref: tabRef,\n            })\n          ) {\n            return true\n          } else if (leavesFirst) {\n            callbackStack.push(() =>\n              callback({\n                field: { ...tab, type: 'tab' },\n                next,\n                parentIsLocalized: parentIsLocalized!,\n                parentPath,\n                parentRef: currentParentRef,\n                ref: tabRef,\n              }),\n            )\n          }\n        }\n\n        if (!tab.localized) {\n          traverseFields({\n            callback,\n            callbackStack,\n            config,\n            fields: tab.fields,\n            fillEmpty,\n            isTopLevel: false,\n            leavesFirst,\n            parentIsLocalized: false,\n            parentPath: tabHasName(tab) ? `${parentPath}${tab.name}` : parentPath,\n            parentRef: currentParentRef,\n            ref: tabRef,\n          })\n        }\n\n        if (skip) {\n          return false\n        }\n      }\n\n      return\n    }\n\n    if (field.type === 'tab' || fieldHasSubFields(field) || field.type === 'blocks') {\n      if ('name' in field && field.name) {\n        currentParentRef = currentRef\n        if (!ref[field.name as keyof typeof ref]) {\n          if (fillEmpty) {\n            if (field.type === 'group' || field.type === 'tab') {\n              if (fieldShouldBeLocalized({ field, parentIsLocalized: parentIsLocalized! })) {\n                ;(ref as Record<string, any>)[field.name] = { en: {} }\n              } else {\n                ;(ref as Record<string, any>)[field.name] = {}\n              }\n            } else if (field.type === 'array' || field.type === 'blocks') {\n              if (fieldShouldBeLocalized({ field, parentIsLocalized: parentIsLocalized! })) {\n                ;(ref as Record<string, any>)[field.name] = { en: [] }\n              } else {\n                ;(ref as Record<string, any>)[field.name] = []\n              }\n            }\n          } else {\n            return\n          }\n        }\n        currentRef = ref[field.name as keyof typeof ref]\n      }\n\n      if (\n        (field.type === 'tab' || field.type === 'group') &&\n        fieldShouldBeLocalized({ field, parentIsLocalized: parentIsLocalized! }) &&\n        currentRef &&\n        typeof currentRef === 'object'\n      ) {\n        if (fieldAffectsData(field)) {\n          for (const key in currentRef as Record<string, unknown>) {\n            if (currentRef[key as keyof typeof currentRef]) {\n              traverseFields({\n                callback,\n                callbackStack,\n                config,\n                fields: field.fields,\n                fillEmpty,\n                isTopLevel: false,\n                leavesFirst,\n                parentIsLocalized: true,\n                parentPath: field.name ? `${parentPath}${field.name}.` : parentPath,\n                parentRef: currentParentRef,\n                ref: currentRef[key as keyof typeof currentRef],\n              })\n            }\n          }\n        } else {\n          traverseFields({\n            callback,\n            callbackStack,\n            config,\n            fields: field.fields,\n            fillEmpty,\n            isTopLevel: false,\n            leavesFirst,\n            parentIsLocalized,\n            parentRef: currentParentRef,\n            ref: currentRef,\n          })\n        }\n\n        return\n      }\n\n      if (\n        (field.type === 'blocks' || field.type === 'array') &&\n        currentRef &&\n        typeof currentRef === 'object'\n      ) {\n        // TODO: `?? field.localized ?? false` shouldn't be necessary, but right now it\n        // is so that all fields are correctly traversed in copyToLocale and\n        // therefore pass the localization integration tests.\n        // I tried replacing the `!parentIsLocalized` condition with `parentIsLocalized === false`\n        // in `fieldShouldBeLocalized`, but several tests failed. We must be calling it with incorrect\n        // parameters somewhere.\n        if (\n          fieldShouldBeLocalized({\n            field,\n            parentIsLocalized: parentIsLocalized ?? false,\n          })\n        ) {\n          if (Array.isArray(currentRef)) {\n            traverseArrayOrBlocksField({\n              callback,\n              callbackStack,\n              config,\n              data: currentRef,\n              field,\n              fillEmpty,\n              leavesFirst,\n              parentIsLocalized: true,\n              parentPath,\n              parentRef: currentParentRef,\n            })\n          } else {\n            for (const key in currentRef as Record<string, unknown>) {\n              const localeData = currentRef[key as keyof typeof currentRef]\n              if (!Array.isArray(localeData)) {\n                continue\n              }\n\n              traverseArrayOrBlocksField({\n                callback,\n                callbackStack,\n                config,\n                data: localeData,\n                field,\n                fillEmpty,\n                leavesFirst,\n                parentIsLocalized: true,\n                parentPath,\n                parentRef: currentParentRef,\n              })\n            }\n          }\n        } else if (Array.isArray(currentRef)) {\n          traverseArrayOrBlocksField({\n            callback,\n            callbackStack,\n            config,\n            data: currentRef as Record<string, unknown>[],\n            field,\n            fillEmpty,\n            leavesFirst,\n            parentIsLocalized: parentIsLocalized!,\n            parentPath,\n            parentRef: currentParentRef,\n          })\n        }\n      } else if (currentRef && typeof currentRef === 'object' && 'fields' in field) {\n        traverseFields({\n          callback,\n          callbackStack,\n          config,\n          fields: field.fields,\n          fillEmpty,\n          isTopLevel: false,\n          leavesFirst,\n          parentIsLocalized,\n          parentPath: 'name' in field && field.name ? `${parentPath}${field.name}.` : parentPath,\n          parentRef: currentParentRef,\n          ref: currentRef,\n        })\n      }\n    }\n\n    if (isTopLevel) {\n      callbackStack.reverse().forEach((cb) => {\n        cb()\n      })\n    }\n  })\n\n  // Fallback: Handle dot-notation paths when no fields matched\n  if (!fieldsMatched && ref && typeof ref === 'object') {\n    Object.keys(ref).forEach((key) => {\n      if (key.includes('.')) {\n        // Split on first dot only\n        const firstDotIndex = key.indexOf('.')\n        const fieldName = key.substring(0, firstDotIndex)\n        const remainingPath = key.substring(firstDotIndex + 1)\n\n        // Create nested structure for this field\n        if (!ref[fieldName as keyof typeof ref]) {\n          ;(ref as Record<string, unknown>)[fieldName] = {}\n        }\n\n        const nestedRef = ref[fieldName as keyof typeof ref] as Record<string, unknown>\n\n        // Move the value to the nested structure\n        nestedRef[remainingPath] = (ref as Record<string, unknown>)[key]\n        delete (ref as Record<string, unknown>)[key]\n\n        // Recursively process the newly created nested structure\n        // The field traversal will naturally handle it if the field exists in the schema\n        traverseFields({\n          callback,\n          callbackStack: _callbackStack,\n          config,\n          fields,\n          fillEmpty,\n          isTopLevel: false,\n          leavesFirst,\n          parentIsLocalized,\n          parentPath,\n          parentRef,\n          ref,\n        })\n      }\n    })\n  }\n}\n"],"names":["fieldAffectsData","fieldHasSubFields","fieldShouldBeLocalized","tabHasName","traverseArrayOrBlocksField","callback","callbackStack","config","data","field","fillEmpty","leavesFirst","parentIsLocalized","parentPath","parentRef","type","traverseFields","fields","isTopLevel","localized","name","_block","blockReferences","blocks","block","find","b","slug","ref","blockType","_callbackStack","fieldsMatched","some","skip","next","push","currentRef","currentParentRef","tab","tabs","tabRef","en","key","Array","isArray","localeData","reverse","forEach","cb","Object","keys","includes","firstDotIndex","indexOf","fieldName","substring","remainingPath","nestedRef"],"mappings":"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"}},
    {"offset": {"line": 5240, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/logError.ts"],"sourcesContent":["import type pino from 'pino'\n\nimport type { Payload } from '../types/index.js'\n\nexport const logError = ({ err, payload }: { err: unknown; payload: Payload }): void => {\n  let level: false | pino.Level = 'error'\n\n  if (\n    err &&\n    typeof err === 'object' &&\n    'name' in err &&\n    typeof err.name === 'string' &&\n    typeof payload.config.loggingLevels[err.name as keyof typeof payload.config.loggingLevels] !==\n      'undefined'\n  ) {\n    level = payload.config.loggingLevels[err.name as keyof typeof payload.config.loggingLevels]\n  }\n\n  if (level) {\n    const logObject: { err?: unknown; msg?: unknown } = {}\n\n    if (level === 'info') {\n      logObject.msg = typeof err === 'object' && 'message' in err! ? err.message : 'Error'\n    } else {\n      logObject.err = err\n    }\n\n    payload.logger[level](logObject)\n  }\n}\n"],"names":["logError","err","payload","level","name","config","loggingLevels","logObject","msg","message","logger"],"mappings":";;;;AAIO,MAAMA,WAAW,CAAC,EAAEC,GAAG,EAAEC,OAAO,EAAsC;IAC3E,IAAIC,QAA4B;IAEhC,IACEF,OACA,OAAOA,QAAQ,YACf,UAAUA,OACV,OAAOA,IAAIG,IAAI,KAAK,YACpB,OAAOF,QAAQG,MAAM,CAACC,aAAa,CAACL,IAAIG,IAAI,CAA8C,KACxF,aACF;QACAD,QAAQD,QAAQG,MAAM,CAACC,aAAa,CAACL,IAAIG,IAAI,CAA8C;IAC7F;IAEA,IAAID,OAAO;QACT,MAAMI,YAA8C,CAAC;QAErD,IAAIJ,UAAU,QAAQ;YACpBI,UAAUC,GAAG,GAAG,OAAOP,QAAQ,YAAY,aAAaA,MAAOA,IAAIQ,OAAO,GAAG;QAC/E,OAAO;YACLF,UAAUN,GAAG,GAAGA;QAClB;QAEAC,QAAQQ,MAAM,CAACP,MAAM,CAACI;IACxB;AACF,EAAC"}},
    {"offset": {"line": 5263, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/mergeHeaders.ts"],"sourcesContent":["export const mergeHeaders = (sourceHeaders: Headers, destinationHeaders: Headers): Headers => {\n  // Create a new Headers object\n  const combinedHeaders = new Headers(destinationHeaders)\n\n  // Append sourceHeaders to combinedHeaders\n  sourceHeaders.forEach((value, key) => {\n    combinedHeaders.append(key, value)\n  })\n\n  return combinedHeaders\n}\n"],"names":["mergeHeaders","sourceHeaders","destinationHeaders","combinedHeaders","Headers","forEach","value","key","append"],"mappings":";;;;AAAO,MAAMA,eAAe,CAACC,eAAwBC;IACnD,8BAA8B;IAC9B,MAAMC,kBAAkB,IAAIC,QAAQF;IAEpC,0CAA0C;IAC1CD,cAAcI,OAAO,CAAC,CAACC,OAAOC;QAC5BJ,gBAAgBK,MAAM,CAACD,KAAKD;IAC9B;IAEA,OAAOH;AACT,EAAC"}},
    {"offset": {"line": 5280, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/isNextBuild.ts"],"sourcesContent":["/**\n * Utility function to determine if the code is being executed during the Next.js build process.\n */\nexport function isNextBuild() {\n  return (\n    process.env.NEXT_PHASE === 'phase-production-build' ||\n    process.env.npm_lifecycle_event === 'build'\n  )\n}\n"],"names":["isNextBuild","process","env","NEXT_PHASE","npm_lifecycle_event"],"mappings":"AAAA;;CAEC,GACD;;;;AAAO,SAASA;IACd,OACEC,QAAQC,GAAG,CAACC,UAAU,KAAK,4BAC3BF,QAAQC,GAAG,CAACE,mBAAmB,KAAK;AAExC"}},
    {"offset": {"line": 5293, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/logger.ts"],"sourcesContent":["import { type Logger, pino } from 'pino'\nimport { build, type PinoPretty, type PrettyOptions } from 'pino-pretty'\n\nimport type { Config } from '../config/types.js'\n\n/**\n * Payload internal logger. Uses Pino.\n * This allows you to bring your own logger instance and let payload use it\n */\nexport type PayloadLogger = Logger\n\nconst prettyOptions: PrettyOptions = {\n  colorize: true,\n  ignore: 'pid,hostname',\n  translateTime: 'SYS:HH:MM:ss',\n}\n\nexport const prettySyncLoggerDestination: PinoPretty.PrettyStream = build({\n  ...prettyOptions,\n  destination: 1, // stdout\n  sync: true,\n})\n\nexport const defaultLoggerOptions: PinoPretty.PrettyStream = build(prettyOptions)\n\nexport const getLogger = (name = 'payload', logger?: Config['logger']): PayloadLogger => {\n  if (!logger) {\n    return pino(defaultLoggerOptions)\n  }\n\n  // Synchronous logger used by bin scripts\n  if (logger === 'sync') {\n    return pino(prettySyncLoggerDestination)\n  }\n\n  // Check if logger is an object\n  if ('options' in logger) {\n    const { destination, options } = logger\n\n    if (!options.name) {\n      options.name = name\n    }\n\n    if (!options.enabled) {\n      options.enabled = process.env.DISABLE_LOGGING !== 'true'\n    }\n\n    return pino(options, destination)\n  } else {\n    // Instantiated logger\n    return logger\n  }\n}\n"],"names":["pino","build","prettyOptions","colorize","ignore","translateTime","prettySyncLoggerDestination","destination","sync","defaultLoggerOptions","getLogger","name","logger","options","enabled","process","env","DISABLE_LOGGING"],"mappings":";;;;;;;;AAAA,SAAsBA,IAAI,QAAQ,OAAM;AACxC,SAASC,KAAK,QAA6C,cAAa;;;AAUxE,MAAMC,gBAA+B;IACnCC,UAAU;IACVC,QAAQ;IACRC,eAAe;AACjB;AAEO,MAAMC,kCAAuDL,4MAAAA,EAAM;IACxE,GAAGC,aAAa;IAChBK,aAAa;IACbC,MAAM;AACR,GAAE;AAEK,MAAMC,2BAAgDR,4MAAAA,EAAMC,eAAc;AAE1E,MAAMQ,YAAY,CAACC,OAAO,SAAS,EAAEC;IAC1C,IAAI,CAACA,QAAQ;QACX,WAAOZ,sLAAAA,EAAKS;IACd;IAEA,yCAAyC;IACzC,IAAIG,WAAW,QAAQ;QACrB,WAAOZ,sLAAAA,EAAKM;IACd;IAEA,+BAA+B;IAC/B,IAAI,aAAaM,QAAQ;QACvB,MAAM,EAAEL,WAAW,EAAEM,OAAO,EAAE,GAAGD;QAEjC,IAAI,CAACC,QAAQF,IAAI,EAAE;YACjBE,QAAQF,IAAI,GAAGA;QACjB;QAEA,IAAI,CAACE,QAAQC,OAAO,EAAE;YACpBD,QAAQC,OAAO,GAAGC,QAAQC,GAAG,CAACC,eAAe,KAAK;QACpD;QAEA,WAAOjB,sLAAAA,EAAKa,SAASN;IACvB,OAAO;QACL,sBAAsB;QACtB,OAAOK;IACT;AACF,EAAC"}},
    {"offset": {"line": 5343, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/telemetry/events/serverInit.ts"],"sourcesContent":["import type { Payload } from '../../../index.js'\n\nimport { sendEvent } from '../index.js'\n\nexport type ServerInitEvent = {\n  type: 'server-init'\n}\n\nexport const serverInit = (payload: Payload): void => {\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  sendEvent({\n    event: {\n      type: 'server-init',\n    },\n    payload,\n  })\n}\n"],"names":["sendEvent","serverInit","payload","event","type"],"mappings":";;;;AAEA,SAASA,SAAS,QAAQ,cAAa;;AAMhC,MAAMC,aAAa,CAACC;IACzB,mEAAmE;QACnEF,uRAAAA,EAAU;QACRG,OAAO;YACLC,MAAM;QACR;QACAF;IACF;AACF,EAAC"}},
    {"offset": {"line": 5362, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/getRequestLanguage.ts"],"sourcesContent":["import type { AcceptedLanguages } from '@payloadcms/translations'\nimport type { ReadonlyRequestCookies } from 'next/dist/server/web/spec-extension/adapters/request-cookies.js'\n\nimport { extractHeaderLanguage } from '@payloadcms/translations'\n\nimport type { SanitizedConfig } from '../config/types.js'\n\ntype GetRequestLanguageArgs = {\n  config: SanitizedConfig\n  cookies: Map<string, string> | ReadonlyRequestCookies\n  defaultLanguage?: AcceptedLanguages\n  headers: Request['headers']\n}\n\nexport const getRequestLanguage = ({\n  config,\n  cookies,\n  headers,\n}: GetRequestLanguageArgs): AcceptedLanguages => {\n  const supportedLanguageKeys = Object.keys(config.i18n.supportedLanguages) as AcceptedLanguages[]\n  const langCookie = cookies.get(`${config.cookiePrefix || 'payload'}-lng`)\n\n  const languageFromCookie: AcceptedLanguages = (\n    typeof langCookie === 'string' ? langCookie : langCookie?.value\n  ) as AcceptedLanguages\n\n  if (languageFromCookie && supportedLanguageKeys.includes(languageFromCookie)) {\n    return languageFromCookie\n  }\n\n  const languageFromHeader = headers.get('Accept-Language')\n    ? extractHeaderLanguage(headers.get('Accept-Language')!)\n    : undefined\n\n  if (languageFromHeader && supportedLanguageKeys.includes(languageFromHeader)) {\n    return languageFromHeader\n  }\n\n  return config.i18n.fallbackLanguage\n}\n"],"names":["extractHeaderLanguage","getRequestLanguage","config","cookies","headers","supportedLanguageKeys","Object","keys","i18n","supportedLanguages","langCookie","get","cookiePrefix","languageFromCookie","value","includes","languageFromHeader","undefined","fallbackLanguage"],"mappings":";;;;AAGA,SAASA,qBAAqB,QAAQ,2BAA0B;;AAWzD,MAAMC,qBAAqB,CAAC,EACjCC,MAAM,EACNC,OAAO,EACPC,OAAO,EACgB;IACvB,MAAMC,wBAAwBC,OAAOC,IAAI,CAACL,OAAOM,IAAI,CAACC,kBAAkB;IACxE,MAAMC,aAAaP,QAAQQ,GAAG,CAAC,GAAGT,OAAOU,YAAY,IAAI,UAAU,IAAI,CAAC;IAExE,MAAMC,qBACJ,OAAOH,eAAe,WAAWA,aAAaA,YAAYI;IAG5D,IAAID,sBAAsBR,sBAAsBU,QAAQ,CAACF,qBAAqB;QAC5E,OAAOA;IACT;IAEA,MAAMG,qBAAqBZ,QAAQO,GAAG,CAAC,yBACnCX,iRAAAA,EAAsBI,QAAQO,GAAG,CAAC,sBAClCM;IAEJ,IAAID,sBAAsBX,sBAAsBU,QAAQ,CAACC,qBAAqB;QAC5E,OAAOA;IACT;IAEA,OAAOd,OAAOM,IAAI,CAACU,gBAAgB;AACrC,EAAC"}},
    {"offset": {"line": 5385, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/createPayloadRequest.ts"],"sourcesContent":["import { initI18n } from '@payloadcms/translations'\nimport * as qs from 'qs-esm'\n\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { CustomPayloadRequestProperties, PayloadRequest } from '../types/index.js'\n\nimport { executeAuthStrategies } from '../auth/executeAuthStrategies.js'\nimport { getDataLoader } from '../collections/dataloader.js'\nimport { getPayload } from '../index.js'\nimport { sanitizeLocales } from './addLocalesToRequest.js'\nimport { getRequestLanguage } from './getRequestLanguage.js'\nimport { parseCookies } from './parseCookies.js'\n\ntype Args = {\n  canSetHeaders?: boolean\n  config: Promise<SanitizedConfig> | SanitizedConfig\n  params?: {\n    collection: string\n  }\n  request: Request\n}\n\nexport const createPayloadRequest = async ({\n  canSetHeaders,\n  config: configPromise,\n  params,\n  request,\n}: Args): Promise<PayloadRequest> => {\n  const cookies = parseCookies(request.headers)\n  const payload = await getPayload({ config: configPromise, cron: true })\n\n  const { config } = payload\n  const localization = config.localization\n\n  const urlProperties = new URL(request.url)\n  const { pathname, searchParams } = urlProperties\n\n  const isGraphQL =\n    !config.graphQL.disable && pathname === `${config.routes.api}${config.routes.graphQL}`\n\n  const language = getRequestLanguage({\n    config,\n    cookies,\n    headers: request.headers,\n  })\n\n  const i18n = await initI18n({\n    config: config.i18n,\n    context: 'api',\n    language,\n  })\n\n  let locale = searchParams.get('locale')\n\n  const { search: queryToParse } = urlProperties\n\n  const query = queryToParse\n    ? qs.parse(queryToParse, {\n        arrayLimit: 1000,\n        depth: 10,\n        ignoreQueryPrefix: true,\n      })\n    : {}\n\n  const fallbackFromRequest =\n    (query.fallbackLocale as string | string[]) ||\n    searchParams.get('fallback-locale') ||\n    searchParams.get('fallbackLocale')\n\n  let fallbackLocale = fallbackFromRequest\n\n  if (localization) {\n    const locales = sanitizeLocales({\n      fallbackLocale: fallbackLocale!,\n      locale: locale!,\n      localization,\n    })\n\n    fallbackLocale = locales.fallbackLocale!\n    locale = locales.locale!\n  }\n\n  const customRequest: CustomPayloadRequestProperties = {\n    context: {},\n    fallbackLocale: fallbackLocale!,\n    hash: urlProperties.hash,\n    host: urlProperties.host,\n    href: urlProperties.href,\n    i18n,\n    locale,\n    origin: urlProperties.origin,\n    pathname: urlProperties.pathname,\n    payload,\n    payloadAPI: isGraphQL ? 'GraphQL' : 'REST',\n    payloadDataLoader: undefined!,\n    payloadUploadSizes: {},\n    port: urlProperties.port,\n    protocol: urlProperties.protocol,\n    query,\n    routeParams: params || {},\n    search: urlProperties.search,\n    searchParams: urlProperties.searchParams,\n    t: i18n.t,\n    transactionID: undefined,\n    user: null,\n  }\n\n  const req: PayloadRequest = Object.assign(request, customRequest)\n\n  req.payloadDataLoader = getDataLoader(req)\n\n  const { responseHeaders, user } = await executeAuthStrategies({\n    canSetHeaders,\n    headers: req.headers,\n    isGraphQL,\n    payload,\n  })\n\n  req.user = user\n\n  if (responseHeaders) {\n    req.responseHeaders = responseHeaders\n  }\n\n  return req\n}\n"],"names":["initI18n","qs","executeAuthStrategies","getDataLoader","getPayload","sanitizeLocales","getRequestLanguage","parseCookies","createPayloadRequest","canSetHeaders","config","configPromise","params","request","cookies","headers","payload","cron","localization","urlProperties","URL","url","pathname","searchParams","isGraphQL","graphQL","disable","routes","api","language","i18n","context","locale","get","search","queryToParse","query","parse","arrayLimit","depth","ignoreQueryPrefix","fallbackFromRequest","fallbackLocale","locales","customRequest","hash","host","href","origin","payloadAPI","payloadDataLoader","undefined","payloadUploadSizes","port","protocol","routeParams","t","transactionID","user","req","Object","assign","responseHeaders"],"mappings":"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"}},
    {"offset": {"line": 5486, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/canAccessAdmin.ts"],"sourcesContent":["import type { PayloadRequest } from '../types/index.js'\n\n/**\n * Protects admin-only routes, server functions, etc.\n * The requesting user must either:\n * a. pass the `access.admin` function on the `users` collection, if defined\n * b. match the `config.admin.user` property on the Payload config\n * c. if no user is present, and there are no users in the system, allow access (for first user creation)\n * @throws {Error} Throws an `Unauthorized` error if access is denied that can be explicitly caught\n */\nexport const canAccessAdmin = async ({ req }: { req: PayloadRequest }) => {\n  const incomingUserSlug = req.user?.collection\n  const adminUserSlug = req.payload.config.admin.user\n\n  if (incomingUserSlug) {\n    const adminAccessFn = req.payload.collections[incomingUserSlug]?.config.access?.admin\n\n    if (adminAccessFn) {\n      const canAccess = await adminAccessFn({ req })\n\n      if (!canAccess) {\n        throw new Error('Unauthorized')\n      }\n      // Match the user collection to the global admin config\n    } else if (adminUserSlug !== incomingUserSlug) {\n      throw new Error('Unauthorized')\n    }\n  } else {\n    const hasUsers = await req.payload.find({\n      collection: adminUserSlug,\n      depth: 0,\n      limit: 1,\n      pagination: false,\n    })\n\n    // If there are users, we should not allow access because of `/create-first-user`\n    if (hasUsers.docs.length) {\n      throw new Error('Unauthorized')\n    }\n  }\n}\n"],"names":["canAccessAdmin","req","incomingUserSlug","user","collection","adminUserSlug","payload","config","admin","adminAccessFn","collections","access","canAccess","Error","hasUsers","find","depth","limit","pagination","docs","length"],"mappings":"AAEA;;;;;;;CAOC,GACD;;;;AAAO,MAAMA,iBAAiB,OAAO,EAAEC,GAAG,EAA2B;IACnE,MAAMC,mBAAmBD,IAAIE,IAAI,EAAEC;IACnC,MAAMC,gBAAgBJ,IAAIK,OAAO,CAACC,MAAM,CAACC,KAAK,CAACL,IAAI;IAEnD,IAAID,kBAAkB;QACpB,MAAMO,gBAAgBR,IAAIK,OAAO,CAACI,WAAW,CAACR,iBAAiB,EAAEK,OAAOI,QAAQH;QAEhF,IAAIC,eAAe;YACjB,MAAMG,YAAY,MAAMH,cAAc;gBAAER;YAAI;YAE5C,IAAI,CAACW,WAAW;gBACd,MAAM,IAAIC,MAAM;YAClB;QACA,uDAAuD;QACzD,OAAO,IAAIR,kBAAkBH,kBAAkB;YAC7C,MAAM,IAAIW,MAAM;QAClB;IACF,OAAO;QACL,MAAMC,WAAW,MAAMb,IAAIK,OAAO,CAACS,IAAI,CAAC;YACtCX,YAAYC;YACZW,OAAO;YACPC,OAAO;YACPC,YAAY;QACd;QAEA,iFAAiF;QACjF,IAAIJ,SAASK,IAAI,CAACC,MAAM,EAAE;YACxB,MAAM,IAAIP,MAAM;QAClB;IACF;AACF,EAAC"}},
    {"offset": {"line": 5530, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/formatErrors.ts"],"sourcesContent":["import type { ErrorResult } from '../config/types.js'\nimport type { APIError } from '../errors/APIError.js'\n\nimport { APIErrorName } from '../errors/APIError.js'\nimport { ValidationErrorName } from '../errors/ValidationError.js'\n\nexport const formatErrors = (incoming: { [key: string]: unknown } | APIError): ErrorResult => {\n  if (incoming) {\n    // Cannot use `instanceof` to check error type: https://github.com/microsoft/TypeScript/issues/13965\n    // Instead, get the prototype of the incoming error and check its constructor name\n    const proto = Object.getPrototypeOf(incoming)\n\n    // Payload 'ValidationError' and 'APIError'\n    if (\n      (proto.constructor.name === ValidationErrorName || proto.constructor.name === APIErrorName) &&\n      incoming.data\n    ) {\n      return {\n        errors: [\n          {\n            name: incoming.name,\n            data: incoming.data,\n            message: incoming.message,\n          },\n        ],\n      }\n    }\n\n    // Mongoose 'ValidationError': https://mongoosejs.com/docs/api/error.html#Error.ValidationError\n    if (proto.constructor.name === ValidationErrorName && 'errors' in incoming && incoming.errors) {\n      return {\n        errors: Object.keys(incoming.errors).reduce(\n          (acc, key) => {\n            acc.push({\n              field: (incoming.errors as any)[key].path,\n              message: (incoming.errors as any)[key].message,\n            })\n            return acc\n          },\n          [] as { field: string; message: string }[],\n        ),\n      }\n    }\n\n    if (Array.isArray(incoming.message)) {\n      return {\n        errors: incoming.message,\n      }\n    }\n\n    if (incoming.name) {\n      return {\n        errors: [\n          {\n            message: incoming.message,\n          },\n        ],\n      }\n    }\n  }\n\n  return {\n    errors: [\n      {\n        message: 'An unknown error occurred.',\n      },\n    ],\n  }\n}\n"],"names":["APIErrorName","ValidationErrorName","formatErrors","incoming","proto","Object","getPrototypeOf","constructor","name","data","errors","message","keys","reduce","acc","key","push","field","path","Array","isArray"],"mappings":";;;;AAGA,SAASA,YAAY,QAAQ,wBAAuB;AACpD,SAASC,mBAAmB,QAAQ,+BAA8B;;;AAE3D,MAAMC,eAAe,CAACC;IAC3B,IAAIA,UAAU;QACZ,oGAAoG;QACpG,kFAAkF;QAClF,MAAMC,QAAQC,OAAOC,cAAc,CAACH;QAEpC,2CAA2C;QAC3C,IACGC,CAAAA,MAAMG,WAAW,CAACC,IAAI,KAAKP,2RAAAA,IAAuBG,MAAMG,WAAW,CAACC,IAAI,KAAKR,6QAAW,KACzFG,SAASM,IAAI,EACb;YACA,OAAO;gBACLC,QAAQ;oBACN;wBACEF,MAAML,SAASK,IAAI;wBACnBC,MAAMN,SAASM,IAAI;wBACnBE,SAASR,SAASQ,OAAO;oBAC3B;iBACD;YACH;QACF;QAEA,+FAA+F;QAC/F,IAAIP,MAAMG,WAAW,CAACC,IAAI,KAAKP,2RAAAA,IAAuB,YAAYE,YAAYA,SAASO,MAAM,EAAE;YAC7F,OAAO;gBACLA,QAAQL,OAAOO,IAAI,CAACT,SAASO,MAAM,EAAEG,MAAM,CACzC,CAACC,KAAKC;oBACJD,IAAIE,IAAI,CAAC;wBACPC,OAAQd,SAASO,MAAc,CAACK,IAAI,CAACG,IAAI;wBACzCP,SAAUR,SAASO,MAAc,CAACK,IAAI,CAACJ,OAAO;oBAChD;oBACA,OAAOG;gBACT,GACA,EAAE;YAEN;QACF;QAEA,IAAIK,MAAMC,OAAO,CAACjB,SAASQ,OAAO,GAAG;YACnC,OAAO;gBACLD,QAAQP,SAASQ,OAAO;YAC1B;QACF;QAEA,IAAIR,SAASK,IAAI,EAAE;YACjB,OAAO;gBACLE,QAAQ;oBACN;wBACEC,SAASR,SAASQ,OAAO;oBAC3B;iBACD;YACH;QACF;IACF;IAEA,OAAO;QACLD,QAAQ;YACN;gBACEC,SAAS;YACX;SACD;IACH;AACF,EAAC"}},
    {"offset": {"line": 5594, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/unflatten.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/*\n * Copyright (c) 2014, Hugh Kennedy\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Copyright (c) 2020, Feross Aboukhadijeh <https://feross.org>\n * Reference: https://www.npmjs.com/package/is-buffer\n * All rights reserved.\n */\nfunction isBuffer(obj: any) {\n  return (\n    obj != null &&\n    obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' &&\n    obj.constructor.isBuffer(obj)\n  )\n}\n\ninterface Opts {\n  delimiter?: string\n  object?: any\n  overwrite?: boolean\n  recursive?: boolean\n}\n\nexport const unflatten = (target: any, opts?: Opts) => {\n  opts = opts || {}\n\n  const delimiter = opts.delimiter || '.'\n  const overwrite = opts.overwrite || false\n  const recursive = opts.recursive || false\n  const result = {}\n\n  const isbuffer = isBuffer(target)\n\n  if (isbuffer || Object.prototype.toString.call(target) !== '[object Object]') {\n    return target\n  }\n\n  // safely ensure that the key is an integer.\n  const getkey = (key: any) => {\n    const parsedKey = Number(key)\n    return isNaN(parsedKey) || key.indexOf('.') !== -1 || opts.object ? key : parsedKey\n  }\n\n  const sortedKeys = Object.keys(target).sort((keyA, keyB) => keyA.length - keyB.length)\n\n  sortedKeys.forEach((key) => {\n    const split = key.split(delimiter)\n    let key1 = getkey(split.shift())\n    let key2 = getkey(split[0])\n    let recipient = result as Record<string, any>\n\n    while (key2 !== undefined) {\n      if (key1 === '__proto__') {\n        return\n      }\n\n      const type = Object.prototype.toString.call(recipient[key1])\n      const isobject = type === '[object Object]' || type === '[object Array]'\n\n      // do not write over falsey, non-undefined values if overwrite is false\n      if (!overwrite && !isobject && typeof recipient[key1] !== 'undefined') {\n        return\n      }\n\n      if ((overwrite && !isobject) || (!overwrite && recipient[key1] == null)) {\n        recipient[key1] = typeof key2 === 'number' && !opts.object ? [] : {}\n      }\n\n      recipient = recipient[key1]\n\n      if (split.length > 0) {\n        key1 = getkey(split.shift())\n        key2 = getkey(split[0])\n      }\n    }\n\n    // unflatten again for 'messy objects'\n    recipient[key1] = recursive ? unflatten(target[key], opts) : target[key]\n  })\n\n  return result\n}\n"],"names":["isBuffer","obj","constructor","unflatten","target","opts","delimiter","overwrite","recursive","result","isbuffer","Object","prototype","toString","call","getkey","key","parsedKey","Number","isNaN","indexOf","object","sortedKeys","keys","sort","keyA","keyB","length","forEach","split","key1","shift","key2","recipient","undefined","type","isobject"],"mappings":";;;;AAAA,qDAAqD,GACrD;;;;;;;;;;CAUC,GAED;;;;CAIC,GACD,SAASA,SAASC,GAAQ;IACxB,OACEA,OAAO,QACPA,IAAIC,WAAW,IAAI,QACnB,OAAOD,IAAIC,WAAW,CAACF,QAAQ,KAAK,cACpCC,IAAIC,WAAW,CAACF,QAAQ,CAACC;AAE7B;AASO,MAAME,YAAY,CAACC,QAAaC;IACrCA,OAAOA,QAAQ,CAAC;IAEhB,MAAMC,YAAYD,KAAKC,SAAS,IAAI;IACpC,MAAMC,YAAYF,KAAKE,SAAS,IAAI;IACpC,MAAMC,YAAYH,KAAKG,SAAS,IAAI;IACpC,MAAMC,SAAS,CAAC;IAEhB,MAAMC,WAAWV,SAASI;IAE1B,IAAIM,YAAYC,OAAOC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACV,YAAY,mBAAmB;QAC5E,OAAOA;IACT;IAEA,4CAA4C;IAC5C,MAAMW,SAAS,CAACC;QACd,MAAMC,YAAYC,OAAOF;QACzB,OAAOG,MAAMF,cAAcD,IAAII,OAAO,CAAC,SAAS,CAAC,KAAKf,KAAKgB,MAAM,GAAGL,MAAMC;IAC5E;IAEA,MAAMK,aAAaX,OAAOY,IAAI,CAACnB,QAAQoB,IAAI,CAAC,CAACC,MAAMC,OAASD,KAAKE,MAAM,GAAGD,KAAKC,MAAM;IAErFL,WAAWM,OAAO,CAAC,CAACZ;QAClB,MAAMa,QAAQb,IAAIa,KAAK,CAACvB;QACxB,IAAIwB,OAAOf,OAAOc,MAAME,KAAK;QAC7B,IAAIC,OAAOjB,OAAOc,KAAK,CAAC,EAAE;QAC1B,IAAII,YAAYxB;QAEhB,MAAOuB,SAASE,UAAW;YACzB,IAAIJ,SAAS,aAAa;gBACxB;YACF;YAEA,MAAMK,OAAOxB,OAAOC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACmB,SAAS,CAACH,KAAK;YAC3D,MAAMM,WAAWD,SAAS,qBAAqBA,SAAS;YAExD,uEAAuE;YACvE,IAAI,CAAC5B,aAAa,CAAC6B,YAAY,OAAOH,SAAS,CAACH,KAAK,KAAK,aAAa;gBACrE;YACF;YAEA,IAAKvB,aAAa,CAAC6B,YAAc,CAAC7B,aAAa0B,SAAS,CAACH,KAAK,IAAI,MAAO;gBACvEG,SAAS,CAACH,KAAK,GAAG,OAAOE,SAAS,YAAY,CAAC3B,KAAKgB,MAAM,GAAG,EAAE,GAAG,CAAC;YACrE;YAEAY,YAAYA,SAAS,CAACH,KAAK;YAE3B,IAAID,MAAMF,MAAM,GAAG,GAAG;gBACpBG,OAAOf,OAAOc,MAAME,KAAK;gBACzBC,OAAOjB,OAAOc,KAAK,CAAC,EAAE;YACxB;QACF;QAEA,sCAAsC;QACtCI,SAAS,CAACH,KAAK,GAAGtB,YAAYL,UAAUC,MAAM,CAACY,IAAI,EAAEX,QAAQD,MAAM,CAACY,IAAI;IAC1E;IAEA,OAAOP;AACT,EAAC"}},
    {"offset": {"line": 5664, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/reduceFieldsToValues.ts"],"sourcesContent":["import type { Data, FormState } from '../admin/types.js'\n\nimport { unflatten as flatleyUnflatten } from './unflatten.js'\n/**\n * Reduce flattened form fields (Fields) to just map to the respective values instead of the full FormField object\n *\n * @param unflatten This also unflattens the data if `unflatten` is true. The unflattened data should match the original data structure\n * @param ignoreDisableFormData - if true, will include fields that have `disableFormData` set to true, for example, blocks or arrays fields.\n *\n */\nexport const reduceFieldsToValues = (\n  fields: FormState,\n  unflatten?: boolean,\n  ignoreDisableFormData?: boolean,\n): Data => {\n  let data: Record<string, any> = {}\n\n  if (!fields) {\n    return data\n  }\n\n  Object.keys(fields).forEach((key) => {\n    if (ignoreDisableFormData === true || !fields[key]?.disableFormData) {\n      data[key] = fields[key]?.value\n    }\n  })\n\n  if (unflatten) {\n    data = flatleyUnflatten(data)\n  }\n\n  return data\n}\n"],"names":["unflatten","flatleyUnflatten","reduceFieldsToValues","fields","ignoreDisableFormData","data","Object","keys","forEach","key","disableFormData","value"],"mappings":";;;;AAEA,SAASA,aAAaC,gBAAgB,QAAQ,iBAAgB;;AAQvD,MAAMC,uBAAuB,CAClCC,QACAH,WACAI;IAEA,IAAIC,OAA4B,CAAC;IAEjC,IAAI,CAACF,QAAQ;QACX,OAAOE;IACT;IAEAC,OAAOC,IAAI,CAACJ,QAAQK,OAAO,CAAC,CAACC;QAC3B,IAAIL,0BAA0B,QAAQ,CAACD,MAAM,CAACM,IAAI,EAAEC,iBAAiB;YACnEL,IAAI,CAACI,IAAI,GAAGN,MAAM,CAACM,IAAI,EAAEE;QAC3B;IACF;IAEA,IAAIX,WAAW;QACbK,WAAOJ,8QAAAA,EAAiBI;IAC1B;IAEA,OAAOA;AACT,EAAC"}},
    {"offset": {"line": 5689, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/applyLocaleFiltering.ts"],"sourcesContent":["import type { ClientConfig } from '../config/client.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nexport async function applyLocaleFiltering({\n  clientConfig,\n  config,\n  req,\n}: {\n  clientConfig: ClientConfig\n  config: SanitizedConfig\n  req: PayloadRequest\n}): Promise<void> {\n  if (\n    !clientConfig.localization ||\n    !config.localization ||\n    typeof config.localization.filterAvailableLocales !== 'function'\n  ) {\n    return\n  }\n\n  const filteredLocales = (\n    await config.localization.filterAvailableLocales({\n      locales: config.localization.locales,\n      req,\n    })\n  ).map(({ toString, ...rest }) => rest)\n\n  clientConfig.localization.localeCodes = filteredLocales.map(({ code }) => code)\n  clientConfig.localization.locales = filteredLocales\n}\n"],"names":["applyLocaleFiltering","clientConfig","config","req","localization","filterAvailableLocales","filteredLocales","locales","map","toString","rest","localeCodes","code"],"mappings":";;;;AAIO,eAAeA,qBAAqB,EACzCC,YAAY,EACZC,MAAM,EACNC,GAAG,EAKJ;IACC,IACE,CAACF,aAAaG,YAAY,IAC1B,CAACF,OAAOE,YAAY,IACpB,OAAOF,OAAOE,YAAY,CAACC,sBAAsB,KAAK,YACtD;QACA;IACF;IAEA,MAAMC,kBACJ,CAAA,MAAMJ,OAAOE,YAAY,CAACC,sBAAsB,CAAC;QAC/CE,SAASL,OAAOE,YAAY,CAACG,OAAO;QACpCJ;IACF,EAAC,EACDK,GAAG,CAAC,CAAC,EAAEC,QAAQ,EAAE,GAAGC,MAAM,GAAKA;IAEjCT,aAAaG,YAAY,CAACO,WAAW,GAAGL,gBAAgBE,GAAG,CAAC,CAAC,EAAEI,IAAI,EAAE,GAAKA;IAC1EX,aAAaG,YAAY,CAACG,OAAO,GAAGD;AACtC"}},
    {"offset": {"line": 5708, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/parseDocumentID.ts"],"sourcesContent":["import type { CollectionSlug, Payload } from '../index.js'\n\nimport { isNumber } from './isNumber.js'\n\ntype ParseDocumentIDArgs = {\n  collectionSlug: CollectionSlug\n  id?: number | string\n  payload: Payload\n}\n\nexport function parseDocumentID({ id, collectionSlug, payload }: ParseDocumentIDArgs) {\n  const idType = payload.collections[collectionSlug]?.customIDType ?? payload.db.defaultIDType\n\n  return id ? (idType === 'number' && isNumber(id) ? parseFloat(String(id)) : id) : undefined\n}\n"],"names":["isNumber","parseDocumentID","id","collectionSlug","payload","idType","collections","customIDType","db","defaultIDType","parseFloat","String","undefined"],"mappings":";;;;AAEA,SAASA,QAAQ,QAAQ,gBAAe;;AAQjC,SAASC,gBAAgB,EAAEC,EAAE,EAAEC,cAAc,EAAEC,OAAO,EAAuB;IAClF,MAAMC,SAASD,QAAQE,WAAW,CAACH,eAAe,EAAEI,gBAAgBH,QAAQI,EAAE,CAACC,aAAa;IAE5F,OAAOP,KAAMG,WAAW,gBAAYL,4QAAAA,EAASE,MAAMQ,WAAWC,OAAOT,OAAOA,KAAMU;AACpF"}},
    {"offset": {"line": 5722, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/combineWhereConstraints.ts"],"sourcesContent":["import type { Where } from '../types/index.js'\n\nexport function combineWhereConstraints(\n  constraints: Array<undefined | Where>,\n  as: 'and' | 'or' = 'and',\n): Where {\n  if (constraints.length === 0) {\n    return {}\n  }\n\n  const reducedConstraints = constraints.reduce<Partial<Where>>(\n    (acc: Partial<Where>, constraint) => {\n      if (constraint && typeof constraint === 'object' && Object.keys(constraint).length > 0) {\n        if (as in constraint) {\n          // merge the objects under the shared key\n          acc[as] = [...(acc[as] as Where[]), ...(constraint[as] as Where[])]\n        } else {\n          // the constraint does not share the key\n          acc[as]?.push(constraint)\n        }\n      }\n\n      return acc\n    },\n    { [as]: [] } satisfies Where,\n  )\n\n  if (reducedConstraints[as]?.length === 0) {\n    // If there are no constraints, return an empty object\n    return {}\n  }\n\n  return reducedConstraints as Where\n}\n"],"names":["combineWhereConstraints","constraints","as","length","reducedConstraints","reduce","acc","constraint","Object","keys","push"],"mappings":";;;;AAEO,SAASA,wBACdC,WAAqC,EACrCC,KAAmB,KAAK;IAExB,IAAID,YAAYE,MAAM,KAAK,GAAG;QAC5B,OAAO,CAAC;IACV;IAEA,MAAMC,qBAAqBH,YAAYI,MAAM,CAC3C,CAACC,KAAqBC;QACpB,IAAIA,cAAc,OAAOA,eAAe,YAAYC,OAAOC,IAAI,CAACF,YAAYJ,MAAM,GAAG,GAAG;YACtF,IAAID,MAAMK,YAAY;gBACpB,yCAAyC;gBACzCD,GAAG,CAACJ,GAAG,GAAG;uBAAKI,GAAG,CAACJ,GAAG;uBAAkBK,UAAU,CAACL,GAAG;iBAAa;YACrE,OAAO;gBACL,wCAAwC;gBACxCI,GAAG,CAACJ,GAAG,EAAEQ,KAAKH;YAChB;QACF;QAEA,OAAOD;IACT,GACA;QAAE,CAACJ,GAAG,EAAE,EAAE;IAAC;IAGb,IAAIE,kBAAkB,CAACF,GAAG,EAAEC,WAAW,GAAG;QACxC,sDAAsD;QACtD,OAAO,CAAC;IACV;IAEA,OAAOC;AACT"}},
    {"offset": {"line": 5757, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/getBestFitFromSizes.ts"],"sourcesContent":["/**\n * Takes image sizes and a target range and returns the url of the image within that range.\n * If no images fit within the range, it selects the next smallest adequate image, the original,\n * or the largest smaller image if no better fit exists.\n *\n * @param sizes The given FileSizes.\n * @param targetSizeMax The ideal image maximum width. Defaults to 180.\n * @param targetSizeMin The ideal image minimum width. Defaults to 40.\n * @param thumbnailURL The thumbnail url set in config. If passed a url, will return early with it.\n * @param url The url of the original file.\n * @param width The width of the original file.\n * @returns A url of the best fit file.\n */\nexport const getBestFitFromSizes = ({\n  sizes,\n  targetSizeMax = 180,\n  targetSizeMin = 40,\n  thumbnailURL,\n  url,\n  width,\n}: {\n  sizes?: Record<string, { url?: string; width?: number }>\n  targetSizeMax?: number\n  targetSizeMin?: number\n  thumbnailURL?: string\n  url: string\n  width?: number\n}) => {\n  if (thumbnailURL) {\n    return thumbnailURL\n  }\n\n  if (!sizes) {\n    return url\n  }\n\n  const bestFit = Object.values(sizes).reduce<{\n    original?: boolean\n    url?: string\n    width?: number\n  }>(\n    (closest, current) => {\n      if (!current.width || current.width < targetSizeMin) {\n        return closest\n      }\n\n      if (current.width >= targetSizeMin && current.width <= targetSizeMax) {\n        return !closest.width ||\n          current.width < closest.width ||\n          closest.width < targetSizeMin ||\n          closest.width > targetSizeMax\n          ? current\n          : closest\n      }\n\n      if (\n        !closest.width ||\n        (!closest.original && closest.width < targetSizeMin && current.width > closest.width) ||\n        (closest.width > targetSizeMax && current.width < closest.width)\n      ) {\n        return current\n      }\n\n      return closest\n    },\n    { original: true, url, width },\n  )\n\n  return bestFit.url || url\n}\n"],"names":["getBestFitFromSizes","sizes","targetSizeMax","targetSizeMin","thumbnailURL","url","width","bestFit","Object","values","reduce","closest","current","original"],"mappings":"AAAA;;;;;;;;;;;;CAYC,GACD;;;;AAAO,MAAMA,sBAAsB,CAAC,EAClCC,KAAK,EACLC,gBAAgB,GAAG,EACnBC,gBAAgB,EAAE,EAClBC,YAAY,EACZC,GAAG,EACHC,KAAK,EAQN;IACC,IAAIF,cAAc;QAChB,OAAOA;IACT;IAEA,IAAI,CAACH,OAAO;QACV,OAAOI;IACT;IAEA,MAAME,UAAUC,OAAOC,MAAM,CAACR,OAAOS,MAAM,CAKzC,CAACC,SAASC;QACR,IAAI,CAACA,QAAQN,KAAK,IAAIM,QAAQN,KAAK,GAAGH,eAAe;YACnD,OAAOQ;QACT;QAEA,IAAIC,QAAQN,KAAK,IAAIH,iBAAiBS,QAAQN,KAAK,IAAIJ,eAAe;YACpE,OAAO,CAACS,QAAQL,KAAK,IACnBM,QAAQN,KAAK,GAAGK,QAAQL,KAAK,IAC7BK,QAAQL,KAAK,GAAGH,iBAChBQ,QAAQL,KAAK,GAAGJ,gBACdU,UACAD;QACN;QAEA,IACE,CAACA,QAAQL,KAAK,IACb,CAACK,QAAQE,QAAQ,IAAIF,QAAQL,KAAK,GAAGH,iBAAiBS,QAAQN,KAAK,GAAGK,QAAQL,KAAK,IACnFK,QAAQL,KAAK,GAAGJ,iBAAiBU,QAAQN,KAAK,GAAGK,QAAQL,KAAK,EAC/D;YACA,OAAOM;QACT;QAEA,OAAOD;IACT,GACA;QAAEE,UAAU;QAAMR;QAAKC;IAAM;IAG/B,OAAOC,QAAQF,GAAG,IAAIA;AACxB,EAAC"}},
    {"offset": {"line": 5802, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/mergeListSearchAndWhere.ts"],"sourcesContent":["import type { ClientCollectionConfig } from '../collections/config/client.js'\nimport type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { Where } from '../types/index.js'\n\nconst isEmptyObject = (obj: object) => Object.keys(obj).length === 0\n\nexport const hoistQueryParamsToAnd = (currentWhere: Where, incomingWhere: Where) => {\n  if (isEmptyObject(incomingWhere)) {\n    return currentWhere\n  }\n\n  if (isEmptyObject(currentWhere)) {\n    return incomingWhere\n  }\n\n  if ('and' in currentWhere && currentWhere.and) {\n    currentWhere.and.push(incomingWhere)\n  } else if ('or' in currentWhere) {\n    currentWhere = {\n      and: [currentWhere, incomingWhere],\n    }\n  } else {\n    currentWhere = {\n      and: [currentWhere, incomingWhere],\n    }\n  }\n\n  return currentWhere\n}\n\ntype Args = {\n  collectionConfig: ClientCollectionConfig | SanitizedCollectionConfig\n  search: string\n  where?: Where\n}\n\nexport const mergeListSearchAndWhere = ({ collectionConfig, search, where = {} }: Args): Where => {\n  if (search) {\n    let copyOfWhere = { ...(where || {}) }\n\n    const searchAsConditions = (\n      collectionConfig.admin.listSearchableFields || [collectionConfig.admin?.useAsTitle || 'id']\n    ).map((fieldName) => ({\n      [fieldName]: {\n        like: search,\n      },\n    }))\n\n    if (searchAsConditions.length > 0) {\n      copyOfWhere = hoistQueryParamsToAnd(copyOfWhere, {\n        or: searchAsConditions,\n      })\n    }\n\n    if (!isEmptyObject(copyOfWhere)) {\n      where = copyOfWhere\n    }\n  }\n\n  return where\n}\n"],"names":["isEmptyObject","obj","Object","keys","length","hoistQueryParamsToAnd","currentWhere","incomingWhere","and","push","mergeListSearchAndWhere","collectionConfig","search","where","copyOfWhere","searchAsConditions","admin","listSearchableFields","useAsTitle","map","fieldName","like","or"],"mappings":";;;;;;AAIA,MAAMA,gBAAgB,CAACC,MAAgBC,OAAOC,IAAI,CAACF,KAAKG,MAAM,KAAK;AAE5D,MAAMC,wBAAwB,CAACC,cAAqBC;IACzD,IAAIP,cAAcO,gBAAgB;QAChC,OAAOD;IACT;IAEA,IAAIN,cAAcM,eAAe;QAC/B,OAAOC;IACT;IAEA,IAAI,SAASD,gBAAgBA,aAAaE,GAAG,EAAE;QAC7CF,aAAaE,GAAG,CAACC,IAAI,CAACF;IACxB,OAAO,IAAI,QAAQD,cAAc;QAC/BA,eAAe;YACbE,KAAK;gBAACF;gBAAcC;aAAc;QACpC;IACF,OAAO;QACLD,eAAe;YACbE,KAAK;gBAACF;gBAAcC;aAAc;QACpC;IACF;IAEA,OAAOD;AACT,EAAC;AAQM,MAAMI,0BAA0B,CAAC,EAAEC,gBAAgB,EAAEC,MAAM,EAAEC,QAAQ,CAAC,CAAC,EAAQ;IACpF,IAAID,QAAQ;QACV,IAAIE,cAAc;YAAE,GAAID,SAAS,CAAC,CAAC;QAAE;QAErC,MAAME,qBACJJ,CAAAA,iBAAiBK,KAAK,CAACC,oBAAoB,IAAI;YAACN,iBAAiBK,KAAK,EAAEE,cAAc;SAAI,EAC1FC,GAAG,CAAC,CAACC,YAAe,CAAA;gBACpB,CAACA,UAAU,EAAE;oBACXC,MAAMT;gBACR;YACF,CAAA;QAEA,IAAIG,mBAAmBX,MAAM,GAAG,GAAG;YACjCU,cAAcT,sBAAsBS,aAAa;gBAC/CQ,IAAIP;YACN;QACF;QAEA,IAAI,CAACf,cAAcc,cAAc;YAC/BD,QAAQC;QACV;IACF;IAEA,OAAOD;AACT,EAAC"}},
    {"offset": {"line": 5862, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/isEntityHidden.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../globals/config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nexport const isEntityHidden = ({\n  hidden,\n  user,\n}: {\n  hidden: SanitizedCollectionConfig['admin']['hidden'] | SanitizedGlobalConfig['admin']['hidden']\n  user: PayloadRequest['user']\n}) => {\n  return typeof hidden === 'function' ? hidden({ user: user! }) : hidden === true\n}\n"],"names":["isEntityHidden","hidden","user"],"mappings":";;;;AAIO,MAAMA,iBAAiB,CAAC,EAC7BC,MAAM,EACNC,IAAI,EAIL;IACC,OAAO,OAAOD,WAAW,aAAaA,OAAO;QAAEC,MAAMA;IAAM,KAAKD,WAAW;AAC7E,EAAC"}},
    {"offset": {"line": 5875, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/getUniqueListBy.ts"],"sourcesContent":["export function getUniqueListBy<T>(arr: T[], key: string): T[] {\n  return [...new Map(arr.map((item) => [item[key as keyof T], item])).values()]\n}\n"],"names":["getUniqueListBy","arr","key","Map","map","item","values"],"mappings":";;;;AAAO,SAASA,gBAAmBC,GAAQ,EAAEC,GAAW;IACtD,OAAO;WAAI,IAAIC,IAAIF,IAAIG,GAAG,CAAC,CAACC,OAAS;gBAACA,IAAI,CAACH,IAAe;gBAAEG;aAAK,GAAGC,MAAM;KAAG;AAC/E"}},
    {"offset": {"line": 5891, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/appendUploadSelectFields.ts"],"sourcesContent":["import type { ClientCollectionConfig, SanitizedCollectionConfig, SelectType } from '../index.js'\n\n/**\n * Mutates the incoming select object to append fields required for upload thumbnails\n * @param collectionConfig\n * @param select\n */\nexport const appendUploadSelectFields = ({\n  collectionConfig,\n  select,\n}: {\n  collectionConfig: ClientCollectionConfig | SanitizedCollectionConfig\n  select: SelectType\n}) => {\n  if (!collectionConfig.upload || !select) {\n    return\n  }\n\n  select.mimeType = true\n  select.thumbnailURL = true\n\n  if (collectionConfig.upload.imageSizes && collectionConfig.upload.imageSizes.length > 0) {\n    if (\n      collectionConfig.upload.adminThumbnail &&\n      typeof collectionConfig.upload.adminThumbnail === 'string'\n    ) {\n      /** Only return image size properties that are required to generate the adminThumbnailURL */\n      select.sizes = {\n        [collectionConfig.upload.adminThumbnail]: {\n          filename: true,\n        },\n      }\n    } else {\n      /** Only return image size properties that are required for thumbnails */\n      select.sizes = collectionConfig.upload.imageSizes.reduce((acc, imageSizeConfig) => {\n        return {\n          ...acc,\n          [imageSizeConfig.name]: {\n            filename: true,\n            url: true,\n            width: true,\n          },\n        }\n      }, {})\n    }\n  } else {\n    select.url = true\n  }\n}\n"],"names":["appendUploadSelectFields","collectionConfig","select","upload","mimeType","thumbnailURL","imageSizes","length","adminThumbnail","sizes","filename","reduce","acc","imageSizeConfig","name","url","width"],"mappings":"AAEA;;;;CAIC,GACD;;;;AAAO,MAAMA,2BAA2B,CAAC,EACvCC,gBAAgB,EAChBC,MAAM,EAIP;IACC,IAAI,CAACD,iBAAiBE,MAAM,IAAI,CAACD,QAAQ;QACvC;IACF;IAEAA,OAAOE,QAAQ,GAAG;IAClBF,OAAOG,YAAY,GAAG;IAEtB,IAAIJ,iBAAiBE,MAAM,CAACG,UAAU,IAAIL,iBAAiBE,MAAM,CAACG,UAAU,CAACC,MAAM,GAAG,GAAG;QACvF,IACEN,iBAAiBE,MAAM,CAACK,cAAc,IACtC,OAAOP,iBAAiBE,MAAM,CAACK,cAAc,KAAK,UAClD;YACA,0FAA0F,GAC1FN,OAAOO,KAAK,GAAG;gBACb,CAACR,iBAAiBE,MAAM,CAACK,cAAc,CAAC,EAAE;oBACxCE,UAAU;gBACZ;YACF;QACF,OAAO;YACL,uEAAuE,GACvER,OAAOO,KAAK,GAAGR,iBAAiBE,MAAM,CAACG,UAAU,CAACK,MAAM,CAAC,CAACC,KAAKC;gBAC7D,OAAO;oBACL,GAAGD,GAAG;oBACN,CAACC,gBAAgBC,IAAI,CAAC,EAAE;wBACtBJ,UAAU;wBACVK,KAAK;wBACLC,OAAO;oBACT;gBACF;YACF,GAAG,CAAC;QACN;IACF,OAAO;QACLd,OAAOa,GAAG,GAAG;IACf;AACF,EAAC"}},
    {"offset": {"line": 5932, "column": 0}, "map": {"version":3,"sources":["file:///Users/stefaniedoll/websites/prepublic/epaper-backend/node_modules/.pnpm/payload%403.64.0_graphql%4016.12.0_typescript%405.5.2/node_modules/payload/src/utilities/transformColumnPreferences.ts"],"sourcesContent":["import type { Column } from '../admin/types.js'\nimport type { ColumnPreference } from '../preferences/types.js'\n\nexport type ColumnsFromURL = string[]\n\n/**\n * Transforms various forms of columns into `ColumnPreference[]` which is what is stored in the user's preferences table\n * In React state, for example, columns are stored in in their entirety, including React components: `[{ accessor: 'title', active: true, Label: React.ReactNode, ... }]`\n * In the URL, they are stored as an array of strings: `['title', '-slug']`, where the `-` prefix is used to indicate that the column is inactive\n * However in the database, columns must be in this exact shape: `[{ accessor: 'title', active: true }, { accessor: 'slug', active: false }]`\n * This means that when handling columns, they need to be consistently transformed back and forth\n */\nexport const transformColumnsToPreferences = (\n  columns: Column[] | ColumnPreference[] | ColumnsFromURL | string | undefined,\n): ColumnPreference[] | undefined => {\n  if (!columns) {\n    return undefined\n  }\n\n  let columnsToTransform = columns\n\n  // Columns that originate from the URL are a stringified JSON array and need to be parsed first\n  if (typeof columns === 'string') {\n    try {\n      columnsToTransform = JSON.parse(columns)\n    } catch (e) {\n      console.error('Error parsing columns', columns, e) // eslint-disable-line no-console\n    }\n  }\n\n  if (columnsToTransform && Array.isArray(columnsToTransform)) {\n    return columnsToTransform.map((col) => {\n      if (typeof col === 'string') {\n        const active = col[0] !== '-'\n        return { accessor: active ? col : col.slice(1), active }\n      }\n\n      return { accessor: col.accessor, active: col.active }\n    })\n  }\n}\n\n/**\n * Does the opposite of `transformColumnsToPreferences`, where `ColumnPreference[]` and `Column[]` are transformed into `ColumnsFromURL`\n * This is useful for storing the columns in the URL, where it appears as a simple comma delimited array of strings\n * The `-` prefix is used to indicate that the column is inactive\n */\nexport const transformColumnsToSearchParams = (\n  columns: Column[] | ColumnPreference[],\n): ColumnsFromURL => {\n  return columns?.map((col) => (col.active ? col.accessor : `-${col.accessor}`))\n}\n"],"names":["transformColumnsToPreferences","columns","undefined","columnsToTransform","JSON","parse","e","console","error","Array","isArray","map","col","active","accessor","slice","transformColumnsToSearchParams"],"mappings":"AAKA;;;;;;CAMC,GACD;;;;;;AAAO,MAAMA,gCAAgC,CAC3CC;IAEA,IAAI,CAACA,SAAS;QACZ,OAAOC;IACT;IAEA,IAAIC,qBAAqBF;IAEzB,+FAA+F;IAC/F,IAAI,OAAOA,YAAY,UAAU;QAC/B,IAAI;YACFE,qBAAqBC,KAAKC,KAAK,CAACJ;QAClC,EAAE,OAAOK,GAAG;YACVC,QAAQC,KAAK,CAAC,yBAAyBP,SAASK,GAAG,iCAAiC;;QACtF;IACF;IAEA,IAAIH,sBAAsBM,MAAMC,OAAO,CAACP,qBAAqB;QAC3D,OAAOA,mBAAmBQ,GAAG,CAAC,CAACC;YAC7B,IAAI,OAAOA,QAAQ,UAAU;gBAC3B,MAAMC,SAASD,GAAG,CAAC,EAAE,KAAK;gBAC1B,OAAO;oBAAEE,UAAUD,SAASD,MAAMA,IAAIG,KAAK,CAAC;oBAAIF;gBAAO;YACzD;YAEA,OAAO;gBAAEC,UAAUF,IAAIE,QAAQ;gBAAED,QAAQD,IAAIC,MAAM;YAAC;QACtD;IACF;AACF,EAAC;AAOM,MAAMG,iCAAiC,CAC5Cf;IAEA,OAAOA,SAASU,IAAI,CAACC,MAASA,IAAIC,MAAM,GAAGD,IAAIE,QAAQ,GAAG,CAAC,CAAC,EAAEF,IAAIE,QAAQ,EAAE;AAC9E,EAAC"}}]
}